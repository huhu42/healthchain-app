"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/node-jose";
exports.ids = ["vendor-chunks/node-jose"];
exports.modules = {

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-cbc-hmac-sha2.js - AES-CBC-HMAC-SHA2 Composited Encryption\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    HMAC = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nfunction checkIv(iv) {\n  if (16 !== iv.length) {\n    throw new Error(\"invalid iv\");\n  }\n}\n\nfunction commonCbcEncryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createCipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(pdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var cdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"encrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(cdata) {\n      cdata = Buffer.from(cdata);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, pdata, iv) {\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve(pdata);\n\n    promise = promise.then(function(pdata) {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createCipheriv(name, encKey, iv);\n      var cdata = Buffer.concat([\n        cipher.update(pdata),\n        cipher.final()\n      ]);\n      return cdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction commonCbcDecryptFN(size) {\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var cipher = forge.cipher.createDecipher(\"AES-CBC\", new DataBuffer(encKey));\n      cipher.start({\n        iv: new DataBuffer(iv)\n      });\n\n      // TODO: chunk data\n      cipher.update(new DataBuffer(cdata));\n      if (!cipher.finish()) {\n        return Promise.reject(new Error(\"encryption failed\"));\n      }\n\n      var pdata = Buffer.from(cipher.output.bytes(), \"binary\");\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var alg = {\n        name: \"AES-CBC\"\n      };\n      return helpers.subtleCrypto.importKey(\"raw\", encKey, alg, true, [\"decrypt\"]);\n    });\n    promise = promise.then(function(key) {\n      var alg = {\n        name: \"AES-CBC\",\n        iv: iv\n      };\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(encKey, cdata, iv) {\n    // validate inputs\n    try {\n      checkIv(iv);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var promise = Promise.resolve();\n\n    promise = promise.then(function() {\n      var name = \"AES-\" + size + \"-CBC\";\n      var cipher = helpers.nodeCrypto.createDecipheriv(name, encKey, iv);\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction checkKey(key, size) {\n  if ((size << 1) !== (key.length << 3)) {\n    throw new Error(\"invalid encryption key size\");\n  }\n}\n\nfunction cbcHmacEncryptFN(size) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n  return function(key, pdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    // STEP 1 -- Encrypt\n    var promise = commonEncrypt(eKey, pdata, iv);\n\n    // STEP 2 -- MAC\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n\n      var promise;\n      promise = HMAC[\"HS\" + (size * 2)].sign(iKey, mdata, {\n        length: size\n      });\n      promise = promise.then(function(result) {\n        // TODO: move slice to hmac.js\n        var tag = result.mac.slice(0, size / 8);\n        return {\n          data: cdata,\n          tag: tag\n        };\n      });\n      return promise;\n    });\n\n    return promise;\n  };\n}\n\nfunction cbcHmacDecryptFN(size) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    // validate inputs\n    try {\n      checkKey(key, size);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var eKey = key.slice(size / 8),\n        iKey = key.slice(0, size / 8),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    var promise = Promise.resolve();\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      var promise;\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        iv,\n        cdata,\n        helpers.int64ToBuffer(adata.length * 8)\n      ]);\n      promise = HMAC[\"HS\" + (size * 2)].verify(iKey, mdata, tag, {\n        length: size\n      });\n      promise = promise.then(function() {\n        return cdata;\n      }, function() {\n        // failure -- invalid tag error\n        throw new Error(\"mac check failed\");\n      });\n      return promise;\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(eKey, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\nvar EncryptionLabel = Buffer.from(\"Encryption\", \"utf8\");\nvar IntegrityLabel = Buffer.from(\"Integrity\", \"utf8\");\nvar DotLabel = Buffer.from(\".\", \"utf8\");\n\nfunction generateCek(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cekSize = masterSize / 2;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cekSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      EncryptionLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cekSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction generateCik(masterKey, alg, epu, epv) {\n  var masterSize = masterKey.length * 8;\n  var cikSize = masterSize;\n  var promise = Promise.resolve();\n\n  promise = promise.then(function(){\n    var input = Buffer.concat([\n      helpers.int32ToBuffer(1),\n      masterKey,\n      helpers.int32ToBuffer(cikSize),\n      Buffer.from(alg, \"utf8\"),\n      epu,\n      epv,\n      IntegrityLabel\n    ]);\n\n    return input;\n  });\n\n  promise = promise.then( function(input) {\n    return sha[\"SHA-\" + masterSize].digest(input).then(function(digest) {\n      return digest.slice(0, cikSize / 8);\n    });\n  });\n  promise = Promise.resolve(promise);\n\n  return promise;\n}\n\nfunction concatKdfCbcHmacEncryptFN(size, alg) {\n  var commonEncrypt = commonCbcEncryptFN(size);\n\n  return function(key, pdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys) {\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n    // STEP 1 -- Encrypt\n    promise = promise.then(function(){\n      return commonEncrypt(cek, pdata, iv);\n    });\n\n    // STEP 2 -- Mac\n    promise = promise.then(function(cdata){\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n      return Promise.all([\n        Promise.resolve(cdata),\n        HMAC[\"HS\" + (size * 2)].sign(cik, mdata, { length: size })\n      ]);\n    });\n    promise = promise.then(function(result){\n      return {\n        data: result[0],\n        tag: result[1].mac\n      };\n    });\n\n    return promise;\n  };\n}\n\nfunction concatKdfCbcHmacDecryptFN(size, alg) {\n  var commonDecrypt = commonCbcDecryptFN(size);\n\n  return function(key, cdata, props) {\n    var epu = props.epu || helpers.int32ToBuffer(0),\n        epv = props.epv || helpers.int32ToBuffer(0),\n        iv = props.iv || Buffer.alloc(0),\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        kdata = props.kdata || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // Pre Step 1 -- Generate Keys\n    var promises = [\n      generateCek(key, alg, epu, epv),\n      generateCik(key, alg, epu, epv)\n    ];\n\n    var cek,\n        cik;\n    var promise = Promise.all(promises).then(function(keys){\n      cek = keys[0];\n      cik = keys[1];\n    });\n\n\n    // STEP 1 -- MAC\n    promise = promise.then(function() {\n      // construct MAC input\n      var mdata = Buffer.concat([\n        adata,\n        DotLabel,\n        Buffer.from(kdata),\n        DotLabel,\n        Buffer.from(util.base64url.encode(iv), \"utf8\"),\n        DotLabel,\n        Buffer.from(util.base64url.encode(cdata), \"utf8\")\n      ]);\n\n      try {\n        return HMAC[\"HS\" + (size * 2)].verify(cik, mdata, tag, {\n          loose: false\n        });\n      } catch (e) {\n        throw new Error(\"mac check failed\");\n      }\n    });\n\n    // STEP 2 -- Decrypt\n    promise = promise.then(function(){\n      return commonDecrypt(cek, cdata, iv);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesCbcHmacSha2 = {};\n[\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC-HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: cbcHmacEncryptFN(size),\n    decrypt: cbcHmacDecryptFN(size)\n  };\n});\n\n[\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)CBC\\+HS(\\d+)?/g.exec(alg)[1]);\n  aesCbcHmacSha2[alg] = {\n    encrypt: concatKdfCbcHmacEncryptFN(size, alg),\n    decrypt: concatKdfCbcHmacDecryptFN(size, alg)\n  };\n});\n\nmodule.exports = aesCbcHmacSha2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1jYmMtaG1hYy1zaGEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLHdFQUFXO0FBQzlCLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTtBQUM1QixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLG9GQUF1QjtBQUNoRCxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGNBQWM7QUFDakU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9hZXMtY2JjLWhtYWMtc2hhMi5qcz9mZmNjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9hZXMtY2JjLWhtYWMtc2hhMi5qcyAtIEFFUy1DQkMtSE1BQy1TSEEyIENvbXBvc2l0ZWQgRW5jcnlwdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIEhNQUMgPSByZXF1aXJlKFwiLi9obWFjLmpzXCIpLFxuICAgIHNoYSA9IHJlcXVpcmUoXCIuL3NoYS5qc1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIERhdGFCdWZmZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9kYXRhYnVmZmVyLmpzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuZnVuY3Rpb24gY2hlY2tJdihpdikge1xuICBpZiAoMTYgIT09IGl2Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbW9uQ2JjRW5jcnlwdEZOKHNpemUpIHtcbiAgLy8gIyMjICdmYWxsYmFjaycgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihlbmNLZXksIHBkYXRhLCBpdikge1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoXCJBRVMtQ0JDXCIsIG5ldyBEYXRhQnVmZmVyKGVuY0tleSkpO1xuICAgICAgY2lwaGVyLnN0YXJ0KHtcbiAgICAgICAgaXY6IG5ldyBEYXRhQnVmZmVyKGl2KVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE86IGNodW5rIGRhdGFcbiAgICAgIGNpcGhlci51cGRhdGUobmV3IERhdGFCdWZmZXIocGRhdGEpKTtcbiAgICAgIGlmICghY2lwaGVyLmZpbmlzaCgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJlbmNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZGF0YSA9IEJ1ZmZlci5mcm9tKGNpcGhlci5vdXRwdXQuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG4gICAgICByZXR1cm4gY2RhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIC8vIFRPRE86IGNhY2hlIENyeXB0b0tleSBzb29uZXJcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGVuY0tleSwgcGRhdGEsIGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWxnID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jS2V5LCBhbGcsIHRydWUsIFtcImVuY3J5cHRcIl0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgYWxnID0ge1xuICAgICAgICBuYW1lOiBcIkFFUy1DQkNcIixcbiAgICAgICAgaXY6IGl2XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmVuY3J5cHQoYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNkYXRhKSB7XG4gICAgICBjZGF0YSA9IEJ1ZmZlci5mcm9tKGNkYXRhKTtcbiAgICAgIHJldHVybiBjZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBOb2RlSlMgaW1wbGVtZW50YXRpb25cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGVuY0tleSwgcGRhdGEsIGl2KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrSXYoaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocGRhdGEpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihwZGF0YSkge1xuICAgICAgdmFyIG5hbWUgPSBcIkFFUy1cIiArIHNpemUgKyBcIi1DQkNcIjtcbiAgICAgIHZhciBjaXBoZXIgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlQ2lwaGVyaXYobmFtZSwgZW5jS2V5LCBpdik7XG4gICAgICB2YXIgY2RhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShwZGF0YSksXG4gICAgICAgIGNpcGhlci5maW5hbCgpXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBjZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gY29tbW9uQ2JjRGVjcnlwdEZOKHNpemUpIHtcbiAgLy8gIyMjICdmYWxsYmFjaycgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihlbmNLZXksIGNkYXRhLCBpdikge1xuICAgIC8vIHZhbGlkYXRlIGlucHV0c1xuICAgIHRyeSB7XG4gICAgICBjaGVja0l2KGl2KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihcIkFFUy1DQkNcIiwgbmV3IERhdGFCdWZmZXIoZW5jS2V5KSk7XG4gICAgICBjaXBoZXIuc3RhcnQoe1xuICAgICAgICBpdjogbmV3IERhdGFCdWZmZXIoaXYpXG4gICAgICB9KTtcblxuICAgICAgLy8gVE9ETzogY2h1bmsgZGF0YVxuICAgICAgY2lwaGVyLnVwZGF0ZShuZXcgRGF0YUJ1ZmZlcihjZGF0YSkpO1xuICAgICAgaWYgKCFjaXBoZXIuZmluaXNoKCkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImVuY3J5cHRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBkYXRhID0gQnVmZmVyLmZyb20oY2lwaGVyLm91dHB1dC5ieXRlcygpLCBcImJpbmFyeVwiKTtcbiAgICAgIHJldHVybiBwZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgLy8gVE9ETzogY2FjaGUgQ3J5cHRvS2V5IHNvb25lclxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oZW5jS2V5LCBjZGF0YSwgaXYpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGcgPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBlbmNLZXksIGFsZywgdHJ1ZSwgW1wiZGVjcnlwdFwiXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBhbGcgPSB7XG4gICAgICAgIG5hbWU6IFwiQUVTLUNCQ1wiLFxuICAgICAgICBpdjogaXZcbiAgICAgIH07XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZGVjcnlwdChhbGcsIGtleSwgY2RhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocGRhdGEpIHtcbiAgICAgIHBkYXRhID0gQnVmZmVyLmZyb20ocGRhdGEpO1xuICAgICAgcmV0dXJuIHBkYXRhO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIE5vZGVKUyBpbXBsZW1lbnRhdGlvblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oZW5jS2V5LCBjZGF0YSwgaXYpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY2hlY2tJdihpdik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuYW1lID0gXCJBRVMtXCIgKyBzaXplICsgXCItQ0JDXCI7XG4gICAgICB2YXIgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYobmFtZSwgZW5jS2V5LCBpdik7XG4gICAgICB2YXIgcGRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgY2lwaGVyLnVwZGF0ZShjZGF0YSksXG4gICAgICAgIGNpcGhlci5maW5hbCgpXG4gICAgICBdKTtcbiAgICAgIHJldHVybiBwZGF0YTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tLZXkoa2V5LCBzaXplKSB7XG4gIGlmICgoc2l6ZSA8PCAxKSAhPT0gKGtleS5sZW5ndGggPDwgMykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuY3J5cHRpb24ga2V5IHNpemVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2JjSG1hY0VuY3J5cHRGTihzaXplKSB7XG4gIHZhciBjb21tb25FbmNyeXB0ID0gY29tbW9uQ2JjRW5jcnlwdEZOKHNpemUpO1xuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY2hlY2tLZXkoa2V5LCBzaXplKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBlS2V5ID0ga2V5LnNsaWNlKHNpemUgLyA4KSxcbiAgICAgICAgaUtleSA9IGtleS5zbGljZSgwLCBzaXplIC8gOCksXG4gICAgICAgIGl2ID0gcHJvcHMuaXYgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyBTVEVQIDEgLS0gRW5jcnlwdFxuICAgIHZhciBwcm9taXNlID0gY29tbW9uRW5jcnlwdChlS2V5LCBwZGF0YSwgaXYpO1xuXG4gICAgLy8gU1RFUCAyIC0tIE1BQ1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY2RhdGEpe1xuICAgICAgdmFyIG1kYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGFkYXRhLFxuICAgICAgICBpdixcbiAgICAgICAgY2RhdGEsXG4gICAgICAgIGhlbHBlcnMuaW50NjRUb0J1ZmZlcihhZGF0YS5sZW5ndGggKiA4KVxuICAgICAgXSk7XG5cbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IEhNQUNbXCJIU1wiICsgKHNpemUgKiAyKV0uc2lnbihpS2V5LCBtZGF0YSwge1xuICAgICAgICBsZW5ndGg6IHNpemVcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgLy8gVE9ETzogbW92ZSBzbGljZSB0byBobWFjLmpzXG4gICAgICAgIHZhciB0YWcgPSByZXN1bHQubWFjLnNsaWNlKDAsIHNpemUgLyA4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBjZGF0YSxcbiAgICAgICAgICB0YWc6IHRhZ1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjYmNIbWFjRGVjcnlwdEZOKHNpemUpIHtcbiAgdmFyIGNvbW1vbkRlY3J5cHQgPSBjb21tb25DYmNEZWNyeXB0Rk4oc2l6ZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNoZWNrS2V5KGtleSwgc2l6ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgZUtleSA9IGtleS5zbGljZShzaXplIC8gOCksXG4gICAgICAgIGlLZXkgPSBrZXkuc2xpY2UoMCwgc2l6ZSAvIDgpLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICB0YWcgPSBwcm9wcy50YWcgfHwgcHJvcHMubWFjIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgICAvLyBTVEVQIDEgLS0gTUFDXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgLy8gY29uc3RydWN0IE1BQyBpbnB1dFxuICAgICAgdmFyIG1kYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGFkYXRhLFxuICAgICAgICBpdixcbiAgICAgICAgY2RhdGEsXG4gICAgICAgIGhlbHBlcnMuaW50NjRUb0J1ZmZlcihhZGF0YS5sZW5ndGggKiA4KVxuICAgICAgXSk7XG4gICAgICBwcm9taXNlID0gSE1BQ1tcIkhTXCIgKyAoc2l6ZSAqIDIpXS52ZXJpZnkoaUtleSwgbWRhdGEsIHRhZywge1xuICAgICAgICBsZW5ndGg6IHNpemVcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNkYXRhO1xuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGZhaWx1cmUgLS0gaW52YWxpZCB0YWcgZXJyb3JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFjIGNoZWNrIGZhaWxlZFwiKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfSk7XG5cbiAgICAvLyBTVEVQIDIgLS0gRGVjcnlwdFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBjb21tb25EZWNyeXB0KGVLZXksIGNkYXRhLCBpdik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxudmFyIEVuY3J5cHRpb25MYWJlbCA9IEJ1ZmZlci5mcm9tKFwiRW5jcnlwdGlvblwiLCBcInV0ZjhcIik7XG52YXIgSW50ZWdyaXR5TGFiZWwgPSBCdWZmZXIuZnJvbShcIkludGVncml0eVwiLCBcInV0ZjhcIik7XG52YXIgRG90TGFiZWwgPSBCdWZmZXIuZnJvbShcIi5cIiwgXCJ1dGY4XCIpO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUNlayhtYXN0ZXJLZXksIGFsZywgZXB1LCBlcHYpIHtcbiAgdmFyIG1hc3RlclNpemUgPSBtYXN0ZXJLZXkubGVuZ3RoICogODtcbiAgdmFyIGNla1NpemUgPSBtYXN0ZXJTaXplIC8gMjtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGlucHV0ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoMSksXG4gICAgICBtYXN0ZXJLZXksXG4gICAgICBoZWxwZXJzLmludDMyVG9CdWZmZXIoY2VrU2l6ZSksXG4gICAgICBCdWZmZXIuZnJvbShhbGcsIFwidXRmOFwiKSxcbiAgICAgIGVwdSxcbiAgICAgIGVwdixcbiAgICAgIEVuY3J5cHRpb25MYWJlbFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9KTtcblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKCBmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBzaGFbXCJTSEEtXCIgKyBtYXN0ZXJTaXplXS5kaWdlc3QoaW5wdXQpLnRoZW4oZnVuY3Rpb24oZGlnZXN0KSB7XG4gICAgICByZXR1cm4gZGlnZXN0LnNsaWNlKDAsIGNla1NpemUgLyA4KTtcbiAgICB9KTtcbiAgfSk7XG4gIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQ2lrKG1hc3RlcktleSwgYWxnLCBlcHUsIGVwdikge1xuICB2YXIgbWFzdGVyU2l6ZSA9IG1hc3RlcktleS5sZW5ndGggKiA4O1xuICB2YXIgY2lrU2l6ZSA9IG1hc3RlclNpemU7XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpe1xuICAgIHZhciBpbnB1dCA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKDEpLFxuICAgICAgbWFzdGVyS2V5LFxuICAgICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKGNpa1NpemUpLFxuICAgICAgQnVmZmVyLmZyb20oYWxnLCBcInV0ZjhcIiksXG4gICAgICBlcHUsXG4gICAgICBlcHYsXG4gICAgICBJbnRlZ3JpdHlMYWJlbFxuICAgIF0pO1xuXG4gICAgcmV0dXJuIGlucHV0O1xuICB9KTtcblxuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKCBmdW5jdGlvbihpbnB1dCkge1xuICAgIHJldHVybiBzaGFbXCJTSEEtXCIgKyBtYXN0ZXJTaXplXS5kaWdlc3QoaW5wdXQpLnRoZW4oZnVuY3Rpb24oZGlnZXN0KSB7XG4gICAgICByZXR1cm4gZGlnZXN0LnNsaWNlKDAsIGNpa1NpemUgLyA4KTtcbiAgICB9KTtcbiAgfSk7XG4gIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUocHJvbWlzZSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdEtkZkNiY0htYWNFbmNyeXB0Rk4oc2l6ZSwgYWxnKSB7XG4gIHZhciBjb21tb25FbmNyeXB0ID0gY29tbW9uQ2JjRW5jcnlwdEZOKHNpemUpO1xuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHZhciBlcHUgPSBwcm9wcy5lcHUgfHwgaGVscGVycy5pbnQzMlRvQnVmZmVyKDApLFxuICAgICAgICBlcHYgPSBwcm9wcy5lcHYgfHwgaGVscGVycy5pbnQzMlRvQnVmZmVyKDApLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBrZGF0YSA9IHByb3BzLmtkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKTtcblxuICAgIC8vIFByZSBTdGVwIDEgLS0gR2VuZXJhdGUgS2V5c1xuICAgIHZhciBwcm9taXNlcyA9IFtcbiAgICAgIGdlbmVyYXRlQ2VrKGtleSwgYWxnLCBlcHUsIGVwdiksXG4gICAgICBnZW5lcmF0ZUNpayhrZXksIGFsZywgZXB1LCBlcHYpXG4gICAgXTtcblxuICAgIHZhciBjZWssXG4gICAgICAgIGNpaztcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgIGNlayA9IGtleXNbMF07XG4gICAgICBjaWsgPSBrZXlzWzFdO1xuICAgIH0pO1xuXG4gICAgLy8gU1RFUCAxIC0tIEVuY3J5cHRcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY29tbW9uRW5jcnlwdChjZWssIHBkYXRhLCBpdik7XG4gICAgfSk7XG5cbiAgICAvLyBTVEVQIDIgLS0gTWFjXG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihjZGF0YSl7XG4gICAgICB2YXIgbWRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgYWRhdGEsXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbShrZGF0YSksXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbSh1dGlsLmJhc2U2NHVybC5lbmNvZGUoaXYpLCBcInV0ZjhcIiksXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbSh1dGlsLmJhc2U2NHVybC5lbmNvZGUoY2RhdGEpLCBcInV0ZjhcIilcbiAgICAgIF0pO1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGNkYXRhKSxcbiAgICAgICAgSE1BQ1tcIkhTXCIgKyAoc2l6ZSAqIDIpXS5zaWduKGNpaywgbWRhdGEsIHsgbGVuZ3RoOiBzaXplIH0pXG4gICAgICBdKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiByZXN1bHRbMF0sXG4gICAgICAgIHRhZzogcmVzdWx0WzFdLm1hY1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb25jYXRLZGZDYmNIbWFjRGVjcnlwdEZOKHNpemUsIGFsZykge1xuICB2YXIgY29tbW9uRGVjcnlwdCA9IGNvbW1vbkNiY0RlY3J5cHRGTihzaXplKTtcblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgZXB1ID0gcHJvcHMuZXB1IHx8IGhlbHBlcnMuaW50MzJUb0J1ZmZlcigwKSxcbiAgICAgICAgZXB2ID0gcHJvcHMuZXB2IHx8IGhlbHBlcnMuaW50MzJUb0J1ZmZlcigwKSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAga2RhdGEgPSBwcm9wcy5rZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHRhZyA9IHByb3BzLnRhZyB8fCBwcm9wcy5tYWMgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgLy8gUHJlIFN0ZXAgMSAtLSBHZW5lcmF0ZSBLZXlzXG4gICAgdmFyIHByb21pc2VzID0gW1xuICAgICAgZ2VuZXJhdGVDZWsoa2V5LCBhbGcsIGVwdSwgZXB2KSxcbiAgICAgIGdlbmVyYXRlQ2lrKGtleSwgYWxnLCBlcHUsIGVwdilcbiAgICBdO1xuXG4gICAgdmFyIGNlayxcbiAgICAgICAgY2lrO1xuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oa2V5cyl7XG4gICAgICBjZWsgPSBrZXlzWzBdO1xuICAgICAgY2lrID0ga2V5c1sxXTtcbiAgICB9KTtcblxuXG4gICAgLy8gU1RFUCAxIC0tIE1BQ1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zdHJ1Y3QgTUFDIGlucHV0XG4gICAgICB2YXIgbWRhdGEgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgYWRhdGEsXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbShrZGF0YSksXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbSh1dGlsLmJhc2U2NHVybC5lbmNvZGUoaXYpLCBcInV0ZjhcIiksXG4gICAgICAgIERvdExhYmVsLFxuICAgICAgICBCdWZmZXIuZnJvbSh1dGlsLmJhc2U2NHVybC5lbmNvZGUoY2RhdGEpLCBcInV0ZjhcIilcbiAgICAgIF0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gSE1BQ1tcIkhTXCIgKyAoc2l6ZSAqIDIpXS52ZXJpZnkoY2lrLCBtZGF0YSwgdGFnLCB7XG4gICAgICAgICAgbG9vc2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtYWMgY2hlY2sgZmFpbGVkXCIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU1RFUCAyIC0tIERlY3J5cHRcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gY29tbW9uRGVjcnlwdChjZWssIGNkYXRhLCBpdik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmVuY3J5cHRcbi8vICogW25hbWVdLmRlY3J5cHRcbnZhciBhZXNDYmNIbWFjU2hhMiA9IHt9O1xuW1xuICBcIkExMjhDQkMtSFMyNTZcIixcbiAgXCJBMTkyQ0JDLUhTMzg0XCIsXG4gIFwiQTI1NkNCQy1IUzUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBzaXplID0gcGFyc2VJbnQoL0EoXFxkKylDQkMtSFMoXFxkKyk/L2cuZXhlYyhhbGcpWzFdKTtcbiAgYWVzQ2JjSG1hY1NoYTJbYWxnXSA9IHtcbiAgICBlbmNyeXB0OiBjYmNIbWFjRW5jcnlwdEZOKHNpemUpLFxuICAgIGRlY3J5cHQ6IGNiY0htYWNEZWNyeXB0Rk4oc2l6ZSlcbiAgfTtcbn0pO1xuXG5bXG4gIFwiQTEyOENCQytIUzI1NlwiLFxuICBcIkExOTJDQkMrSFMzODRcIixcbiAgXCJBMjU2Q0JDK0hTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIHNpemUgPSBwYXJzZUludCgvQShcXGQrKUNCQ1xcK0hTKFxcZCspPy9nLmV4ZWMoYWxnKVsxXSk7XG4gIGFlc0NiY0htYWNTaGEyW2FsZ10gPSB7XG4gICAgZW5jcnlwdDogY29uY2F0S2RmQ2JjSG1hY0VuY3J5cHRGTihzaXplLCBhbGcpLFxuICAgIGRlY3J5cHQ6IGNvbmNhdEtkZkNiY0htYWNEZWNyeXB0Rk4oc2l6ZSwgYWxnKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gYWVzQ2JjSG1hY1NoYTI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-gcm.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-gcm.js - AES-GCM Encryption and Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    GCM = __webpack_require__(/*! ../deps/ciphermodes/gcm */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\");\n\nfunction gcmEncryptFN(size, wrap) {\n  function commonChecks(key, iv) {\n    if (size !== (key.length << 3)) {\n       throw new Error(\"invalid key size\");\n    }\n    if (!iv && !wrap) {\n      throw new Error(\"invalid iv\");\n    }\n    if (iv && 12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n  }\n\n  function prepareResults(results) {\n    if (wrap) {\n      var iv = util.base64url.encode(results.iv);\n      var tag = util.base64url.encode(results.tag);\n\n      results = {\n        data: results.data,\n        header: {\n          iv: iv,\n          tag: tag\n        }\n      };\n    }\n\n    return results;\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0),\n        cipher,\n        cdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    // setup cipher\n    cipher = GCM.createCipher({\n      key: key,\n      iv: iv,\n      additionalData: adata\n    });\n    // ciphertext is the same length as plaintext\n    cdata = Buffer.alloc(pdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          clen = 0,\n          poff = 0;\n\n      (function doChunk() {\n        var plen = Math.min(amt, pdata.length - poff);\n        clen += cipher.update(pdata,\n                              poff,\n                              plen,\n                              cdata,\n                              clen);\n        poff += plen;\n        if (pdata.length > poff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        // finish it\n        clen += cipher.finish(cdata, clen);\n        if (clen !== pdata.length) {\n          reject(new Error(\"encryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        var tag = cipher.tag;\n        resolve(prepareResults({\n          data: cdata,\n          iv: iv,\n          tag: tag\n        }));\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"encrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      return helpers.subtleCrypto.encrypt(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var tagStart = result.byteLength - 16;\n\n      var tag = result.slice(tagStart);\n      tag = Buffer.from(tag);\n\n      var cdata = result.slice(0, tagStart);\n      cdata = Buffer.from(cdata);\n\n      return prepareResults({\n        data: cdata,\n        iv: iv,\n        tag: tag\n      });\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    var iv = props.iv,\n        adata = props.aad || props.adata || Buffer.alloc(0);\n\n    try {\n      commonChecks(key, iv, adata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    iv = iv || util.randomBytes(12);\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createCipheriv(alg, key, iv);\n    } catch (err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    var cdata = Buffer.concat([\n      cipher.update(pdata),\n      cipher.final()\n    ]);\n    var tag = cipher.getAuthTag();\n\n    return prepareResults({\n      data: cdata,\n      iv: iv,\n      tag: tag\n    });\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction gcmDecryptFN(size) {\n  function commonChecks(key, iv, tag) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (12 !== iv.length) {\n      throw new Error(\"invalid iv\");\n    }\n    if (16 !== tag.length) {\n      throw new Error(\"invalid tag length\");\n    }\n  }\n\n  // ### fallback implementation -- uses forge\n  var fallback = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0),\n        cipher,\n        pdata;\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    cipher = GCM.createDecipher({\n      key: key,\n      iv: iv,\n      additionalData: adata,\n      tag: tag\n    });\n    // plaintext is the same length as ciphertext\n    pdata = Buffer.alloc(cdata.length);\n\n    var promise = new Promise(function(resolve, reject) {\n      var amt = CONSTANTS.CHUNK_SIZE,\n          plen = 0,\n          coff = 0;\n\n      (function doChunk() {\n        var clen = Math.min(amt, cdata.length - coff);\n        plen += cipher.update(cdata,\n                              coff,\n                              clen,\n                              pdata,\n                              plen);\n        coff += clen;\n        if (cdata.length > coff) {\n          setTimeout(doChunk, 0);\n          return;\n        }\n\n        try {\n          plen += cipher.finish(pdata, plen);\n        } catch (err) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        if (plen !== cdata.length) {\n          reject(new Error(\"decryption failed\"));\n          return;\n        }\n\n        // resolve with output\n        resolve(pdata);\n      })();\n    });\n\n    return promise;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-GCM\"\n    };\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"decrypt\"]);\n    promise = promise.then(function(key) {\n      alg.iv = iv;\n      alg.tagLength = 128;\n      if (adata.length) {\n        alg.additionalData = adata;\n      }\n\n      // concatenate cdata and tag\n      cdata = Buffer.concat([cdata, tag], cdata.length + tag.length);\n\n      return helpers.subtleCrypto.decrypt(alg, key, cdata);\n    });\n    promise = promise.then(function(pdata) {\n      pdata = Buffer.from(pdata);\n      return pdata;\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, cdata, props) {\n    var adata = props.aad || props.adata || Buffer.alloc(0),\n        iv = props.iv || Buffer.alloc(0),\n        tag = props.tag || props.mac || Buffer.alloc(0);\n\n    // validate inputs\n    try {\n      commonChecks(key, iv, tag);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = \"aes-\" + (key.length * 8) + \"-gcm\";\n    var cipher;\n    try {\n      cipher = helpers.nodeCrypto.createDecipheriv(alg, key, iv);\n    } catch(err) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    if (\"function\" !== typeof cipher.setAAD) {\n      throw new Error(\"unsupported algorithm: \" + alg);\n    }\n    cipher.setAuthTag(tag);\n    if (adata.length) {\n      cipher.setAAD(adata);\n    }\n\n    try {\n      var pdata = Buffer.concat([\n        cipher.update(cdata),\n        cipher.final()\n      ]);\n\n      return pdata;\n    } catch (err) {\n      throw new Error(\"decryption failed\");\n    }\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesGcm = {};\n[\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\"\n].forEach(function(alg) {\n  var parts = /A(\\d+)GCM(KW)?/g.exec(alg);\n  var size = parseInt(parts[1]);\n  var wrap = (parts[2] === \"KW\");\n  aesGcm[alg] = {\n    encrypt: gcmEncryptFN(size, wrap),\n    decrypt: gcmDecryptFN(size, wrap)\n  };\n});\n\nmodule.exports = aesGcm;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1nY20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxpR0FBeUI7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvYWVzLWdjbS5qcz8yN2ZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9hZXMtZ2NtLmpzIC0gQUVTLUdDTSBFbmNyeXB0aW9uIGFuZCBLZXktV3JhcHBpbmdcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLFxuICAgIEdDTSA9IHJlcXVpcmUoXCIuLi9kZXBzL2NpcGhlcm1vZGVzL2djbVwiKTtcblxuZnVuY3Rpb24gZ2NtRW5jcnlwdEZOKHNpemUsIHdyYXApIHtcbiAgZnVuY3Rpb24gY29tbW9uQ2hlY2tzKGtleSwgaXYpIHtcbiAgICBpZiAoc2l6ZSAhPT0gKGtleS5sZW5ndGggPDwgMykpIHtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtleSBzaXplXCIpO1xuICAgIH1cbiAgICBpZiAoIWl2ICYmICF3cmFwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl2XCIpO1xuICAgIH1cbiAgICBpZiAoaXYgJiYgMTIgIT09IGl2Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgaWYgKHdyYXApIHtcbiAgICAgIHZhciBpdiA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHRzLml2KTtcbiAgICAgIHZhciB0YWcgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0cy50YWcpO1xuXG4gICAgICByZXN1bHRzID0ge1xuICAgICAgICBkYXRhOiByZXN1bHRzLmRhdGEsXG4gICAgICAgIGhlYWRlcjoge1xuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICB0YWc6IHRhZ1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gIyMjICdmYWxsYmFjaycgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHZhciBpdiA9IHByb3BzLml2LFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIGNpcGhlcixcbiAgICAgICAgY2RhdGE7XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIGFkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGl2ID0gaXYgfHwgdXRpbC5yYW5kb21CeXRlcygxMik7XG5cbiAgICAvLyBzZXR1cCBjaXBoZXJcbiAgICBjaXBoZXIgPSBHQ00uY3JlYXRlQ2lwaGVyKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXY6IGl2LFxuICAgICAgYWRkaXRpb25hbERhdGE6IGFkYXRhXG4gICAgfSk7XG4gICAgLy8gY2lwaGVydGV4dCBpcyB0aGUgc2FtZSBsZW5ndGggYXMgcGxhaW50ZXh0XG4gICAgY2RhdGEgPSBCdWZmZXIuYWxsb2MocGRhdGEubGVuZ3RoKTtcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgYW10ID0gQ09OU1RBTlRTLkNIVU5LX1NJWkUsXG4gICAgICAgICAgY2xlbiA9IDAsXG4gICAgICAgICAgcG9mZiA9IDA7XG5cbiAgICAgIChmdW5jdGlvbiBkb0NodW5rKCkge1xuICAgICAgICB2YXIgcGxlbiA9IE1hdGgubWluKGFtdCwgcGRhdGEubGVuZ3RoIC0gcG9mZik7XG4gICAgICAgIGNsZW4gKz0gY2lwaGVyLnVwZGF0ZShwZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvZmYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2RhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVuKTtcbiAgICAgICAgcG9mZiArPSBwbGVuO1xuICAgICAgICBpZiAocGRhdGEubGVuZ3RoID4gcG9mZikge1xuICAgICAgICAgIHNldFRpbWVvdXQoZG9DaHVuaywgMCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluaXNoIGl0XG4gICAgICAgIGNsZW4gKz0gY2lwaGVyLmZpbmlzaChjZGF0YSwgY2xlbik7XG4gICAgICAgIGlmIChjbGVuICE9PSBwZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiZW5jcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc29sdmUgd2l0aCBvdXRwdXRcbiAgICAgICAgdmFyIHRhZyA9IGNpcGhlci50YWc7XG4gICAgICAgIHJlc29sdmUocHJlcGFyZVJlc3VsdHMoe1xuICAgICAgICAgIGRhdGE6IGNkYXRhLFxuICAgICAgICAgIGl2OiBpdixcbiAgICAgICAgICB0YWc6IHRhZ1xuICAgICAgICB9KSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBjYWNoZSBDcnlwdG9LZXkgc29vbmVyXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBwcm9wcykge1xuICAgIHZhciBpdiA9IHByb3BzLml2LFxuICAgICAgICBhZGF0YSA9IHByb3BzLmFhZCB8fCBwcm9wcy5hZGF0YSB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIGFkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGl2ID0gaXYgfHwgdXRpbC5yYW5kb21CeXRlcygxMik7XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJBRVMtR0NNXCJcbiAgICB9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5LCBhbGcsIHRydWUsIFtcImVuY3J5cHRcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICBhbGcuaXYgPSBpdjtcbiAgICAgIGFsZy50YWdMZW5ndGggPSAxMjg7XG4gICAgICBpZiAoYWRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGFsZy5hZGRpdGlvbmFsRGF0YSA9IGFkYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZW5jcnlwdChhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICB2YXIgdGFnU3RhcnQgPSByZXN1bHQuYnl0ZUxlbmd0aCAtIDE2O1xuXG4gICAgICB2YXIgdGFnID0gcmVzdWx0LnNsaWNlKHRhZ1N0YXJ0KTtcbiAgICAgIHRhZyA9IEJ1ZmZlci5mcm9tKHRhZyk7XG5cbiAgICAgIHZhciBjZGF0YSA9IHJlc3VsdC5zbGljZSgwLCB0YWdTdGFydCk7XG4gICAgICBjZGF0YSA9IEJ1ZmZlci5mcm9tKGNkYXRhKTtcblxuICAgICAgcmV0dXJuIHByZXBhcmVSZXN1bHRzKHtcbiAgICAgICAgZGF0YTogY2RhdGEsXG4gICAgICAgIGl2OiBpdixcbiAgICAgICAgdGFnOiB0YWdcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIE5vZGVKUyBpbXBsZW1lbnRhdGlvblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgaXYgPSBwcm9wcy5pdixcbiAgICAgICAgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCBhZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBpdiA9IGl2IHx8IHV0aWwucmFuZG9tQnl0ZXMoMTIpO1xuXG4gICAgdmFyIGFsZyA9IFwiYWVzLVwiICsgKGtleS5sZW5ndGggKiA4KSArIFwiLWdjbVwiO1xuICAgIHZhciBjaXBoZXI7XG4gICAgdHJ5IHtcbiAgICAgIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVDaXBoZXJpdihhbGcsIGtleSwgaXYpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjaXBoZXIuc2V0QUFEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgICB9XG4gICAgaWYgKGFkYXRhLmxlbmd0aCkge1xuICAgICAgY2lwaGVyLnNldEFBRChhZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGNkYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBjaXBoZXIudXBkYXRlKHBkYXRhKSxcbiAgICAgIGNpcGhlci5maW5hbCgpXG4gICAgXSk7XG4gICAgdmFyIHRhZyA9IGNpcGhlci5nZXRBdXRoVGFnKCk7XG5cbiAgICByZXR1cm4gcHJlcGFyZVJlc3VsdHMoe1xuICAgICAgZGF0YTogY2RhdGEsXG4gICAgICBpdjogaXYsXG4gICAgICB0YWc6IHRhZ1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2NtRGVjcnlwdEZOKHNpemUpIHtcbiAgZnVuY3Rpb24gY29tbW9uQ2hlY2tzKGtleSwgaXYsIHRhZykge1xuICAgIGlmIChzaXplICE9PSAoa2V5Lmxlbmd0aCA8PCAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKDEyICE9PSBpdi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG4gICAgfVxuICAgIGlmICgxNiAhPT0gdGFnLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0YWcgbGVuZ3RoXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgdmFyIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHRhZyA9IHByb3BzLnRhZyB8fCBwcm9wcy5tYWMgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBjaXBoZXIsXG4gICAgICAgIHBkYXRhO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCB0YWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgY2lwaGVyXG4gICAgY2lwaGVyID0gR0NNLmNyZWF0ZURlY2lwaGVyKHtcbiAgICAgIGtleToga2V5LFxuICAgICAgaXY6IGl2LFxuICAgICAgYWRkaXRpb25hbERhdGE6IGFkYXRhLFxuICAgICAgdGFnOiB0YWdcbiAgICB9KTtcbiAgICAvLyBwbGFpbnRleHQgaXMgdGhlIHNhbWUgbGVuZ3RoIGFzIGNpcGhlcnRleHRcbiAgICBwZGF0YSA9IEJ1ZmZlci5hbGxvYyhjZGF0YS5sZW5ndGgpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBhbXQgPSBDT05TVEFOVFMuQ0hVTktfU0laRSxcbiAgICAgICAgICBwbGVuID0gMCxcbiAgICAgICAgICBjb2ZmID0gMDtcblxuICAgICAgKGZ1bmN0aW9uIGRvQ2h1bmsoKSB7XG4gICAgICAgIHZhciBjbGVuID0gTWF0aC5taW4oYW10LCBjZGF0YS5sZW5ndGggLSBjb2ZmKTtcbiAgICAgICAgcGxlbiArPSBjaXBoZXIudXBkYXRlKGNkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29mZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsZW4pO1xuICAgICAgICBjb2ZmICs9IGNsZW47XG4gICAgICAgIGlmIChjZGF0YS5sZW5ndGggPiBjb2ZmKSB7XG4gICAgICAgICAgc2V0VGltZW91dChkb0NodW5rLCAwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBsZW4gKz0gY2lwaGVyLmZpbmlzaChwZGF0YSwgcGxlbik7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJkZWNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBsZW4gIT09IGNkYXRhLmxlbmd0aCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJkZWNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSB3aXRoIG91dHB1dFxuICAgICAgICByZXNvbHZlKHBkYXRhKTtcbiAgICAgIH0pKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIGltcGxlbWVudGF0aW9uXG4gIC8vIFRPRE86IGNhY2hlIENyeXB0b0tleSBzb29uZXJcbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgY2RhdGEsIHByb3BzKSB7XG4gICAgdmFyIGFkYXRhID0gcHJvcHMuYWFkIHx8IHByb3BzLmFkYXRhIHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgaXYgPSBwcm9wcy5pdiB8fCBCdWZmZXIuYWxsb2MoMCksXG4gICAgICAgIHRhZyA9IHByb3BzLnRhZyB8fCBwcm9wcy5tYWMgfHwgQnVmZmVyLmFsbG9jKDApO1xuXG4gICAgLy8gdmFsaWRhdGUgaW5wdXRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIGl2LCB0YWcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiQUVTLUdDTVwiXG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJkZWNyeXB0XCJdKTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgYWxnLml2ID0gaXY7XG4gICAgICBhbGcudGFnTGVuZ3RoID0gMTI4O1xuICAgICAgaWYgKGFkYXRhLmxlbmd0aCkge1xuICAgICAgICBhbGcuYWRkaXRpb25hbERhdGEgPSBhZGF0YTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uY2F0ZW5hdGUgY2RhdGEgYW5kIHRhZ1xuICAgICAgY2RhdGEgPSBCdWZmZXIuY29uY2F0KFtjZGF0YSwgdGFnXSwgY2RhdGEubGVuZ3RoICsgdGFnLmxlbmd0aCk7XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5kZWNyeXB0KGFsZywga2V5LCBjZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihwZGF0YSkge1xuICAgICAgcGRhdGEgPSBCdWZmZXIuZnJvbShwZGF0YSk7XG4gICAgICByZXR1cm4gcGRhdGE7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICB2YXIgYWRhdGEgPSBwcm9wcy5hYWQgfHwgcHJvcHMuYWRhdGEgfHwgQnVmZmVyLmFsbG9jKDApLFxuICAgICAgICBpdiA9IHByb3BzLml2IHx8IEJ1ZmZlci5hbGxvYygwKSxcbiAgICAgICAgdGFnID0gcHJvcHMudGFnIHx8IHByb3BzLm1hYyB8fCBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgICAvLyB2YWxpZGF0ZSBpbnB1dHNcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgaXYsIHRhZyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgYWxnID0gXCJhZXMtXCIgKyAoa2V5Lmxlbmd0aCAqIDgpICsgXCItZ2NtXCI7XG4gICAgdmFyIGNpcGhlcjtcbiAgICB0cnkge1xuICAgICAgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoYWxnLCBrZXksIGl2KTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZyk7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjaXBoZXIuc2V0QUFEKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKTtcbiAgICB9XG4gICAgY2lwaGVyLnNldEF1dGhUYWcodGFnKTtcbiAgICBpZiAoYWRhdGEubGVuZ3RoKSB7XG4gICAgICBjaXBoZXIuc2V0QUFEKGFkYXRhKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHBkYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIGNpcGhlci51cGRhdGUoY2RhdGEpLFxuICAgICAgICBjaXBoZXIuZmluYWwoKVxuICAgICAgXSk7XG5cbiAgICAgIHJldHVybiBwZGF0YTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRlY3J5cHRpb24gZmFpbGVkXCIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG52YXIgYWVzR2NtID0ge307XG5bXG4gIFwiQTEyOEdDTVwiLFxuICBcIkExOTJHQ01cIixcbiAgXCJBMjU2R0NNXCIsXG4gIFwiQTEyOEdDTUtXXCIsXG4gIFwiQTE5MkdDTUtXXCIsXG4gIFwiQTI1NkdDTUtXXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIHBhcnRzID0gL0EoXFxkKylHQ00oS1cpPy9nLmV4ZWMoYWxnKTtcbiAgdmFyIHNpemUgPSBwYXJzZUludChwYXJ0c1sxXSk7XG4gIHZhciB3cmFwID0gKHBhcnRzWzJdID09PSBcIktXXCIpO1xuICBhZXNHY21bYWxnXSA9IHtcbiAgICBlbmNyeXB0OiBnY21FbmNyeXB0Rk4oc2l6ZSwgd3JhcCksXG4gICAgZGVjcnlwdDogZ2NtRGVjcnlwdEZOKHNpemUsIHdyYXApXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZXNHY207XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/aes-kw.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/aes-kw.js - AES-KW Key-Wrapping\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\");\n\nvar A0 = Buffer.from(\"a6a6a6a6a6a6a6a6\", \"hex\");\n\n// ### helpers\nfunction xor(a, b) {\n  var len = Math.max(a.length, b.length);\n  var result = Buffer.alloc(len);\n  for (var idx = 0; len > idx; idx++) {\n    result[idx] = (a[idx] || 0) ^ (b[idx] || 0);\n  }\n  return result;\n}\n\nfunction split(input, size) {\n  var output = [];\n  for (var idx = 0; input.length > idx; idx += size) {\n    output.push(input.slice(idx, idx + size));\n  }\n  return output;\n}\n\nfunction longToBigEndian(input) {\n  var hi = Math.floor(input / 4294967296),\n      lo = input % 4294967296;\n  var output = Buffer.alloc(8);\n  output[0] = 0xff & (hi >>> 24);\n  output[1] = 0xff & (hi >>> 16);\n  output[2] = 0xff & (hi >>> 8);\n  output[3] = 0xff & (hi >>> 0);\n  output[4] = 0xff & (lo >>> 24);\n  output[5] = 0xff & (lo >>> 16);\n  output[6] = 0xff & (lo >>> 8);\n  output[7] = 0xff & (lo >>> 0);\n  return output;\n}\n\nfunction kwEncryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < data.length && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createCipher(\"AES\", new DataBuffer(key));\n\n    // split input into chunks\n    var R = split(pdata, 8);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = [\n      helpers.subtleCrypto.importKey(\"raw\", pdata, { name: \"HMAC\", hash: \"SHA-256\" }, true, [\"sign\"]),\n      helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"wrapKey\"])\n    ];\n    promise = Promise.all(promise);\n    promise = promise.then(function(keys) {\n      return helpers.subtleCrypto.wrapKey(\"raw\",\n                                          keys[0], // key\n                                          keys[1], // wrappingKey\n                                          alg);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n\n      return {\n        data: result\n      };\n    });\n    return promise;\n  };\n  var node = function(key, pdata) {\n    try {\n      commonChecks(key, pdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // split input into chunks\n    var R = split(pdata, 8),\n        iv = Buffer.alloc(16);\n    var A,\n        B,\n        count;\n    A = A0;\n    for (var jdx = 0; 6 > jdx; jdx++) {\n      for (var idx = 0; R.length > idx; idx++) {\n        count = (R.length * jdx) + idx + 1;\n        B = Buffer.concat([A, R[idx]]);\n        var cipher = helpers.nodeCrypto.createCipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = xor(B.slice(0, 8),\n                longToBigEndian(count));\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    R = [A].concat(R);\n    var cdata = Buffer.concat(R);\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\nfunction kwDecryptFN(size) {\n  function commonChecks(key, data) {\n    if (size !== (key.length << 3)) {\n      throw new Error(\"invalid key size\");\n    }\n    if (0 < (data.length - 8) && 0 !== (data.length % 8)) {\n      throw new Error(\"invalid data length\");\n    }\n  }\n\n  // ### 'fallback' implementation -- uses forge\n  var fallback = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // setup cipher\n    var cipher = forge.cipher.createDecipher(\"AES\", new DataBuffer(key));\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx]]);\n        cipher.start();\n        cipher.update(new DataBuffer(B));\n        cipher.finish();\n        B = Buffer.from(cipher.output.bytes(), \"binary\");\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n  // ### WebCryptoAPI implementation\n  var webcrypto = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var alg = {\n      name: \"AES-KW\"\n    };\n    var promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"unwrapKey\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.unwrapKey(\"raw\", cdata, key, alg, {name: \"HMAC\", hash: \"SHA-256\"}, true, [\"sign\"]);\n    });\n    promise = promise.then(function(result) {\n      // unwrapped CryptoKey -- extract raw\n      return helpers.subtleCrypto.exportKey(\"raw\", result);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n  var node = function(key, cdata) {\n    try {\n      commonChecks(key, cdata);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    // prepare inputs\n    var R = split(cdata, 8),\n        iv = Buffer.alloc(16),\n        A,\n        B,\n        count;\n    A = R[0];\n    R = R.slice(1);\n    for (var jdx = 5; 0 <= jdx; --jdx) {\n      for (var idx = R.length - 1; 0 <= idx; --idx) {\n        count = (R.length * jdx) + idx + 1;\n        B = xor(A,\n                longToBigEndian(count));\n        B = Buffer.concat([B, R[idx], iv]);\n        var cipher = helpers.nodeCrypto.createDecipheriv(\"AES\" + size, key, iv);\n        B = cipher.update(B);\n\n        A = B.slice(0, 8);\n        R[idx] = B.slice(8, 16);\n      }\n    }\n    if (A.toString() !== A0.toString()) {\n      return Promise.reject(new Error(\"decryption failed\"));\n    }\n    var pdata = Buffer.concat(R);\n    return Promise.resolve(pdata);\n  };\n\n  return helpers.setupFallback(node, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar aesKw = {};\n[\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\"\n].forEach(function(alg) {\n  var size = parseInt(/A(\\d+)KW/g.exec(alg)[1]);\n  aesKw[alg] = {\n    encrypt: kwEncryptFN(size),\n    decrypt: kwDecryptFN(size)\n  };\n});\n\nmodule.exports = aesKw;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Flcy1rdy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCOztBQUVoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQix3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELCtCQUErQjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw4QkFBOEI7QUFDbkcsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQyxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvYWVzLWt3LmpzP2Q2NGMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2Flcy1rdy5qcyAtIEFFUy1LVyBLZXktV3JhcHBpbmdcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIERhdGFCdWZmZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9kYXRhYnVmZmVyLmpzXCIpO1xuXG52YXIgQTAgPSBCdWZmZXIuZnJvbShcImE2YTZhNmE2YTZhNmE2YTZcIiwgXCJoZXhcIik7XG5cbi8vICMjIyBoZWxwZXJzXG5mdW5jdGlvbiB4b3IoYSwgYikge1xuICB2YXIgbGVuID0gTWF0aC5tYXgoYS5sZW5ndGgsIGIubGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5hbGxvYyhsZW4pO1xuICBmb3IgKHZhciBpZHggPSAwOyBsZW4gPiBpZHg7IGlkeCsrKSB7XG4gICAgcmVzdWx0W2lkeF0gPSAoYVtpZHhdIHx8IDApIF4gKGJbaWR4XSB8fCAwKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBzcGxpdChpbnB1dCwgc2l6ZSkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGlkeCA9IDA7IGlucHV0Lmxlbmd0aCA+IGlkeDsgaWR4ICs9IHNpemUpIHtcbiAgICBvdXRwdXQucHVzaChpbnB1dC5zbGljZShpZHgsIGlkeCArIHNpemUpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBsb25nVG9CaWdFbmRpYW4oaW5wdXQpIHtcbiAgdmFyIGhpID0gTWF0aC5mbG9vcihpbnB1dCAvIDQyOTQ5NjcyOTYpLFxuICAgICAgbG8gPSBpbnB1dCAlIDQyOTQ5NjcyOTY7XG4gIHZhciBvdXRwdXQgPSBCdWZmZXIuYWxsb2MoOCk7XG4gIG91dHB1dFswXSA9IDB4ZmYgJiAoaGkgPj4+IDI0KTtcbiAgb3V0cHV0WzFdID0gMHhmZiAmIChoaSA+Pj4gMTYpO1xuICBvdXRwdXRbMl0gPSAweGZmICYgKGhpID4+PiA4KTtcbiAgb3V0cHV0WzNdID0gMHhmZiAmIChoaSA+Pj4gMCk7XG4gIG91dHB1dFs0XSA9IDB4ZmYgJiAobG8gPj4+IDI0KTtcbiAgb3V0cHV0WzVdID0gMHhmZiAmIChsbyA+Pj4gMTYpO1xuICBvdXRwdXRbNl0gPSAweGZmICYgKGxvID4+PiA4KTtcbiAgb3V0cHV0WzddID0gMHhmZiAmIChsbyA+Pj4gMCk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGt3RW5jcnlwdEZOKHNpemUpIHtcbiAgZnVuY3Rpb24gY29tbW9uQ2hlY2tzKGtleSwgZGF0YSkge1xuICAgIGlmIChzaXplICE9PSAoa2V5Lmxlbmd0aCA8PCAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKDAgPCBkYXRhLmxlbmd0aCAmJiAwICE9PSAoZGF0YS5sZW5ndGggJSA4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aFwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgJ2ZhbGxiYWNrJyBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgcGRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgY2lwaGVyXG4gICAgdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVDaXBoZXIoXCJBRVNcIiwgbmV3IERhdGFCdWZmZXIoa2V5KSk7XG5cbiAgICAvLyBzcGxpdCBpbnB1dCBpbnRvIGNodW5rc1xuICAgIHZhciBSID0gc3BsaXQocGRhdGEsIDgpO1xuICAgIHZhciBBLFxuICAgICAgICBCLFxuICAgICAgICBjb3VudDtcbiAgICBBID0gQTA7XG4gICAgZm9yICh2YXIgamR4ID0gMDsgNiA+IGpkeDsgamR4KyspIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IFIubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgICAgICBjb3VudCA9IChSLmxlbmd0aCAqIGpkeCkgKyBpZHggKyAxO1xuICAgICAgICBCID0gQnVmZmVyLmNvbmNhdChbQSwgUltpZHhdXSk7XG4gICAgICAgIGNpcGhlci5zdGFydCgpO1xuICAgICAgICBjaXBoZXIudXBkYXRlKG5ldyBEYXRhQnVmZmVyKEIpKTtcbiAgICAgICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgICAgICBCID0gQnVmZmVyLmZyb20oY2lwaGVyLm91dHB1dC5ieXRlcygpLCBcImJpbmFyeVwiKTtcblxuICAgICAgICBBID0geG9yKEIuc2xpY2UoMCwgOCksXG4gICAgICAgICAgICAgICAgbG9uZ1RvQmlnRW5kaWFuKGNvdW50KSk7XG4gICAgICAgIFJbaWR4XSA9IEIuc2xpY2UoOCwgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgICBSID0gW0FdLmNvbmNhdChSKTtcbiAgICB2YXIgY2RhdGEgPSBCdWZmZXIuY29uY2F0KFIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogY2RhdGFcbiAgICB9KTtcbiAgfTtcbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb21tb25DaGVja3Moa2V5LCBwZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJBRVMtS1dcIlxuICAgIH07XG4gICAgdmFyIHByb21pc2UgPSBbXG4gICAgICBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwgcGRhdGEsIHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH0sIHRydWUsIFtcInNpZ25cIl0pLFxuICAgICAgaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJ3cmFwS2V5XCJdKVxuICAgIF07XG4gICAgcHJvbWlzZSA9IFByb21pc2UuYWxsKHByb21pc2UpO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5cykge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLndyYXBLZXkoXCJyYXdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXNbMF0sIC8vIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5c1sxXSwgLy8gd3JhcHBpbmdLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZyk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbiAgdmFyIG5vZGUgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1vbkNoZWNrcyhrZXksIHBkYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IGlucHV0IGludG8gY2h1bmtzXG4gICAgdmFyIFIgPSBzcGxpdChwZGF0YSwgOCksXG4gICAgICAgIGl2ID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgICB2YXIgQSxcbiAgICAgICAgQixcbiAgICAgICAgY291bnQ7XG4gICAgQSA9IEEwO1xuICAgIGZvciAodmFyIGpkeCA9IDA7IDYgPiBqZHg7IGpkeCsrKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBSLmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgICAgY291bnQgPSAoUi5sZW5ndGggKiBqZHgpICsgaWR4ICsgMTtcbiAgICAgICAgQiA9IEJ1ZmZlci5jb25jYXQoW0EsIFJbaWR4XV0pO1xuICAgICAgICB2YXIgY2lwaGVyID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZUNpcGhlcml2KFwiQUVTXCIgKyBzaXplLCBrZXksIGl2KTtcbiAgICAgICAgQiA9IGNpcGhlci51cGRhdGUoQik7XG5cbiAgICAgICAgQSA9IHhvcihCLnNsaWNlKDAsIDgpLFxuICAgICAgICAgICAgICAgIGxvbmdUb0JpZ0VuZGlhbihjb3VudCkpO1xuICAgICAgICBSW2lkeF0gPSBCLnNsaWNlKDgsIDE2KTtcbiAgICAgIH1cbiAgICB9XG4gICAgUiA9IFtBXS5jb25jYXQoUik7XG4gICAgdmFyIGNkYXRhID0gQnVmZmVyLmNvbmNhdChSKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIGRhdGE6IGNkYXRhXG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cbmZ1bmN0aW9uIGt3RGVjcnlwdEZOKHNpemUpIHtcbiAgZnVuY3Rpb24gY29tbW9uQ2hlY2tzKGtleSwgZGF0YSkge1xuICAgIGlmIChzaXplICE9PSAoa2V5Lmxlbmd0aCA8PCAzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgc2l6ZVwiKTtcbiAgICB9XG4gICAgaWYgKDAgPCAoZGF0YS5sZW5ndGggLSA4KSAmJiAwICE9PSAoZGF0YS5sZW5ndGggJSA4KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aFwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgJ2ZhbGxiYWNrJyBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgY2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgY2RhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgY2lwaGVyXG4gICAgdmFyIGNpcGhlciA9IGZvcmdlLmNpcGhlci5jcmVhdGVEZWNpcGhlcihcIkFFU1wiLCBuZXcgRGF0YUJ1ZmZlcihrZXkpKTtcblxuICAgIC8vIHByZXBhcmUgaW5wdXRzXG4gICAgdmFyIFIgPSBzcGxpdChjZGF0YSwgOCksXG4gICAgICAgIEEsXG4gICAgICAgIEIsXG4gICAgICAgIGNvdW50O1xuICAgIEEgPSBSWzBdO1xuICAgIFIgPSBSLnNsaWNlKDEpO1xuICAgIGZvciAodmFyIGpkeCA9IDU7IDAgPD0gamR4OyAtLWpkeCkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gUi5sZW5ndGggLSAxOyAwIDw9IGlkeDsgLS1pZHgpIHtcbiAgICAgICAgY291bnQgPSAoUi5sZW5ndGggKiBqZHgpICsgaWR4ICsgMTtcbiAgICAgICAgQiA9IHhvcihBLFxuICAgICAgICAgICAgICAgIGxvbmdUb0JpZ0VuZGlhbihjb3VudCkpO1xuICAgICAgICBCID0gQnVmZmVyLmNvbmNhdChbQiwgUltpZHhdXSk7XG4gICAgICAgIGNpcGhlci5zdGFydCgpO1xuICAgICAgICBjaXBoZXIudXBkYXRlKG5ldyBEYXRhQnVmZmVyKEIpKTtcbiAgICAgICAgY2lwaGVyLmZpbmlzaCgpO1xuICAgICAgICBCID0gQnVmZmVyLmZyb20oY2lwaGVyLm91dHB1dC5ieXRlcygpLCBcImJpbmFyeVwiKTtcblxuICAgICAgICBBID0gQi5zbGljZSgwLCA4KTtcbiAgICAgICAgUltpZHhdID0gQi5zbGljZSg4LCAxNik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBLnRvU3RyaW5nKCkgIT09IEEwLnRvU3RyaW5nKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJkZWNyeXB0aW9uIGZhaWxlZFwiKSk7XG4gICAgfVxuICAgIHZhciBwZGF0YSA9IEJ1ZmZlci5jb25jYXQoUik7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZGF0YSk7XG4gIH07XG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgaW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgY2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgY2RhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiQUVTLUtXXCJcbiAgICB9O1xuICAgIHZhciBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJ1bndyYXBLZXlcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8udW53cmFwS2V5KFwicmF3XCIsIGNkYXRhLCBrZXksIGFsZywge25hbWU6IFwiSE1BQ1wiLCBoYXNoOiBcIlNIQS0yNTZcIn0sIHRydWUsIFtcInNpZ25cIl0pO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAvLyB1bndyYXBwZWQgQ3J5cHRvS2V5IC0tIGV4dHJhY3QgcmF3XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uZXhwb3J0S2V5KFwicmF3XCIsIHJlc3VsdCk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICB2YXIgbm9kZSA9IGZ1bmN0aW9uKGtleSwgY2RhdGEpIHtcbiAgICB0cnkge1xuICAgICAgY29tbW9uQ2hlY2tzKGtleSwgY2RhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgLy8gcHJlcGFyZSBpbnB1dHNcbiAgICB2YXIgUiA9IHNwbGl0KGNkYXRhLCA4KSxcbiAgICAgICAgaXYgPSBCdWZmZXIuYWxsb2MoMTYpLFxuICAgICAgICBBLFxuICAgICAgICBCLFxuICAgICAgICBjb3VudDtcbiAgICBBID0gUlswXTtcbiAgICBSID0gUi5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBqZHggPSA1OyAwIDw9IGpkeDsgLS1qZHgpIHtcbiAgICAgIGZvciAodmFyIGlkeCA9IFIubGVuZ3RoIC0gMTsgMCA8PSBpZHg7IC0taWR4KSB7XG4gICAgICAgIGNvdW50ID0gKFIubGVuZ3RoICogamR4KSArIGlkeCArIDE7XG4gICAgICAgIEIgPSB4b3IoQSxcbiAgICAgICAgICAgICAgICBsb25nVG9CaWdFbmRpYW4oY291bnQpKTtcbiAgICAgICAgQiA9IEJ1ZmZlci5jb25jYXQoW0IsIFJbaWR4XSwgaXZdKTtcbiAgICAgICAgdmFyIGNpcGhlciA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVEZWNpcGhlcml2KFwiQUVTXCIgKyBzaXplLCBrZXksIGl2KTtcbiAgICAgICAgQiA9IGNpcGhlci51cGRhdGUoQik7XG5cbiAgICAgICAgQSA9IEIuc2xpY2UoMCwgOCk7XG4gICAgICAgIFJbaWR4XSA9IEIuc2xpY2UoOCwgMTYpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoQS50b1N0cmluZygpICE9PSBBMC50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiZGVjcnlwdGlvbiBmYWlsZWRcIikpO1xuICAgIH1cbiAgICB2YXIgcGRhdGEgPSBCdWZmZXIuY29uY2F0KFIpO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGRhdGEpO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZSwgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG52YXIgYWVzS3cgPSB7fTtcbltcbiAgXCJBMTI4S1dcIixcbiAgXCJBMTkyS1dcIixcbiAgXCJBMjU2S1dcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICB2YXIgc2l6ZSA9IHBhcnNlSW50KC9BKFxcZCspS1cvZy5leGVjKGFsZylbMV0pO1xuICBhZXNLd1thbGddID0ge1xuICAgIGVuY3J5cHQ6IGt3RW5jcnlwdEZOKHNpemUpLFxuICAgIGRlY3J5cHQ6IGt3RGVjcnlwdEZOKHNpemUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZXNLdztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/concat.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/concat.js - Concat Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction concatDeriveFn(name) {\n  name = name.replace(\"CONCAT-\", \"\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since ConcatKDF is\n  //       implemented using the SHA algorithms\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var keyLen = props.length,\n        hashLen = CONSTANTS.HASHLENGTH[name];\n    if (!keyLen) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    // setup otherInfo\n    if (!props.otherInfo) {\n      return Promise.reject(new Error(\"invalid otherInfo\"));\n    }\n    var otherInfo = props.otherInfo;\n\n    var op = sha[name].digest;\n    var N = Math.ceil(keyLen / hashLen),\n        idx = 0,\n        okm = [];\n    function step() {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      var T = Buffer.alloc(4 + key.length + otherInfo.length);\n      T.writeUInt32BE(idx, 0);\n      key.copy(T, 4);\n      otherInfo.copy(T, 4 + key.length);\n      return op(T).then(function(result) {\n        okm.push(result);\n        return step();\n      });\n    }\n\n    return step();\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar concat = {};\n[\n  \"CONCAT-SHA-1\",\n  \"CONCAT-SHA-256\",\n  \"CONCAT-SHA-384\",\n  \"CONCAT-SHA-512\"\n].forEach(function(name) {\n  concat[name] = {\n    derive: concatDeriveFn(name)\n  };\n});\n\nmodule.exports = concat;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbmNhdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQWdCO0FBQ3hDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbmNhdC5qcz8wNWRlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9jb25jYXQuanMgLSBDb25jYXQgS2V5IERlcml2YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIiksXG4gICAgc2hhID0gcmVxdWlyZShcIi4vc2hhLmpzXCIpO1xuXG5mdW5jdGlvbiBjb25jYXREZXJpdmVGbihuYW1lKSB7XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJDT05DQVQtXCIsIFwiXCIpO1xuXG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIENvbmNhdEtERiBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyB0aGUgU0hBIGFsZ29yaXRobXNcblxuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIGhhc2hMZW4gPSBDT05TVEFOVFMuSEFTSExFTkdUSFtuYW1lXTtcbiAgICBpZiAoIWtleUxlbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQga2V5IGxlbmd0aFwiKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgb3RoZXJJbmZvXG4gICAgaWYgKCFwcm9wcy5vdGhlckluZm8pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIG90aGVySW5mb1wiKSk7XG4gICAgfVxuICAgIHZhciBvdGhlckluZm8gPSBwcm9wcy5vdGhlckluZm87XG5cbiAgICB2YXIgb3AgPSBzaGFbbmFtZV0uZGlnZXN0O1xuICAgIHZhciBOID0gTWF0aC5jZWlsKGtleUxlbiAvIGhhc2hMZW4pLFxuICAgICAgICBpZHggPSAwLFxuICAgICAgICBva20gPSBbXTtcbiAgICBmdW5jdGlvbiBzdGVwKCkge1xuICAgICAgaWYgKE4gPT09IGlkeCsrKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KG9rbSkuc2xpY2UoMCwga2V5TGVuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFQgPSBCdWZmZXIuYWxsb2MoNCArIGtleS5sZW5ndGggKyBvdGhlckluZm8ubGVuZ3RoKTtcbiAgICAgIFQud3JpdGVVSW50MzJCRShpZHgsIDApO1xuICAgICAga2V5LmNvcHkoVCwgNCk7XG4gICAgICBvdGhlckluZm8uY29weShULCA0ICsga2V5Lmxlbmd0aCk7XG4gICAgICByZXR1cm4gb3AoVCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgb2ttLnB1c2gocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHN0ZXAoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBzdGVwKCk7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vLyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5kZXJpdmVcbnZhciBjb25jYXQgPSB7fTtcbltcbiAgXCJDT05DQVQtU0hBLTFcIixcbiAgXCJDT05DQVQtU0hBLTI1NlwiLFxuICBcIkNPTkNBVC1TSEEtMzg0XCIsXG4gIFwiQ09OQ0FULVNIQS01MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgY29uY2F0W25hbWVdID0ge1xuICAgIGRlcml2ZTogY29uY2F0RGVyaXZlRm4obmFtZSlcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/constants.js - Constants used in Cryptographic Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nmodule.exports = {\n  CHUNK_SIZE: 1024,\n  HASHLENGTH: {\n    \"SHA-1\": 160,\n    \"SHA-256\": 256,\n    \"SHA-384\": 384,\n    \"SHA-512\": 512\n  },\n  ENCLENGTH: {\n    \"AES-128-CBC\": 128,\n    \"AES-192-CBC\": 192,\n    \"AES-256-CBC\": 256,\n    \"AES-128-KW\": 128,\n    \"AES-192-KW\": 192,\n    \"AES-256-KW\": 256\n  },\n  KEYLENGTH: {\n    \"A128CBC-HS256\": 256,\n    \"A192CBC-HS384\": 384,\n    \"A256CBC-HS512\": 512,\n    \"A128CBC+HS256\": 256,\n    \"A192CBC+HS384\": 384,\n    \"A256CBC+HS512\": 512,\n    \"A128GCM\": 128,\n    \"A192GCM\": 192,\n    \"A256GCM\": 256,\n    \"A128KW\": 128,\n    \"A192KW\": 192,\n    \"A256KW\": 256,\n    \"ECDH-ES+A128KW\": 128,\n    \"ECDH-ES+A192KW\": 192,\n    \"ECDH-ES+A256KW\": 256\n  },\n  NONCELENGTH: {\n    \"A128CBC-HS256\": 128,\n    \"A192CBC-HS384\": 128,\n    \"A256CBC-HS512\": 128,\n    \"A128CBC+HS256\": 128,\n    \"A192CBC+HS384\": 128,\n    \"A256CBC+HS512\": 128,\n    \"A128GCM\": 96,\n    \"A192GCM\": 96,\n    \"A256GCM\": 96\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2NvbnN0YW50cy5qcz8wYjQwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9jb25zdGFudHMuanMgLSBDb25zdGFudHMgdXNlZCBpbiBDcnlwdG9ncmFwaGljIEFsZ29yaXRobXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuIFwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ0hVTktfU0laRTogMTAyNCxcbiAgSEFTSExFTkdUSDoge1xuICAgIFwiU0hBLTFcIjogMTYwLFxuICAgIFwiU0hBLTI1NlwiOiAyNTYsXG4gICAgXCJTSEEtMzg0XCI6IDM4NCxcbiAgICBcIlNIQS01MTJcIjogNTEyXG4gIH0sXG4gIEVOQ0xFTkdUSDoge1xuICAgIFwiQUVTLTEyOC1DQkNcIjogMTI4LFxuICAgIFwiQUVTLTE5Mi1DQkNcIjogMTkyLFxuICAgIFwiQUVTLTI1Ni1DQkNcIjogMjU2LFxuICAgIFwiQUVTLTEyOC1LV1wiOiAxMjgsXG4gICAgXCJBRVMtMTkyLUtXXCI6IDE5MixcbiAgICBcIkFFUy0yNTYtS1dcIjogMjU2XG4gIH0sXG4gIEtFWUxFTkdUSDoge1xuICAgIFwiQTEyOENCQy1IUzI1NlwiOiAyNTYsXG4gICAgXCJBMTkyQ0JDLUhTMzg0XCI6IDM4NCxcbiAgICBcIkEyNTZDQkMtSFM1MTJcIjogNTEyLFxuICAgIFwiQTEyOENCQytIUzI1NlwiOiAyNTYsXG4gICAgXCJBMTkyQ0JDK0hTMzg0XCI6IDM4NCxcbiAgICBcIkEyNTZDQkMrSFM1MTJcIjogNTEyLFxuICAgIFwiQTEyOEdDTVwiOiAxMjgsXG4gICAgXCJBMTkyR0NNXCI6IDE5MixcbiAgICBcIkEyNTZHQ01cIjogMjU2LFxuICAgIFwiQTEyOEtXXCI6IDEyOCxcbiAgICBcIkExOTJLV1wiOiAxOTIsXG4gICAgXCJBMjU2S1dcIjogMjU2LFxuICAgIFwiRUNESC1FUytBMTI4S1dcIjogMTI4LFxuICAgIFwiRUNESC1FUytBMTkyS1dcIjogMTkyLFxuICAgIFwiRUNESC1FUytBMjU2S1dcIjogMjU2XG4gIH0sXG4gIE5PTkNFTEVOR1RIOiB7XG4gICAgXCJBMTI4Q0JDLUhTMjU2XCI6IDEyOCxcbiAgICBcIkExOTJDQkMtSFMzODRcIjogMTI4LFxuICAgIFwiQTI1NkNCQy1IUzUxMlwiOiAxMjgsXG4gICAgXCJBMTI4Q0JDK0hTMjU2XCI6IDEyOCxcbiAgICBcIkExOTJDQkMrSFMzODRcIjogMTI4LFxuICAgIFwiQTI1NkNCQytIUzUxMlwiOiAxMjgsXG4gICAgXCJBMTI4R0NNXCI6IDk2LFxuICAgIFwiQTE5MkdDTVwiOiA5NixcbiAgICBcIkEyNTZHQ01cIjogOTZcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/dir.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/dir.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * algorithms/dir.js - Direct key mode\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nfunction dirEncryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve({\n    data: key,\n    once: true,\n    direct: true\n  });\n}\nfunction dirDecryptFN(key) {\n  // NOTE: pdata unused\n  // NOTE: props unused\n  return Promise.resolve(key);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar direct = {\n  dir: {\n    encrypt: dirEncryptFN,\n    decrypt: dirDecryptFN\n  }\n};\n\nmodule.exports = direct;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2Rpci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvZGlyLmpzPzk0NDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2Rpci5qcyAtIERpcmVjdCBrZXkgbW9kZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZGlyRW5jcnlwdEZOKGtleSkge1xuICAvLyBOT1RFOiBwZGF0YSB1bnVzZWRcbiAgLy8gTk9URTogcHJvcHMgdW51c2VkXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgIGRhdGE6IGtleSxcbiAgICBvbmNlOiB0cnVlLFxuICAgIGRpcmVjdDogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRpckRlY3J5cHRGTihrZXkpIHtcbiAgLy8gTk9URTogcGRhdGEgdW51c2VkXG4gIC8vIE5PVEU6IHByb3BzIHVudXNlZFxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG52YXIgZGlyZWN0ID0ge1xuICBkaXI6IHtcbiAgICBlbmNyeXB0OiBkaXJFbmNyeXB0Rk4sXG4gICAgZGVjcnlwdDogZGlyRGVjcnlwdEZOXG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGlyZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ec-util.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ec-util.js - Elliptic Curve Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    ecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar EC_KEYSIZES = {\n  \"P-256\": 256,\n  \"P-384\": 384,\n  \"P-521\": 521\n};\n\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n  // prefix with curve\n  parts = [key.crv].concat(parts);\n  var fn = isPublic ?\n           ecc.asPublicKey :\n           ecc.asPrivateKey;\n  return fn.apply(ecc, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"x\", \"y\", \"d\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n  }\n\n  return result;\n}\n\nfunction convertToObj(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"x\", \"y\"] :\n              [\"d\"];\n  parts.forEach(function(f) {\n    // assume string if base64url-encoded\n    result[f] = util.asBuffer(result[f], \"base64url\");\n  });\n\n  return result;\n}\n\nvar UNCOMPRESSED = Buffer.from([0x04]);\nfunction convertToBuffer(key, isPublic) {\n  key = convertToObj(key, isPublic);\n  var result = isPublic ?\n               Buffer.concat([UNCOMPRESSED, key.x, key.y]) :\n               key.d;\n  return result;\n}\n\nfunction curveSize(crv) {\n  return EC_KEYSIZES[crv || \"\"] || NaN;\n}\n\nfunction curveNameToOid(crv) {\n  switch (crv) {\n    case \"P-256\":\n      return \"1.2.840.10045.3.1.7\";\n    case \"P-384\":\n      return \"1.3.132.0.34\";\n    case \"P-521\":\n      return \"1.3.132.0.35\";\n    default:\n      return null;\n  }\n}\n\nvar EC_OID = \"1.2.840.10045.2.1\";\nfunction convertToPEM(key, isPrivate) {\n  // curveName to OID\n  var oid = key.crv;\n  oid = curveNameToOid(oid);\n  oid = forge.asn1.oidToDer(oid);\n  // key as bytes\n  var type,\n      pub,\n      asn1;\n  if (isPrivate) {\n    type = \"EC PRIVATE KEY\";\n    pub = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    key = key.d.toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, \"\\u0001\"),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, key),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 0, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.CONTEXT_SPECIFIC, 1, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, pub)\n      ])\n    ]);\n  } else {\n    type = \"PUBLIC KEY\";\n    key = Buffer.concat([\n      Buffer.from([0x00, 0x04]),\n      key.x,\n      key.y\n    ]).toString(\"binary\");\n    asn1 = forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(EC_OID).bytes()),\n        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, oid.bytes())\n      ]),\n      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.BITSTRING, false, key)\n    ]);\n  }\n  asn1 = forge.asn1.toDer(asn1).bytes();\n  var pem = forge.pem.encode({\n    type: type,\n    body: asn1\n  });\n  return pem;\n}\n\n// Inspired by teifip/node-webtokens/blob/master/lib/ecdsa.js\nvar ERR_MSG = \"Could not extract parameters from DER signature\";\nfunction derToConcat(signature, size) {\n  var offset = 0;\n  if (signature[offset++] !== 0x30) {\n    throw new Error(ERR_MSG);\n  }\n  var seqLength = signature[offset++];\n  if (seqLength === 0x81) {\n    seqLength = signature[offset++];\n  }\n  if (seqLength > signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var rLength = signature[offset++];\n  if (rLength > signature.length - offset - 2) {\n    throw new Error(ERR_MSG);\n  }\n  if (rLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var rOffset = offset;\n  offset += rLength;\n  if (signature[offset++] !== 0x02) {\n    throw new Error(ERR_MSG);\n  }\n  var sLength = signature[offset++];\n  if (sLength !== signature.length - offset) {\n    throw new Error(ERR_MSG);\n  }\n  if (sLength > size + 1) {\n    throw new Error(ERR_MSG);\n  }\n  var sOffset = offset;\n  offset += sLength;\n  if (offset !== signature.length) {\n    throw new Error(ERR_MSG);\n  }\n  var rPadding = size - rLength;\n  var sPadding = size - sLength;\n  var dst = Buffer.alloc(rPadding + rLength + sPadding + sLength);\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var rPad = Math.max(-rPadding, 0);\n  signature.copy(dst, offset, rOffset + rPad, rOffset + rLength);\n  offset = size;\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n  var sPad = Math.max(-sPadding, 0);\n  signature.copy(dst, offset, sOffset + sPad, sOffset + sLength);\n  return dst;\n}\n\nfunction countPadding(buf, start, stop) {\n  var padding = 0;\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n  var needsSign = buf[start + padding] >= 0x80;\n  if (needsSign) {\n    --padding;\n  }\n  return padding;\n}\n\nfunction concatToDer(signature, size) {\n  var rPadding = countPadding(signature, 0, size);\n  var sPadding = countPadding(signature, size, signature.length);\n  var rLength = size - rPadding;\n  var sLength = size - sPadding;\n  var rsBytes = rLength + sLength + 4;\n  var shortLength = rsBytes < 0x80;\n  var dst = Buffer.alloc((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = 0x30;\n  if (shortLength) {\n    dst[offset++] = rsBytes;\n  } else {\n    dst[offset++] = 0x81;\n    dst[offset++] = rsBytes & 0xFF;\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = rLength;\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, size);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, size);\n  }\n  dst[offset++] = 0x02;\n  dst[offset++] = sLength;\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, size);\n  } else {\n    signature.copy(dst, offset, size + sPadding);\n  }\n  return dst;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToObj: convertToObj,\n  convertToBuffer: convertToBuffer,\n  curveSize: curveSize,\n  derToConcat: derToConcat,\n  concatToDer: concatToDer,\n  convertToPEM: convertToPEM,\n  EC_OID: EC_OID\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjLXV0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxVQUFVLG1CQUFPLENBQUMseUVBQWE7QUFDL0IsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9lYy11dGlsLmpzP2ZmMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2VjLXV0aWwuanMgLSBFbGxpcHRpYyBDdXJ2ZSBVdGlsaXR5IEZ1bmN0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICBlY2MgPSByZXF1aXJlKFwiLi4vZGVwcy9lY2NcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbnZhciBFQ19LRVlTSVpFUyA9IHtcbiAgXCJQLTI1NlwiOiAyNTYsXG4gIFwiUC0zODRcIjogMzg0LFxuICBcIlAtNTIxXCI6IDUyMVxufTtcblxuZnVuY3Rpb24gY29udmVydFRvRm9yZ2Uoa2V5LCBpc1B1YmxpYykge1xuICB2YXIgcGFydHMgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgIFtcInhcIiwgXCJ5XCJdIDpcbiAgICAgICAgICAgICAgW1wiZFwiXTtcbiAgcGFydHMgPSBwYXJ0cy5tYXAoZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBuZXcgZm9yZ2UuanNibi5CaWdJbnRlZ2VyKGtleVtmXS50b1N0cmluZyhcImhleFwiKSwgMTYpO1xuICB9KTtcbiAgLy8gcHJlZml4IHdpdGggY3VydmVcbiAgcGFydHMgPSBba2V5LmNydl0uY29uY2F0KHBhcnRzKTtcbiAgdmFyIGZuID0gaXNQdWJsaWMgP1xuICAgICAgICAgICBlY2MuYXNQdWJsaWNLZXkgOlxuICAgICAgICAgICBlY2MuYXNQcml2YXRlS2V5O1xuICByZXR1cm4gZm4uYXBwbHkoZWNjLCBwYXJ0cyk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0pXSyhrZXksIGlzUHVibGljKSB7XG4gIHZhciByZXN1bHQgPSBjbG9uZShrZXkpO1xuICB2YXIgcGFydHMgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgIFtcInhcIiwgXCJ5XCJdIDpcbiAgICAgICAgICAgICAgW1wieFwiLCBcInlcIiwgXCJkXCJdO1xuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICByZXN1bHRbZl0gPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocmVzdWx0W2ZdKTtcbiAgfSk7XG5cbiAgLy8gcmVtb3ZlIHBvdGVudGlhbGx5IHRyb3VibGVzb21lIHByb3BlcnRpZXNcbiAgZGVsZXRlIHJlc3VsdC5rZXlfb3BzO1xuICBkZWxldGUgcmVzdWx0LnVzZTtcbiAgZGVsZXRlIHJlc3VsdC5hbGc7XG5cbiAgaWYgKGlzUHVibGljKSB7XG4gICAgZGVsZXRlIHJlc3VsdC5kO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gY29udmVydFRvT2JqKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIHJlc3VsdCA9IGNsb25lKGtleSk7XG4gIHZhciBwYXJ0cyA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgW1wieFwiLCBcInlcIl0gOlxuICAgICAgICAgICAgICBbXCJkXCJdO1xuICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAvLyBhc3N1bWUgc3RyaW5nIGlmIGJhc2U2NHVybC1lbmNvZGVkXG4gICAgcmVzdWx0W2ZdID0gdXRpbC5hc0J1ZmZlcihyZXN1bHRbZl0sIFwiYmFzZTY0dXJsXCIpO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG52YXIgVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oWzB4MDRdKTtcbmZ1bmN0aW9uIGNvbnZlcnRUb0J1ZmZlcihrZXksIGlzUHVibGljKSB7XG4gIGtleSA9IGNvbnZlcnRUb09iaihrZXksIGlzUHVibGljKTtcbiAgdmFyIHJlc3VsdCA9IGlzUHVibGljID9cbiAgICAgICAgICAgICAgIEJ1ZmZlci5jb25jYXQoW1VOQ09NUFJFU1NFRCwga2V5LngsIGtleS55XSkgOlxuICAgICAgICAgICAgICAga2V5LmQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGN1cnZlU2l6ZShjcnYpIHtcbiAgcmV0dXJuIEVDX0tFWVNJWkVTW2NydiB8fCBcIlwiXSB8fCBOYU47XG59XG5cbmZ1bmN0aW9uIGN1cnZlTmFtZVRvT2lkKGNydikge1xuICBzd2l0Y2ggKGNydikge1xuICAgIGNhc2UgXCJQLTI1NlwiOlxuICAgICAgcmV0dXJuIFwiMS4yLjg0MC4xMDA0NS4zLjEuN1wiO1xuICAgIGNhc2UgXCJQLTM4NFwiOlxuICAgICAgcmV0dXJuIFwiMS4zLjEzMi4wLjM0XCI7XG4gICAgY2FzZSBcIlAtNTIxXCI6XG4gICAgICByZXR1cm4gXCIxLjMuMTMyLjAuMzVcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIEVDX09JRCA9IFwiMS4yLjg0MC4xMDA0NS4yLjFcIjtcbmZ1bmN0aW9uIGNvbnZlcnRUb1BFTShrZXksIGlzUHJpdmF0ZSkge1xuICAvLyBjdXJ2ZU5hbWUgdG8gT0lEXG4gIHZhciBvaWQgPSBrZXkuY3J2O1xuICBvaWQgPSBjdXJ2ZU5hbWVUb09pZChvaWQpO1xuICBvaWQgPSBmb3JnZS5hc24xLm9pZFRvRGVyKG9pZCk7XG4gIC8vIGtleSBhcyBieXRlc1xuICB2YXIgdHlwZSxcbiAgICAgIHB1YixcbiAgICAgIGFzbjE7XG4gIGlmIChpc1ByaXZhdGUpIHtcbiAgICB0eXBlID0gXCJFQyBQUklWQVRFIEtFWVwiO1xuICAgIHB1YiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgQnVmZmVyLmZyb20oWzB4MDAsIDB4MDRdKSxcbiAgICAgIGtleS54LFxuICAgICAga2V5LnlcbiAgICBdKS50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICBrZXkgPSBrZXkuZC50b1N0cmluZyhcImJpbmFyeVwiKTtcbiAgICBhc24xID0gZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSwgdHJ1ZSwgW1xuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLCBmYWxzZSwgXCJcXHUwMDAxXCIpLFxuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5PQ1RFVFNUUklORywgZmFsc2UsIGtleSksXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsIDAsIHRydWUsIFtcbiAgICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsIGZvcmdlLmFzbjEuVHlwZS5PSUQsIGZhbHNlLCBvaWQuYnl0ZXMoKSlcbiAgICAgIF0pLFxuICAgICAgZm9yZ2UuYXNuMS5jcmVhdGUoZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLCAxLCB0cnVlLCBbXG4gICAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLCBmYWxzZSwgcHViKVxuICAgICAgXSlcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gXCJQVUJMSUMgS0VZXCI7XG4gICAga2V5ID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICBCdWZmZXIuZnJvbShbMHgwMCwgMHgwNF0pLFxuICAgICAga2V5LngsXG4gICAgICBrZXkueVxuICAgIF0pLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIGFzbjEgPSBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLCB0cnVlLCBbXG4gICAgICAgIGZvcmdlLmFzbjEuY3JlYXRlKGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLCBmb3JnZS5hc24xLlR5cGUuT0lELCBmYWxzZSwgZm9yZ2UuYXNuMS5vaWRUb0RlcihFQ19PSUQpLmJ5dGVzKCkpLFxuICAgICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLk9JRCwgZmFsc2UsIG9pZC5ieXRlcygpKVxuICAgICAgXSksXG4gICAgICBmb3JnZS5hc24xLmNyZWF0ZShmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCwgZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORywgZmFsc2UsIGtleSlcbiAgICBdKTtcbiAgfVxuICBhc24xID0gZm9yZ2UuYXNuMS50b0Rlcihhc24xKS5ieXRlcygpO1xuICB2YXIgcGVtID0gZm9yZ2UucGVtLmVuY29kZSh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBib2R5OiBhc24xXG4gIH0pO1xuICByZXR1cm4gcGVtO1xufVxuXG4vLyBJbnNwaXJlZCBieSB0ZWlmaXAvbm9kZS13ZWJ0b2tlbnMvYmxvYi9tYXN0ZXIvbGliL2VjZHNhLmpzXG52YXIgRVJSX01TRyA9IFwiQ291bGQgbm90IGV4dHJhY3QgcGFyYW1ldGVycyBmcm9tIERFUiBzaWduYXR1cmVcIjtcbmZ1bmN0aW9uIGRlclRvQ29uY2F0KHNpZ25hdHVyZSwgc2l6ZSkge1xuICB2YXIgb2Zmc2V0ID0gMDtcbiAgaWYgKHNpZ25hdHVyZVtvZmZzZXQrK10gIT09IDB4MzApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHNlcUxlbmd0aCA9IHNpZ25hdHVyZVtvZmZzZXQrK107XG4gIGlmIChzZXFMZW5ndGggPT09IDB4ODEpIHtcbiAgICBzZXFMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuICB9XG4gIGlmIChzZXFMZW5ndGggPiBzaWduYXR1cmUubGVuZ3RoIC0gb2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIGlmIChzaWduYXR1cmVbb2Zmc2V0KytdICE9PSAweDAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciByTGVuZ3RoID0gc2lnbmF0dXJlW29mZnNldCsrXTtcbiAgaWYgKHJMZW5ndGggPiBzaWduYXR1cmUubGVuZ3RoIC0gb2Zmc2V0IC0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICBpZiAockxlbmd0aCA+IHNpemUgKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciByT2Zmc2V0ID0gb2Zmc2V0O1xuICBvZmZzZXQgKz0gckxlbmd0aDtcbiAgaWYgKHNpZ25hdHVyZVtvZmZzZXQrK10gIT09IDB4MDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRVJSX01TRyk7XG4gIH1cbiAgdmFyIHNMZW5ndGggPSBzaWduYXR1cmVbb2Zmc2V0KytdO1xuICBpZiAoc0xlbmd0aCAhPT0gc2lnbmF0dXJlLmxlbmd0aCAtIG9mZnNldCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICBpZiAoc0xlbmd0aCA+IHNpemUgKyAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKEVSUl9NU0cpO1xuICB9XG4gIHZhciBzT2Zmc2V0ID0gb2Zmc2V0O1xuICBvZmZzZXQgKz0gc0xlbmd0aDtcbiAgaWYgKG9mZnNldCAhPT0gc2lnbmF0dXJlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFUlJfTVNHKTtcbiAgfVxuICB2YXIgclBhZGRpbmcgPSBzaXplIC0gckxlbmd0aDtcbiAgdmFyIHNQYWRkaW5nID0gc2l6ZSAtIHNMZW5ndGg7XG4gIHZhciBkc3QgPSBCdWZmZXIuYWxsb2MoclBhZGRpbmcgKyByTGVuZ3RoICsgc1BhZGRpbmcgKyBzTGVuZ3RoKTtcbiAgZm9yIChvZmZzZXQgPSAwOyBvZmZzZXQgPCByUGFkZGluZzsgKytvZmZzZXQpIHtcbiAgICBkc3Rbb2Zmc2V0XSA9IDA7XG4gIH1cbiAgdmFyIHJQYWQgPSBNYXRoLm1heCgtclBhZGRpbmcsIDApO1xuICBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgck9mZnNldCArIHJQYWQsIHJPZmZzZXQgKyByTGVuZ3RoKTtcbiAgb2Zmc2V0ID0gc2l6ZTtcbiAgZm9yICh2YXIgbyA9IG9mZnNldDsgb2Zmc2V0IDwgbyArIHNQYWRkaW5nOyArK29mZnNldCkge1xuICAgIGRzdFtvZmZzZXRdID0gMDtcbiAgfVxuICB2YXIgc1BhZCA9IE1hdGgubWF4KC1zUGFkZGluZywgMCk7XG4gIHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCBzT2Zmc2V0ICsgc1BhZCwgc09mZnNldCArIHNMZW5ndGgpO1xuICByZXR1cm4gZHN0O1xufVxuXG5mdW5jdGlvbiBjb3VudFBhZGRpbmcoYnVmLCBzdGFydCwgc3RvcCkge1xuICB2YXIgcGFkZGluZyA9IDA7XG4gIHdoaWxlIChzdGFydCArIHBhZGRpbmcgPCBzdG9wICYmIGJ1ZltzdGFydCArIHBhZGRpbmddID09PSAwKSB7XG4gICAgKytwYWRkaW5nO1xuICB9XG4gIHZhciBuZWVkc1NpZ24gPSBidWZbc3RhcnQgKyBwYWRkaW5nXSA+PSAweDgwO1xuICBpZiAobmVlZHNTaWduKSB7XG4gICAgLS1wYWRkaW5nO1xuICB9XG4gIHJldHVybiBwYWRkaW5nO1xufVxuXG5mdW5jdGlvbiBjb25jYXRUb0RlcihzaWduYXR1cmUsIHNpemUpIHtcbiAgdmFyIHJQYWRkaW5nID0gY291bnRQYWRkaW5nKHNpZ25hdHVyZSwgMCwgc2l6ZSk7XG4gIHZhciBzUGFkZGluZyA9IGNvdW50UGFkZGluZyhzaWduYXR1cmUsIHNpemUsIHNpZ25hdHVyZS5sZW5ndGgpO1xuICB2YXIgckxlbmd0aCA9IHNpemUgLSByUGFkZGluZztcbiAgdmFyIHNMZW5ndGggPSBzaXplIC0gc1BhZGRpbmc7XG4gIHZhciByc0J5dGVzID0gckxlbmd0aCArIHNMZW5ndGggKyA0O1xuICB2YXIgc2hvcnRMZW5ndGggPSByc0J5dGVzIDwgMHg4MDtcbiAgdmFyIGRzdCA9IEJ1ZmZlci5hbGxvYygoc2hvcnRMZW5ndGggPyAyIDogMykgKyByc0J5dGVzKTtcbiAgdmFyIG9mZnNldCA9IDA7XG4gIGRzdFtvZmZzZXQrK10gPSAweDMwO1xuICBpZiAoc2hvcnRMZW5ndGgpIHtcbiAgICBkc3Rbb2Zmc2V0KytdID0gcnNCeXRlcztcbiAgfSBlbHNlIHtcbiAgICBkc3Rbb2Zmc2V0KytdID0gMHg4MTtcbiAgICBkc3Rbb2Zmc2V0KytdID0gcnNCeXRlcyAmIDB4RkY7XG4gIH1cbiAgZHN0W29mZnNldCsrXSA9IDB4MDI7XG4gIGRzdFtvZmZzZXQrK10gPSByTGVuZ3RoO1xuICBpZiAoclBhZGRpbmcgPCAwKSB7XG4gICAgZHN0W29mZnNldCsrXSA9IDA7XG4gICAgb2Zmc2V0ICs9IHNpZ25hdHVyZS5jb3B5KGRzdCwgb2Zmc2V0LCAwLCBzaXplKTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXQgKz0gc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHJQYWRkaW5nLCBzaXplKTtcbiAgfVxuICBkc3Rbb2Zmc2V0KytdID0gMHgwMjtcbiAgZHN0W29mZnNldCsrXSA9IHNMZW5ndGg7XG4gIGlmIChzUGFkZGluZyA8IDApIHtcbiAgICBkc3Rbb2Zmc2V0KytdID0gMDtcbiAgICBzaWduYXR1cmUuY29weShkc3QsIG9mZnNldCwgc2l6ZSk7XG4gIH0gZWxzZSB7XG4gICAgc2lnbmF0dXJlLmNvcHkoZHN0LCBvZmZzZXQsIHNpemUgKyBzUGFkZGluZyk7XG4gIH1cbiAgcmV0dXJuIGRzdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZlcnRUb0ZvcmdlOiBjb252ZXJ0VG9Gb3JnZSxcbiAgY29udmVydFRvSldLOiBjb252ZXJ0VG9KV0ssXG4gIGNvbnZlcnRUb09iajogY29udmVydFRvT2JqLFxuICBjb252ZXJ0VG9CdWZmZXI6IGNvbnZlcnRUb0J1ZmZlcixcbiAgY3VydmVTaXplOiBjdXJ2ZVNpemUsXG4gIGRlclRvQ29uY2F0OiBkZXJUb0NvbmNhdCxcbiAgY29uY2F0VG9EZXI6IGNvbmNhdFRvRGVyLFxuICBjb252ZXJ0VG9QRU06IGNvbnZlcnRUb1BFTSxcbiAgRUNfT0lEOiBFQ19PSURcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdh.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdh.js - Elliptic Curve Diffie-Hellman algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    hkdf = __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n    concat = __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n    aesKw = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\n\nfunction idealHash(curve) {\n  switch (curve) {\n    case \"P-256\":\n      return \"SHA-256\";\n    case \"P-384\":\n      return \"SHA-384\";\n    case \"P-521\":\n      return \"SHA-512\";\n    default:\n      throw new Error(\"unsupported curve: \" + curve);\n  }\n}\n\n// ### Exported\nvar ecdh = module.exports = {};\n\n// ### Derivation algorithms\n// ### \"raw\" ECDH\nfunction ecdhDeriveFn() {\n  var alg = {\n    name: \"ECDH\"\n  };\n\n  var validatePublic = function(pk, form) {\n    var pubKey = pk && ecUtil.convertToForge(pk, true);\n    if (!pubKey || !pubKey.isValid()) {\n      return Promise.reject(new Error(\"invalid EC public key\"));\n    }\n\n    switch (form) {\n      case \"jwk\":\n        pubKey = ecUtil.convertToJWK(pk, true);\n        break;\n      case \"buffer\":\n        pubKey = ecUtil.convertToBuffer(pk, true);\n        break;\n    }\n    return Promise.resolve(pubKey);\n  }\n\n  // ### fallback implementation -- uses ecc + forge\n  var fallback = function(key, props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToForge(key, false);\n\n    var p = validatePublic(props.public, \"forge\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"forge\"\n\n      var secret = privKey.computeSecret(pubKey);\n      if (keyLen) {\n        // truncate to requested key length\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n\n      return secret;\n    });\n    return p;\n  };\n\n  // ### WebCryptoAPI implementation\n  // TODO: cache CryptoKey sooner\n  var webcrypto = function(key, props) {\n    key = key || {};\n    props = props || {};\n\n    var keyLen = props.length || 0,\n        algParams = merge(clone(alg), {\n          namedCurve: key.crv\n        });\n\n    // assume {key} is privateKey\n    if (!keyLen) {\n      // calculate key length from private key size\n      keyLen = key.d.length;\n    }\n    var privKey = ecUtil.convertToJWK(key, false);\n    privKey = helpers.subtleCrypto.importKey(\"jwk\",\n                                             privKey,\n                                             algParams,\n                                             false,\n                                             [ \"deriveBits\" ]);\n\n    // assume {props.public} is publicKey\n    var pubKey = validatePublic(props.public, \"jwk\");\n    pubKey = pubKey.then(function(pubKey) {\n      // {pubKey} is \"jwk\"\n      return helpers.subtleCrypto.importKey(\"jwk\",\n                                            pubKey,\n                                            algParams,\n                                            false,\n                                            []);\n    });\n\n    var p = Promise.all([privKey, pubKey]);\n    p = p.then(function(keypair) {\n      var privKey = keypair[0],\n          pubKey = keypair[1];\n\n      var algParams = merge(clone(alg), {\n        public: pubKey\n      });\n      return helpers.subtleCrypto.deriveBits(algParams, privKey, keyLen * 8);\n    });\n    p = p.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return p;\n  };\n\n  var nodejs = function(key, props) {\n    if (\"function\" !== typeof helpers.nodeCrypto.createECDH) {\n      throw new Error(\"unsupported algorithm: ECDH\");\n    }\n\n    props = props || {};\n    var keyLen = props.length || 0;\n    var curve;\n    switch (key.crv) {\n      case \"P-256\":\n        curve = \"prime256v1\";\n        break;\n      case \"P-384\":\n        curve = \"secp384r1\";\n        break;\n      case \"P-521\":\n        curve = \"secp521r1\";\n        break;\n      default:\n        return Promise.reject(new Error(\"invalid curve: \" + curve));\n    }\n\n    // assume {key} is privateKey\n    // assume {props.public} is publicKey\n    var privKey = ecUtil.convertToBuffer(key, false);\n\n    var p = validatePublic(props.public, \"buffer\");\n    p = p.then(function(pubKey) {\n      // {pubKey} is \"buffer\"\n      var ecdh = helpers.nodeCrypto.createECDH(curve);\n      // dummy call so computeSecret doesn't fail\n      // ecdh.generateKeys();\n      ecdh.setPrivateKey(privKey);\n      var secret = ecdh.computeSecret(pubKey);\n      if (keyLen) {\n        if (secret.length < keyLen) {\n          return Promise.reject(new Error(\"key length too large: \" + keyLen));\n        }\n        secret = secret.slice(0, keyLen);\n      }\n      return secret;\n    });\n    return p;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdhConcatDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return concat[\"CONCAT-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhHkdfDeriveFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n\n  var fn = function(key, props) {\n    props = props || {};\n\n    var hash;\n    try {\n      hash = props.hash || idealHash(key.crv);\n      if (!hash) {\n        throw new Error(\"invalid hash: \" + hash);\n      }\n      hash.toUpperCase();\n    } catch (ex) {\n      return Promise.reject(ex);\n    }\n\n    var params = [\"public\"];\n    // derive shared secret\n    // NOTE: whitelist items from {props} for ECDH\n    var promise = ecdh.ECDH.derive(key, pick(props, params));\n    // extract-and-expand\n    promise = promise.then(function(shared) {\n      // NOTE: blacklist items from {props} for ECDH\n      return hkdf[\"HKDF-\" + hash].derive(shared, omit(props, params));\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Wrap/Unwrap algorithms\nfunction doEcdhesCommonDerive(privKey, pubKey, props) {\n  function prependLen(input) {\n    return Buffer.concat([\n      helpers.int32ToBuffer(input.length),\n      input\n    ]);\n  }\n\n  var algId = props.algorithm || \"\",\n      keyLen = CONSTANTS.KEYLENGTH[algId],\n      apu = util.asBuffer(props.apu || \"\", \"base64url\"),\n      apv = util.asBuffer(props.apv || \"\", \"base64url\");\n  var otherInfo = Buffer.concat([\n    prependLen(Buffer.from(algId, \"utf8\")),\n    prependLen(apu),\n    prependLen(apv),\n    helpers.int32ToBuffer(keyLen)\n  ]);\n\n  var params = {\n    public: pubKey,\n    length: keyLen / 8,\n    hash: \"SHA-256\",\n    otherInfo: otherInfo\n  };\n  return ecdh[\"ECDH-CONCAT\"].derive(privKey, params);\n}\n\nfunction ecdhesDirEncryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return {\n        data: shared,\n        once: true,\n        direct: true\n      };\n    });\n    return promise;\n  };\n\n  return fn;\n}\nfunction ecdhesDirDecryptFn() {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.enc,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      return shared;\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwEncryptFn(wrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, pdata, props) {\n    props = props || {};\n\n    // {props.epk} is private\n    if (!props.epk || !props.epk.d) {\n      return Promise.reject(new Error(\"missing ephemeral private key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, false);\n\n    // {key} is public\n    if (!key || !key.x || !key.y) {\n      return Promise.reject(new Error(\"missing static public key\"));\n    }\n    var spk = ecUtil.convertToObj(key, true);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(epk, spk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // wrap provided key with ECDH shared\n      return wrap(shared, pdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\nfunction ecdhesKwDecryptFn(unwrap) {\n  // NOTE: no nodejs/webcrypto/fallback model, since this algorithm is\n  //       implemented using other primitives\n  var fn = function(key, cdata, props) {\n    props = props || {};\n\n    // {props.epk} is public\n    if (!props.epk || !props.epk.x || !props.epk.y) {\n      return Promise.reject(new Error(\"missing ephemeral public key\"));\n    }\n    var epk = ecUtil.convertToObj(props.epk, true);\n\n    // {key} is private\n    if (!key || !key.d) {\n      return Promise.reject(new Error(\"missing static private key\"));\n    }\n    var spk = ecUtil.convertToObj(key, false);\n\n    // derive ECDH shared\n    var promise = doEcdhesCommonDerive(spk, epk, {\n      algorithm: props.alg,\n      apu: props.apu,\n      apv: props.apv\n    });\n    promise = promise.then(function(shared) {\n      // unwrap provided key with ECDH shared\n      return unwrap(shared, cdata);\n    });\n    return promise;\n  };\n\n  return fn;\n}\n\n// ### Public API\n// * [name].derive\n[\n  \"ECDH\",\n  \"ECDH-HKDF\",\n  \"ECDH-CONCAT\"\n].forEach(function(name) {\n  var kdf = /^ECDH(?:-(\\w+))?$/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  switch (kdf || \"\") {\n    case \"CONCAT\":\n      op.derive = ecdhConcatDeriveFn();\n      break;\n    case \"HKDF\":\n      op.derive = ecdhHkdfDeriveFn();\n      break;\n    case \"\":\n      op.derive = ecdhDeriveFn();\n      break;\n    default:\n      op.derive = null;\n  }\n});\n\n// * [name].encrypt\n// * [name].decrypt\n[\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n].forEach(function(name) {\n  var kw = /^ECDH-ES(?:\\+(.+))?/g.exec(name || \"\")[1];\n  var op = ecdh[name] = ecdh[name] || {};\n  if (!kw) {\n    op.encrypt = ecdhesDirEncryptFn();\n    op.decrypt = ecdhesDirDecryptFn();\n  } else {\n    kw = aesKw[kw];\n    if (kw) {\n      op.encrypt = ecdhesKwEncryptFn(kw.encrypt);\n      op.decrypt = ecdhesKwDecryptFn(kw.decrypt);\n    } else {\n      op.ecrypt = op.decrypt = null;\n    }\n  }\n});\n//*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZGguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyx1RUFBZTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLDhFQUFjO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyx3RUFBVztBQUM5QixhQUFhLG1CQUFPLENBQUMsNEVBQWE7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDRFQUFhO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7O0FBRXhDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLHdEQUFhOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLGNBQWM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLFVBQVUsUUFBUTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxjQUFjO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTztBQUMxQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsS0FBSztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2FsZ29yaXRobXMvZWNkaC5qcz9iOWFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9lY2RoLmpzIC0gRWxsaXB0aWMgQ3VydmUgRGlmZmllLUhlbGxtYW4gYWxnb3JpdGhtc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIGVjVXRpbCA9IHJlcXVpcmUoXCIuL2VjLXV0aWwuanNcIiksXG4gICAgaGtkZiA9IHJlcXVpcmUoXCIuL2hrZGYuanNcIiksXG4gICAgY29uY2F0ID0gcmVxdWlyZShcIi4vY29uY2F0LmpzXCIpLFxuICAgIGFlc0t3ID0gcmVxdWlyZShcIi4vYWVzLWt3LmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKTtcbnZhciBvbWl0ID0gcmVxdWlyZShcImxvZGFzaC9vbWl0XCIpO1xudmFyIHBpY2sgPSByZXF1aXJlKFwibG9kYXNoL3BpY2tcIik7XG5cbmZ1bmN0aW9uIGlkZWFsSGFzaChjdXJ2ZSkge1xuICBzd2l0Y2ggKGN1cnZlKSB7XG4gICAgY2FzZSBcIlAtMjU2XCI6XG4gICAgICByZXR1cm4gXCJTSEEtMjU2XCI7XG4gICAgY2FzZSBcIlAtMzg0XCI6XG4gICAgICByZXR1cm4gXCJTSEEtMzg0XCI7XG4gICAgY2FzZSBcIlAtNTIxXCI6XG4gICAgICByZXR1cm4gXCJTSEEtNTEyXCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGN1cnZlOiBcIiArIGN1cnZlKTtcbiAgfVxufVxuXG4vLyAjIyMgRXhwb3J0ZWRcbnZhciBlY2RoID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gIyMjIERlcml2YXRpb24gYWxnb3JpdGhtc1xuLy8gIyMjIFwicmF3XCIgRUNESFxuZnVuY3Rpb24gZWNkaERlcml2ZUZuKCkge1xuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IFwiRUNESFwiXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHVibGljID0gZnVuY3Rpb24ocGssIGZvcm0pIHtcbiAgICB2YXIgcHViS2V5ID0gcGsgJiYgZWNVdGlsLmNvbnZlcnRUb0ZvcmdlKHBrLCB0cnVlKTtcbiAgICBpZiAoIXB1YktleSB8fCAhcHViS2V5LmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgRUMgcHVibGljIGtleVwiKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChmb3JtKSB7XG4gICAgICBjYXNlIFwiandrXCI6XG4gICAgICAgIHB1YktleSA9IGVjVXRpbC5jb252ZXJ0VG9KV0socGssIHRydWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJidWZmZXJcIjpcbiAgICAgICAgcHViS2V5ID0gZWNVdGlsLmNvbnZlcnRUb0J1ZmZlcihwaywgdHJ1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHB1YktleSk7XG4gIH1cblxuICAvLyAjIyMgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBlY2MgKyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoIHx8IDA7XG4gICAgLy8gYXNzdW1lIHtrZXl9IGlzIHByaXZhdGVLZXlcbiAgICAvLyBhc3N1bWUge3Byb3BzLnB1YmxpY30gaXMgcHVibGljS2V5XG4gICAgdmFyIHByaXZLZXkgPSBlY1V0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCBmYWxzZSk7XG5cbiAgICB2YXIgcCA9IHZhbGlkYXRlUHVibGljKHByb3BzLnB1YmxpYywgXCJmb3JnZVwiKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHB1YktleSkge1xuICAgICAgLy8ge3B1YktleX0gaXMgXCJmb3JnZVwiXG5cbiAgICAgIHZhciBzZWNyZXQgPSBwcml2S2V5LmNvbXB1dGVTZWNyZXQocHViS2V5KTtcbiAgICAgIGlmIChrZXlMZW4pIHtcbiAgICAgICAgLy8gdHJ1bmNhdGUgdG8gcmVxdWVzdGVkIGtleSBsZW5ndGhcbiAgICAgICAgaWYgKHNlY3JldC5sZW5ndGggPCBrZXlMZW4pIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwia2V5IGxlbmd0aCB0b28gbGFyZ2U6IFwiICsga2V5TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjcmV0ID0gc2VjcmV0LnNsaWNlKDAsIGtleUxlbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWNyZXQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBpbXBsZW1lbnRhdGlvblxuICAvLyBUT0RPOiBjYWNoZSBDcnlwdG9LZXkgc29vbmVyXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAga2V5ID0ga2V5IHx8IHt9O1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoIHx8IDAsXG4gICAgICAgIGFsZ1BhcmFtcyA9IG1lcmdlKGNsb25lKGFsZyksIHtcbiAgICAgICAgICBuYW1lZEN1cnZlOiBrZXkuY3J2XG4gICAgICAgIH0pO1xuXG4gICAgLy8gYXNzdW1lIHtrZXl9IGlzIHByaXZhdGVLZXlcbiAgICBpZiAoIWtleUxlbikge1xuICAgICAgLy8gY2FsY3VsYXRlIGtleSBsZW5ndGggZnJvbSBwcml2YXRlIGtleSBzaXplXG4gICAgICBrZXlMZW4gPSBrZXkuZC5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBwcml2S2V5ID0gZWNVdGlsLmNvbnZlcnRUb0pXSyhrZXksIGZhbHNlKTtcbiAgICBwcml2S2V5ID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcml2S2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxnUGFyYW1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbIFwiZGVyaXZlQml0c1wiIF0pO1xuXG4gICAgLy8gYXNzdW1lIHtwcm9wcy5wdWJsaWN9IGlzIHB1YmxpY0tleVxuICAgIHZhciBwdWJLZXkgPSB2YWxpZGF0ZVB1YmxpYyhwcm9wcy5wdWJsaWMsIFwiandrXCIpO1xuICAgIHB1YktleSA9IHB1YktleS50aGVuKGZ1bmN0aW9uKHB1YktleSkge1xuICAgICAgLy8ge3B1YktleX0gaXMgXCJqd2tcIlxuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcImp3a1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWJLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZ1BhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdKTtcbiAgICB9KTtcblxuICAgIHZhciBwID0gUHJvbWlzZS5hbGwoW3ByaXZLZXksIHB1YktleV0pO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oa2V5cGFpcikge1xuICAgICAgdmFyIHByaXZLZXkgPSBrZXlwYWlyWzBdLFxuICAgICAgICAgIHB1YktleSA9IGtleXBhaXJbMV07XG5cbiAgICAgIHZhciBhbGdQYXJhbXMgPSBtZXJnZShjbG9uZShhbGcpLCB7XG4gICAgICAgIHB1YmxpYzogcHViS2V5XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5kZXJpdmVCaXRzKGFsZ1BhcmFtcywgcHJpdktleSwga2V5TGVuICogOCk7XG4gICAgfSk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHZhciBub2RlanMgPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVFQ0RIKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IEVDREhcIik7XG4gICAgfVxuXG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoIHx8IDA7XG4gICAgdmFyIGN1cnZlO1xuICAgIHN3aXRjaCAoa2V5LmNydikge1xuICAgICAgY2FzZSBcIlAtMjU2XCI6XG4gICAgICAgIGN1cnZlID0gXCJwcmltZTI1NnYxXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlAtMzg0XCI6XG4gICAgICAgIGN1cnZlID0gXCJzZWNwMzg0cjFcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUC01MjFcIjpcbiAgICAgICAgY3VydmUgPSBcInNlY3A1MjFyMVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlOiBcIiArIGN1cnZlKSk7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lIHtrZXl9IGlzIHByaXZhdGVLZXlcbiAgICAvLyBhc3N1bWUge3Byb3BzLnB1YmxpY30gaXMgcHVibGljS2V5XG4gICAgdmFyIHByaXZLZXkgPSBlY1V0aWwuY29udmVydFRvQnVmZmVyKGtleSwgZmFsc2UpO1xuXG4gICAgdmFyIHAgPSB2YWxpZGF0ZVB1YmxpYyhwcm9wcy5wdWJsaWMsIFwiYnVmZmVyXCIpO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocHViS2V5KSB7XG4gICAgICAvLyB7cHViS2V5fSBpcyBcImJ1ZmZlclwiXG4gICAgICB2YXIgZWNkaCA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVFQ0RIKGN1cnZlKTtcbiAgICAgIC8vIGR1bW15IGNhbGwgc28gY29tcHV0ZVNlY3JldCBkb2Vzbid0IGZhaWxcbiAgICAgIC8vIGVjZGguZ2VuZXJhdGVLZXlzKCk7XG4gICAgICBlY2RoLnNldFByaXZhdGVLZXkocHJpdktleSk7XG4gICAgICB2YXIgc2VjcmV0ID0gZWNkaC5jb21wdXRlU2VjcmV0KHB1YktleSk7XG4gICAgICBpZiAoa2V5TGVuKSB7XG4gICAgICAgIGlmIChzZWNyZXQubGVuZ3RoIDwga2V5TGVuKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImtleSBsZW5ndGggdG9vIGxhcmdlOiBcIiArIGtleUxlbikpO1xuICAgICAgICB9XG4gICAgICAgIHNlY3JldCA9IHNlY3JldC5zbGljZSgwLCBrZXlMZW4pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlY3JldDtcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIGVjZGhDb25jYXREZXJpdmVGbigpIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGhhc2g7XG4gICAgdHJ5IHtcbiAgICAgIGhhc2ggPSBwcm9wcy5oYXNoIHx8IGlkZWFsSGFzaChrZXkuY3J2KTtcbiAgICAgIGlmICghaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGhhc2g6IFwiICsgaGFzaCk7XG4gICAgICB9XG4gICAgICBoYXNoLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IFtcInB1YmxpY1wiXTtcbiAgICAvLyBkZXJpdmUgc2hhcmVkIHNlY3JldFxuICAgIC8vIE5PVEU6IHdoaXRlbGlzdCBpdGVtcyBmcm9tIHtwcm9wc30gZm9yIEVDREhcbiAgICB2YXIgcHJvbWlzZSA9IGVjZGguRUNESC5kZXJpdmUoa2V5LCBwaWNrKHByb3BzLCBwYXJhbXMpKTtcbiAgICAvLyBleHBhbmRcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgLy8gTk9URTogYmxhY2tsaXN0IGl0ZW1zIGZyb20ge3Byb3BzfSBmb3IgRUNESFxuICAgICAgcmV0dXJuIGNvbmNhdFtcIkNPTkNBVC1cIiArIGhhc2hdLmRlcml2ZShzaGFyZWQsIG9taXQocHJvcHMsIHBhcmFtcykpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gZWNkaEhrZGZEZXJpdmVGbigpIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGhhc2g7XG4gICAgdHJ5IHtcbiAgICAgIGhhc2ggPSBwcm9wcy5oYXNoIHx8IGlkZWFsSGFzaChrZXkuY3J2KTtcbiAgICAgIGlmICghaGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGhhc2g6IFwiICsgaGFzaCk7XG4gICAgICB9XG4gICAgICBoYXNoLnRvVXBwZXJDYXNlKCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChleCk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IFtcInB1YmxpY1wiXTtcbiAgICAvLyBkZXJpdmUgc2hhcmVkIHNlY3JldFxuICAgIC8vIE5PVEU6IHdoaXRlbGlzdCBpdGVtcyBmcm9tIHtwcm9wc30gZm9yIEVDREhcbiAgICB2YXIgcHJvbWlzZSA9IGVjZGguRUNESC5kZXJpdmUoa2V5LCBwaWNrKHByb3BzLCBwYXJhbXMpKTtcbiAgICAvLyBleHRyYWN0LWFuZC1leHBhbmRcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgLy8gTk9URTogYmxhY2tsaXN0IGl0ZW1zIGZyb20ge3Byb3BzfSBmb3IgRUNESFxuICAgICAgcmV0dXJuIGhrZGZbXCJIS0RGLVwiICsgaGFzaF0uZGVyaXZlKHNoYXJlZCwgb21pdChwcm9wcywgcGFyYW1zKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vLyAjIyMgV3JhcC9VbndyYXAgYWxnb3JpdGhtc1xuZnVuY3Rpb24gZG9FY2RoZXNDb21tb25EZXJpdmUocHJpdktleSwgcHViS2V5LCBwcm9wcykge1xuICBmdW5jdGlvbiBwcmVwZW5kTGVuKGlucHV0KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKGlucHV0Lmxlbmd0aCksXG4gICAgICBpbnB1dFxuICAgIF0pO1xuICB9XG5cbiAgdmFyIGFsZ0lkID0gcHJvcHMuYWxnb3JpdGhtIHx8IFwiXCIsXG4gICAgICBrZXlMZW4gPSBDT05TVEFOVFMuS0VZTEVOR1RIW2FsZ0lkXSxcbiAgICAgIGFwdSA9IHV0aWwuYXNCdWZmZXIocHJvcHMuYXB1IHx8IFwiXCIsIFwiYmFzZTY0dXJsXCIpLFxuICAgICAgYXB2ID0gdXRpbC5hc0J1ZmZlcihwcm9wcy5hcHYgfHwgXCJcIiwgXCJiYXNlNjR1cmxcIik7XG4gIHZhciBvdGhlckluZm8gPSBCdWZmZXIuY29uY2F0KFtcbiAgICBwcmVwZW5kTGVuKEJ1ZmZlci5mcm9tKGFsZ0lkLCBcInV0ZjhcIikpLFxuICAgIHByZXBlbmRMZW4oYXB1KSxcbiAgICBwcmVwZW5kTGVuKGFwdiksXG4gICAgaGVscGVycy5pbnQzMlRvQnVmZmVyKGtleUxlbilcbiAgXSk7XG5cbiAgdmFyIHBhcmFtcyA9IHtcbiAgICBwdWJsaWM6IHB1YktleSxcbiAgICBsZW5ndGg6IGtleUxlbiAvIDgsXG4gICAgaGFzaDogXCJTSEEtMjU2XCIsXG4gICAgb3RoZXJJbmZvOiBvdGhlckluZm9cbiAgfTtcbiAgcmV0dXJuIGVjZGhbXCJFQ0RILUNPTkNBVFwiXS5kZXJpdmUocHJpdktleSwgcGFyYW1zKTtcbn1cblxuZnVuY3Rpb24gZWNkaGVzRGlyRW5jcnlwdEZuKCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIC8vIHtwcm9wcy5lcGt9IGlzIHByaXZhdGVcbiAgICBpZiAoIXByb3BzLmVwayB8fCAhcHJvcHMuZXBrLmQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGVwaGVtZXJhbCBwcml2YXRlIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBlcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKHByb3BzLmVwaywgZmFsc2UpO1xuXG4gICAgLy8ge2tleX0gaXMgcHVibGljXG4gICAgaWYgKCFrZXkgfHwgIWtleS54IHx8ICFrZXkueSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcgc3RhdGljIHB1YmxpYyBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgc3BrID0gZWNVdGlsLmNvbnZlcnRUb09iaihrZXksIHRydWUpO1xuXG4gICAgLy8gZGVyaXZlIEVDREggc2hhcmVkXG4gICAgdmFyIHByb21pc2UgPSBkb0VjZGhlc0NvbW1vbkRlcml2ZShlcGssIHNwaywge1xuICAgICAgYWxnb3JpdGhtOiBwcm9wcy5lbmMsXG4gICAgICBhcHU6IHByb3BzLmFwdSxcbiAgICAgIGFwdjogcHJvcHMuYXB2XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHNoYXJlZCxcbiAgICAgICAgb25jZTogdHJ1ZSxcbiAgICAgICAgZGlyZWN0OiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cbmZ1bmN0aW9uIGVjZGhlc0RpckRlY3J5cHRGbigpIHtcbiAgLy8gTk9URTogbm8gbm9kZWpzL3dlYmNyeXB0by9mYWxsYmFjayBtb2RlbCwgc2luY2UgdGhpcyBhbGdvcml0aG0gaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgb3RoZXIgcHJpbWl0aXZlc1xuICB2YXIgZm4gPSBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAvLyB7cHJvcHMuZXBrfSBpcyBwdWJsaWNcbiAgICBpZiAoIXByb3BzLmVwayB8fCAhcHJvcHMuZXBrLnggfHwgIXByb3BzLmVway55KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBlcGhlbWVyYWwgcHVibGljIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBlcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKHByb3BzLmVwaywgdHJ1ZSk7XG5cbiAgICAvLyB7a2V5fSBpcyBwcml2YXRlXG4gICAgaWYgKCFrZXkgfHwgIWtleS5kKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibWlzc2luZyBzdGF0aWMgcHJpdmF0ZSBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgc3BrID0gZWNVdGlsLmNvbnZlcnRUb09iaihrZXksIGZhbHNlKTtcblxuICAgIC8vIGRlcml2ZSBFQ0RIIHNoYXJlZFxuICAgIHZhciBwcm9taXNlID0gZG9FY2RoZXNDb21tb25EZXJpdmUoc3BrLCBlcGssIHtcbiAgICAgIGFsZ29yaXRobTogcHJvcHMuZW5jLFxuICAgICAgYXB1OiBwcm9wcy5hcHUsXG4gICAgICBhcHY6IHByb3BzLmFwdlxuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2hhcmVkKSB7XG4gICAgICByZXR1cm4gc2hhcmVkO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gZWNkaGVzS3dFbmNyeXB0Rm4od3JhcCkge1xuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIGFsZ29yaXRobSBpc1xuICAvLyAgICAgICBpbXBsZW1lbnRlZCB1c2luZyBvdGhlciBwcmltaXRpdmVzXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIC8vIHtwcm9wcy5lcGt9IGlzIHByaXZhdGVcbiAgICBpZiAoIXByb3BzLmVwayB8fCAhcHJvcHMuZXBrLmQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGVwaGVtZXJhbCBwcml2YXRlIGtleVwiKSk7XG4gICAgfVxuICAgIHZhciBlcGsgPSBlY1V0aWwuY29udmVydFRvT2JqKHByb3BzLmVwaywgZmFsc2UpO1xuXG4gICAgLy8ge2tleX0gaXMgcHVibGljXG4gICAgaWYgKCFrZXkgfHwgIWtleS54IHx8ICFrZXkueSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcgc3RhdGljIHB1YmxpYyBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgc3BrID0gZWNVdGlsLmNvbnZlcnRUb09iaihrZXksIHRydWUpO1xuXG4gICAgLy8gZGVyaXZlIEVDREggc2hhcmVkXG4gICAgdmFyIHByb21pc2UgPSBkb0VjZGhlc0NvbW1vbkRlcml2ZShlcGssIHNwaywge1xuICAgICAgYWxnb3JpdGhtOiBwcm9wcy5hbGcsXG4gICAgICBhcHU6IHByb3BzLmFwdSxcbiAgICAgIGFwdjogcHJvcHMuYXB2XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihzaGFyZWQpIHtcbiAgICAgIC8vIHdyYXAgcHJvdmlkZWQga2V5IHdpdGggRUNESCBzaGFyZWRcbiAgICAgIHJldHVybiB3cmFwKHNoYXJlZCwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuZnVuY3Rpb24gZWNkaGVzS3dEZWNyeXB0Rm4odW53cmFwKSB7XG4gIC8vIE5PVEU6IG5vIG5vZGVqcy93ZWJjcnlwdG8vZmFsbGJhY2sgbW9kZWwsIHNpbmNlIHRoaXMgYWxnb3JpdGhtIGlzXG4gIC8vICAgICAgIGltcGxlbWVudGVkIHVzaW5nIG90aGVyIHByaW1pdGl2ZXNcbiAgdmFyIGZuID0gZnVuY3Rpb24oa2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgLy8ge3Byb3BzLmVwa30gaXMgcHVibGljXG4gICAgaWYgKCFwcm9wcy5lcGsgfHwgIXByb3BzLmVway54IHx8ICFwcm9wcy5lcGsueSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3NpbmcgZXBoZW1lcmFsIHB1YmxpYyBrZXlcIikpO1xuICAgIH1cbiAgICB2YXIgZXBrID0gZWNVdGlsLmNvbnZlcnRUb09iaihwcm9wcy5lcGssIHRydWUpO1xuXG4gICAgLy8ge2tleX0gaXMgcHJpdmF0ZVxuICAgIGlmICgha2V5IHx8ICFrZXkuZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcgc3RhdGljIHByaXZhdGUga2V5XCIpKTtcbiAgICB9XG4gICAgdmFyIHNwayA9IGVjVXRpbC5jb252ZXJ0VG9PYmooa2V5LCBmYWxzZSk7XG5cbiAgICAvLyBkZXJpdmUgRUNESCBzaGFyZWRcbiAgICB2YXIgcHJvbWlzZSA9IGRvRWNkaGVzQ29tbW9uRGVyaXZlKHNwaywgZXBrLCB7XG4gICAgICBhbGdvcml0aG06IHByb3BzLmFsZyxcbiAgICAgIGFwdTogcHJvcHMuYXB1LFxuICAgICAgYXB2OiBwcm9wcy5hcHZcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHNoYXJlZCkge1xuICAgICAgLy8gdW53cmFwIHByb3ZpZGVkIGtleSB3aXRoIEVDREggc2hhcmVkXG4gICAgICByZXR1cm4gdW53cmFwKHNoYXJlZCwgY2RhdGEpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHJldHVybiBmbjtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLmRlcml2ZVxuW1xuICBcIkVDREhcIixcbiAgXCJFQ0RILUhLREZcIixcbiAgXCJFQ0RILUNPTkNBVFwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICB2YXIga2RmID0gL15FQ0RIKD86LShcXHcrKSk/JC9nLmV4ZWMobmFtZSB8fCBcIlwiKVsxXTtcbiAgdmFyIG9wID0gZWNkaFtuYW1lXSA9IGVjZGhbbmFtZV0gfHwge307XG4gIHN3aXRjaCAoa2RmIHx8IFwiXCIpIHtcbiAgICBjYXNlIFwiQ09OQ0FUXCI6XG4gICAgICBvcC5kZXJpdmUgPSBlY2RoQ29uY2F0RGVyaXZlRm4oKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJIS0RGXCI6XG4gICAgICBvcC5kZXJpdmUgPSBlY2RoSGtkZkRlcml2ZUZuKCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiXCI6XG4gICAgICBvcC5kZXJpdmUgPSBlY2RoRGVyaXZlRm4oKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBvcC5kZXJpdmUgPSBudWxsO1xuICB9XG59KTtcblxuLy8gKiBbbmFtZV0uZW5jcnlwdFxuLy8gKiBbbmFtZV0uZGVjcnlwdFxuW1xuICBcIkVDREgtRVNcIixcbiAgXCJFQ0RILUVTK0ExMjhLV1wiLFxuICBcIkVDREgtRVMrQTE5MktXXCIsXG4gIFwiRUNESC1FUytBMjU2S1dcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGt3ID0gL15FQ0RILUVTKD86XFwrKC4rKSk/L2cuZXhlYyhuYW1lIHx8IFwiXCIpWzFdO1xuICB2YXIgb3AgPSBlY2RoW25hbWVdID0gZWNkaFtuYW1lXSB8fCB7fTtcbiAgaWYgKCFrdykge1xuICAgIG9wLmVuY3J5cHQgPSBlY2RoZXNEaXJFbmNyeXB0Rm4oKTtcbiAgICBvcC5kZWNyeXB0ID0gZWNkaGVzRGlyRGVjcnlwdEZuKCk7XG4gIH0gZWxzZSB7XG4gICAga3cgPSBhZXNLd1trd107XG4gICAgaWYgKGt3KSB7XG4gICAgICBvcC5lbmNyeXB0ID0gZWNkaGVzS3dFbmNyeXB0Rm4oa3cuZW5jcnlwdCk7XG4gICAgICBvcC5kZWNyeXB0ID0gZWNkaGVzS3dEZWNyeXB0Rm4oa3cuZGVjcnlwdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wLmVjcnlwdCA9IG9wLmRlY3J5cHQgPSBudWxsO1xuICAgIH1cbiAgfVxufSk7XG4vLyovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/ecdsa.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/ecdsa.js - Elliptic Curve Digitial Signature Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar ecUtil = __webpack_require__(/*! ./ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    sha = __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\");\n\nfunction idealCurve(hash) {\n  switch (hash) {\n    case \"SHA-256\":\n      return \"P-256\";\n    case \"SHA-384\":\n      return \"P-384\";\n    case \"SHA-512\":\n      return \"P-521\";\n    default:\n      throw new Error(\"unsupported hash: \" + hash);\n  }\n}\n\nfunction ecdsaSignFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, false);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // sign hash\n    promise = promise.then(function(result) {\n      result = pk.sign(result);\n      result = Buffer.concat([result.r, result.s]);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, false);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [ \"sign\" ]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: result\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createSign(nodeHash));\n      promise = promise.then(function (sign) {\n        sign.update(pdata);\n        return sign;\n      });\n\n      var size;\n\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      promise = promise.then(function (sign) {\n        return ecUtil.derToConcat(sign.sign(ecUtil.convertToPEM(key, true)), size);\n      });\n\n      promise = promise.then(function (result) {\n        return {\n          data: pdata,\n          mac: result\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction ecdsaVerifyFN(hash) {\n  var curve = idealCurve(hash);\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac /*, props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToForge(key, true);\n\n    var promise;\n    // generate hash\n    promise = sha[hash].digest(pdata);\n    // verify hash\n    promise = promise.then(function(result) {\n      var len = mac.length / 2;\n      var rs = {\n        r: mac.slice(0, len),\n        s: mac.slice(len)\n      };\n      if (!pk.verify(result, rs)) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  // ### WebCrypto API implementation\n  var webcrypto = function(key, pdata, mac /* , props */) {\n    if (curve !== key.crv) {\n      return Promise.reject(new Error(\"invalid curve\"));\n    }\n    var pk = ecUtil.convertToJWK(key, true);\n\n    var promise;\n    var alg = {\n      name: \"ECDSA\",\n      namedCurve: pk.crv,\n      hash: {\n        name: hash\n      }\n    };\n    promise = helpers.subtleCrypto.importKey(\"jwk\",\n                                             pk,\n                                             alg,\n                                             true,\n                                             [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = hash.toLowerCase().replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata, mac /* , props */) {\n      if (curve !== key.crv) {\n        return Promise.reject(new Error(\"invalid curve\"));\n      }\n\n      var size;\n      switch (nodeHash.slice(-3)) {\n        case \"384\":\n          size = 48;\n          break;\n        case \"512\":\n          size = 66;\n          break;\n        default:\n          size = 32;\n      }\n\n      var promise;\n      promise = Promise.resolve(helpers.nodeCrypto.createVerify(nodeHash));\n      promise = promise.then(function (verify) {\n        verify.update(pdata);\n        verify.end();\n        return verify.verify(ecUtil.convertToPEM(key, false), ecUtil.concatToDer(mac, size));\n      });\n      promise = promise.then(function (result) {\n        if (!result) {\n          throw new Error(\"verification failed\");\n        }\n        return {\n          data: pdata,\n          mac: mac,\n          valid: true\n        };\n      });\n\n      return promise;\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\nvar ecdsa = {};\n\n// * [name].sign\n// * [name].verify\n[\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n].forEach(function(name) {\n  var hash = name.replace(/ES(\\d+)/g, function(m, size) {\n    return \"SHA-\" + size;\n  });\n  ecdsa[name] = {\n    sign: ecdsaSignFN(hash),\n    verify: ecdsaVerifyFN(hash)\n  };\n});\n\nmodule.exports = ecdsa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZHNhLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsOEVBQWM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLDhFQUFjO0FBQ3BDLFVBQVUsbUJBQU8sQ0FBQyxzRUFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2VjZHNhLmpzPzY5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2VjZHNhLmpzIC0gRWxsaXB0aWMgQ3VydmUgRGlnaXRpYWwgU2lnbmF0dXJlIEFsZ29yaXRobXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlY1V0aWwgPSByZXF1aXJlKFwiLi9lYy11dGlsLmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIHNoYSA9IHJlcXVpcmUoXCIuL3NoYS5qc1wiKTtcblxuZnVuY3Rpb24gaWRlYWxDdXJ2ZShoYXNoKSB7XG4gIHN3aXRjaCAoaGFzaCkge1xuICAgIGNhc2UgXCJTSEEtMjU2XCI6XG4gICAgICByZXR1cm4gXCJQLTI1NlwiO1xuICAgIGNhc2UgXCJTSEEtMzg0XCI6XG4gICAgICByZXR1cm4gXCJQLTM4NFwiO1xuICAgIGNhc2UgXCJTSEEtNTEyXCI6XG4gICAgICByZXR1cm4gXCJQLTUyMVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBoYXNoOiBcIiArIGhhc2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVjZHNhU2lnbkZOKGhhc2gpIHtcbiAgdmFyIGN1cnZlID0gaWRlYWxDdXJ2ZShoYXNoKTtcblxuICAvLyAjIyMgRmFsbGJhY2sgaW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhIC8qLCBwcm9wcyAqLykge1xuICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgIH1cbiAgICB2YXIgcGsgPSBlY1V0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCBmYWxzZSk7XG5cbiAgICB2YXIgcHJvbWlzZTtcbiAgICAvLyBnZW5lcmF0ZSBoYXNoXG4gICAgcHJvbWlzZSA9IHNoYVtoYXNoXS5kaWdlc3QocGRhdGEpO1xuICAgIC8vIHNpZ24gaGFzaFxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXN1bHQgPSBway5zaWduKHJlc3VsdCk7XG4gICAgICByZXN1bHQgPSBCdWZmZXIuY29uY2F0KFtyZXN1bHQuciwgcmVzdWx0LnNdKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHJlc3VsdFxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvIEFQSSBpbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSAvKiwgcHJvcHMgKi8pIHtcbiAgICBpZiAoY3VydmUgIT09IGtleS5jcnYpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICB9XG4gICAgdmFyIHBrID0gZWNVdGlsLmNvbnZlcnRUb0pXSyhrZXksIGZhbHNlKTtcblxuICAgIHZhciBwcm9taXNlO1xuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkVDRFNBXCIsXG4gICAgICBuYW1lZEN1cnZlOiBway5jcnYsXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IGhhc2hcbiAgICAgIH1cbiAgICB9O1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsgXCJzaWduXCIgXSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5zaWduKGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiByZXN1bHRcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgdmFyIG5vZGVIYXNoID0gaGFzaC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICBpZiAoaGVscGVycy5ub2RlQ3J5cHRvICYmIGhlbHBlcnMubm9kZUNyeXB0by5nZXRIYXNoZXMoKS5pbmRleE9mKG5vZGVIYXNoKSA+IC0xKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVTaWduKG5vZGVIYXNoKSk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzaWduKSB7XG4gICAgICAgIHNpZ24udXBkYXRlKHBkYXRhKTtcbiAgICAgICAgcmV0dXJuIHNpZ247XG4gICAgICB9KTtcblxuICAgICAgdmFyIHNpemU7XG5cbiAgICAgIHN3aXRjaCAobm9kZUhhc2guc2xpY2UoLTMpKSB7XG4gICAgICAgIGNhc2UgXCIzODRcIjpcbiAgICAgICAgICBzaXplID0gNDg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCI1MTJcIjpcbiAgICAgICAgICBzaXplID0gNjY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc2l6ZSA9IDMyO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChzaWduKSB7XG4gICAgICAgIHJldHVybiBlY1V0aWwuZGVyVG9Db25jYXQoc2lnbi5zaWduKGVjVXRpbC5jb252ZXJ0VG9QRU0oa2V5LCB0cnVlKSksIHNpemUpO1xuICAgICAgfSk7XG5cbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICAgIG1hYzogcmVzdWx0XG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZWNkc2FWZXJpZnlGTihoYXNoKSB7XG4gIHZhciBjdXJ2ZSA9IGlkZWFsQ3VydmUoaGFzaCk7XG5cbiAgLy8gIyMjIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjIC8qLCBwcm9wcyAqLykge1xuICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgIH1cbiAgICB2YXIgcGsgPSBlY1V0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCB0cnVlKTtcblxuICAgIHZhciBwcm9taXNlO1xuICAgIC8vIGdlbmVyYXRlIGhhc2hcbiAgICBwcm9taXNlID0gc2hhW2hhc2hdLmRpZ2VzdChwZGF0YSk7XG4gICAgLy8gdmVyaWZ5IGhhc2hcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgdmFyIGxlbiA9IG1hYy5sZW5ndGggLyAyO1xuICAgICAgdmFyIHJzID0ge1xuICAgICAgICByOiBtYWMuc2xpY2UoMCwgbGVuKSxcbiAgICAgICAgczogbWFjLnNsaWNlKGxlbilcbiAgICAgIH07XG4gICAgICBpZiAoIXBrLnZlcmlmeShyZXN1bHQsIHJzKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG8gQVBJIGltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMgLyogLCBwcm9wcyAqLykge1xuICAgIGlmIChjdXJ2ZSAhPT0ga2V5LmNydikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgY3VydmVcIikpO1xuICAgIH1cbiAgICB2YXIgcGsgPSBlY1V0aWwuY29udmVydFRvSldLKGtleSwgdHJ1ZSk7XG5cbiAgICB2YXIgcHJvbWlzZTtcbiAgICB2YXIgYWxnID0ge1xuICAgICAgbmFtZTogXCJFQ0RTQVwiLFxuICAgICAgbmFtZWRDdXJ2ZTogcGsuY3J2LFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBoYXNoXG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ2ZXJpZnlcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8udmVyaWZ5KGFsZywga2V5LCBtYWMsIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICB2YXIgbm9kZUhhc2ggPSBoYXNoLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIi1cIiwgXCJcIik7XG4gIGlmIChoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmdldEhhc2hlcygpLmluZGV4T2Yobm9kZUhhc2gpID4gLTEpIHtcbiAgICBub2RlanMgPSBmdW5jdGlvbihrZXksIHBkYXRhLCBtYWMgLyogLCBwcm9wcyAqLykge1xuICAgICAgaWYgKGN1cnZlICE9PSBrZXkuY3J2KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGN1cnZlXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemU7XG4gICAgICBzd2l0Y2ggKG5vZGVIYXNoLnNsaWNlKC0zKSkge1xuICAgICAgICBjYXNlIFwiMzg0XCI6XG4gICAgICAgICAgc2l6ZSA9IDQ4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiNTEyXCI6XG4gICAgICAgICAgc2l6ZSA9IDY2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHNpemUgPSAzMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVWZXJpZnkobm9kZUhhc2gpKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHZlcmlmeSkge1xuICAgICAgICB2ZXJpZnkudXBkYXRlKHBkYXRhKTtcbiAgICAgICAgdmVyaWZ5LmVuZCgpO1xuICAgICAgICByZXR1cm4gdmVyaWZ5LnZlcmlmeShlY1V0aWwuY29udmVydFRvUEVNKGtleSwgZmFsc2UpLCBlY1V0aWwuY29uY2F0VG9EZXIobWFjLCBzaXplKSk7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG52YXIgZWNkc2EgPSB7fTtcblxuLy8gKiBbbmFtZV0uc2lnblxuLy8gKiBbbmFtZV0udmVyaWZ5XG5bXG4gIFwiRVMyNTZcIixcbiAgXCJFUzM4NFwiLFxuICBcIkVTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBoYXNoID0gbmFtZS5yZXBsYWNlKC9FUyhcXGQrKS9nLCBmdW5jdGlvbihtLCBzaXplKSB7XG4gICAgcmV0dXJuIFwiU0hBLVwiICsgc2l6ZTtcbiAgfSk7XG4gIGVjZHNhW25hbWVdID0ge1xuICAgIHNpZ246IGVjZHNhU2lnbkZOKGhhc2gpLFxuICAgIHZlcmlmeTogZWNkc2FWZXJpZnlGTihoYXNoKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZWNkc2E7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/helpers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/helpers.js - Internal functions and fields used in Cryptographic\n * Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\n// ###\nexports.int32ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(4);\n  b[0] = (v >>> 24) & 0xff;\n  b[1] = (v >>> 16) & 0xff;\n  b[2] = (v >>> 8) & 0xff;\n  b[3] = v & 0xff;\n  return b;\n};\n\nvar MAX_INT32 = Math.pow(2, 32);\nexports.int64ToBuffer = function(v, b) {\n  b = b || Buffer.alloc(8);\n  var hi = Math.floor(v / MAX_INT32),\n      lo = v % MAX_INT32;\n  hi = exports.int32ToBuffer(hi);\n  lo = exports.int32ToBuffer(lo);\n  b = Buffer.concat([hi, lo]);\n  return b;\n};\n\n// ### crypto and DOMException in browsers ###\n/* global crypto:false, DOMException:false */\n\nfunction getCryptoSubtle() {\n  if (\"undefined\" !== typeof crypto) {\n    if (\"undefined\" !== typeof crypto.subtle) {\n      return crypto.subtle;\n    }\n  }\n\n  return undefined;\n}\nfunction getCryptoNodeJS() {\n  var crypto;\n  try {\n    crypto = __webpack_require__(/*! crypto */ \"crypto\");\n  } catch (err) {\n    return undefined;\n  }\n\n  if (!Object.keys(crypto).length) {\n    // treat empty the same as missing\n    return undefined;\n  }\n\n  return crypto;\n}\n\nvar supported = {};\nObject.defineProperty(exports, \"subtleCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"subtleCrypto\" in supported) {\n      result = supported.subtleCrypto;\n    } else {\n      result = supported.subtleCrypto = getCryptoSubtle();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\nObject.defineProperty(exports, \"nodeCrypto\", ({\n  get: function() {\n    var result;\n\n    if (\"nodeCrypto\" in supported) {\n      result = supported.nodeCrypto;\n    } else {\n      result = supported.nodeCrypto = getCryptoNodeJS();\n    }\n\n    return result;\n  },\n  enumerable: true\n}));\n\nexports.setupFallback = function(nodejs, webcrypto, fallback) {\n  var impl;\n\n  if (nodejs && exports.nodeCrypto) {\n    impl = function main() {\n      var args = arguments,\n          promise;\n\n      function check(err) {\n        if (0 === err.message.indexOf(\"unsupported algorithm:\")) {\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n        return Promise.reject(err);\n      }\n\n      try {\n        promise = Promise.resolve(nodejs.apply(null, args));\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else if (webcrypto && exports.subtleCrypto) {\n    impl = function main() {\n      var args = arguments,\n         promise;\n\n      function check(err) {\n        if (err.code === DOMException.NOT_SUPPORTED_ERR ||\n            // Firefox rejects some operations erroneously complaining about inputs\n            err.message === \"Only ArrayBuffer and ArrayBufferView objects can be passed as CryptoOperationData\" ||\n            // MS Edge rejects with not an Error\n            !(err instanceof Error)) {\n          // not actually supported -- always use fallback\n          impl = fallback;\n          return impl.apply(null, args);\n        }\n\n       return Promise.reject(err);\n      }\n\n      try {\n        promise = webcrypto.apply(null, args);\n        promise = promise.catch(check);\n      } catch(err) {\n        promise = check(err);\n      }\n\n      return promise;\n    };\n  } else {\n    impl = fallback;\n  }\n\n  return impl;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0IsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUErQztBQUMvQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQztBQUNGLDhDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsRUFBQzs7QUFFRixxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9oZWxwZXJzLmpzPzFlN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2hlbHBlcnMuanMgLSBJbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGZpZWxkcyB1c2VkIGluIENyeXB0b2dyYXBoaWNcbiAqIEFsZ29yaXRobXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmlmICh0eXBlb2YgUHJvbWlzZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICByZXF1aXJlKFwiZXM2LXByb21pc2VcIikucG9seWZpbGwoKTtcbn1cblxuLy8gIyMjXG5leHBvcnRzLmludDMyVG9CdWZmZXIgPSBmdW5jdGlvbih2LCBiKSB7XG4gIGIgPSBiIHx8IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYlswXSA9ICh2ID4+PiAyNCkgJiAweGZmO1xuICBiWzFdID0gKHYgPj4+IDE2KSAmIDB4ZmY7XG4gIGJbMl0gPSAodiA+Pj4gOCkgJiAweGZmO1xuICBiWzNdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBiO1xufTtcblxudmFyIE1BWF9JTlQzMiA9IE1hdGgucG93KDIsIDMyKTtcbmV4cG9ydHMuaW50NjRUb0J1ZmZlciA9IGZ1bmN0aW9uKHYsIGIpIHtcbiAgYiA9IGIgfHwgQnVmZmVyLmFsbG9jKDgpO1xuICB2YXIgaGkgPSBNYXRoLmZsb29yKHYgLyBNQVhfSU5UMzIpLFxuICAgICAgbG8gPSB2ICUgTUFYX0lOVDMyO1xuICBoaSA9IGV4cG9ydHMuaW50MzJUb0J1ZmZlcihoaSk7XG4gIGxvID0gZXhwb3J0cy5pbnQzMlRvQnVmZmVyKGxvKTtcbiAgYiA9IEJ1ZmZlci5jb25jYXQoW2hpLCBsb10pO1xuICByZXR1cm4gYjtcbn07XG5cbi8vICMjIyBjcnlwdG8gYW5kIERPTUV4Y2VwdGlvbiBpbiBicm93c2VycyAjIyNcbi8qIGdsb2JhbCBjcnlwdG86ZmFsc2UsIERPTUV4Y2VwdGlvbjpmYWxzZSAqL1xuXG5mdW5jdGlvbiBnZXRDcnlwdG9TdWJ0bGUoKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgY3J5cHRvKSB7XG4gICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjcnlwdG8uc3VidGxlKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0Q3J5cHRvTm9kZUpTKCkge1xuICB2YXIgY3J5cHRvO1xuICB0cnkge1xuICAgIGNyeXB0byA9IHJlcXVpcmUoXCJjcnlwdG9cIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIU9iamVjdC5rZXlzKGNyeXB0bykubGVuZ3RoKSB7XG4gICAgLy8gdHJlYXQgZW1wdHkgdGhlIHNhbWUgYXMgbWlzc2luZ1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICByZXR1cm4gY3J5cHRvO1xufVxuXG52YXIgc3VwcG9ydGVkID0ge307XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJ0bGVDcnlwdG9cIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoXCJzdWJ0bGVDcnlwdG9cIiBpbiBzdXBwb3J0ZWQpIHtcbiAgICAgIHJlc3VsdCA9IHN1cHBvcnRlZC5zdWJ0bGVDcnlwdG87XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHN1cHBvcnRlZC5zdWJ0bGVDcnlwdG8gPSBnZXRDcnlwdG9TdWJ0bGUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vZGVDcnlwdG9cIiwge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAoXCJub2RlQ3J5cHRvXCIgaW4gc3VwcG9ydGVkKSB7XG4gICAgICByZXN1bHQgPSBzdXBwb3J0ZWQubm9kZUNyeXB0bztcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gc3VwcG9ydGVkLm5vZGVDcnlwdG8gPSBnZXRDcnlwdG9Ob2RlSlMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBlbnVtZXJhYmxlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5zZXR1cEZhbGxiYWNrID0gZnVuY3Rpb24obm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKSB7XG4gIHZhciBpbXBsO1xuXG4gIGlmIChub2RlanMgJiYgZXhwb3J0cy5ub2RlQ3J5cHRvKSB7XG4gICAgaW1wbCA9IGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICBwcm9taXNlO1xuXG4gICAgICBmdW5jdGlvbiBjaGVjayhlcnIpIHtcbiAgICAgICAgaWYgKDAgPT09IGVyci5tZXNzYWdlLmluZGV4T2YoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06XCIpKSB7XG4gICAgICAgICAgaW1wbCA9IGZhbGxiYWNrO1xuICAgICAgICAgIHJldHVybiBpbXBsLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUobm9kZWpzLmFwcGx5KG51bGwsIGFyZ3MpKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHByb21pc2UgPSBjaGVjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHdlYmNyeXB0byAmJiBleHBvcnRzLnN1YnRsZUNyeXB0bykge1xuICAgIGltcGwgPSBmdW5jdGlvbiBtYWluKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICBwcm9taXNlO1xuXG4gICAgICBmdW5jdGlvbiBjaGVjayhlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSBET01FeGNlcHRpb24uTk9UX1NVUFBPUlRFRF9FUlIgfHxcbiAgICAgICAgICAgIC8vIEZpcmVmb3ggcmVqZWN0cyBzb21lIG9wZXJhdGlvbnMgZXJyb25lb3VzbHkgY29tcGxhaW5pbmcgYWJvdXQgaW5wdXRzXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJPbmx5IEFycmF5QnVmZmVyIGFuZCBBcnJheUJ1ZmZlclZpZXcgb2JqZWN0cyBjYW4gYmUgcGFzc2VkIGFzIENyeXB0b09wZXJhdGlvbkRhdGFcIiB8fFxuICAgICAgICAgICAgLy8gTVMgRWRnZSByZWplY3RzIHdpdGggbm90IGFuIEVycm9yXG4gICAgICAgICAgICAhKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIC8vIG5vdCBhY3R1YWxseSBzdXBwb3J0ZWQgLS0gYWx3YXlzIHVzZSBmYWxsYmFja1xuICAgICAgICAgIGltcGwgPSBmYWxsYmFjaztcbiAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHByb21pc2UgPSB3ZWJjcnlwdG8uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLmNhdGNoKGNoZWNrKTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIHByb21pc2UgPSBjaGVjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGltcGwgPSBmYWxsYmFjaztcbiAgfVxuXG4gIHJldHVybiBpbXBsO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hkdf.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hkdf.js - HMAC-based Extract-and-Expand Key Derivation\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    hmac = __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\");\n\nfunction hkdfDeriveFn(name) {\n  var hash = name.replace(\"HKDF-\", \"\"),\n      op = name.replace(\"HKDF-SHA-\", \"HS\");\n\n  // NOTE: no nodejs/webcrypto/fallback model, since this HKDF is\n  //       implemented using the HMAC algorithms\n\n  var fn = function(key, props) {\n    var hashLen = CONSTANTS.HASHLENGTH[hash] / 8;\n\n    if (\"string\" === typeof op) {\n      op = hmac[op].sign;\n    }\n\n    // prepare options\n    props = props || {};\n    var salt = props.salt;\n    if (!salt || 0 === salt.length) {\n      salt = Buffer.alloc(hashLen);\n    }\n    var info = props.info || Buffer.alloc(0);\n    var keyLen = props.length || hashLen;\n\n    var promise;\n\n    // Setup Expansion\n    var N = Math.ceil(keyLen / hashLen),\n        okm = [],\n        idx = 0;\n    function expand(key, T) {\n      if (N === idx++) {\n        return Buffer.concat(okm).slice(0, keyLen);\n      }\n\n      if (!T) {\n        T = Buffer.alloc(0);\n      }\n      T = Buffer.concat([T, info, Buffer.from([idx])]);\n      T = op(key, T);\n      T = T.then(function(result) {\n        T = result.mac;\n        okm.push(T);\n\n        return expand(key, T);\n      });\n      return T;\n    }\n\n    // Step 1: Extract\n    promise = op(salt, key, { length: salt.length * 8 });\n    promise = promise.then(function(result) {\n      // Step 2: Expand\n      return expand(result.mac);\n    });\n\n    return promise;\n  };\n\n  return fn;\n}\n\n// Public API\n// * [name].derive\nvar hkdf = {};\n[\n  \"HKDF-SHA-1\",\n  \"HKDF-SHA-256\",\n  \"HKDF-SHA-384\",\n  \"HKDF-SHA-512\"\n].forEach(function(name) {\n  hkdf[name] = {\n    derive: hkdfDeriveFn(name)\n  };\n});\n\nmodule.exports = hkdf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hrZGYuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFnQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsd0VBQVc7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2hrZGYuanM/Mjg0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGFsZ29yaXRobXMvaGtkZi5qcyAtIEhNQUMtYmFzZWQgRXh0cmFjdC1hbmQtRXhwYW5kIEtleSBEZXJpdmF0aW9uXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpLFxuICAgIGhtYWMgPSByZXF1aXJlKFwiLi9obWFjLmpzXCIpO1xuXG5mdW5jdGlvbiBoa2RmRGVyaXZlRm4obmFtZSkge1xuICB2YXIgaGFzaCA9IG5hbWUucmVwbGFjZShcIkhLREYtXCIsIFwiXCIpLFxuICAgICAgb3AgPSBuYW1lLnJlcGxhY2UoXCJIS0RGLVNIQS1cIiwgXCJIU1wiKTtcblxuICAvLyBOT1RFOiBubyBub2RlanMvd2ViY3J5cHRvL2ZhbGxiYWNrIG1vZGVsLCBzaW5jZSB0aGlzIEhLREYgaXNcbiAgLy8gICAgICAgaW1wbGVtZW50ZWQgdXNpbmcgdGhlIEhNQUMgYWxnb3JpdGhtc1xuXG4gIHZhciBmbiA9IGZ1bmN0aW9uKGtleSwgcHJvcHMpIHtcbiAgICB2YXIgaGFzaExlbiA9IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdIC8gODtcblxuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2Ygb3ApIHtcbiAgICAgIG9wID0gaG1hY1tvcF0uc2lnbjtcbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIG9wdGlvbnNcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHZhciBzYWx0ID0gcHJvcHMuc2FsdDtcbiAgICBpZiAoIXNhbHQgfHwgMCA9PT0gc2FsdC5sZW5ndGgpIHtcbiAgICAgIHNhbHQgPSBCdWZmZXIuYWxsb2MoaGFzaExlbik7XG4gICAgfVxuICAgIHZhciBpbmZvID0gcHJvcHMuaW5mbyB8fCBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdmFyIGtleUxlbiA9IHByb3BzLmxlbmd0aCB8fCBoYXNoTGVuO1xuXG4gICAgdmFyIHByb21pc2U7XG5cbiAgICAvLyBTZXR1cCBFeHBhbnNpb25cbiAgICB2YXIgTiA9IE1hdGguY2VpbChrZXlMZW4gLyBoYXNoTGVuKSxcbiAgICAgICAgb2ttID0gW10sXG4gICAgICAgIGlkeCA9IDA7XG4gICAgZnVuY3Rpb24gZXhwYW5kKGtleSwgVCkge1xuICAgICAgaWYgKE4gPT09IGlkeCsrKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KG9rbSkuc2xpY2UoMCwga2V5TGVuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFUKSB7XG4gICAgICAgIFQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICB9XG4gICAgICBUID0gQnVmZmVyLmNvbmNhdChbVCwgaW5mbywgQnVmZmVyLmZyb20oW2lkeF0pXSk7XG4gICAgICBUID0gb3Aoa2V5LCBUKTtcbiAgICAgIFQgPSBULnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIFQgPSByZXN1bHQubWFjO1xuICAgICAgICBva20ucHVzaChUKTtcblxuICAgICAgICByZXR1cm4gZXhwYW5kKGtleSwgVCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBUO1xuICAgIH1cblxuICAgIC8vIFN0ZXAgMTogRXh0cmFjdFxuICAgIHByb21pc2UgPSBvcChzYWx0LCBrZXksIHsgbGVuZ3RoOiBzYWx0Lmxlbmd0aCAqIDggfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIC8vIFN0ZXAgMjogRXhwYW5kXG4gICAgICByZXR1cm4gZXhwYW5kKHJlc3VsdC5tYWMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vLyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5kZXJpdmVcbnZhciBoa2RmID0ge307XG5bXG4gIFwiSEtERi1TSEEtMVwiLFxuICBcIkhLREYtU0hBLTI1NlwiLFxuICBcIkhLREYtU0hBLTM4NFwiLFxuICBcIkhLREYtU0hBLTUxMlwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICBoa2RmW25hbWVdID0ge1xuICAgIGRlcml2ZTogaGtkZkRlcml2ZUZuKG5hbWUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBoa2RmO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/hmac.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/hmac.js - HMAC-based \"signatures\"\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hmacSignFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function checkKeyLength(len, key) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    if (len > key.length) {\n      return Promise.reject(new Error(\"invalid key length\"));\n    }\n\n    return Promise.resolve(key);\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, props) {\n    props = props || {};\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var sig = forge.hmac.create();\n      sig.start(md, key.toString(\"binary\"));\n      sig.update(pdata.toString(\"binary\"));\n      sig = Buffer.from(sig.digest().bytes(), \"binary\");\n\n      return {\n        data: pdata,\n        mac: sig\n      }\n    });\n    return promise;\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      return helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n    });\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  // ### NodeJS implementation\n  var nodejs = function(key, pdata, props) {\n    props = props || {};\n\n    var promise;\n    promise = checkKeyLength(props.length, key);\n    promise = promise.then(function() {\n      var hmac = helpers.nodeCrypto.createHmac(md, key);\n      hmac.update(pdata);\n\n      var sig = hmac.digest();\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction hmacVerifyFN(name) {\n  var md = name.replace(\"HS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"HS\", \"SHA-\");\n\n  function compare(len, expected, actual) {\n    len = (len || CONSTANTS.HASHLENGTH[hash]) / 8;\n    var valid = true;\n    for (var idx = 0; len > idx; idx++) {\n      valid = valid && (expected[idx] === actual[idx]);\n    }\n    return valid;\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var vrfy = forge.hmac.create();\n    vrfy.start(md, new DataBuffer(key));\n    vrfy.update(pdata.toString(\"binary\"));\n    vrfy = Buffer.from(vrfy.digest().bytes(), \"binary\");\n\n    if (compare(props.length, mac, vrfy)) {\n      return Promise.resolve({\n        data: pdata,\n        mac: mac,\n        valid: true\n      });\n    } else {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n  };\n\n  var webcrypto = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var alg = {\n      name: \"HMAC\",\n      hash: {\n        name: hash\n      }\n    };\n    var promise;\n    if (props.length) {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"sign\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.sign(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var sig = Buffer.from(result);\n        return compare(props.length, mac, sig);\n      });\n    } else {\n      promise = helpers.subtleCrypto.importKey(\"raw\", key, alg, true, [\"verify\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n      });\n    }\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verifaction failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs = function(key, pdata, mac, props) {\n    props = props || {};\n\n    var hmac = helpers.nodeCrypto.createHmac(md, key);\n    hmac.update(pdata);\n\n    var sig = hmac.digest();\n    if (!compare(props.length, mac, sig)) {\n      throw new Error(\"verification failed\");\n    }\n    return {\n      data: pdata,\n      mac: sig,\n      valid: true\n    };\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar hmac = {};\n[\n  \"HS1\",\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n].forEach(function(alg) {\n  hmac[alg] = {\n    sign: hmacSignFN(alg),\n    verify: hmacVerifyFN(alg)\n  };\n});\n\nmodule.exports = hmac;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2htYWMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFhO0FBQ3JDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0ZBQXVCO0FBQ2hELGNBQWMsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9obWFjLmpzPzkzNDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2htYWMuanMgLSBITUFDLWJhc2VkIFwic2lnbmF0dXJlc1wiXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgRGF0YUJ1ZmZlciA9IHJlcXVpcmUoXCIuLi91dGlsL2RhdGFidWZmZXIuanNcIiksXG4gICAgaGVscGVycyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIik7XG5cbmZ1bmN0aW9uIGhtYWNTaWduRk4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJIU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIkhTXCIsIFwiU0hBLVwiKTtcblxuICBmdW5jdGlvbiBjaGVja0tleUxlbmd0aChsZW4sIGtleSkge1xuICAgIGxlbiA9IChsZW4gfHwgQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0pIC8gODtcbiAgICBpZiAobGVuID4ga2V5Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQga2V5IGxlbmd0aFwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShrZXkpO1xuICB9XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBjaGVja0tleUxlbmd0aChwcm9wcy5sZW5ndGgsIGtleSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzaWcgPSBmb3JnZS5obWFjLmNyZWF0ZSgpO1xuICAgICAgc2lnLnN0YXJ0KG1kLCBrZXkudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgICAgc2lnLnVwZGF0ZShwZGF0YS50b1N0cmluZyhcImJpbmFyeVwiKSk7XG4gICAgICBzaWcgPSBCdWZmZXIuZnJvbShzaWcuZGlnZXN0KCkuYnl0ZXMoKSwgXCJiaW5hcnlcIik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcblxuICAgIHZhciBhbGcgPSB7XG4gICAgICBuYW1lOiBcIkhNQUNcIixcbiAgICAgIGhhc2g6IHtcbiAgICAgICAgbmFtZTogaGFzaFxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGNoZWNrS2V5TGVuZ3RoKHByb3BzLmxlbmd0aCwga2V5KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmltcG9ydEtleShcInJhd1wiLCBrZXksIGFsZywgdHJ1ZSwgW1wic2lnblwiXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5zaWduKGFsZywga2V5LCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHZhciBzaWcgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgLy8gIyMjIE5vZGVKUyBpbXBsZW1lbnRhdGlvblxuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIHByb21pc2U7XG4gICAgcHJvbWlzZSA9IGNoZWNrS2V5TGVuZ3RoKHByb3BzLmxlbmd0aCwga2V5KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhtYWMgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlSG1hYyhtZCwga2V5KTtcbiAgICAgIGhtYWMudXBkYXRlKHBkYXRhKTtcblxuICAgICAgdmFyIHNpZyA9IGhtYWMuZGlnZXN0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWdcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBobWFjVmVyaWZ5Rk4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJIU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIkhTXCIsIFwiU0hBLVwiKTtcblxuICBmdW5jdGlvbiBjb21wYXJlKGxlbiwgZXhwZWN0ZWQsIGFjdHVhbCkge1xuICAgIGxlbiA9IChsZW4gfHwgQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0pIC8gODtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGxlbiA+IGlkeDsgaWR4KyspIHtcbiAgICAgIHZhbGlkID0gdmFsaWQgJiYgKGV4cGVjdGVkW2lkeF0gPT09IGFjdHVhbFtpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgdnJmeSA9IGZvcmdlLmhtYWMuY3JlYXRlKCk7XG4gICAgdnJmeS5zdGFydChtZCwgbmV3IERhdGFCdWZmZXIoa2V5KSk7XG4gICAgdnJmeS51cGRhdGUocGRhdGEudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgIHZyZnkgPSBCdWZmZXIuZnJvbSh2cmZ5LmRpZ2VzdCgpLmJ5dGVzKCksIFwiYmluYXJ5XCIpO1xuXG4gICAgaWYgKGNvbXBhcmUocHJvcHMubGVuZ3RoLCBtYWMsIHZyZnkpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYywgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGFsZyA9IHtcbiAgICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgICAgaGFzaDoge1xuICAgICAgICBuYW1lOiBoYXNoXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJzaWduXCJdKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5zaWduKGFsZywga2V5LCBwZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciBzaWcgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgICByZXR1cm4gY29tcGFyZShwcm9wcy5sZW5ndGgsIG1hYywgc2lnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwicmF3XCIsIGtleSwgYWxnLCB0cnVlLCBbXCJ2ZXJpZnlcIl0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnZlcmlmeShhbGcsIGtleSwgbWFjLCBwZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmFjdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYywgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIGhtYWMgPSBoZWxwZXJzLm5vZGVDcnlwdG8uY3JlYXRlSG1hYyhtZCwga2V5KTtcbiAgICBobWFjLnVwZGF0ZShwZGF0YSk7XG5cbiAgICB2YXIgc2lnID0gaG1hYy5kaWdlc3QoKTtcbiAgICBpZiAoIWNvbXBhcmUocHJvcHMubGVuZ3RoLCBtYWMsIHNpZykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBwZGF0YSxcbiAgICAgIG1hYzogc2lnLFxuICAgICAgdmFsaWQ6IHRydWVcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gIyMjIFB1YmxpYyBBUElcbi8vICogW25hbWVdLnNpZ25cbi8vICogW25hbWVdLnZlcmlmeVxudmFyIGhtYWMgPSB7fTtcbltcbiAgXCJIUzFcIixcbiAgXCJIUzI1NlwiLFxuICBcIkhTMzg0XCIsXG4gIFwiSFM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKGFsZykge1xuICBobWFjW2FsZ10gPSB7XG4gICAgc2lnbjogaG1hY1NpZ25GTihhbGcpLFxuICAgIHZlcmlmeTogaG1hY1ZlcmlmeUZOKGFsZylcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhtYWM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/index.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * algorithms/index.js - Cryptographic Algorithms Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\n// setup implementations\nvar implementations = [\n  __webpack_require__(/*! ./aes-cbc-hmac-sha2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-cbc-hmac-sha2.js\"),\n  __webpack_require__(/*! ./aes-gcm.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-gcm.js\"),\n  __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\"),\n  __webpack_require__(/*! ./concat.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/concat.js\"),\n  __webpack_require__(/*! ./dir.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/dir.js\"),\n  __webpack_require__(/*! ./ecdh.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdh.js\"),\n  __webpack_require__(/*! ./ecdsa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ecdsa.js\"),\n  __webpack_require__(/*! ./hkdf.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hkdf.js\"),\n  __webpack_require__(/*! ./hmac.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/hmac.js\"),\n  __webpack_require__(/*! ./pbes2.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\"),\n  __webpack_require__(/*! ./rsaes.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\"),\n  __webpack_require__(/*! ./rsassa.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\"),\n  __webpack_require__(/*! ./sha.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\")\n];\n\nvar ALGS_DIGEST = {};\nvar ALGS_DERIVE = {};\nvar ALGS_SIGN = {},\n    ALGS_VRFY = {};\nvar ALGS_ENC = {},\n    ALGS_DEC = {};\n\nimplementations.forEach(function(mod) {\n  Object.keys(mod).forEach(function(alg) {\n    var op = mod[alg];\n\n    if (\"function\" === typeof op.encrypt) {\n      ALGS_ENC[alg] = op.encrypt;\n    }\n    if (\"function\" === typeof op.decrypt) {\n      ALGS_DEC[alg] = op.decrypt;\n    }\n    if (\"function\" === typeof op.sign) {\n      ALGS_SIGN[alg] = op.sign;\n    }\n    if (\"function\" === typeof op.verify) {\n      ALGS_VRFY[alg] = op.verify;\n    }\n    if (\"function\" === typeof op.digest) {\n      ALGS_DIGEST[alg] = op.digest;\n    }\n    if (\"function\" === typeof op.derive) {\n      ALGS_DERIVE[alg] = op.derive;\n    }\n  });\n});\n\n// public API\nexports.digest = function(alg, data, props) {\n  var op = ALGS_DIGEST[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(data, props);\n};\n\nexports.derive = function(alg, key, props) {\n  var op = ALGS_DERIVE[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, props);\n};\n\nexports.sign = function(alg, key, pdata, props) {\n  var op = ALGS_SIGN[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.verify = function(alg, key, pdata, mac, props) {\n  var op = ALGS_VRFY[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, mac, props || {});\n};\n\nexports.encrypt = function(alg, key, pdata, props) {\n  var op = ALGS_ENC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, pdata, props || {});\n};\n\nexports.decrypt = function(alg, key, cdata, props) {\n  var op = ALGS_DEC[alg];\n  if (!op) {\n    return Promise.reject(new Error(\"unsupported algorithm: \" + alg));\n  }\n\n  return op(key, cdata, props || {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0EsRUFBRSxtQkFBTyxDQUFDLGtHQUF3QjtBQUNsQyxFQUFFLG1CQUFPLENBQUMsOEVBQWM7QUFDeEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyw0RUFBYTtBQUN2QixFQUFFLG1CQUFPLENBQUMsc0VBQVU7QUFDcEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsd0VBQVc7QUFDckIsRUFBRSxtQkFBTyxDQUFDLHdFQUFXO0FBQ3JCLEVBQUUsbUJBQU8sQ0FBQywwRUFBWTtBQUN0QixFQUFFLG1CQUFPLENBQUMsMEVBQVk7QUFDdEIsRUFBRSxtQkFBTyxDQUFDLDRFQUFhO0FBQ3ZCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNwQjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4Qzs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL2luZGV4LmpzP2Q2NTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL2luZGV4LmpzIC0gQ3J5cHRvZ3JhcGhpYyBBbGdvcml0aG1zIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG4vLyBzZXR1cCBpbXBsZW1lbnRhdGlvbnNcbnZhciBpbXBsZW1lbnRhdGlvbnMgPSBbXG4gIHJlcXVpcmUoXCIuL2Flcy1jYmMtaG1hYy1zaGEyLmpzXCIpLFxuICByZXF1aXJlKFwiLi9hZXMtZ2NtLmpzXCIpLFxuICByZXF1aXJlKFwiLi9hZXMta3cuanNcIiksXG4gIHJlcXVpcmUoXCIuL2NvbmNhdC5qc1wiKSxcbiAgcmVxdWlyZShcIi4vZGlyLmpzXCIpLFxuICByZXF1aXJlKFwiLi9lY2RoLmpzXCIpLFxuICByZXF1aXJlKFwiLi9lY2RzYS5qc1wiKSxcbiAgcmVxdWlyZShcIi4vaGtkZi5qc1wiKSxcbiAgcmVxdWlyZShcIi4vaG1hYy5qc1wiKSxcbiAgcmVxdWlyZShcIi4vcGJlczIuanNcIiksXG4gIHJlcXVpcmUoXCIuL3JzYWVzLmpzXCIpLFxuICByZXF1aXJlKFwiLi9yc2Fzc2EuanNcIiksXG4gIHJlcXVpcmUoXCIuL3NoYS5qc1wiKVxuXTtcblxudmFyIEFMR1NfRElHRVNUID0ge307XG52YXIgQUxHU19ERVJJVkUgPSB7fTtcbnZhciBBTEdTX1NJR04gPSB7fSxcbiAgICBBTEdTX1ZSRlkgPSB7fTtcbnZhciBBTEdTX0VOQyA9IHt9LFxuICAgIEFMR1NfREVDID0ge307XG5cbmltcGxlbWVudGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKG1vZCkge1xuICBPYmplY3Qua2V5cyhtb2QpLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gICAgdmFyIG9wID0gbW9kW2FsZ107XG5cbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3AuZW5jcnlwdCkge1xuICAgICAgQUxHU19FTkNbYWxnXSA9IG9wLmVuY3J5cHQ7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC5kZWNyeXB0KSB7XG4gICAgICBBTEdTX0RFQ1thbGddID0gb3AuZGVjcnlwdDtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLnNpZ24pIHtcbiAgICAgIEFMR1NfU0lHTlthbGddID0gb3Auc2lnbjtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wLnZlcmlmeSkge1xuICAgICAgQUxHU19WUkZZW2FsZ10gPSBvcC52ZXJpZnk7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC5kaWdlc3QpIHtcbiAgICAgIEFMR1NfRElHRVNUW2FsZ10gPSBvcC5kaWdlc3Q7XG4gICAgfVxuICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcC5kZXJpdmUpIHtcbiAgICAgIEFMR1NfREVSSVZFW2FsZ10gPSBvcC5kZXJpdmU7XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vLyBwdWJsaWMgQVBJXG5leHBvcnRzLmRpZ2VzdCA9IGZ1bmN0aW9uKGFsZywgZGF0YSwgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19ESUdFU1RbYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3AoZGF0YSwgcHJvcHMpO1xufTtcblxuZXhwb3J0cy5kZXJpdmUgPSBmdW5jdGlvbihhbGcsIGtleSwgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19ERVJJVkVbYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3Aoa2V5LCBwcm9wcyk7XG59O1xuXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbihhbGcsIGtleSwgcGRhdGEsIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfU0lHTlthbGddO1xuICBpZiAoIW9wKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogXCIgKyBhbGcpKTtcbiAgfVxuXG4gIHJldHVybiBvcChrZXksIHBkYXRhLCBwcm9wcyB8fCB7fSk7XG59O1xuXG5leHBvcnRzLnZlcmlmeSA9IGZ1bmN0aW9uKGFsZywga2V5LCBwZGF0YSwgbWFjLCBwcm9wcykge1xuICB2YXIgb3AgPSBBTEdTX1ZSRllbYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3Aoa2V5LCBwZGF0YSwgbWFjLCBwcm9wcyB8fCB7fSk7XG59O1xuXG5leHBvcnRzLmVuY3J5cHQgPSBmdW5jdGlvbihhbGcsIGtleSwgcGRhdGEsIHByb3BzKSB7XG4gIHZhciBvcCA9IEFMR1NfRU5DW2FsZ107XG4gIGlmICghb3ApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQgYWxnb3JpdGhtOiBcIiArIGFsZykpO1xuICB9XG5cbiAgcmV0dXJuIG9wKGtleSwgcGRhdGEsIHByb3BzIHx8IHt9KTtcbn07XG5cbmV4cG9ydHMuZGVjcnlwdCA9IGZ1bmN0aW9uKGFsZywga2V5LCBjZGF0YSwgcHJvcHMpIHtcbiAgdmFyIG9wID0gQUxHU19ERUNbYWxnXTtcbiAgaWYgKCFvcCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG06IFwiICsgYWxnKSk7XG4gIH1cblxuICByZXR1cm4gb3Aoa2V5LCBjZGF0YSwgcHJvcHMgfHwge30pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/pbes2.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/pbes2.js - Password-Based Encryption (v2) Algorithms\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    merge = __webpack_require__(/*! ../util/merge.js */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    KW = __webpack_require__(/*! ./aes-kw.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/aes-kw.js\");\n\nvar NULL_BUFFER = Buffer.from([0]);\nvar DEFAULT_ITERATIONS = 8192;\nvar DEFAULT_SALT_LENGTH = 16;\n\nfunction fixSalt(hmac, kw, salt) {\n  var alg = \"PBES2-\" + hmac + \"+\" + kw;\n  var output = [\n    Buffer.from(alg, \"utf8\"),\n    NULL_BUFFER,\n    salt\n  ];\n  return Buffer.concat(output);\n}\n\nfunction pbkdf2Fn(hash) {\n  function prepareProps(props) {\n    props = props || {};\n    var keyLen = props.length || 0;\n    var salt = util.asBuffer(props.salt || Buffer.alloc(0), \"base64u4l\"),\n        itrs = props.iterations || 0;\n\n    if (0 >= keyLen) {\n      throw new Error(\"invalid key length\");\n    }\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n\n    props.length = keyLen;\n    props.salt = salt;\n    props.iterations = itrs;\n\n    return props;\n  }\n\n  var fallback = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = new Promise(function(resolve, reject) {\n      var md = forge.md[hash.replace(\"-\", \"\").toLowerCase()].create();\n      var cb = function(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          dk = Buffer.from(dk, \"binary\");\n          resolve(dk);\n        }\n      };\n\n      forge.pkcs5.pbkdf2(key.toString(\"binary\"),\n                         salt.toString(\"binary\"),\n                         itrs,\n                         keyLen,\n                         md,\n                         cb);\n    });\n    return promise;\n  };\n  var webcrypto = function(key, props) {\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n    var promise = Promise.resolve(key);\n    promise = promise.then(function(keyval) {\n      return helpers.subtleCrypto.importKey(\"raw\", keyval, \"PBKDF2\", false, [\"deriveBits\"]);\n    });\n    promise = promise.then(function(key) {\n      var mainAlgo = {\n        name: \"PBKDF2\",\n        salt: new Uint8Array(salt),\n        iterations: itrs,\n        hash: hash\n      };\n\n      return helpers.subtleCrypto.deriveBits(mainAlgo, key, keyLen * 8);\n    });\n    promise = promise.then(function(result) {\n      return util.asBuffer(result);\n    });\n    return promise;\n  };\n  var nodejs = function(key, props) {\n    if (6 > helpers.nodeCrypto.pbkdf2.length) {\n      throw new Error(\"unsupported algorithm: PBKDF2-\" + hash);\n    }\n\n    try {\n      props = prepareProps(props);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    var keyLen = props.length,\n        salt = props.salt,\n        itrs = props.iterations;\n\n        var md = hash.replace(\"-\", \"\");\n    var promise = new Promise(function(resolve, reject) {\n      function cb(err, dk) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(dk);\n        }\n      }\n      helpers.nodeCrypto.pbkdf2(key, salt, itrs, keyLen, md, cb);\n    });\n    return promise;\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction pbes2EncryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, pdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n      itrs = props.p2c || DEFAULT_ITERATIONS;\n\n    if (0 >= itrs) {\n      throw new Error(\"invalid iteration count\");\n    }\n    if (0 === salt.length) {\n      salt = util.randomBytes(DEFAULT_SALT_LENGTH);\n    } else if (8 > salt.length) {\n      throw new Error(\"salt too small\");\n    }\n    var header = {\n      p2s: util.base64url.encode(salt),\n      p2c: itrs\n    };\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n    // STEP 1: derive shared key\n    promise = promise.then(function (key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: encrypt cek\n    promise = promise.then(function (dk) {\n      return KW[kw].encrypt(dk, pdata);\n    });\n    // STEP 3: (re-)apply headers\n    promise = promise.then(function (results) {\n      results.header = merge(results.header || {}, header);\n      return results;\n    });\n\n    return promise;\n  };\n}\n\nfunction pbes2DecryptFN(hmac, kw) {\n  var deriveAlg = \"PBKDF2-\" + hmac.replace(\"HS\", \"SHA-\");\n  var keyLen = CONSTANTS.KEYLENGTH[kw] / 8;\n\n  return function(key, cdata, props) {\n    props = props || {};\n\n    var salt = util.asBuffer(props.p2s || Buffer.alloc(0), \"base64url\"),\n        itrs = props.p2c || 0;\n\n    if (0 >= itrs) {\n      return Promise.reject(new Error(\"invalid iteration count\"));\n    }\n\n    if (8 > salt.length) {\n      return Promise.reject(new Error(\"salt too small\"));\n    }\n    salt = fixSalt(hmac, kw, salt);\n    props = merge(props, {\n      salt: salt,\n      iterations: itrs,\n      length: keyLen\n    });\n\n    var promise = Promise.resolve(key);\n\n    // STEP 1: derived shared key\n    promise = promise.then(function(key) {\n      return pbes2[deriveAlg].derive(key, props);\n    });\n    // STEP 2: decrypt cek\n    promise = promise.then(function(dk) {\n      return KW[kw].decrypt(dk, cdata);\n    });\n\n    return promise;\n  };\n}\n\n// ### Public API\nvar pbes2 = {};\n\n// * [name].derive\n[\n  \"PBKDF2-SHA-256\",\n  \"PBKDF2-SHA-384\",\n  \"PBKDF2-SHA-512\"\n].forEach(function(alg) {\n  var hash = alg.replace(\"PBKDF2-\", \"\");\n  pbes2[alg] = {\n    derive: pbkdf2Fn(hash)\n  };\n});\n\n// [name].encrypt\n// [name].decrypt\n[\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\"\n].forEach(function(alg) {\n  var parts = /PBES2-(HS\\d+)\\+(A\\d+KW)/g.exec(alg);\n  var hmac = parts[1],\n      kw = parts[2];\n  pbes2[alg] = {\n    encrypt: pbes2EncryptFN(hmac, kw),\n    decrypt: pbes2DecryptFN(hmac, kw)\n  };\n});\n\nmodule.exports = pbes2;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3BiZXMyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBZ0I7QUFDeEMsU0FBUyxtQkFBTyxDQUFDLDRFQUFhOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvYWxnb3JpdGhtcy9wYmVzMi5qcz9iODU0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9wYmVzMi5qcyAtIFBhc3N3b3JkLUJhc2VkIEVuY3J5cHRpb24gKHYyKSBBbGdvcml0aG1zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlLmpzXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIiksXG4gICAgS1cgPSByZXF1aXJlKFwiLi9hZXMta3cuanNcIik7XG5cbnZhciBOVUxMX0JVRkZFUiA9IEJ1ZmZlci5mcm9tKFswXSk7XG52YXIgREVGQVVMVF9JVEVSQVRJT05TID0gODE5MjtcbnZhciBERUZBVUxUX1NBTFRfTEVOR1RIID0gMTY7XG5cbmZ1bmN0aW9uIGZpeFNhbHQoaG1hYywga3csIHNhbHQpIHtcbiAgdmFyIGFsZyA9IFwiUEJFUzItXCIgKyBobWFjICsgXCIrXCIgKyBrdztcbiAgdmFyIG91dHB1dCA9IFtcbiAgICBCdWZmZXIuZnJvbShhbGcsIFwidXRmOFwiKSxcbiAgICBOVUxMX0JVRkZFUixcbiAgICBzYWx0XG4gIF07XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KG91dHB1dCk7XG59XG5cbmZ1bmN0aW9uIHBia2RmMkZuKGhhc2gpIHtcbiAgZnVuY3Rpb24gcHJlcGFyZVByb3BzKHByb3BzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICB2YXIga2V5TGVuID0gcHJvcHMubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHNhbHQgPSB1dGlsLmFzQnVmZmVyKHByb3BzLnNhbHQgfHwgQnVmZmVyLmFsbG9jKDApLCBcImJhc2U2NHU0bFwiKSxcbiAgICAgICAgaXRycyA9IHByb3BzLml0ZXJhdGlvbnMgfHwgMDtcblxuICAgIGlmICgwID49IGtleUxlbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXkgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBpZiAoMCA+PSBpdHJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl0ZXJhdGlvbiBjb3VudFwiKTtcbiAgICB9XG5cbiAgICBwcm9wcy5sZW5ndGggPSBrZXlMZW47XG4gICAgcHJvcHMuc2FsdCA9IHNhbHQ7XG4gICAgcHJvcHMuaXRlcmF0aW9ucyA9IGl0cnM7XG5cbiAgICByZXR1cm4gcHJvcHM7XG4gIH1cblxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHByb3BzID0gcHJlcGFyZVByb3BzKHByb3BzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIHNhbHQgPSBwcm9wcy5zYWx0LFxuICAgICAgICBpdHJzID0gcHJvcHMuaXRlcmF0aW9ucztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbWQgPSBmb3JnZS5tZFtoYXNoLnJlcGxhY2UoXCItXCIsIFwiXCIpLnRvTG93ZXJDYXNlKCldLmNyZWF0ZSgpO1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24oZXJyLCBkaykge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGsgPSBCdWZmZXIuZnJvbShkaywgXCJiaW5hcnlcIik7XG4gICAgICAgICAgcmVzb2x2ZShkayk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvcmdlLnBrY3M1LnBia2RmMihrZXkudG9TdHJpbmcoXCJiaW5hcnlcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgc2FsdC50b1N0cmluZyhcImJpbmFyeVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBpdHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGtleUxlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICBtZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBjYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihrZXksIHByb3BzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHByb3BzID0gcHJlcGFyZVByb3BzKHByb3BzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIHNhbHQgPSBwcm9wcy5zYWx0LFxuICAgICAgICBpdHJzID0gcHJvcHMuaXRlcmF0aW9ucztcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXl2YWwpIHtcbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJyYXdcIiwga2V5dmFsLCBcIlBCS0RGMlwiLCBmYWxzZSwgW1wiZGVyaXZlQml0c1wiXSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBtYWluQWxnbyA9IHtcbiAgICAgICAgbmFtZTogXCJQQktERjJcIixcbiAgICAgICAgc2FsdDogbmV3IFVpbnQ4QXJyYXkoc2FsdCksXG4gICAgICAgIGl0ZXJhdGlvbnM6IGl0cnMsXG4gICAgICAgIGhhc2g6IGhhc2hcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBoZWxwZXJzLnN1YnRsZUNyeXB0by5kZXJpdmVCaXRzKG1haW5BbGdvLCBrZXksIGtleUxlbiAqIDgpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICByZXR1cm4gdXRpbC5hc0J1ZmZlcihyZXN1bHQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICB2YXIgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwcm9wcykge1xuICAgIGlmICg2ID4gaGVscGVycy5ub2RlQ3J5cHRvLnBia2RmMi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobTogUEJLREYyLVwiICsgaGFzaCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHByb3BzID0gcHJlcGFyZVByb3BzKHByb3BzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHZhciBrZXlMZW4gPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgIHNhbHQgPSBwcm9wcy5zYWx0LFxuICAgICAgICBpdHJzID0gcHJvcHMuaXRlcmF0aW9ucztcblxuICAgICAgICB2YXIgbWQgPSBoYXNoLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBmdW5jdGlvbiBjYihlcnIsIGRrKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKGRrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGVscGVycy5ub2RlQ3J5cHRvLnBia2RmMihrZXksIHNhbHQsIGl0cnMsIGtleUxlbiwgbWQsIGNiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHBiZXMyRW5jcnlwdEZOKGhtYWMsIGt3KSB7XG4gIHZhciBkZXJpdmVBbGcgPSBcIlBCS0RGMi1cIiArIGhtYWMucmVwbGFjZShcIkhTXCIsIFwiU0hBLVwiKTtcbiAgdmFyIGtleUxlbiA9IENPTlNUQU5UUy5LRVlMRU5HVEhba3ddIC8gODtcblxuICByZXR1cm4gZnVuY3Rpb24oa2V5LCBwZGF0YSwgcHJvcHMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuXG4gICAgdmFyIHNhbHQgPSB1dGlsLmFzQnVmZmVyKHByb3BzLnAycyB8fCBCdWZmZXIuYWxsb2MoMCksIFwiYmFzZTY0dXJsXCIpLFxuICAgICAgaXRycyA9IHByb3BzLnAyYyB8fCBERUZBVUxUX0lURVJBVElPTlM7XG5cbiAgICBpZiAoMCA+PSBpdHJzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGl0ZXJhdGlvbiBjb3VudFwiKTtcbiAgICB9XG4gICAgaWYgKDAgPT09IHNhbHQubGVuZ3RoKSB7XG4gICAgICBzYWx0ID0gdXRpbC5yYW5kb21CeXRlcyhERUZBVUxUX1NBTFRfTEVOR1RIKTtcbiAgICB9IGVsc2UgaWYgKDggPiBzYWx0Lmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2FsdCB0b28gc21hbGxcIik7XG4gICAgfVxuICAgIHZhciBoZWFkZXIgPSB7XG4gICAgICBwMnM6IHV0aWwuYmFzZTY0dXJsLmVuY29kZShzYWx0KSxcbiAgICAgIHAyYzogaXRyc1xuICAgIH07XG4gICAgc2FsdCA9IGZpeFNhbHQoaG1hYywga3csIHNhbHQpO1xuICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIHtcbiAgICAgIHNhbHQ6IHNhbHQsXG4gICAgICBpdGVyYXRpb25zOiBpdHJzLFxuICAgICAgbGVuZ3RoOiBrZXlMZW5cbiAgICB9KTtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgLy8gU1RFUCAxOiBkZXJpdmUgc2hhcmVkIGtleVxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHBiZXMyW2Rlcml2ZUFsZ10uZGVyaXZlKGtleSwgcHJvcHMpO1xuICAgIH0pO1xuICAgIC8vIFNURVAgMjogZW5jcnlwdCBjZWtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChkaykge1xuICAgICAgcmV0dXJuIEtXW2t3XS5lbmNyeXB0KGRrLCBwZGF0YSk7XG4gICAgfSk7XG4gICAgLy8gU1RFUCAzOiAocmUtKWFwcGx5IGhlYWRlcnNcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICByZXN1bHRzLmhlYWRlciA9IG1lcmdlKHJlc3VsdHMuaGVhZGVyIHx8IHt9LCBoZWFkZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGJlczJEZWNyeXB0Rk4oaG1hYywga3cpIHtcbiAgdmFyIGRlcml2ZUFsZyA9IFwiUEJLREYyLVwiICsgaG1hYy5yZXBsYWNlKFwiSFNcIiwgXCJTSEEtXCIpO1xuICB2YXIga2V5TGVuID0gQ09OU1RBTlRTLktFWUxFTkdUSFtrd10gLyA4O1xuXG4gIHJldHVybiBmdW5jdGlvbihrZXksIGNkYXRhLCBwcm9wcykge1xuICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICB2YXIgc2FsdCA9IHV0aWwuYXNCdWZmZXIocHJvcHMucDJzIHx8IEJ1ZmZlci5hbGxvYygwKSwgXCJiYXNlNjR1cmxcIiksXG4gICAgICAgIGl0cnMgPSBwcm9wcy5wMmMgfHwgMDtcblxuICAgIGlmICgwID49IGl0cnMpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIGl0ZXJhdGlvbiBjb3VudFwiKSk7XG4gICAgfVxuXG4gICAgaWYgKDggPiBzYWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNhbHQgdG9vIHNtYWxsXCIpKTtcbiAgICB9XG4gICAgc2FsdCA9IGZpeFNhbHQoaG1hYywga3csIHNhbHQpO1xuICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIHtcbiAgICAgIHNhbHQ6IHNhbHQsXG4gICAgICBpdGVyYXRpb25zOiBpdHJzLFxuICAgICAgbGVuZ3RoOiBrZXlMZW5cbiAgICB9KTtcblxuICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG5cbiAgICAvLyBTVEVQIDE6IGRlcml2ZWQgc2hhcmVkIGtleVxuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gcGJlczJbZGVyaXZlQWxnXS5kZXJpdmUoa2V5LCBwcm9wcyk7XG4gICAgfSk7XG4gICAgLy8gU1RFUCAyOiBkZWNyeXB0IGNla1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZGspIHtcbiAgICAgIHJldHVybiBLV1trd10uZGVjcnlwdChkaywgY2RhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG52YXIgcGJlczIgPSB7fTtcblxuLy8gKiBbbmFtZV0uZGVyaXZlXG5bXG4gIFwiUEJLREYyLVNIQS0yNTZcIixcbiAgXCJQQktERjItU0hBLTM4NFwiLFxuICBcIlBCS0RGMi1TSEEtNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihhbGcpIHtcbiAgdmFyIGhhc2ggPSBhbGcucmVwbGFjZShcIlBCS0RGMi1cIiwgXCJcIik7XG4gIHBiZXMyW2FsZ10gPSB7XG4gICAgZGVyaXZlOiBwYmtkZjJGbihoYXNoKVxuICB9O1xufSk7XG5cbi8vIFtuYW1lXS5lbmNyeXB0XG4vLyBbbmFtZV0uZGVjcnlwdFxuW1xuICBcIlBCRVMyLUhTMjU2K0ExMjhLV1wiLFxuICBcIlBCRVMyLUhTMzg0K0ExOTJLV1wiLFxuICBcIlBCRVMyLUhTNTEyK0EyNTZLV1wiXG5dLmZvckVhY2goZnVuY3Rpb24oYWxnKSB7XG4gIHZhciBwYXJ0cyA9IC9QQkVTMi0oSFNcXGQrKVxcKyhBXFxkK0tXKS9nLmV4ZWMoYWxnKTtcbiAgdmFyIGhtYWMgPSBwYXJ0c1sxXSxcbiAgICAgIGt3ID0gcGFydHNbMl07XG4gIHBiZXMyW2FsZ10gPSB7XG4gICAgZW5jcnlwdDogcGJlczJFbmNyeXB0Rk4oaG1hYywga3cpLFxuICAgIGRlY3J5cHQ6IHBiZXMyRGVjcnlwdEZOKGhtYWMsIGt3KVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcGJlczI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/pbes2.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js":
/*!***********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsa-util.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsa-util.js - RSA Utility Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n// ### RSA-specific Helpers\nfunction convertToForge(key, isPublic) {\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts = parts.map(function(f) {\n    return new forge.jsbn.BigInteger(key[f].toString(\"hex\"), 16);\n  });\n\n  var fn = isPublic ?\n           forge.pki.rsa.setPublicKey :\n           forge.pki.rsa.setPrivateKey;\n  return fn.apply(forge.pki.rsa, parts);\n}\n\nfunction convertToJWK(key, isPublic) {\n  var result = clone(key);\n  var parts = isPublic ?\n              [\"n\", \"e\"] :\n              [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"];\n  parts.forEach(function(f) {\n    result[f] = util.base64url.encode(result[f]);\n  });\n\n  // remove potentially troublesome properties\n  delete result.key_ops;\n  delete result.use;\n  delete result.alg;\n\n  if (isPublic) {\n    delete result.d;\n    delete result.p;\n    delete result.q;\n    delete result.dp;\n    delete result.dq;\n    delete result.qi;\n  }\n\n  return result;\n}\n\nfunction convertToPem(key, isPublic) {\n  var cacheKey = isPublic ? \"__cachedPublicPem\" : \"__cachedPrivatePem\";\n  if (key[cacheKey]) {\n    return key[cacheKey];\n  }\n\n  var value;\n  if (isPublic) {\n    value = forge.pki.publicKeyToPem(convertToForge(key, isPublic));\n  } else {\n    value = forge.pki.privateKeyToPem(convertToForge(key, isPublic));\n  }\n\n  Object.defineProperty(key, cacheKey, { value: value });\n  return value;\n}\n\nmodule.exports = {\n  convertToForge: convertToForge,\n  convertToJWK: convertToJWK,\n  convertToPem: convertToPem\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYS11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYS11dGlsLmpzPzNmODEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL3JzYS11dGlsLmpzIC0gUlNBIFV0aWxpdHkgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG4vLyAjIyMgUlNBLXNwZWNpZmljIEhlbHBlcnNcbmZ1bmN0aW9uIGNvbnZlcnRUb0ZvcmdlKGtleSwgaXNQdWJsaWMpIHtcbiAgdmFyIHBhcnRzID0gaXNQdWJsaWMgP1xuICAgICAgICAgICAgICBbXCJuXCIsIFwiZVwiXSA6XG4gICAgICAgICAgICAgIFtcIm5cIiwgXCJlXCIsIFwiZFwiLCBcInBcIiwgXCJxXCIsIFwiZHBcIiwgXCJkcVwiLCBcInFpXCJdO1xuICBwYXJ0cyA9IHBhcnRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIG5ldyBmb3JnZS5qc2JuLkJpZ0ludGVnZXIoa2V5W2ZdLnRvU3RyaW5nKFwiaGV4XCIpLCAxNik7XG4gIH0pO1xuXG4gIHZhciBmbiA9IGlzUHVibGljID9cbiAgICAgICAgICAgZm9yZ2UucGtpLnJzYS5zZXRQdWJsaWNLZXkgOlxuICAgICAgICAgICBmb3JnZS5wa2kucnNhLnNldFByaXZhdGVLZXk7XG4gIHJldHVybiBmbi5hcHBseShmb3JnZS5wa2kucnNhLCBwYXJ0cyk7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0pXSyhrZXksIGlzUHVibGljKSB7XG4gIHZhciByZXN1bHQgPSBjbG9uZShrZXkpO1xuICB2YXIgcGFydHMgPSBpc1B1YmxpYyA/XG4gICAgICAgICAgICAgIFtcIm5cIiwgXCJlXCJdIDpcbiAgICAgICAgICAgICAgW1wiblwiLCBcImVcIiwgXCJkXCIsIFwicFwiLCBcInFcIiwgXCJkcFwiLCBcImRxXCIsIFwicWlcIl07XG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24oZikge1xuICAgIHJlc3VsdFtmXSA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHRbZl0pO1xuICB9KTtcblxuICAvLyByZW1vdmUgcG90ZW50aWFsbHkgdHJvdWJsZXNvbWUgcHJvcGVydGllc1xuICBkZWxldGUgcmVzdWx0LmtleV9vcHM7XG4gIGRlbGV0ZSByZXN1bHQudXNlO1xuICBkZWxldGUgcmVzdWx0LmFsZztcblxuICBpZiAoaXNQdWJsaWMpIHtcbiAgICBkZWxldGUgcmVzdWx0LmQ7XG4gICAgZGVsZXRlIHJlc3VsdC5wO1xuICAgIGRlbGV0ZSByZXN1bHQucTtcbiAgICBkZWxldGUgcmVzdWx0LmRwO1xuICAgIGRlbGV0ZSByZXN1bHQuZHE7XG4gICAgZGVsZXRlIHJlc3VsdC5xaTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb1BlbShrZXksIGlzUHVibGljKSB7XG4gIHZhciBjYWNoZUtleSA9IGlzUHVibGljID8gXCJfX2NhY2hlZFB1YmxpY1BlbVwiIDogXCJfX2NhY2hlZFByaXZhdGVQZW1cIjtcbiAgaWYgKGtleVtjYWNoZUtleV0pIHtcbiAgICByZXR1cm4ga2V5W2NhY2hlS2V5XTtcbiAgfVxuXG4gIHZhciB2YWx1ZTtcbiAgaWYgKGlzUHVibGljKSB7XG4gICAgdmFsdWUgPSBmb3JnZS5wa2kucHVibGljS2V5VG9QZW0oY29udmVydFRvRm9yZ2Uoa2V5LCBpc1B1YmxpYykpO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZm9yZ2UucGtpLnByaXZhdGVLZXlUb1BlbShjb252ZXJ0VG9Gb3JnZShrZXksIGlzUHVibGljKSk7XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoa2V5LCBjYWNoZUtleSwgeyB2YWx1ZTogdmFsdWUgfSk7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNvbnZlcnRUb0ZvcmdlOiBjb252ZXJ0VG9Gb3JnZSxcbiAgY29udmVydFRvSldLOiBjb252ZXJ0VG9KV0ssXG4gIGNvbnZlcnRUb1BlbTogY29udmVydFRvUGVtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js":
/*!********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsaes.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsaes.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    DataBuffer = __webpack_require__(/*! ../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nvar nodeSupport = {\n  \"RSA-OAEP\": \"RSA_PKCS1_OAEP_PADDING\",\n  RSA1_5: \"RSA_PKCS1_PADDING\"\n};\n\nfunction nodeSupportCheck(name) {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && Object.keys(nodeSupport).indexOf(name) !== -1;\n}\n\n// ### RSAES-PKCS1-v1_5\n\n// ### RSAES-OAEP\nfunction rsaesEncryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // convert pdata to byte string\n    pdata = new DataBuffer(pdata).bytes();\n\n    // encrypt it\n    var pki = rsaUtil.convertToForge(key, true),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var cdata = pki.encrypt(pdata, alg.name.toUpperCase(), params);\n\n    // convert cdata to Buffer\n    cdata = new DataBuffer(cdata).native();\n\n    return Promise.resolve({\n      data: cdata\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, true);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"encrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.encrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var cdata = Buffer.from(result);\n        return {\n          data: cdata\n        };\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) {\n    nodejs = function (key, pdata) {\n      key = rsaUtil.convertToPem(key, true);\n\n      var cdata = helpers.nodeCrypto.publicEncrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n\n      return {\n        data: cdata\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsaesDecryptFn(name) {\n  var alg = {\n    name: name\n  };\n\n  if (\"RSA-OAEP-256\" === name) {\n    alg.name = \"RSA-OAEP\";\n    alg.hash = {\n      name: \"SHA-256\"\n    };\n  } else if (\"RSA-OAEP\" === name) {\n    alg.hash = {\n      name: \"SHA-1\"\n    };\n  } else {\n    alg.name = \"RSAES-PKCS1-v1_5\";\n  }\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, cdata) {\n    // convert cdata to byte string\n    cdata = new DataBuffer(cdata).bytes();\n\n    // decrypt it\n    var pki = rsaUtil.convertToForge(key, false),\n        params = {};\n    if (\"RSA-OAEP\" === alg.name) {\n      params.md = alg.hash.name.toLowerCase().replace(/-/g, \"\");\n      params.md = forge.md[params.md].create();\n    }\n    var pdata = pki.decrypt(cdata, alg.name.toUpperCase(), params);\n\n    // convert pdata to Buffer\n    pdata = new DataBuffer(pdata).native();\n\n    return Promise.resolve(pdata);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto;\n  if (\"RSAES-PKCS1-v1_5\" !== alg.name) {\n    webcrypto = function(key, pdata) {\n      key = rsaUtil.convertToJWK(key, false);\n      var promise;\n      promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"decrypt\"]);\n      promise = promise.then(function(key) {\n        return helpers.subtleCrypto.decrypt(alg, key, pdata);\n      });\n      promise = promise.then(function(result) {\n        var pdata = Buffer.from(result);\n        return pdata;\n      });\n\n      return promise;\n    };\n  } else {\n    webcrypto = null;\n  }\n\n  var nodejs;\n  if (nodeSupportCheck(name)) { // node ^6.12.0 || >= 8.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt({\n        key: key,\n        padding: helpers.nodeCrypto.constants[nodeSupport[name]]\n      }, pdata);\n    };\n  } else if (helpers.nodeCrypto && name === \"RSA-OAEP\") { // node (>= 6.0.0 && < 6.12.0) || ^7.0.0\n    nodejs = function(key, pdata) {\n      key = rsaUtil.convertToPem(key, false);\n      return helpers.nodeCrypto.privateDecrypt(key, pdata);\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].encrypt\n// * [name].decrypt\nvar rsaes = {};\n[\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n].forEach(function(name) {\n  rsaes[name] = {\n    encrypt: rsaesEncryptFn(name),\n    decrypt: rsaesDecryptFn(name)\n  };\n});\n\nmodule.exports = rsaes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyw4RUFBYztBQUNwQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBdUI7QUFDaEQsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUksc0RBQXNEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYWVzLmpzPzllYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBhbGdvcml0aG1zL3JzYWVzLmpzIC0gUlNBIFNpZ25hdHVyZXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIERhdGFCdWZmZXIgPSByZXF1aXJlKFwiLi4vdXRpbC9kYXRhYnVmZmVyLmpzXCIpLFxuICAgIHJzYVV0aWwgPSByZXF1aXJlKFwiLi9yc2EtdXRpbC5qc1wiKTtcblxudmFyIG5vZGVTdXBwb3J0ID0ge1xuICBcIlJTQS1PQUVQXCI6IFwiUlNBX1BLQ1MxX09BRVBfUEFERElOR1wiLFxuICBSU0ExXzU6IFwiUlNBX1BLQ1MxX1BBRERJTkdcIlxufTtcblxuZnVuY3Rpb24gbm9kZVN1cHBvcnRDaGVjayhuYW1lKSB7XG4gIHJldHVybiBoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cyAmJiBPYmplY3Qua2V5cyhub2RlU3VwcG9ydCkuaW5kZXhPZihuYW1lKSAhPT0gLTE7XG59XG5cbi8vICMjIyBSU0FFUy1QS0NTMS12MV81XG5cbi8vICMjIyBSU0FFUy1PQUVQXG5mdW5jdGlvbiByc2Flc0VuY3J5cHRGbihuYW1lKSB7XG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogbmFtZVxuICB9O1xuXG4gIGlmIChcIlJTQS1PQUVQLTI1NlwiID09PSBuYW1lKSB7XG4gICAgYWxnLm5hbWUgPSBcIlJTQS1PQUVQXCI7XG4gICAgYWxnLmhhc2ggPSB7XG4gICAgICBuYW1lOiBcIlNIQS0yNTZcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoXCJSU0EtT0FFUFwiID09PSBuYW1lKSB7XG4gICAgYWxnLmhhc2ggPSB7XG4gICAgICBuYW1lOiBcIlNIQS0xXCJcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGFsZy5uYW1lID0gXCJSU0FFUy1QS0NTMS12MV81XCI7XG4gIH1cblxuICAvLyAjIyMgRmFsbGJhY2sgSW1wbGVtZW50YXRpb24gLS0gdXNlcyBmb3JnZVxuICB2YXIgZmFsbGJhY2sgPSBmdW5jdGlvbihrZXksIHBkYXRhKSB7XG4gICAgLy8gY29udmVydCBwZGF0YSB0byBieXRlIHN0cmluZ1xuICAgIHBkYXRhID0gbmV3IERhdGFCdWZmZXIocGRhdGEpLmJ5dGVzKCk7XG5cbiAgICAvLyBlbmNyeXB0IGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCB0cnVlKSxcbiAgICAgICAgcGFyYW1zID0ge307XG4gICAgaWYgKFwiUlNBLU9BRVBcIiA9PT0gYWxnLm5hbWUpIHtcbiAgICAgIHBhcmFtcy5tZCA9IGFsZy5oYXNoLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICAgICAgcGFyYW1zLm1kID0gZm9yZ2UubWRbcGFyYW1zLm1kXS5jcmVhdGUoKTtcbiAgICB9XG4gICAgdmFyIGNkYXRhID0gcGtpLmVuY3J5cHQocGRhdGEsIGFsZy5uYW1lLnRvVXBwZXJDYXNlKCksIHBhcmFtcyk7XG5cbiAgICAvLyBjb252ZXJ0IGNkYXRhIHRvIEJ1ZmZlclxuICAgIGNkYXRhID0gbmV3IERhdGFCdWZmZXIoY2RhdGEpLm5hdGl2ZSgpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBjZGF0YVxuICAgIH0pO1xuICB9O1xuXG4gIC8vICMjIyBXZWJDcnlwdG9BUEkgSW1wbGVtZW50YXRpb25cbiAgdmFyIHdlYmNyeXB0bztcbiAgaWYgKFwiUlNBRVMtUEtDUzEtdjFfNVwiICE9PSBhbGcubmFtZSkge1xuICAgIHdlYmNyeXB0byA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgdHJ1ZSk7XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcImVuY3J5cHRcIl0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmVuY3J5cHQoYWxnLCBrZXksIHBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdmFyIGNkYXRhID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkYXRhOiBjZGF0YVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgd2ViY3J5cHRvID0gbnVsbDtcbiAgfVxuXG4gIHZhciBub2RlanM7XG4gIGlmIChub2RlU3VwcG9ydENoZWNrKG5hbWUpKSB7XG4gICAgbm9kZWpzID0gZnVuY3Rpb24gKGtleSwgcGRhdGEpIHtcbiAgICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgdHJ1ZSk7XG5cbiAgICAgIHZhciBjZGF0YSA9IGhlbHBlcnMubm9kZUNyeXB0by5wdWJsaWNFbmNyeXB0KHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHBhZGRpbmc6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHNbbm9kZVN1cHBvcnRbbmFtZV1dXG4gICAgICB9LCBwZGF0YSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IGNkYXRhXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJzYWVzRGVjcnlwdEZuKG5hbWUpIHtcbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBuYW1lXG4gIH07XG5cbiAgaWYgKFwiUlNBLU9BRVAtMjU2XCIgPT09IG5hbWUpIHtcbiAgICBhbGcubmFtZSA9IFwiUlNBLU9BRVBcIjtcbiAgICBhbGcuaGFzaCA9IHtcbiAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgfTtcbiAgfSBlbHNlIGlmIChcIlJTQS1PQUVQXCIgPT09IG5hbWUpIHtcbiAgICBhbGcuaGFzaCA9IHtcbiAgICAgIG5hbWU6IFwiU0hBLTFcIlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYWxnLm5hbWUgPSBcIlJTQUVTLVBLQ1MxLXYxXzVcIjtcbiAgfVxuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgY2RhdGEpIHtcbiAgICAvLyBjb252ZXJ0IGNkYXRhIHRvIGJ5dGUgc3RyaW5nXG4gICAgY2RhdGEgPSBuZXcgRGF0YUJ1ZmZlcihjZGF0YSkuYnl0ZXMoKTtcblxuICAgIC8vIGRlY3J5cHQgaXRcbiAgICB2YXIgcGtpID0gcnNhVXRpbC5jb252ZXJ0VG9Gb3JnZShrZXksIGZhbHNlKSxcbiAgICAgICAgcGFyYW1zID0ge307XG4gICAgaWYgKFwiUlNBLU9BRVBcIiA9PT0gYWxnLm5hbWUpIHtcbiAgICAgIHBhcmFtcy5tZCA9IGFsZy5oYXNoLm5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tL2csIFwiXCIpO1xuICAgICAgcGFyYW1zLm1kID0gZm9yZ2UubWRbcGFyYW1zLm1kXS5jcmVhdGUoKTtcbiAgICB9XG4gICAgdmFyIHBkYXRhID0gcGtpLmRlY3J5cHQoY2RhdGEsIGFsZy5uYW1lLnRvVXBwZXJDYXNlKCksIHBhcmFtcyk7XG5cbiAgICAvLyBjb252ZXJ0IHBkYXRhIHRvIEJ1ZmZlclxuICAgIHBkYXRhID0gbmV3IERhdGFCdWZmZXIocGRhdGEpLm5hdGl2ZSgpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwZGF0YSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvO1xuICBpZiAoXCJSU0FFUy1QS0NTMS12MV81XCIgIT09IGFsZy5uYW1lKSB7XG4gICAgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCBmYWxzZSk7XG4gICAgICB2YXIgcHJvbWlzZTtcbiAgICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcImRlY3J5cHRcIl0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLmRlY3J5cHQoYWxnLCBrZXksIHBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgdmFyIHBkYXRhID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHBkYXRhO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgd2ViY3J5cHRvID0gbnVsbDtcbiAgfVxuXG4gIHZhciBub2RlanM7XG4gIGlmIChub2RlU3VwcG9ydENoZWNrKG5hbWUpKSB7IC8vIG5vZGUgXjYuMTIuMCB8fCA+PSA4LjAuMFxuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvUGVtKGtleSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIGhlbHBlcnMubm9kZUNyeXB0by5wcml2YXRlRGVjcnlwdCh7XG4gICAgICAgIGtleToga2V5LFxuICAgICAgICBwYWRkaW5nOiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzW25vZGVTdXBwb3J0W25hbWVdXVxuICAgICAgfSwgcGRhdGEpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoaGVscGVycy5ub2RlQ3J5cHRvICYmIG5hbWUgPT09IFwiUlNBLU9BRVBcIikgeyAvLyBub2RlICg+PSA2LjAuMCAmJiA8IDYuMTIuMCkgfHwgXjcuMC4wXG4gICAgbm9kZWpzID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCBmYWxzZSk7XG4gICAgICByZXR1cm4gaGVscGVycy5ub2RlQ3J5cHRvLnByaXZhdGVEZWNyeXB0KGtleSwgcGRhdGEpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBQdWJsaWMgQVBJXG4vLyAqIFtuYW1lXS5lbmNyeXB0XG4vLyAqIFtuYW1lXS5kZWNyeXB0XG52YXIgcnNhZXMgPSB7fTtcbltcbiAgXCJSU0EtT0FFUFwiLFxuICBcIlJTQS1PQUVQLTI1NlwiLFxuICBcIlJTQTFfNVwiXG5dLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICByc2Flc1tuYW1lXSA9IHtcbiAgICBlbmNyeXB0OiByc2Flc0VuY3J5cHRGbihuYW1lKSxcbiAgICBkZWNyeXB0OiByc2Flc0RlY3J5cHRGbihuYW1lKVxuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gcnNhZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsaes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js":
/*!*********************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/rsassa.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/rsassa.js - RSA Signatures\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\"),\n    rsaUtil = __webpack_require__(/*! ./rsa-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\");\n\nfunction nodePSSsupport() {\n  return helpers.nodeCrypto && helpers.nodeCrypto.constants && helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST;\n}\n\n// ### RSASSA-PKCS1-v1_5\n\nfunction rsassaV15SignFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, \"RSASSA-PKCS1-V1_5\");\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function(result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(nodeHash) > -1) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      return {\n        data: pdata,\n        mac: sign.sign(rsaUtil.convertToPem(key, false))\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaV15VerifyFn(name) {\n  var md = name.replace(\"RS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"RS\", \"SHA-\");\n  var alg = {\n    name: \"RSASSA-PKCS1-V1_5\",\n    hash: {\n      name: hash\n    }\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function(key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, \"RSASSA-PKCS1-V1_5\");\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function(key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function(result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (helpers.nodeCrypto && helpers.nodeCrypto.getHashes().indexOf(md) > -1) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify(rsaUtil.convertToPem(key, true), mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### RSA-PSS\nfunction rsassaPssSignFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // sign it\n    var pki = rsaUtil.convertToForge(key, false);\n    var sig = pki.sign(digest, pss);\n    sig = Buffer.from(sig, \"binary\");\n\n    return Promise.resolve({\n      data: pdata,\n      mac: sig\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata) {\n    key = rsaUtil.convertToJWK(key, false);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"sign\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.sign(alg, key, pdata);\n    });\n    promise = promise.then(function (result) {\n      var sig = Buffer.from(result);\n      return {\n        data: pdata,\n        mac: sig\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  var nodeHash = \"RSA-\" + hash.replace(\"-\", \"\");\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata) {\n      var sign = helpers.nodeCrypto.createSign(nodeHash);\n      sign.update(pdata);\n\n      var sig = sign.sign({\n        key: rsaUtil.convertToPem(key, false),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      });\n\n      return {\n        data: pdata,\n        mac: sig\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\nfunction rsassaPssVerifyFn(name) {\n  var md = name.replace(\"PS\", \"SHA\").toLowerCase(),\n      hash = name.replace(\"PS\", \"SHA-\");\n\n  var alg = {\n    name: \"RSA-PSS\",\n    hash: {\n      name: hash\n    },\n    saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n  };\n\n  // ### Fallback implementation -- uses forge\n  var fallback = function (key, pdata, mac) {\n    // create the digest\n    var digest = forge.md[md].create();\n    digest.start();\n    digest.update(pdata);\n    digest = digest.digest().bytes();\n\n    // setup padding\n    var pss = forge.pss.create({\n      md: forge.md[md].create(),\n      mgf: forge.mgf.mgf1.create(forge.md[md].create()),\n      saltLength: CONSTANTS.HASHLENGTH[hash] / 8\n    });\n\n    // verify it\n    var pki = rsaUtil.convertToForge(key, true);\n    var sig = mac.toString(\"binary\");\n    var result = pki.verify(digest, sig, pss);\n    if (!result) {\n      return Promise.reject(new Error(\"verification failed\"));\n    }\n    return Promise.resolve({\n      data: pdata,\n      mac: mac,\n      valid: true\n    });\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(key, pdata, mac) {\n    key = rsaUtil.convertToJWK(key, true);\n    var promise;\n    promise = helpers.subtleCrypto.importKey(\"jwk\", key, alg, true, [\"verify\"]);\n    promise = promise.then(function (key) {\n      return helpers.subtleCrypto.verify(alg, key, mac, pdata);\n    });\n    promise = promise.then(function (result) {\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    });\n\n    return promise;\n  };\n\n  var nodejs;\n  if (nodePSSsupport()) {\n    nodejs = function(key, pdata, mac) {\n      var verify = helpers.nodeCrypto.createVerify(md);\n      verify.update(pdata);\n      verify.end();\n      var result = verify.verify({\n        key: rsaUtil.convertToPem(key, true),\n        padding: helpers.nodeCrypto.constants.RSA_PKCS1_PSS_PADDING,\n        saltLength: helpers.nodeCrypto.constants.RSA_PSS_SALTLEN_DIGEST\n      }, mac);\n      if (!result) {\n        return Promise.reject(new Error(\"verification failed\"));\n      }\n\n      return {\n        data: pdata,\n        mac: mac,\n        valid: true\n      };\n    };\n  }\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// ### Public API\n// * [name].sign\n// * [name].verify\nvar rsassa = {};\n[\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaPssSignFn(name),\n    verify: rsassaPssVerifyFn(name)\n  };\n});\n\n[\n  \"RS256\",\n  \"RS384\",\n  \"RS512\"\n].forEach(function(name) {\n  rsassa[name] = {\n    sign: rsassaV15SignFn(name),\n    verify: rsassaV15VerifyFn(name)\n  };\n});\n\nmodule.exports = rsassa;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYXNzYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBYTtBQUNyQyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7QUFDcEMsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3JzYXNzYS5qcz82YzBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9yc2Fzc2EuanMgLSBSU0EgU2lnbmF0dXJlc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgQ09OU1RBTlRTID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIHJzYVV0aWwgPSByZXF1aXJlKFwiLi9yc2EtdXRpbC5qc1wiKTtcblxuZnVuY3Rpb24gbm9kZVBTU3N1cHBvcnQoKSB7XG4gIHJldHVybiBoZWxwZXJzLm5vZGVDcnlwdG8gJiYgaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cyAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uY29uc3RhbnRzLlJTQV9QU1NfU0FMVExFTl9ESUdFU1Q7XG59XG5cbi8vICMjIyBSU0FTU0EtUEtDUzEtdjFfNVxuXG5mdW5jdGlvbiByc2Fzc2FWMTVTaWduRm4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJSU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIlJTXCIsIFwiU0hBLVwiKTtcblxuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IFwiUlNBU1NBLVBLQ1MxLVYxXzVcIixcbiAgICBoYXNoOiB7XG4gICAgICBuYW1lOiBoYXNoXG4gICAgfVxuICB9O1xuXG4gIC8vICMjIyBGYWxsYmFjayBJbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGRpZ2VzdFxuICAgIHZhciBkaWdlc3QgPSBmb3JnZS5tZFttZF0uY3JlYXRlKCk7XG4gICAgZGlnZXN0LnN0YXJ0KCk7XG4gICAgZGlnZXN0LnVwZGF0ZShwZGF0YSk7XG5cbiAgICAvLyBzaWduIGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCBmYWxzZSk7XG4gICAgdmFyIHNpZyA9IHBraS5zaWduKGRpZ2VzdCwgXCJSU0FTU0EtUEtDUzEtVjFfNVwiKTtcbiAgICBzaWcgPSBCdWZmZXIuZnJvbShzaWcsIFwiYmluYXJ5XCIpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBwZGF0YSxcbiAgICAgIG1hYzogc2lnXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgZmFsc2UpO1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcInNpZ25cIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8uc2lnbihhbGcsIGtleSwgcGRhdGEpO1xuICAgIH0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICB2YXIgc2lnID0gQnVmZmVyLmZyb20ocmVzdWx0KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIHZhciBub2RlanM7XG4gIHZhciBub2RlSGFzaCA9IFwiUlNBLVwiICsgaGFzaC5yZXBsYWNlKFwiLVwiLCBcIlwiKTtcbiAgaWYgKGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uZ2V0SGFzaGVzKCkuaW5kZXhPZihub2RlSGFzaCkgPiAtMSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIHZhciBzaWduID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVNpZ24obm9kZUhhc2gpO1xuICAgICAgc2lnbi51cGRhdGUocGRhdGEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBzaWduLnNpZ24ocnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCBmYWxzZSkpXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHJzYXNzYVYxNVZlcmlmeUZuKG5hbWUpIHtcbiAgdmFyIG1kID0gbmFtZS5yZXBsYWNlKFwiUlNcIiwgXCJTSEFcIikudG9Mb3dlckNhc2UoKSxcbiAgICAgIGhhc2ggPSBuYW1lLnJlcGxhY2UoXCJSU1wiLCBcIlNIQS1cIik7XG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogXCJSU0FTU0EtUEtDUzEtVjFfNVwiLFxuICAgIGhhc2g6IHtcbiAgICAgIG5hbWU6IGhhc2hcbiAgICB9XG4gIH07XG5cbiAgLy8gIyMjIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAgLy8gY3JlYXRlIHRoZSBkaWdlc3RcbiAgICB2YXIgZGlnZXN0ID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICAgIGRpZ2VzdC5zdGFydCgpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEpO1xuICAgIGRpZ2VzdCA9IGRpZ2VzdC5kaWdlc3QoKS5ieXRlcygpO1xuXG4gICAgLy8gdmVyaWZ5IGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCB0cnVlKTtcbiAgICB2YXIgc2lnID0gbWFjLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIHZhciByZXN1bHQgPSBwa2kudmVyaWZ5KGRpZ2VzdCwgc2lnLCBcIlJTQVNTQS1QS0NTMS1WMV81XCIpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogcGRhdGEsXG4gICAgICBtYWM6IG1hYyxcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCB0cnVlKTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJ2ZXJpZnlcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gaGVscGVycy5zdWJ0bGVDcnlwdG8udmVyaWZ5KGFsZywga2V5LCBtYWMsIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgaWYgKGhlbHBlcnMubm9kZUNyeXB0byAmJiBoZWxwZXJzLm5vZGVDcnlwdG8uZ2V0SGFzaGVzKCkuaW5kZXhPZihtZCkgPiAtMSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYykge1xuICAgICAgdmFyIHZlcmlmeSA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVWZXJpZnkobWQpO1xuICAgICAgdmVyaWZ5LnVwZGF0ZShwZGF0YSk7XG4gICAgICB2ZXJpZnkuZW5kKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gdmVyaWZ5LnZlcmlmeShyc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIHRydWUpLCBtYWMpO1xuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInZlcmlmaWNhdGlvbiBmYWlsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiBwZGF0YSxcbiAgICAgICAgbWFjOiBtYWMsXG4gICAgICAgIHZhbGlkOiB0cnVlXG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gaGVscGVycy5zZXR1cEZhbGxiYWNrKG5vZGVqcywgd2ViY3J5cHRvLCBmYWxsYmFjayk7XG59XG5cbi8vICMjIyBSU0EtUFNTXG5mdW5jdGlvbiByc2Fzc2FQc3NTaWduRm4obmFtZSkge1xuICB2YXIgbWQgPSBuYW1lLnJlcGxhY2UoXCJQU1wiLCBcIlNIQVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgaGFzaCA9IG5hbWUucmVwbGFjZShcIlBTXCIsIFwiU0hBLVwiKTtcblxuICB2YXIgYWxnID0ge1xuICAgIG5hbWU6IFwiUlNBLVBTU1wiLFxuICAgIGhhc2g6IHtcbiAgICAgIG5hbWU6IGhhc2hcbiAgICB9LFxuICAgIHNhbHRMZW5ndGg6IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdIC8gOFxuICB9O1xuXG4gIC8vICMjIyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiAtLSB1c2VzIGZvcmdlXG4gIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uIChrZXksIHBkYXRhKSB7XG4gICAgLy8gY3JlYXRlIHRoZSBkaWdlc3RcbiAgICB2YXIgZGlnZXN0ID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICAgIGRpZ2VzdC5zdGFydCgpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEpO1xuXG4gICAgLy8gc2V0dXAgcGFkZGluZ1xuICAgIHZhciBwc3MgPSBmb3JnZS5wc3MuY3JlYXRlKHtcbiAgICAgIG1kOiBmb3JnZS5tZFttZF0uY3JlYXRlKCksXG4gICAgICBtZ2Y6IGZvcmdlLm1nZi5tZ2YxLmNyZWF0ZShmb3JnZS5tZFttZF0uY3JlYXRlKCkpLFxuICAgICAgc2FsdExlbmd0aDogQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0gLyA4XG4gICAgfSk7XG5cbiAgICAvLyBzaWduIGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCBmYWxzZSk7XG4gICAgdmFyIHNpZyA9IHBraS5zaWduKGRpZ2VzdCwgcHNzKTtcbiAgICBzaWcgPSBCdWZmZXIuZnJvbShzaWcsIFwiYmluYXJ5XCIpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBkYXRhOiBwZGF0YSxcbiAgICAgIG1hYzogc2lnXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSkge1xuICAgIGtleSA9IHJzYVV0aWwuY29udmVydFRvSldLKGtleSwgZmFsc2UpO1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5pbXBvcnRLZXkoXCJqd2tcIiwga2V5LCBhbGcsIHRydWUsIFtcInNpZ25cIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnNpZ24oYWxnLCBrZXksIHBkYXRhKTtcbiAgICB9KTtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHZhciBzaWcgPSBCdWZmZXIuZnJvbShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogc2lnXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbiAgdmFyIG5vZGVqcztcbiAgdmFyIG5vZGVIYXNoID0gXCJSU0EtXCIgKyBoYXNoLnJlcGxhY2UoXCItXCIsIFwiXCIpO1xuICBpZiAobm9kZVBTU3N1cHBvcnQoKSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEpIHtcbiAgICAgIHZhciBzaWduID0gaGVscGVycy5ub2RlQ3J5cHRvLmNyZWF0ZVNpZ24obm9kZUhhc2gpO1xuICAgICAgc2lnbi51cGRhdGUocGRhdGEpO1xuXG4gICAgICB2YXIgc2lnID0gc2lnbi5zaWduKHtcbiAgICAgICAga2V5OiByc2FVdGlsLmNvbnZlcnRUb1BlbShrZXksIGZhbHNlKSxcbiAgICAgICAgcGFkZGluZzogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICAgIHNhbHRMZW5ndGg6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMuUlNBX1BTU19TQUxUTEVOX0RJR0VTVFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IHNpZ1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiByc2Fzc2FQc3NWZXJpZnlGbihuYW1lKSB7XG4gIHZhciBtZCA9IG5hbWUucmVwbGFjZShcIlBTXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCksXG4gICAgICBoYXNoID0gbmFtZS5yZXBsYWNlKFwiUFNcIiwgXCJTSEEtXCIpO1xuXG4gIHZhciBhbGcgPSB7XG4gICAgbmFtZTogXCJSU0EtUFNTXCIsXG4gICAgaGFzaDoge1xuICAgICAgbmFtZTogaGFzaFxuICAgIH0sXG4gICAgc2FsdExlbmd0aDogQ09OU1RBTlRTLkhBU0hMRU5HVEhbaGFzaF0gLyA4XG4gIH07XG5cbiAgLy8gIyMjIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24gKGtleSwgcGRhdGEsIG1hYykge1xuICAgIC8vIGNyZWF0ZSB0aGUgZGlnZXN0XG4gICAgdmFyIGRpZ2VzdCA9IGZvcmdlLm1kW21kXS5jcmVhdGUoKTtcbiAgICBkaWdlc3Quc3RhcnQoKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhKTtcbiAgICBkaWdlc3QgPSBkaWdlc3QuZGlnZXN0KCkuYnl0ZXMoKTtcblxuICAgIC8vIHNldHVwIHBhZGRpbmdcbiAgICB2YXIgcHNzID0gZm9yZ2UucHNzLmNyZWF0ZSh7XG4gICAgICBtZDogZm9yZ2UubWRbbWRdLmNyZWF0ZSgpLFxuICAgICAgbWdmOiBmb3JnZS5tZ2YubWdmMS5jcmVhdGUoZm9yZ2UubWRbbWRdLmNyZWF0ZSgpKSxcbiAgICAgIHNhbHRMZW5ndGg6IENPTlNUQU5UUy5IQVNITEVOR1RIW2hhc2hdIC8gOFxuICAgIH0pO1xuXG4gICAgLy8gdmVyaWZ5IGl0XG4gICAgdmFyIHBraSA9IHJzYVV0aWwuY29udmVydFRvRm9yZ2Uoa2V5LCB0cnVlKTtcbiAgICB2YXIgc2lnID0gbWFjLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIHZhciByZXN1bHQgPSBwa2kudmVyaWZ5KGRpZ2VzdCwgc2lnLCBwc3MpO1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgZGF0YTogcGRhdGEsXG4gICAgICBtYWM6IG1hYyxcbiAgICAgIHZhbGlkOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgLy8gIyMjIFdlYkNyeXB0b0FQSSBJbXBsZW1lbnRhdGlvblxuICB2YXIgd2ViY3J5cHRvID0gZnVuY3Rpb24oa2V5LCBwZGF0YSwgbWFjKSB7XG4gICAga2V5ID0gcnNhVXRpbC5jb252ZXJ0VG9KV0soa2V5LCB0cnVlKTtcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBwcm9taXNlID0gaGVscGVycy5zdWJ0bGVDcnlwdG8uaW1wb3J0S2V5KFwiandrXCIsIGtleSwgYWxnLCB0cnVlLCBbXCJ2ZXJpZnlcIl0pO1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGhlbHBlcnMuc3VidGxlQ3J5cHRvLnZlcmlmeShhbGcsIGtleSwgbWFjLCBwZGF0YSk7XG4gICAgfSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidmVyaWZpY2F0aW9uIGZhaWxlZFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGE6IHBkYXRhLFxuICAgICAgICBtYWM6IG1hYyxcbiAgICAgICAgdmFsaWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICB2YXIgbm9kZWpzO1xuICBpZiAobm9kZVBTU3N1cHBvcnQoKSkge1xuICAgIG5vZGVqcyA9IGZ1bmN0aW9uKGtleSwgcGRhdGEsIG1hYykge1xuICAgICAgdmFyIHZlcmlmeSA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVWZXJpZnkobWQpO1xuICAgICAgdmVyaWZ5LnVwZGF0ZShwZGF0YSk7XG4gICAgICB2ZXJpZnkuZW5kKCk7XG4gICAgICB2YXIgcmVzdWx0ID0gdmVyaWZ5LnZlcmlmeSh7XG4gICAgICAgIGtleTogcnNhVXRpbC5jb252ZXJ0VG9QZW0oa2V5LCB0cnVlKSxcbiAgICAgICAgcGFkZGluZzogaGVscGVycy5ub2RlQ3J5cHRvLmNvbnN0YW50cy5SU0FfUEtDUzFfUFNTX1BBRERJTkcsXG4gICAgICAgIHNhbHRMZW5ndGg6IGhlbHBlcnMubm9kZUNyeXB0by5jb25zdGFudHMuUlNBX1BTU19TQUxUTEVOX0RJR0VTVFxuICAgICAgfSwgbWFjKTtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ2ZXJpZmljYXRpb24gZmFpbGVkXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YTogcGRhdGEsXG4gICAgICAgIG1hYzogbWFjLFxuICAgICAgICB2YWxpZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGhlbHBlcnMuc2V0dXBGYWxsYmFjayhub2RlanMsIHdlYmNyeXB0bywgZmFsbGJhY2spO1xufVxuXG4vLyAjIyMgUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uc2lnblxuLy8gKiBbbmFtZV0udmVyaWZ5XG52YXIgcnNhc3NhID0ge307XG5bXG4gIFwiUFMyNTZcIixcbiAgXCJQUzM4NFwiLFxuICBcIlBTNTEyXCJcbl0uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIHJzYXNzYVtuYW1lXSA9IHtcbiAgICBzaWduOiByc2Fzc2FQc3NTaWduRm4obmFtZSksXG4gICAgdmVyaWZ5OiByc2Fzc2FQc3NWZXJpZnlGbihuYW1lKVxuICB9O1xufSk7XG5cbltcbiAgXCJSUzI1NlwiLFxuICBcIlJTMzg0XCIsXG4gIFwiUlM1MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgcnNhc3NhW25hbWVdID0ge1xuICAgIHNpZ246IHJzYXNzYVYxNVNpZ25GbihuYW1lKSxcbiAgICB2ZXJpZnk6IHJzYXNzYVYxNVZlcmlmeUZuKG5hbWUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSByc2Fzc2E7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/rsassa.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/algorithms/sha.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/algorithms/sha.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * algorithms/sha.js - Cryptographic Secure Hash Algorithms, versions 1 and 2\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\");\n\nfunction hashDigestFN(hash) {\n  var md = hash.replace(\"SHA-\", \"SHA\").toLowerCase();\n\n  var alg = {\n    name: hash\n  };\n\n  // ### Fallback Implementation -- uses forge\n  var fallback = function(pdata /* props */) {\n    var digest = forge.md[md].create();\n    digest.update(pdata.toString(\"binary\"));\n    digest = Buffer.from(digest.digest().bytes(), \"binary\");\n\n    return Promise.resolve(digest);\n  };\n\n  // ### WebCryptoAPI Implementation\n  var webcrypto = function(pdata /* props */) {\n    var promise;\n    promise = helpers.subtleCrypto.digest(alg, pdata);\n    promise = promise.then(function(result) {\n      result = Buffer.from(result);\n      return result;\n    });\n    return promise;\n  };\n\n  // ### nodejs Implementation\n  var nodejs = function(pdata /* props */) {\n    var digest = helpers.nodeCrypto.createHash(md);\n    digest.update(pdata);\n    return digest.digest();\n  };\n\n  return helpers.setupFallback(nodejs, webcrypto, fallback);\n}\n\n// Public API\n// * [name].digest\nvar sha = {};\n[\n  \"SHA-1\",\n  \"SHA-256\",\n  \"SHA-384\",\n  \"SHA-512\"\n].forEach(function(name) {\n  sha[name] = {\n    digest: hashDigestFN(name)\n  };\n});\n\nmodule.exports = sha;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3NoYS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QyxjQUFjLG1CQUFPLENBQUMsOEVBQWM7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9hbGdvcml0aG1zL3NoYS5qcz83ZGE3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogYWxnb3JpdGhtcy9zaGEuanMgLSBDcnlwdG9ncmFwaGljIFNlY3VyZSBIYXNoIEFsZ29yaXRobXMsIHZlcnNpb25zIDEgYW5kIDJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlLmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpO1xuXG5mdW5jdGlvbiBoYXNoRGlnZXN0Rk4oaGFzaCkge1xuICB2YXIgbWQgPSBoYXNoLnJlcGxhY2UoXCJTSEEtXCIsIFwiU0hBXCIpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIGFsZyA9IHtcbiAgICBuYW1lOiBoYXNoXG4gIH07XG5cbiAgLy8gIyMjIEZhbGxiYWNrIEltcGxlbWVudGF0aW9uIC0tIHVzZXMgZm9yZ2VcbiAgdmFyIGZhbGxiYWNrID0gZnVuY3Rpb24ocGRhdGEgLyogcHJvcHMgKi8pIHtcbiAgICB2YXIgZGlnZXN0ID0gZm9yZ2UubWRbbWRdLmNyZWF0ZSgpO1xuICAgIGRpZ2VzdC51cGRhdGUocGRhdGEudG9TdHJpbmcoXCJiaW5hcnlcIikpO1xuICAgIGRpZ2VzdCA9IEJ1ZmZlci5mcm9tKGRpZ2VzdC5kaWdlc3QoKS5ieXRlcygpLCBcImJpbmFyeVwiKTtcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZGlnZXN0KTtcbiAgfTtcblxuICAvLyAjIyMgV2ViQ3J5cHRvQVBJIEltcGxlbWVudGF0aW9uXG4gIHZhciB3ZWJjcnlwdG8gPSBmdW5jdGlvbihwZGF0YSAvKiBwcm9wcyAqLykge1xuICAgIHZhciBwcm9taXNlO1xuICAgIHByb21pc2UgPSBoZWxwZXJzLnN1YnRsZUNyeXB0by5kaWdlc3QoYWxnLCBwZGF0YSk7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIC8vICMjIyBub2RlanMgSW1wbGVtZW50YXRpb25cbiAgdmFyIG5vZGVqcyA9IGZ1bmN0aW9uKHBkYXRhIC8qIHByb3BzICovKSB7XG4gICAgdmFyIGRpZ2VzdCA9IGhlbHBlcnMubm9kZUNyeXB0by5jcmVhdGVIYXNoKG1kKTtcbiAgICBkaWdlc3QudXBkYXRlKHBkYXRhKTtcbiAgICByZXR1cm4gZGlnZXN0LmRpZ2VzdCgpO1xuICB9O1xuXG4gIHJldHVybiBoZWxwZXJzLnNldHVwRmFsbGJhY2sobm9kZWpzLCB3ZWJjcnlwdG8sIGZhbGxiYWNrKTtcbn1cblxuLy8gUHVibGljIEFQSVxuLy8gKiBbbmFtZV0uZGlnZXN0XG52YXIgc2hhID0ge307XG5bXG4gIFwiU0hBLTFcIixcbiAgXCJTSEEtMjU2XCIsXG4gIFwiU0hBLTM4NFwiLFxuICBcIlNIQS01MTJcIlxuXS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgc2hhW25hbWVdID0ge1xuICAgIGRpZ2VzdDogaGFzaERpZ2VzdEZOKG5hbWUpXG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzaGE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/algorithms/sha.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/helpers.js - AES-GCM Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    fill = __webpack_require__(/*! lodash/fill */ \"(ssr)/./node_modules/lodash/fill.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nvar E1 = 0xe1000000,\n    E1B = 0xe1,\n    E1L = new Long(E1 >> 8);\n\nfunction generateLookup() {\n  var lookup = [];\n\n  for (var c = 0; c < 256; ++c) {\n    var v = 0;\n    for (var i = 7; i >= 0; --i) {\n      if ((c & (1 << i)) !== 0) {\n        v ^= (E1 >>> (7 - i));\n      }\n    }\n    lookup.push(v);\n  }\n\n  return lookup;\n}\n\nvar helpers = module.exports = {\n  // ### Constants\n  E1: E1,\n  E1B: E1B,\n  E1L: E1L,\n  LOOKUP: generateLookup(),\n\n  // ### Array Helpers\n  arrayCopy: function(src, srcPos, dest, destPos, length) {\n    // Start by checking for negatives since arrays in JS auto-expand\n    if (srcPos < 0 || destPos < 0 || length < 0) {\n      throw new TypeError(\"Invalid input.\");\n    }\n\n    if (dest instanceof Uint8Array) {\n      // Check for overflow if dest is a typed-array\n      if (destPos >= dest.length || (destPos + length) > dest.length) {\n        throw new TypeError(\"Invalid input.\");\n      }\n\n      if (srcPos !== 0 || length < src.length) {\n        if (src instanceof Uint8Array) {\n          src = src.subarray(srcPos, srcPos + length);\n        } else {\n          src = src.slice(srcPos, srcPos + length);\n        }\n      }\n\n      dest.set(src, destPos);\n    } else {\n      for (var i = 0; i < length; ++i) {\n        dest[destPos + i] = src[srcPos + i];\n      }\n    }\n  },\n  arrayEqual: function(a1, a2) {\n    a1 = a1 || [];\n    a2 = a2 || [];\n\n    var len = Math.min(a1.length, a2.length),\n        result = (a1.length === a2.length);\n\n    for (var idx = 0; idx < len; idx++) {\n      result = result &&\n               (\"undefined\" !== typeof a1[idx]) &&\n               (\"undefined\" !== typeof a2[idx]) &&\n               (a1[idx] === a2[idx]);\n    }\n\n    return result;\n  },\n\n  // ### Conversions\n  asBytes: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = Buffer.alloc(16);\n        pack.intToBigEndian(x, z, 0);\n        return z;\n      case 2:\n        pack.intToBigEndian(x, z, 0);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  asInts: function(x, z) {\n    switch (arguments.length) {\n      case 1:\n        z = [];\n        fill(z, 0, 0, 4);\n        pack.bigEndianToInt(x, 0, z);\n        return z;\n      case 2:\n        pack.bigEndianToInt(x, 0, z);\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  oneAsInts: function() {\n    var tmp = [];\n    for (var c = 0; c < 4; ++c) {\n        tmp.push(1 << 31);\n    }\n    return tmp;\n  },\n\n  // ## Bit-wise\n  shiftRight: function(x, z) {\n    var b, c;\n    switch (arguments.length) {\n      case 1:\n        b = x[0];\n        x[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        x[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        x[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        x[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      case 2:\n        b = x[0];\n        z[0] = b >>> 1;\n        c = b << 31;\n        b = x[1];\n        z[1] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[2];\n        z[2] = (b >>> 1) | c;\n        c = b << 31;\n        b = x[3];\n        z[3] = (b >>> 1) | c;\n        return (b << 31) & 0xffffffff;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  shiftRightN: function(x, n, z) {\n    var nInv, b, c;\n    switch (arguments.length) {\n      case 2:\n        b = x[0];\n        nInv = 32 - n;\n        x[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        x[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        x[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        x[3] = (b >>> n) | c;\n        return b << nInv;\n      case 3:\n        b = x[0];\n        nInv = 32 - n;\n        z[0] = b >>> n;\n        c = b << nInv;\n        b = x[1];\n        z[1] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[2];\n        z[2] = (b >>> n) | c;\n        c = b << nInv;\n        b = x[3];\n        z[3] = (b >>> n) | c;\n        return b << nInv;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  xor: function(x, y, z) {\n    switch (arguments.length) {\n      case 2:\n        x[0] ^= y[0];\n        x[1] ^= y[1];\n        x[2] ^= y[2];\n        x[3] ^= y[3];\n        break;\n      case 3:\n        z[0] = x[0] ^ y[0];\n        z[1] = x[1] ^ y[1];\n        z[2] = x[2] ^ y[2];\n        z[3] = x[3] ^ y[3];\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n\n  multiply: function(x, y) {\n    var r0 = x.slice();\n    var r1 = [];\n\n    for (var i = 0; i < 4; ++i) {\n      var bits = y[i];\n      for (var j = 31; j >= 0; --j) {\n        if ((bits & (1 << j)) !== 0) {\n          helpers.xor(r1, r0);\n        }\n\n        if (helpers.shiftRight(r0) !== 0) {\n          r0[0] ^= helpers.E1;\n        }\n      }\n    }\n\n    helpers.arrayCopy(r1, 0, x, 0, 4);\n  },\n  multiplyP: function(x, y) {\n    switch (arguments.length) {\n      case 1:\n        if (helpers.shiftRight(x) !== 0) {\n          x[0] ^= helpers.E1;\n        }\n        break;\n      case 2:\n        if (helpers.shiftRight(x, y) !== 0) {\n          y[0] ^= helpers.E1;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  },\n  multiplyP8: function(x, y) {\n    var c;\n    switch (arguments.length) {\n      case 1:\n        c = helpers.shiftRightN(x, 8);\n        x[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      case 2:\n        c = helpers.shiftRightN(x, 8, y);\n        y[0] ^= helpers.LOOKUP[c >>> 24];\n        break;\n      default:\n        throw new TypeError(\"Expected 1 or 2 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTs7QUFFL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTixzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLHVCQUF1QixRQUFRO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvZ2NtL2hlbHBlcnMuanM/YTE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvY2lwaGVybW9kZXMvZ2NtL2hlbHBlcnMuanMgLSBBRVMtR0NNIEhlbHBlciBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMb25nID0gcmVxdWlyZShcImxvbmdcIiksXG4gICAgZmlsbCA9IHJlcXVpcmUoXCJsb2Rhc2gvZmlsbFwiKSxcbiAgICBwYWNrID0gcmVxdWlyZShcIi4uL3BhY2suanNcIik7XG5cbnZhciBFMSA9IDB4ZTEwMDAwMDAsXG4gICAgRTFCID0gMHhlMSxcbiAgICBFMUwgPSBuZXcgTG9uZyhFMSA+PiA4KTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVMb29rdXAoKSB7XG4gIHZhciBsb29rdXAgPSBbXTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IDI1NjsgKytjKSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSA3OyBpID49IDA7IC0taSkge1xuICAgICAgaWYgKChjICYgKDEgPDwgaSkpICE9PSAwKSB7XG4gICAgICAgIHYgXj0gKEUxID4+PiAoNyAtIGkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbG9va3VwLnB1c2godik7XG4gIH1cblxuICByZXR1cm4gbG9va3VwO1xufVxuXG52YXIgaGVscGVycyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAvLyAjIyMgQ29uc3RhbnRzXG4gIEUxOiBFMSxcbiAgRTFCOiBFMUIsXG4gIEUxTDogRTFMLFxuICBMT09LVVA6IGdlbmVyYXRlTG9va3VwKCksXG5cbiAgLy8gIyMjIEFycmF5IEhlbHBlcnNcbiAgYXJyYXlDb3B5OiBmdW5jdGlvbihzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gICAgLy8gU3RhcnQgYnkgY2hlY2tpbmcgZm9yIG5lZ2F0aXZlcyBzaW5jZSBhcnJheXMgaW4gSlMgYXV0by1leHBhbmRcbiAgICBpZiAoc3JjUG9zIDwgMCB8fCBkZXN0UG9zIDwgMCB8fCBsZW5ndGggPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRlc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAvLyBDaGVjayBmb3Igb3ZlcmZsb3cgaWYgZGVzdCBpcyBhIHR5cGVkLWFycmF5XG4gICAgICBpZiAoZGVzdFBvcyA+PSBkZXN0Lmxlbmd0aCB8fCAoZGVzdFBvcyArIGxlbmd0aCkgPiBkZXN0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBpbnB1dC5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzcmNQb3MgIT09IDAgfHwgbGVuZ3RoIDwgc3JjLmxlbmd0aCkge1xuICAgICAgICBpZiAoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3JjID0gc3JjLnNsaWNlKHNyY1Bvcywgc3JjUG9zICsgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBkZXN0LnNldChzcmMsIGRlc3RQb3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGRlc3RbZGVzdFBvcyArIGldID0gc3JjW3NyY1BvcyArIGldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYXJyYXlFcXVhbDogZnVuY3Rpb24oYTEsIGEyKSB7XG4gICAgYTEgPSBhMSB8fCBbXTtcbiAgICBhMiA9IGEyIHx8IFtdO1xuXG4gICAgdmFyIGxlbiA9IE1hdGgubWluKGExLmxlbmd0aCwgYTIubGVuZ3RoKSxcbiAgICAgICAgcmVzdWx0ID0gKGExLmxlbmd0aCA9PT0gYTIubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4KyspIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJlxuICAgICAgICAgICAgICAgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhMVtpZHhdKSAmJlxuICAgICAgICAgICAgICAgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBhMltpZHhdKSAmJlxuICAgICAgICAgICAgICAgKGExW2lkeF0gPT09IGEyW2lkeF0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLy8gIyMjIENvbnZlcnNpb25zXG4gIGFzQnl0ZXM6IGZ1bmN0aW9uKHgsIHopIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeiA9IEJ1ZmZlci5hbGxvYygxNik7XG4gICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4oeCwgeiwgMCk7XG4gICAgICAgIHJldHVybiB6O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKHgsIHosIDApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDIgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIGFzSW50czogZnVuY3Rpb24oeCwgeikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB6ID0gW107XG4gICAgICAgIGZpbGwoeiwgMCwgMCwgNCk7XG4gICAgICAgIHBhY2suYmlnRW5kaWFuVG9JbnQoeCwgMCwgeik7XG4gICAgICAgIHJldHVybiB6O1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwYWNrLmJpZ0VuZGlhblRvSW50KHgsIDAsIHopO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDIgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIG9uZUFzSW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRtcCA9IFtdO1xuICAgIGZvciAodmFyIGMgPSAwOyBjIDwgNDsgKytjKSB7XG4gICAgICAgIHRtcC5wdXNoKDEgPDwgMzEpO1xuICAgIH1cbiAgICByZXR1cm4gdG1wO1xuICB9LFxuXG4gIC8vICMjIEJpdC13aXNlXG4gIHNoaWZ0UmlnaHQ6IGZ1bmN0aW9uKHgsIHopIHtcbiAgICB2YXIgYiwgYztcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYiA9IHhbMF07XG4gICAgICAgIHhbMF0gPSBiID4+PiAxO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbMV07XG4gICAgICAgIHhbMV0gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbMl07XG4gICAgICAgIHhbMl0gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbM107XG4gICAgICAgIHhbM10gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICByZXR1cm4gKGIgPDwgMzEpICYgMHhmZmZmZmZmZjtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgYiA9IHhbMF07XG4gICAgICAgIHpbMF0gPSBiID4+PiAxO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbMV07XG4gICAgICAgIHpbMV0gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbMl07XG4gICAgICAgIHpbMl0gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICBjID0gYiA8PCAzMTtcbiAgICAgICAgYiA9IHhbM107XG4gICAgICAgIHpbM10gPSAoYiA+Pj4gMSkgfCBjO1xuICAgICAgICByZXR1cm4gKGIgPDwgMzEpICYgMHhmZmZmZmZmZjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDIgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIHNoaWZ0UmlnaHROOiBmdW5jdGlvbih4LCBuLCB6KSB7XG4gICAgdmFyIG5JbnYsIGIsIGM7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGIgPSB4WzBdO1xuICAgICAgICBuSW52ID0gMzIgLSBuO1xuICAgICAgICB4WzBdID0gYiA+Pj4gbjtcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbMV07XG4gICAgICAgIHhbMV0gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFsyXTtcbiAgICAgICAgeFsyXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzNdO1xuICAgICAgICB4WzNdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgcmV0dXJuIGIgPDwgbkludjtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgYiA9IHhbMF07XG4gICAgICAgIG5JbnYgPSAzMiAtIG47XG4gICAgICAgIHpbMF0gPSBiID4+PiBuO1xuICAgICAgICBjID0gYiA8PCBuSW52O1xuICAgICAgICBiID0geFsxXTtcbiAgICAgICAgelsxXSA9IChiID4+PiBuKSB8IGM7XG4gICAgICAgIGMgPSBiIDw8IG5JbnY7XG4gICAgICAgIGIgPSB4WzJdO1xuICAgICAgICB6WzJdID0gKGIgPj4+IG4pIHwgYztcbiAgICAgICAgYyA9IGIgPDwgbkludjtcbiAgICAgICAgYiA9IHhbM107XG4gICAgICAgIHpbM10gPSAoYiA+Pj4gbikgfCBjO1xuICAgICAgICByZXR1cm4gYiA8PCBuSW52O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIDIgb3IgMyBhcmd1bWVudHMuXCIpO1xuICAgIH1cbiAgfSxcbiAgeG9yOiBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHhbMF0gXj0geVswXTtcbiAgICAgICAgeFsxXSBePSB5WzFdO1xuICAgICAgICB4WzJdIF49IHlbMl07XG4gICAgICAgIHhbM10gXj0geVszXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHpbMF0gPSB4WzBdIF4geVswXTtcbiAgICAgICAgelsxXSA9IHhbMV0gXiB5WzFdO1xuICAgICAgICB6WzJdID0geFsyXSBeIHlbMl07XG4gICAgICAgIHpbM10gPSB4WzNdIF4geVszXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMiBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHIwID0geC5zbGljZSgpO1xuICAgIHZhciByMSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIHZhciBiaXRzID0geVtpXTtcbiAgICAgIGZvciAodmFyIGogPSAzMTsgaiA+PSAwOyAtLWopIHtcbiAgICAgICAgaWYgKChiaXRzICYgKDEgPDwgaikpICE9PSAwKSB7XG4gICAgICAgICAgaGVscGVycy54b3IocjEsIHIwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWxwZXJzLnNoaWZ0UmlnaHQocjApICE9PSAwKSB7XG4gICAgICAgICAgcjBbMF0gXj0gaGVscGVycy5FMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGhlbHBlcnMuYXJyYXlDb3B5KHIxLCAwLCB4LCAwLCA0KTtcbiAgfSxcbiAgbXVsdGlwbHlQOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChoZWxwZXJzLnNoaWZ0UmlnaHQoeCkgIT09IDApIHtcbiAgICAgICAgICB4WzBdIF49IGhlbHBlcnMuRTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmIChoZWxwZXJzLnNoaWZ0UmlnaHQoeCwgeSkgIT09IDApIHtcbiAgICAgICAgICB5WzBdIF49IGhlbHBlcnMuRTE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9LFxuICBtdWx0aXBseVA4OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGM7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGMgPSBoZWxwZXJzLnNoaWZ0UmlnaHROKHgsIDgpO1xuICAgICAgICB4WzBdIF49IGhlbHBlcnMuTE9PS1VQW2MgPj4+IDI0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGMgPSBoZWxwZXJzLnNoaWZ0UmlnaHROKHgsIDgsIHkpO1xuICAgICAgICB5WzBdIF49IGhlbHBlcnMuTE9PS1VQW2MgPj4+IDI0XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAyIGFyZ3VtZW50cy5cIik7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/index.js - AES-GCM implementation Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\"),\n    forge = __webpack_require__(/*! ../../../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    multipliers = __webpack_require__(/*! ./multipliers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\"),\n    helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\"),\n    DataBuffer = __webpack_require__(/*! ../../../util/databuffer.js */ \"(ssr)/./node_modules/node-jose/lib/util/databuffer.js\"),\n    cipherHelpers = __webpack_require__(/*! ../helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\");\n\nvar BLOCK_SIZE = 16;\n\n// ### GCM Mode\n// ### Constructor\nfunction Gcm(options) {\n  options = options || {};\n\n  this.name = \"GCM\";\n  this.cipher = options.cipher;\n  this.blockSize = this.blockSize || 16;\n}\n\n// ### exports\nmodule.exports = {\n  createCipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode.start(options);\n\n    return alg.mode;\n  },\n  createDecipher: function(options) {\n    var alg = new forge.aes.Algorithm(\"AES-GCM\", Gcm);\n    alg.initialize({\n      key: new DataBuffer(options.key)\n    });\n    alg.mode._decrypt = true;\n    alg.mode.start(options);\n\n    return alg.mode;\n  }\n};\n\n// ### Public API\nGcm.prototype.start = function(options) {\n  this.tag = null;\n\n  options = options || {};\n\n  if (!(\"iv\" in options)) {\n    throw new Error(\"Gcm needs ParametersWithIV or AEADParameters\");\n  }\n  this.nonce = options.iv;\n  if (this.nonce == null || this.nonce.length < 1) {\n    throw new Error(\"IV must be at least 1 byte\");\n  }\n\n  // TODO: variable tagLength?\n  this.tagLength = 16;\n\n  // TODO: validate tag\n  if (\"tag\" in options) {\n    this.tag = Buffer.from(options.tag);\n  }\n\n  var bufLength = !this._decrypt ?\n                  this.blockSize :\n                  (this.blockSize + this.tagLength);\n  this.bufBlock = Buffer.alloc(bufLength);\n\n  var multiplier = options.multiplier;\n  if (multiplier == null) {\n    multiplier = new (multipliers[\"8k\"])();\n  }\n  this.multiplier = multiplier;\n\n  this.H = this.zeroBlock();\n  cipherHelpers.encrypt(this.cipher, this.H, 0, this.H, 0);\n\n  // GcmMultiplier tables don\"t change unless the key changes\n  // (and are expensive to init)\n  this.multiplier.init(this.H);\n  this.exp = null;\n\n  this.J0 = this.zeroBlock();\n\n  if (this.nonce.length === 12) {\n    this.nonce.copy(this.J0, 0, 0, this.nonce.length);\n    this.J0[this.blockSize - 1] = 0x01;\n  } else {\n    this.gHASH(this.J0, this.nonce, this.nonce.length);\n    var X = this.zeroBlock();\n    pack.longToBigEndian(new Long(this.nonce.length).\n                         multiply(8), X, 8);\n    this.gHASHBlock(this.J0, X);\n  }\n\n  this.S = this.zeroBlock();\n  this.SAt = this.zeroBlock();\n  this.SAtPre = this.zeroBlock();\n  this.atBlock = this.zeroBlock();\n  this.atBlockPos = 0;\n  this.atLength = Long.ZERO;\n  this.atLengthPre = Long.ZERO;\n  this.counter = Buffer.from(this.J0);\n  this.bufOff = 0;\n  this.totalLength = Long.ZERO;\n\n  if (\"additionalData\" in options) {\n    this.processAADBytes(options.additionalData, 0, options.additionalData.length);\n  }\n};\n\nGcm.prototype.update = function(inV, inOff, len, out, outOff) {\n  var resultLen = 0;\n\n  while (len > 0) {\n    var inLen = Math.min(len, this.bufBlock.length - this.bufOff);\n    inV.copy(this.bufBlock, this.bufOff, inOff, inOff + inLen);\n    len -= inLen;\n    inOff += inLen;\n    this.bufOff += inLen;\n    if (this.bufOff === this.bufBlock.length) {\n      this.outputBlock(out, outOff + resultLen);\n      resultLen += this.blockSize;\n    }\n  }\n\n  return resultLen;\n};\nGcm.prototype.finish = function(out, outOff) {\n  var resultLen = 0;\n\n  if (this._decrypt) {\n    // append tag\n    resultLen += this.update(this.tag, 0, this.tag.length, out, outOff);\n  }\n\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n\n  var extra = this.bufOff;\n  if (this._decrypt) {\n    if (extra < this.tagLength) {\n      throw new Error(\"data too short\");\n    }\n    extra -= this.tagLength;\n  }\n\n  if (extra > 0) {\n    this.gCTRPartial(this.bufBlock, 0, extra, out, outOff + resultLen);\n    resultLen += extra;\n  }\n\n  this.atLength = this.atLength.add(this.atBlockPos);\n\n  // Final gHASH\n  var X = this.zeroBlock();\n  pack.longToBigEndian(this.atLength.multiply(8),\n                       X,\n                       0);\n  pack.longToBigEndian(this.totalLength.multiply(8),\n                       X,\n                       8);\n\n  this.gHASHBlock(this.S, X);\n\n  // TODO Fix this if tagLength becomes configurable\n  // T = MSBt(GCTRk(J0,S))\n  var tag = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.J0, 0, tag, 0);\n  this.xor(tag, this.S);\n\n  if (this._decrypt) {\n    if (!helpers.arrayEqual(this.tag, tag)) {\n      throw new Error(\"mac check in Gcm failed\");\n    }\n  } else {\n    // We place into tag our calculated value for T\n    this.tag = Buffer.alloc(this.tagLength);\n    tag.copy(this.tag, 0, 0, this.tagLength);\n  }\n\n  return resultLen;\n};\n\n// ### \"Internal\" Helper Functions\nGcm.prototype.initCipher = function() {\n  if (this.atLength.greaterThan(Long.ZERO)) {\n    this.SAt.copy(this.SAtPre, 0, 0, this.blockSize);\n    this.atLengthPre = this.atLength.add(Long.ZERO);\n  }\n\n  // Finish hash for partial AAD block\n  if (this.atBlockPos > 0) {\n    this.gHASHPartial(this.SAtPre, this.atBlock, 0, this.atBlockPos);\n    this.atLengthPre = this.atLengthPre.add(this.atBlockPos);\n  }\n\n  if (this.atLengthPre.greaterThan(Long.ZERO)) {\n    this.SAtPre.copy(this.S, 0, 0, this.blockSize);\n  }\n};\n\nGcm.prototype.outputBlock = function(output, offset) {\n  if (this.totalLength.isZero()) {\n    this.initCipher();\n  }\n  this.gCTRBlock(this.bufBlock, output, offset);\n  if (!this._decrypt) {\n    this.bufOff = 0;\n  } else {\n    this.bufBlock.copy(this.bufBlock, 0, this.blockSize, this.blockSize + this.tagLength);\n    this.bufOff = this.tagLength;\n  }\n};\n\nGcm.prototype.processAADBytes = function(inV, inOff, len) {\n  for (var i = 0; i < len; ++i) {\n    this.atBlock[this.atBlockPos] = inV[inOff + i];\n    if (++this.atBlockPos === this.blockSize) {\n      // Hash each block as it fills\n      this.gHASHBlock(this.SAt, this.atBlock);\n      this.atBlockPos = 0;\n      this.atLength = this.atLength.add(this.blockSize);\n    }\n  }\n};\n\nGcm.prototype.getNextCounterBlock = function() {\n  for (var i = 15; i >= 12; --i) {\n    var b = ((this.counter[i] + 1) & 0xff);\n    this.counter[i] = b;\n\n    if (b !== 0) {\n      break;\n    }\n  }\n\n  // encrypt counter\n  var outb = Buffer.alloc(this.blockSize);\n  cipherHelpers.encrypt(this.cipher, this.counter, 0, outb, 0);\n\n  return outb;\n};\n\nGcm.prototype.gCTRBlock = function(block, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, block);\n  tmp.copy(out, outOff, 0, this.blockSize);\n\n  this.gHASHBlock(this.S, !this._decrypt ? tmp : block);\n\n  this.totalLength = this.totalLength.add(this.blockSize);\n};\nGcm.prototype.gCTRPartial = function(buf, off, len, out, outOff) {\n  var tmp = this.getNextCounterBlock();\n\n  this.xor(tmp, buf, off, len);\n  tmp.copy(out, outOff, 0, len);\n\n  this.gHASHPartial(this.S, !this._decrypt ? tmp : buf, 0, len);\n\n  this.totalLength = this.totalLength.add(len);\n};\n\nGcm.prototype.gHASHBlock = function(Y, b) {\n  this.xor(Y, b);\n  this.multiplier.multiplyH(Y);\n};\nGcm.prototype.gHASHPartial = function(Y, b, off, len) {\n  this.xor(Y, b, off, len);\n  this.multiplier.multiplyH(Y);\n};\n\nGcm.prototype.xor = function(block, val, off, len) {\n  switch (arguments.length) {\n    case 2:\n      for (var i = 15; i >= 0; --i) {\n        block[i] ^= val[i];\n      }\n      break;\n    case 4:\n      while (len-- > 0) {\n        block[len] ^= val[off + len];\n      }\n      break;\n    default:\n      throw new TypeError(\"Expected 2 or 4 arguments.\");\n  }\n\n  return block;\n};\n\nGcm.prototype.zeroBlock = function() {\n  var block = Buffer.alloc(BLOCK_SIZE);\n  return block;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxXQUFXLG1CQUFPLENBQUMsb0RBQU07QUFDekIsWUFBWSxtQkFBTyxDQUFDLGdGQUF3QjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyxnR0FBa0I7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLHdGQUFjO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQywrRUFBWTtBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQywwRkFBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMscUZBQWU7O0FBRTNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9jaXBoZXJtb2Rlcy9nY20vaW5kZXguanM/NGUwZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvY2lwaGVybW9kZXMvZ2NtL2luZGV4LmpzIC0gQUVTLUdDTSBpbXBsZW1lbnRhdGlvbiBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG4gXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMb25nID0gcmVxdWlyZShcImxvbmdcIiksXG4gICAgZm9yZ2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBtdWx0aXBsaWVycyA9IHJlcXVpcmUoXCIuL211bHRpcGxpZXJzLmpzXCIpLFxuICAgIGhlbHBlcnMgPSByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpLFxuICAgIHBhY2sgPSByZXF1aXJlKFwiLi4vcGFjay5qc1wiKSxcbiAgICBEYXRhQnVmZmVyID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWwvZGF0YWJ1ZmZlci5qc1wiKSxcbiAgICBjaXBoZXJIZWxwZXJzID0gcmVxdWlyZShcIi4uL2hlbHBlcnMuanNcIik7XG5cbnZhciBCTE9DS19TSVpFID0gMTY7XG5cbi8vICMjIyBHQ00gTW9kZVxuLy8gIyMjIENvbnN0cnVjdG9yXG5mdW5jdGlvbiBHY20ob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLm5hbWUgPSBcIkdDTVwiO1xuICB0aGlzLmNpcGhlciA9IG9wdGlvbnMuY2lwaGVyO1xuICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplIHx8IDE2O1xufVxuXG4vLyAjIyMgZXhwb3J0c1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZUNpcGhlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBhbGcgPSBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShcIkFFUy1HQ01cIiwgR2NtKTtcbiAgICBhbGcuaW5pdGlhbGl6ZSh7XG4gICAgICBrZXk6IG5ldyBEYXRhQnVmZmVyKG9wdGlvbnMua2V5KVxuICAgIH0pO1xuICAgIGFsZy5tb2RlLnN0YXJ0KG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIGFsZy5tb2RlO1xuICB9LFxuICBjcmVhdGVEZWNpcGhlcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBhbGcgPSBuZXcgZm9yZ2UuYWVzLkFsZ29yaXRobShcIkFFUy1HQ01cIiwgR2NtKTtcbiAgICBhbGcuaW5pdGlhbGl6ZSh7XG4gICAgICBrZXk6IG5ldyBEYXRhQnVmZmVyKG9wdGlvbnMua2V5KVxuICAgIH0pO1xuICAgIGFsZy5tb2RlLl9kZWNyeXB0ID0gdHJ1ZTtcbiAgICBhbGcubW9kZS5zdGFydChvcHRpb25zKTtcblxuICAgIHJldHVybiBhbGcubW9kZTtcbiAgfVxufTtcblxuLy8gIyMjIFB1YmxpYyBBUElcbkdjbS5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHRoaXMudGFnID0gbnVsbDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoIShcIml2XCIgaW4gb3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHY20gbmVlZHMgUGFyYW1ldGVyc1dpdGhJViBvciBBRUFEUGFyYW1ldGVyc1wiKTtcbiAgfVxuICB0aGlzLm5vbmNlID0gb3B0aW9ucy5pdjtcbiAgaWYgKHRoaXMubm9uY2UgPT0gbnVsbCB8fCB0aGlzLm5vbmNlLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJViBtdXN0IGJlIGF0IGxlYXN0IDEgYnl0ZVwiKTtcbiAgfVxuXG4gIC8vIFRPRE86IHZhcmlhYmxlIHRhZ0xlbmd0aD9cbiAgdGhpcy50YWdMZW5ndGggPSAxNjtcblxuICAvLyBUT0RPOiB2YWxpZGF0ZSB0YWdcbiAgaWYgKFwidGFnXCIgaW4gb3B0aW9ucykge1xuICAgIHRoaXMudGFnID0gQnVmZmVyLmZyb20ob3B0aW9ucy50YWcpO1xuICB9XG5cbiAgdmFyIGJ1Zkxlbmd0aCA9ICF0aGlzLl9kZWNyeXB0ID9cbiAgICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTaXplIDpcbiAgICAgICAgICAgICAgICAgICh0aGlzLmJsb2NrU2l6ZSArIHRoaXMudGFnTGVuZ3RoKTtcbiAgdGhpcy5idWZCbG9jayA9IEJ1ZmZlci5hbGxvYyhidWZMZW5ndGgpO1xuXG4gIHZhciBtdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICBpZiAobXVsdGlwbGllciA9PSBudWxsKSB7XG4gICAgbXVsdGlwbGllciA9IG5ldyAobXVsdGlwbGllcnNbXCI4a1wiXSkoKTtcbiAgfVxuICB0aGlzLm11bHRpcGxpZXIgPSBtdWx0aXBsaWVyO1xuXG4gIHRoaXMuSCA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIGNpcGhlckhlbHBlcnMuZW5jcnlwdCh0aGlzLmNpcGhlciwgdGhpcy5ILCAwLCB0aGlzLkgsIDApO1xuXG4gIC8vIEdjbU11bHRpcGxpZXIgdGFibGVzIGRvblwidCBjaGFuZ2UgdW5sZXNzIHRoZSBrZXkgY2hhbmdlc1xuICAvLyAoYW5kIGFyZSBleHBlbnNpdmUgdG8gaW5pdClcbiAgdGhpcy5tdWx0aXBsaWVyLmluaXQodGhpcy5IKTtcbiAgdGhpcy5leHAgPSBudWxsO1xuXG4gIHRoaXMuSjAgPSB0aGlzLnplcm9CbG9jaygpO1xuXG4gIGlmICh0aGlzLm5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICB0aGlzLm5vbmNlLmNvcHkodGhpcy5KMCwgMCwgMCwgdGhpcy5ub25jZS5sZW5ndGgpO1xuICAgIHRoaXMuSjBbdGhpcy5ibG9ja1NpemUgLSAxXSA9IDB4MDE7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5nSEFTSCh0aGlzLkowLCB0aGlzLm5vbmNlLCB0aGlzLm5vbmNlLmxlbmd0aCk7XG4gICAgdmFyIFggPSB0aGlzLnplcm9CbG9jaygpO1xuICAgIHBhY2subG9uZ1RvQmlnRW5kaWFuKG5ldyBMb25nKHRoaXMubm9uY2UubGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBseSg4KSwgWCwgOCk7XG4gICAgdGhpcy5nSEFTSEJsb2NrKHRoaXMuSjAsIFgpO1xuICB9XG5cbiAgdGhpcy5TID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgdGhpcy5TQXQgPSB0aGlzLnplcm9CbG9jaygpO1xuICB0aGlzLlNBdFByZSA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIHRoaXMuYXRCbG9jayA9IHRoaXMuemVyb0Jsb2NrKCk7XG4gIHRoaXMuYXRCbG9ja1BvcyA9IDA7XG4gIHRoaXMuYXRMZW5ndGggPSBMb25nLlpFUk87XG4gIHRoaXMuYXRMZW5ndGhQcmUgPSBMb25nLlpFUk87XG4gIHRoaXMuY291bnRlciA9IEJ1ZmZlci5mcm9tKHRoaXMuSjApO1xuICB0aGlzLmJ1Zk9mZiA9IDA7XG4gIHRoaXMudG90YWxMZW5ndGggPSBMb25nLlpFUk87XG5cbiAgaWYgKFwiYWRkaXRpb25hbERhdGFcIiBpbiBvcHRpb25zKSB7XG4gICAgdGhpcy5wcm9jZXNzQUFEQnl0ZXMob3B0aW9ucy5hZGRpdGlvbmFsRGF0YSwgMCwgb3B0aW9ucy5hZGRpdGlvbmFsRGF0YS5sZW5ndGgpO1xuICB9XG59O1xuXG5HY20ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKGluViwgaW5PZmYsIGxlbiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHJlc3VsdExlbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICB2YXIgaW5MZW4gPSBNYXRoLm1pbihsZW4sIHRoaXMuYnVmQmxvY2subGVuZ3RoIC0gdGhpcy5idWZPZmYpO1xuICAgIGluVi5jb3B5KHRoaXMuYnVmQmxvY2ssIHRoaXMuYnVmT2ZmLCBpbk9mZiwgaW5PZmYgKyBpbkxlbik7XG4gICAgbGVuIC09IGluTGVuO1xuICAgIGluT2ZmICs9IGluTGVuO1xuICAgIHRoaXMuYnVmT2ZmICs9IGluTGVuO1xuICAgIGlmICh0aGlzLmJ1Zk9mZiA9PT0gdGhpcy5idWZCbG9jay5sZW5ndGgpIHtcbiAgICAgIHRoaXMub3V0cHV0QmxvY2sob3V0LCBvdXRPZmYgKyByZXN1bHRMZW4pO1xuICAgICAgcmVzdWx0TGVuICs9IHRoaXMuYmxvY2tTaXplO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRMZW47XG59O1xuR2NtLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihvdXQsIG91dE9mZikge1xuICB2YXIgcmVzdWx0TGVuID0gMDtcblxuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIC8vIGFwcGVuZCB0YWdcbiAgICByZXN1bHRMZW4gKz0gdGhpcy51cGRhdGUodGhpcy50YWcsIDAsIHRoaXMudGFnLmxlbmd0aCwgb3V0LCBvdXRPZmYpO1xuICB9XG5cbiAgaWYgKHRoaXMudG90YWxMZW5ndGguaXNaZXJvKCkpIHtcbiAgICB0aGlzLmluaXRDaXBoZXIoKTtcbiAgfVxuXG4gIHZhciBleHRyYSA9IHRoaXMuYnVmT2ZmO1xuICBpZiAodGhpcy5fZGVjcnlwdCkge1xuICAgIGlmIChleHRyYSA8IHRoaXMudGFnTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiKTtcbiAgICB9XG4gICAgZXh0cmEgLT0gdGhpcy50YWdMZW5ndGg7XG4gIH1cblxuICBpZiAoZXh0cmEgPiAwKSB7XG4gICAgdGhpcy5nQ1RSUGFydGlhbCh0aGlzLmJ1ZkJsb2NrLCAwLCBleHRyYSwgb3V0LCBvdXRPZmYgKyByZXN1bHRMZW4pO1xuICAgIHJlc3VsdExlbiArPSBleHRyYTtcbiAgfVxuXG4gIHRoaXMuYXRMZW5ndGggPSB0aGlzLmF0TGVuZ3RoLmFkZCh0aGlzLmF0QmxvY2tQb3MpO1xuXG4gIC8vIEZpbmFsIGdIQVNIXG4gIHZhciBYID0gdGhpcy56ZXJvQmxvY2soKTtcbiAgcGFjay5sb25nVG9CaWdFbmRpYW4odGhpcy5hdExlbmd0aC5tdWx0aXBseSg4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgWCxcbiAgICAgICAgICAgICAgICAgICAgICAgMCk7XG4gIHBhY2subG9uZ1RvQmlnRW5kaWFuKHRoaXMudG90YWxMZW5ndGgubXVsdGlwbHkoOCksXG4gICAgICAgICAgICAgICAgICAgICAgIFgsXG4gICAgICAgICAgICAgICAgICAgICAgIDgpO1xuXG4gIHRoaXMuZ0hBU0hCbG9jayh0aGlzLlMsIFgpO1xuXG4gIC8vIFRPRE8gRml4IHRoaXMgaWYgdGFnTGVuZ3RoIGJlY29tZXMgY29uZmlndXJhYmxlXG4gIC8vIFQgPSBNU0J0KEdDVFJrKEowLFMpKVxuICB2YXIgdGFnID0gQnVmZmVyLmFsbG9jKHRoaXMuYmxvY2tTaXplKTtcbiAgY2lwaGVySGVscGVycy5lbmNyeXB0KHRoaXMuY2lwaGVyLCB0aGlzLkowLCAwLCB0YWcsIDApO1xuICB0aGlzLnhvcih0YWcsIHRoaXMuUyk7XG5cbiAgaWYgKHRoaXMuX2RlY3J5cHQpIHtcbiAgICBpZiAoIWhlbHBlcnMuYXJyYXlFcXVhbCh0aGlzLnRhZywgdGFnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWFjIGNoZWNrIGluIEdjbSBmYWlsZWRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdlIHBsYWNlIGludG8gdGFnIG91ciBjYWxjdWxhdGVkIHZhbHVlIGZvciBUXG4gICAgdGhpcy50YWcgPSBCdWZmZXIuYWxsb2ModGhpcy50YWdMZW5ndGgpO1xuICAgIHRhZy5jb3B5KHRoaXMudGFnLCAwLCAwLCB0aGlzLnRhZ0xlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0TGVuO1xufTtcblxuLy8gIyMjIFwiSW50ZXJuYWxcIiBIZWxwZXIgRnVuY3Rpb25zXG5HY20ucHJvdG90eXBlLmluaXRDaXBoZXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuYXRMZW5ndGguZ3JlYXRlclRoYW4oTG9uZy5aRVJPKSkge1xuICAgIHRoaXMuU0F0LmNvcHkodGhpcy5TQXRQcmUsIDAsIDAsIHRoaXMuYmxvY2tTaXplKTtcbiAgICB0aGlzLmF0TGVuZ3RoUHJlID0gdGhpcy5hdExlbmd0aC5hZGQoTG9uZy5aRVJPKTtcbiAgfVxuXG4gIC8vIEZpbmlzaCBoYXNoIGZvciBwYXJ0aWFsIEFBRCBibG9ja1xuICBpZiAodGhpcy5hdEJsb2NrUG9zID4gMCkge1xuICAgIHRoaXMuZ0hBU0hQYXJ0aWFsKHRoaXMuU0F0UHJlLCB0aGlzLmF0QmxvY2ssIDAsIHRoaXMuYXRCbG9ja1Bvcyk7XG4gICAgdGhpcy5hdExlbmd0aFByZSA9IHRoaXMuYXRMZW5ndGhQcmUuYWRkKHRoaXMuYXRCbG9ja1Bvcyk7XG4gIH1cblxuICBpZiAodGhpcy5hdExlbmd0aFByZS5ncmVhdGVyVGhhbihMb25nLlpFUk8pKSB7XG4gICAgdGhpcy5TQXRQcmUuY29weSh0aGlzLlMsIDAsIDAsIHRoaXMuYmxvY2tTaXplKTtcbiAgfVxufTtcblxuR2NtLnByb3RvdHlwZS5vdXRwdXRCbG9jayA9IGZ1bmN0aW9uKG91dHB1dCwgb2Zmc2V0KSB7XG4gIGlmICh0aGlzLnRvdGFsTGVuZ3RoLmlzWmVybygpKSB7XG4gICAgdGhpcy5pbml0Q2lwaGVyKCk7XG4gIH1cbiAgdGhpcy5nQ1RSQmxvY2sodGhpcy5idWZCbG9jaywgb3V0cHV0LCBvZmZzZXQpO1xuICBpZiAoIXRoaXMuX2RlY3J5cHQpIHtcbiAgICB0aGlzLmJ1Zk9mZiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5idWZCbG9jay5jb3B5KHRoaXMuYnVmQmxvY2ssIDAsIHRoaXMuYmxvY2tTaXplLCB0aGlzLmJsb2NrU2l6ZSArIHRoaXMudGFnTGVuZ3RoKTtcbiAgICB0aGlzLmJ1Zk9mZiA9IHRoaXMudGFnTGVuZ3RoO1xuICB9XG59O1xuXG5HY20ucHJvdG90eXBlLnByb2Nlc3NBQURCeXRlcyA9IGZ1bmN0aW9uKGluViwgaW5PZmYsIGxlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdGhpcy5hdEJsb2NrW3RoaXMuYXRCbG9ja1Bvc10gPSBpblZbaW5PZmYgKyBpXTtcbiAgICBpZiAoKyt0aGlzLmF0QmxvY2tQb3MgPT09IHRoaXMuYmxvY2tTaXplKSB7XG4gICAgICAvLyBIYXNoIGVhY2ggYmxvY2sgYXMgaXQgZmlsbHNcbiAgICAgIHRoaXMuZ0hBU0hCbG9jayh0aGlzLlNBdCwgdGhpcy5hdEJsb2NrKTtcbiAgICAgIHRoaXMuYXRCbG9ja1BvcyA9IDA7XG4gICAgICB0aGlzLmF0TGVuZ3RoID0gdGhpcy5hdExlbmd0aC5hZGQodGhpcy5ibG9ja1NpemUpO1xuICAgIH1cbiAgfVxufTtcblxuR2NtLnByb3RvdHlwZS5nZXROZXh0Q291bnRlckJsb2NrID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAxNTsgaSA+PSAxMjsgLS1pKSB7XG4gICAgdmFyIGIgPSAoKHRoaXMuY291bnRlcltpXSArIDEpICYgMHhmZik7XG4gICAgdGhpcy5jb3VudGVyW2ldID0gYjtcblxuICAgIGlmIChiICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBlbmNyeXB0IGNvdW50ZXJcbiAgdmFyIG91dGIgPSBCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1NpemUpO1xuICBjaXBoZXJIZWxwZXJzLmVuY3J5cHQodGhpcy5jaXBoZXIsIHRoaXMuY291bnRlciwgMCwgb3V0YiwgMCk7XG5cbiAgcmV0dXJuIG91dGI7XG59O1xuXG5HY20ucHJvdG90eXBlLmdDVFJCbG9jayA9IGZ1bmN0aW9uKGJsb2NrLCBvdXQsIG91dE9mZikge1xuICB2YXIgdG1wID0gdGhpcy5nZXROZXh0Q291bnRlckJsb2NrKCk7XG5cbiAgdGhpcy54b3IodG1wLCBibG9jayk7XG4gIHRtcC5jb3B5KG91dCwgb3V0T2ZmLCAwLCB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgdGhpcy5nSEFTSEJsb2NrKHRoaXMuUywgIXRoaXMuX2RlY3J5cHQgPyB0bXAgOiBibG9jayk7XG5cbiAgdGhpcy50b3RhbExlbmd0aCA9IHRoaXMudG90YWxMZW5ndGguYWRkKHRoaXMuYmxvY2tTaXplKTtcbn07XG5HY20ucHJvdG90eXBlLmdDVFJQYXJ0aWFsID0gZnVuY3Rpb24oYnVmLCBvZmYsIGxlbiwgb3V0LCBvdXRPZmYpIHtcbiAgdmFyIHRtcCA9IHRoaXMuZ2V0TmV4dENvdW50ZXJCbG9jaygpO1xuXG4gIHRoaXMueG9yKHRtcCwgYnVmLCBvZmYsIGxlbik7XG4gIHRtcC5jb3B5KG91dCwgb3V0T2ZmLCAwLCBsZW4pO1xuXG4gIHRoaXMuZ0hBU0hQYXJ0aWFsKHRoaXMuUywgIXRoaXMuX2RlY3J5cHQgPyB0bXAgOiBidWYsIDAsIGxlbik7XG5cbiAgdGhpcy50b3RhbExlbmd0aCA9IHRoaXMudG90YWxMZW5ndGguYWRkKGxlbik7XG59O1xuXG5HY20ucHJvdG90eXBlLmdIQVNIQmxvY2sgPSBmdW5jdGlvbihZLCBiKSB7XG4gIHRoaXMueG9yKFksIGIpO1xuICB0aGlzLm11bHRpcGxpZXIubXVsdGlwbHlIKFkpO1xufTtcbkdjbS5wcm90b3R5cGUuZ0hBU0hQYXJ0aWFsID0gZnVuY3Rpb24oWSwgYiwgb2ZmLCBsZW4pIHtcbiAgdGhpcy54b3IoWSwgYiwgb2ZmLCBsZW4pO1xuICB0aGlzLm11bHRpcGxpZXIubXVsdGlwbHlIKFkpO1xufTtcblxuR2NtLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbihibG9jaywgdmFsLCBvZmYsIGxlbikge1xuICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBjYXNlIDI6XG4gICAgICBmb3IgKHZhciBpID0gMTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGJsb2NrW2ldIF49IHZhbFtpXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHdoaWxlIChsZW4tLSA+IDApIHtcbiAgICAgICAgYmxvY2tbbGVuXSBePSB2YWxbb2ZmICsgbGVuXTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMiBvciA0IGFyZ3VtZW50cy5cIik7XG4gIH1cblxuICByZXR1cm4gYmxvY2s7XG59O1xuXG5HY20ucHJvdG90eXBlLnplcm9CbG9jayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYmxvY2sgPSBCdWZmZXIuYWxsb2MoQkxPQ0tfU0laRSk7XG4gIHJldHVybiBibG9jaztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/gcm/multipliers.js - AES-GCM Multipliers\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n \n\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/helpers.js\"),\n    pack = __webpack_require__(/*! ../pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\n\n// ### 8K Table Multiplier\nfunction Gcm8KMultiplier() {\n  this.H = [];\n  this.M = null;\n}\n\nGcm8KMultiplier.prototype.init = function(H) {\n  var i, j, k;\n  if (this.M == null) {\n    // sc: I realize this UGLY...\n    //M = new int[32][16][4];\n    this.M = [];\n    for (i = 0; i < 32; ++i) {\n      this.M[i] = [];\n      for (j = 0; j < 16; ++j) {\n        this.M[i][j] = [];\n        for (k = 0; k < 4; ++k) {\n          this.M[i][j][k] = 0;\n        }\n      }\n    }\n  } else if (helpers.arrayEqual(this.H, H)) {\n    return;\n  }\n\n  this.H = H.slice();\n\n  // M[0][0] is ZEROES;\n  // M[1][0] is ZEROES;\n  helpers.asInts(H, this.M[1][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[1][j + j], this.M[1][j]);\n  }\n  helpers.multiplyP(this.M[1][1], this.M[0][8]);\n\n  for (j = 4; j >= 1; j >>= 1) {\n    helpers.multiplyP(this.M[0][j + j], this.M[0][j]);\n  }\n\n  i = 0;\n  for (;;) {\n    for (j = 2; j < 16; j += j) {\n      for (k = 1; k < j; ++k) {\n        helpers.xor(this.M[i][j], this.M[i][k], this.M[i][j + k]);\n      }\n    }\n\n    if (++i === 32) {\n      return;\n    }\n\n    if (i > 1) {\n      // M[i][0] is ZEROES;\n      for (j = 8; j > 0; j >>= 1) {\n        helpers.multiplyP8(this.M[i - 2][j], this.M[i][j]);\n      }\n    }\n  }\n};\nGcm8KMultiplier.prototype.multiplyH = function(x) {\n  var z = [];\n  for (var i = 15; i >= 0; --i) {\n    var m = this.M[i + i][x[i] & 0x0f];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n    m = this.M[i + i + 1][(x[i] & 0xf0) >>> 4];\n    z[0] ^= m[0];\n    z[1] ^= m[1];\n    z[2] ^= m[2];\n    z[3] ^= m[3];\n  }\n\n  pack.intToBigEndian(z, x, 0);\n};\n\n\nmodule.exports = {\n  \"8k\": Gcm8KMultiplier\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2djbS9tdWx0aXBsaWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBYzs7QUFFZCxjQUFjLG1CQUFPLENBQUMsd0ZBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLCtFQUFZOzs7QUFHL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsUUFBUTtBQUN4QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9jaXBoZXJtb2Rlcy9nY20vbXVsdGlwbGllcnMuanM/MWMwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGRlcHMvY2lwaGVybW9kZXMvZ2NtL211bHRpcGxpZXJzLmpzIC0gQUVTLUdDTSBNdWx0aXBsaWVyc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG4gXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKSxcbiAgICBwYWNrID0gcmVxdWlyZShcIi4uL3BhY2suanNcIik7XG5cblxuLy8gIyMjIDhLIFRhYmxlIE11bHRpcGxpZXJcbmZ1bmN0aW9uIEdjbThLTXVsdGlwbGllcigpIHtcbiAgdGhpcy5IID0gW107XG4gIHRoaXMuTSA9IG51bGw7XG59XG5cbkdjbThLTXVsdGlwbGllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKEgpIHtcbiAgdmFyIGksIGosIGs7XG4gIGlmICh0aGlzLk0gPT0gbnVsbCkge1xuICAgIC8vIHNjOiBJIHJlYWxpemUgdGhpcyBVR0xZLi4uXG4gICAgLy9NID0gbmV3IGludFszMl1bMTZdWzRdO1xuICAgIHRoaXMuTSA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7XG4gICAgICB0aGlzLk1baV0gPSBbXTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICAgIHRoaXMuTVtpXVtqXSA9IFtdO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgNDsgKytrKSB7XG4gICAgICAgICAgdGhpcy5NW2ldW2pdW2tdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWxwZXJzLmFycmF5RXF1YWwodGhpcy5ILCBIKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuSCA9IEguc2xpY2UoKTtcblxuICAvLyBNWzBdWzBdIGlzIFpFUk9FUztcbiAgLy8gTVsxXVswXSBpcyBaRVJPRVM7XG4gIGhlbHBlcnMuYXNJbnRzKEgsIHRoaXMuTVsxXVs4XSk7XG5cbiAgZm9yIChqID0gNDsgaiA+PSAxOyBqID4+PSAxKSB7XG4gICAgaGVscGVycy5tdWx0aXBseVAodGhpcy5NWzFdW2ogKyBqXSwgdGhpcy5NWzFdW2pdKTtcbiAgfVxuICBoZWxwZXJzLm11bHRpcGx5UCh0aGlzLk1bMV1bMV0sIHRoaXMuTVswXVs4XSk7XG5cbiAgZm9yIChqID0gNDsgaiA+PSAxOyBqID4+PSAxKSB7XG4gICAgaGVscGVycy5tdWx0aXBseVAodGhpcy5NWzBdW2ogKyBqXSwgdGhpcy5NWzBdW2pdKTtcbiAgfVxuXG4gIGkgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgZm9yIChqID0gMjsgaiA8IDE2OyBqICs9IGopIHtcbiAgICAgIGZvciAoayA9IDE7IGsgPCBqOyArK2spIHtcbiAgICAgICAgaGVscGVycy54b3IodGhpcy5NW2ldW2pdLCB0aGlzLk1baV1ba10sIHRoaXMuTVtpXVtqICsga10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICgrK2kgPT09IDMyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGkgPiAxKSB7XG4gICAgICAvLyBNW2ldWzBdIGlzIFpFUk9FUztcbiAgICAgIGZvciAoaiA9IDg7IGogPiAwOyBqID4+PSAxKSB7XG4gICAgICAgIGhlbHBlcnMubXVsdGlwbHlQOCh0aGlzLk1baSAtIDJdW2pdLCB0aGlzLk1baV1bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkdjbThLTXVsdGlwbGllci5wcm90b3R5cGUubXVsdGlwbHlIID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeiA9IFtdO1xuICBmb3IgKHZhciBpID0gMTU7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIG0gPSB0aGlzLk1baSArIGldW3hbaV0gJiAweDBmXTtcbiAgICB6WzBdIF49IG1bMF07XG4gICAgelsxXSBePSBtWzFdO1xuICAgIHpbMl0gXj0gbVsyXTtcbiAgICB6WzNdIF49IG1bM107XG4gICAgbSA9IHRoaXMuTVtpICsgaSArIDFdWyh4W2ldICYgMHhmMCkgPj4+IDRdO1xuICAgIHpbMF0gXj0gbVswXTtcbiAgICB6WzFdIF49IG1bMV07XG4gICAgelsyXSBePSBtWzJdO1xuICAgIHpbM10gXj0gbVszXTtcbiAgfVxuXG4gIHBhY2suaW50VG9CaWdFbmRpYW4oeiwgeCwgMCk7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjhrXCI6IEdjbThLTXVsdGlwbGllclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/gcm/multipliers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/helpers.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/helpers.js - Cipher Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar pack = __webpack_require__(/*! ./pack.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\");\n\nfunction doEncrypt(cipher, inb, inOff, outb, outOff) {\n  var input = new Array(4),\n      output = new Array(4);\n\n  pack.bigEndianToInt(inb, inOff, input);\n  cipher.encrypt(input, output);\n  pack.intToBigEndian(output, outb, outOff);\n}\n\nmodule.exports = {\n  encrypt: doEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyw4RUFBVzs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvY2lwaGVybW9kZXMvaGVscGVycy5qcz83Y2FmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9jaXBoZXJtb2Rlcy9oZWxwZXJzLmpzIC0gQ2lwaGVyIEhlbHBlciBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBwYWNrID0gcmVxdWlyZShcIi4vcGFjay5qc1wiKTtcblxuZnVuY3Rpb24gZG9FbmNyeXB0KGNpcGhlciwgaW5iLCBpbk9mZiwgb3V0Yiwgb3V0T2ZmKSB7XG4gIHZhciBpbnB1dCA9IG5ldyBBcnJheSg0KSxcbiAgICAgIG91dHB1dCA9IG5ldyBBcnJheSg0KTtcblxuICBwYWNrLmJpZ0VuZGlhblRvSW50KGluYiwgaW5PZmYsIGlucHV0KTtcbiAgY2lwaGVyLmVuY3J5cHQoaW5wdXQsIG91dHB1dCk7XG4gIHBhY2suaW50VG9CaWdFbmRpYW4ob3V0cHV0LCBvdXRiLCBvdXRPZmYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jcnlwdDogZG9FbmNyeXB0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ciphermodes/pack.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/ciphermodes/pack.js - Pack/Unpack Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\n\nvar pack = module.exports = {\n  intToBigEndian: function(n, bs, off) {\n    if (typeof n === \"number\") {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          bs[off] = 0xff & (n >>> 24);\n          bs[++off] = 0xff & (n >>> 16);\n          bs[++off] = 0xff & (n >>> 8);\n          bs[++off] = 0xff & (n);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(4 * n.length);\n          pack.intToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.intToBigEndian(n[i], bs, off);\n            off += 4;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n  longToBigEndian: function(n, bs, off) {\n    if (!Array.isArray(n)) {\n      // Single\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          var lo = n.low,\n              hi = n.high;\n          pack.intToBigEndian(hi, bs, off);\n          pack.intToBigEndian(lo, bs, off + 4);\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    } else {\n      // Array\n      switch (arguments.length) {\n        case 1:\n          bs = Buffer.alloc(8 * n.length);\n          pack.longToBigEndian(n, bs, 0);\n          break;\n        case 3:\n          for (var i = 0; i < n.length; ++i) {\n            pack.longToBigEndian(n[i], bs, off);\n            off += 8;\n          }\n          break;\n        default:\n          throw new TypeError(\"Expected 1 or 3 arguments.\");\n      }\n    }\n\n    return bs;\n  },\n\n  bigEndianToInt: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var n = bs[off] << 24;\n        n |= (bs[++off] & 0xff) << 16;\n        n |= (bs[++off] & 0xff) << 8;\n        n |= (bs[++off] & 0xff);\n        return n;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToInt(bs, off);\n          off += 4;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  },\n  bigEndianToLong: function(bs, off, ns) {\n    switch (arguments.length) {\n      case 2:\n        var hi = pack.bigEndianToInt(bs, off);\n        var lo = pack.bigEndianToInt(bs, off + 4);\n        var num = new Long(lo, hi);\n        return num;\n      case 3:\n        for (var i = 0; i < ns.length; ++i) {\n          ns[i] = pack.bigEndianToLong(bs, off);\n          off += 8;\n        }\n        break;\n      default:\n        throw new TypeError(\"Expected 2 or 3 arguments.\");\n    }\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2NpcGhlcm1vZGVzL3BhY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxvREFBTTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9jaXBoZXJtb2Rlcy9wYWNrLmpzP2FhNTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBkZXBzL2NpcGhlcm1vZGVzL3BhY2suanMgLSBQYWNrL1VucGFjayBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5cbnZhciBwYWNrID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGludFRvQmlnRW5kaWFuOiBmdW5jdGlvbihuLCBicywgb2ZmKSB7XG4gICAgaWYgKHR5cGVvZiBuID09PSBcIm51bWJlclwiKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJzID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgIHBhY2suaW50VG9CaWdFbmRpYW4obiwgYnMsIDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgYnNbb2ZmXSA9IDB4ZmYgJiAobiA+Pj4gMjQpO1xuICAgICAgICAgIGJzWysrb2ZmXSA9IDB4ZmYgJiAobiA+Pj4gMTYpO1xuICAgICAgICAgIGJzWysrb2ZmXSA9IDB4ZmYgJiAobiA+Pj4gOCk7XG4gICAgICAgICAgYnNbKytvZmZdID0gMHhmZiAmIChuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnMgPSBCdWZmZXIuYWxsb2MoNCAqIG4ubGVuZ3RoKTtcbiAgICAgICAgICBwYWNrLmludFRvQmlnRW5kaWFuKG4sIGJzLCAwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbi5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbihuW2ldLCBicywgb2ZmKTtcbiAgICAgICAgICAgIG9mZiArPSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgMSBvciAzIGFyZ3VtZW50cy5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJzO1xuICB9LFxuICBsb25nVG9CaWdFbmRpYW46IGZ1bmN0aW9uKG4sIGJzLCBvZmYpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobikpIHtcbiAgICAgIC8vIFNpbmdsZVxuICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBicyA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICAgICAgICBwYWNrLmxvbmdUb0JpZ0VuZGlhbihuLCBicywgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB2YXIgbG8gPSBuLmxvdyxcbiAgICAgICAgICAgICAgaGkgPSBuLmhpZ2g7XG4gICAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbihoaSwgYnMsIG9mZik7XG4gICAgICAgICAgcGFjay5pbnRUb0JpZ0VuZGlhbihsbywgYnMsIG9mZiArIDQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXJyYXlcbiAgICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnMgPSBCdWZmZXIuYWxsb2MoOCAqIG4ubGVuZ3RoKTtcbiAgICAgICAgICBwYWNrLmxvbmdUb0JpZ0VuZGlhbihuLCBicywgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHBhY2subG9uZ1RvQmlnRW5kaWFuKG5baV0sIGJzLCBvZmYpO1xuICAgICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAxIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnM7XG4gIH0sXG5cbiAgYmlnRW5kaWFuVG9JbnQ6IGZ1bmN0aW9uKGJzLCBvZmYsIG5zKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHZhciBuID0gYnNbb2ZmXSA8PCAyNDtcbiAgICAgICAgbiB8PSAoYnNbKytvZmZdICYgMHhmZikgPDwgMTY7XG4gICAgICAgIG4gfD0gKGJzWysrb2ZmXSAmIDB4ZmYpIDw8IDg7XG4gICAgICAgIG4gfD0gKGJzWysrb2ZmXSAmIDB4ZmYpO1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIG5zW2ldID0gcGFjay5iaWdFbmRpYW5Ub0ludChicywgb2ZmKTtcbiAgICAgICAgICBvZmYgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAyIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH0sXG4gIGJpZ0VuZGlhblRvTG9uZzogZnVuY3Rpb24oYnMsIG9mZiwgbnMpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgdmFyIGhpID0gcGFjay5iaWdFbmRpYW5Ub0ludChicywgb2ZmKTtcbiAgICAgICAgdmFyIGxvID0gcGFjay5iaWdFbmRpYW5Ub0ludChicywgb2ZmICsgNCk7XG4gICAgICAgIHZhciBudW0gPSBuZXcgTG9uZyhsbywgaGkpO1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgbnNbaV0gPSBwYWNrLmJpZ0VuZGlhblRvTG9uZyhicywgb2ZmKTtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCAyIG9yIDMgYXJndW1lbnRzLlwiKTtcbiAgICB9XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ciphermodes/pack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/curves.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/curves.js - Elliptic Curve NIST/SECG/X9.62 Parameters\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Named EC curves\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\");\n\n// ----------------\n// X9ECParameters\n\n// constructor\nfunction X9ECParameters(curve, g, n, h) {\n  this.curve = curve;\n  this.g = g;\n  this.n = n;\n  this.h = h;\n}\n\nfunction x9getCurve() {\n  return this.curve;\n}\n\nfunction x9getG() {\n  return this.g;\n}\n\nfunction x9getN() {\n  return this.n;\n}\n\nfunction x9getH() {\n  return this.h;\n}\n\nX9ECParameters.prototype.getCurve = x9getCurve;\nX9ECParameters.prototype.getG = x9getG;\nX9ECParameters.prototype.getN = x9getN;\nX9ECParameters.prototype.getH = x9getH;\n\n// ----------------\n// SECNamedCurves\n\nfunction fromHex(s) { return new BigInteger(s, 16); }\n\nfunction secp256r1() {\n  // p = 2^224 (2^32 - 1) + 2^192 + 2^96 - 1\n  var p = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\");\n  var n = fromHex(\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\"\n              + \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp384r1() {\n  // p = 2^384 - 2^128 - 2^96 + 2^32 - 1\n  var p = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\");\n  var a = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\");\n  var b = fromHex(\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\");\n  var n = fromHex(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n              + \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\"\n              + \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\nfunction secp521r1() {\n  // p = 2^521 - 1\n  var p = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\");\n  var a = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\");\n  var b = fromHex(\"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\");\n  var n = fromHex(\"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\");\n  var h = BigInteger.ONE;\n  var curve = new ec.ECCurveFp(p, a, b);\n  var G = curve.decodePointHex(\"04\"\n                + \"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\"\n                + \"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\");\n  return new X9ECParameters(curve, G, n, h);\n}\n\n// ----------------\n// Public API\n\nvar CURVES = module.exports = {\n  \"secp256r1\": secp256r1(),\n  \"secp384r1\": secp384r1(),\n  \"secp521r1\": secp521r1()\n};\n\n// also export NIST names\nCURVES[\"P-256\"] = CURVES.secp256r1;\nCURVES[\"P-384\"] = CURVES.secp384r1;\nCURVES[\"P-521\"] = CURVES.secp521r1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9jdXJ2ZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjs7QUFFQSxpQkFBaUIsc0dBQWdDO0FBQ2pELFNBQVMsbUJBQU8sQ0FBQyxzRUFBVzs7QUFFNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2RlcHMvZWNjL2N1cnZlcy5qcz8xMDE5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZGVwcy9lY2MvY3VydmVzLmpzIC0gRWxsaXB0aWMgQ3VydmUgTklTVC9TRUNHL1g5LjYyIFBhcmFtZXRlcnNcbiAqIE9yaWdpbmFsIENvcHlyaWdodCAoYykgMjAwMy0yMDA1ICBUb20gV3UuXG4gKiBNb2RpZmljYXRpb25zIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICpcbiAqIFBvcnRlZCBmcm9tIFRvbSBXdSwgd2hpY2ggaXMgcG9ydGVkIGZyb20gQm91bmN5Q2FzdGxlXG4gKiBNb2RpZmllZCB0byByZXVzZSBleGlzdGluZyBleHRlcm5hbCBOUE0gbW9kdWxlcywgcmVzdHJpY3RlZCB0byB0aGVcbiAqIE5JU1QvL1NFQ0cvWDkuNjIgcHJpbWUgY3VydmVzIG9ubHksIGFuZCBmb3JtYXR0ZWQgdG8gbWF0Y2ggcHJvamVjdFxuICogY29kaW5nIHN0eWxlcy5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIE5hbWVkIEVDIGN1cnZlc1xuXG52YXIgQmlnSW50ZWdlciA9IHJlcXVpcmUoXCIuLi8uLi9kZXBzL2ZvcmdlXCIpLmpzYm4uQmlnSW50ZWdlcixcbiAgICBlYyA9IHJlcXVpcmUoXCIuL21hdGguanNcIik7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIFg5RUNQYXJhbWV0ZXJzXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBYOUVDUGFyYW1ldGVycyhjdXJ2ZSwgZywgbiwgaCkge1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMuZyA9IGc7XG4gIHRoaXMubiA9IG47XG4gIHRoaXMuaCA9IGg7XG59XG5cbmZ1bmN0aW9uIHg5Z2V0Q3VydmUoKSB7XG4gIHJldHVybiB0aGlzLmN1cnZlO1xufVxuXG5mdW5jdGlvbiB4OWdldEcoKSB7XG4gIHJldHVybiB0aGlzLmc7XG59XG5cbmZ1bmN0aW9uIHg5Z2V0TigpIHtcbiAgcmV0dXJuIHRoaXMubjtcbn1cblxuZnVuY3Rpb24geDlnZXRIKCkge1xuICByZXR1cm4gdGhpcy5oO1xufVxuXG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q3VydmUgPSB4OWdldEN1cnZlO1xuWDlFQ1BhcmFtZXRlcnMucHJvdG90eXBlLmdldEcgPSB4OWdldEc7XG5YOUVDUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0TiA9IHg5Z2V0Tjtcblg5RUNQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRIID0geDlnZXRIO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tXG4vLyBTRUNOYW1lZEN1cnZlc1xuXG5mdW5jdGlvbiBmcm9tSGV4KHMpIHsgcmV0dXJuIG5ldyBCaWdJbnRlZ2VyKHMsIDE2KTsgfVxuXG5mdW5jdGlvbiBzZWNwMjU2cjEoKSB7XG4gIC8vIHAgPSAyXjIyNCAoMl4zMiAtIDEpICsgMl4xOTIgKyAyXjk2IC0gMVxuICB2YXIgcCA9IGZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGXCIpO1xuICB2YXIgYSA9IGZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDXCIpO1xuICB2YXIgYiA9IGZyb21IZXgoXCI1QUM2MzVEOEFBM0E5M0U3QjNFQkJENTU3Njk4ODZCQzY1MUQwNkIwQ0M1M0IwRjYzQkNFM0MzRTI3RDI2MDRCXCIpO1xuICB2YXIgbiA9IGZyb21IZXgoXCJGRkZGRkZGRjAwMDAwMDAwRkZGRkZGRkZGRkZGRkZGRkJDRTZGQUFEQTcxNzlFODRGM0I5Q0FDMkZDNjMyNTUxXCIpO1xuICB2YXIgaCA9IEJpZ0ludGVnZXIuT05FO1xuICB2YXIgY3VydmUgPSBuZXcgZWMuRUNDdXJ2ZUZwKHAsIGEsIGIpO1xuICB2YXIgRyA9IGN1cnZlLmRlY29kZVBvaW50SGV4KFwiMDRcIlxuICAgICAgICAgICAgICArIFwiNkIxN0QxRjJFMTJDNDI0N0Y4QkNFNkU1NjNBNDQwRjI3NzAzN0Q4MTJERUIzM0EwRjRBMTM5NDVEODk4QzI5NlwiXG4gICAgICAgICAgICAgICsgXCI0RkUzNDJFMkZFMUE3RjlCOEVFN0VCNEE3QzBGOUUxNjJCQ0UzMzU3NkIzMTVFQ0VDQkI2NDA2ODM3QkY1MUY1XCIpO1xuICByZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLCBHLCBuLCBoKTtcbn1cblxuZnVuY3Rpb24gc2VjcDM4NHIxKCkge1xuICAvLyBwID0gMl4zODQgLSAyXjEyOCAtIDJeOTYgKyAyXjMyIC0gMVxuICB2YXIgcCA9IGZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZFRkZGRkZGRkYwMDAwMDAwMDAwMDAwMDAwRkZGRkZGRkZcIik7XG4gIHZhciBhID0gZnJvbUhleChcIkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkVGRkZGRkZGRjAwMDAwMDAwMDAwMDAwMDBGRkZGRkZGQ1wiKTtcbiAgdmFyIGIgPSBmcm9tSGV4KFwiQjMzMTJGQTdFMjNFRTdFNDk4OEUwNTZCRTNGODJEMTkxODFEOUM2RUZFODE0MTEyMDMxNDA4OEY1MDEzODc1QUM2NTYzOThEOEEyRUQxOUQyQTg1QzhFREQzRUMyQUVGXCIpO1xuICB2YXIgbiA9IGZyb21IZXgoXCJGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDNzYzNEQ4MUY0MzcyRERGNTgxQTBEQjI0OEIwQTc3QUVDRUMxOTZBQ0NDNTI5NzNcIik7XG4gIHZhciBoID0gQmlnSW50ZWdlci5PTkU7XG4gIHZhciBjdXJ2ZSA9IG5ldyBlYy5FQ0N1cnZlRnAocCwgYSwgYik7XG4gIHZhciBHID0gY3VydmUuZGVjb2RlUG9pbnRIZXgoXCIwNFwiXG4gICAgICAgICAgICAgICsgXCJBQTg3Q0EyMkJFOEIwNTM3OEVCMUM3MUVGMzIwQUQ3NDZFMUQzQjYyOEJBNzlCOTg1OUY3NDFFMDgyNTQyQTM4NTUwMkYyNURCRjU1Mjk2QzNBNTQ1RTM4NzI3NjBBQjdcIlxuICAgICAgICAgICAgICArIFwiMzYxN0RFNEE5NjI2MkM2RjVEOUU5OEJGOTI5MkRDMjlGOEY0MURCRDI4OUExNDdDRTlEQTMxMTNCNUYwQjhDMDBBNjBCMUNFMUQ3RTgxOUQ3QTQzMUQ3QzkwRUEwRTVGXCIpO1xuICByZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLCBHLCBuLCBoKTtcbn1cblxuZnVuY3Rpb24gc2VjcDUyMXIxKCkge1xuICAvLyBwID0gMl41MjEgLSAxXG4gIHZhciBwID0gZnJvbUhleChcIjAxRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRlwiKTtcbiAgdmFyIGEgPSBmcm9tSGV4KFwiMDFGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZDXCIpO1xuICB2YXIgYiA9IGZyb21IZXgoXCIwMDUxOTUzRUI5NjE4RTFDOUExRjkyOUEyMUEwQjY4NTQwRUVBMkRBNzI1Qjk5QjMxNUYzQjhCNDg5OTE4RUYxMDlFMTU2MTkzOTUxRUM3RTkzN0IxNjUyQzBCRDNCQjFCRjA3MzU3M0RGODgzRDJDMzRGMUVGNDUxRkQ0NkI1MDNGMDBcIik7XG4gIHZhciBuID0gZnJvbUhleChcIjAxRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZGRkZBNTE4Njg3ODNCRjJGOTY2QjdGQ0MwMTQ4RjcwOUE1RDAzQkI1QzlCODg5OUM0N0FFQkI2RkI3MUU5MTM4NjQwOVwiKTtcbiAgdmFyIGggPSBCaWdJbnRlZ2VyLk9ORTtcbiAgdmFyIGN1cnZlID0gbmV3IGVjLkVDQ3VydmVGcChwLCBhLCBiKTtcbiAgdmFyIEcgPSBjdXJ2ZS5kZWNvZGVQb2ludEhleChcIjA0XCJcbiAgICAgICAgICAgICAgICArIFwiMDBDNjg1OEUwNkI3MDQwNEU5Q0Q5RTNFQ0I2NjIzOTVCNDQyOUM2NDgxMzkwNTNGQjUyMUY4MjhBRjYwNkI0RDNEQkFBMTRCNUU3N0VGRTc1OTI4RkUxREMxMjdBMkZGQThERTMzNDhCM0MxODU2QTQyOUJGOTdFN0UzMUMyRTVCRDY2XCJcbiAgICAgICAgICAgICAgICArIFwiMDExODM5Mjk2QTc4OUEzQkMwMDQ1QzhBNUZCNDJDN0QxQkQ5OThGNTQ0NDk1NzlCNDQ2ODE3QUZCRDE3MjczRTY2MkM5N0VFNzI5OTVFRjQyNjQwQzU1MEI5MDEzRkFEMDc2MTM1M0M3MDg2QTI3MkMyNDA4OEJFOTQ3NjlGRDE2NjUwXCIpO1xuICByZXR1cm4gbmV3IFg5RUNQYXJhbWV0ZXJzKGN1cnZlLCBHLCBuLCBoKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHVibGljIEFQSVxuXG52YXIgQ1VSVkVTID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIFwic2VjcDI1NnIxXCI6IHNlY3AyNTZyMSgpLFxuICBcInNlY3AzODRyMVwiOiBzZWNwMzg0cjEoKSxcbiAgXCJzZWNwNTIxcjFcIjogc2VjcDUyMXIxKClcbn07XG5cbi8vIGFsc28gZXhwb3J0IE5JU1QgbmFtZXNcbkNVUlZFU1tcIlAtMjU2XCJdID0gQ1VSVkVTLnNlY3AyNTZyMTtcbkNVUlZFU1tcIlAtMzg0XCJdID0gQ1VSVkVTLnNlY3AzODRyMTtcbkNVUlZFU1tcIlAtNTIxXCJdID0gQ1VSVkVTLnNlY3A1MjFyMTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * deps/ecc/index.js - Elliptic Curve Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    BigInteger = forge.jsbn.BigInteger,\n    ec = __webpack_require__(/*! ./math.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\"),\n    CURVES = __webpack_require__(/*! ./curves.js */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/curves.js\");\n\n// ### Helpers\nfunction hex2bn(s) {\n  return new BigInteger(s, 16);\n}\n\nfunction bn2bin(bn, len) {\n  if (!len) {\n    len = Math.ceil(bn.bitLength() / 8);\n  }\n  len = len * 2;\n\n  var hex = bn.toString(16);\n  // truncate-left if too large\n  hex = hex.substring(Math.max(hex.length - len, 0));\n  // pad-left if too small\n  while (len > hex.length) {\n    hex = \"0\" + hex;\n  }\n\n  return Buffer.from(hex, \"hex\");\n}\nfunction bin2bn(s) {\n  if (\"string\" === typeof s) {\n    s = Buffer.from(s, \"binary\");\n  }\n  return hex2bn(s.toString(\"hex\"));\n}\n\nfunction keySizeBytes(params) {\n  return Math.ceil(params.getN().bitLength() / 8);\n}\n\nfunction namedCurve(curve) {\n  var params = CURVES[curve];\n  if (!params) {\n    throw new TypeError(\"unsupported named curve: \" + curve);\n  }\n\n  return params;\n}\n\nfunction normalizeEcdsa(params, md) {\n  var log2n = params.getN().bitLength(),\n      mdLen = md.length * 8;\n\n  var e = bin2bn(md);\n  if (log2n < mdLen) {\n    e = e.shiftRight(mdLen - log2n);\n  }\n\n  return e;\n}\n\n// ### EC Public Key\n\n/**\n *\n * @param {String} curve The named curve\n * @param {BigInteger} x The X coordinate\n * @param {BigInteger} y The Y coordinate\n */\nfunction ECPublicKey(curve, x, y) {\n  var params = namedCurve(curve),\n      c = params.getCurve();\n  var key = new ec.ECPointFp(c,\n                             c.fromBigInteger(x),\n                             c.fromBigInteger(y));\n\n  this.curve = curve;\n  this.params = params;\n  this.point = key;\n\n  var size = keySizeBytes(params);\n  this.x = bn2bin(x, size);\n  this.y = bn2bin(y, size);\n}\n\n// basics\nECPublicKey.prototype.isValid = function() {\n  return this.params.curve.contains(this.point);\n}\n\n// ECDSA\nECPublicKey.prototype.verify = function(md, sig) {\n  var N = this.params.getN(),\n      G = this.params.getG();\n\n  // prepare and validate (r, s)\n  var r = bin2bn(sig.r),\n      s = bin2bn(sig.s);\n  if (r.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n  if (s.compareTo(BigInteger.ONE) < 0 || r.compareTo(N) >= 0) {\n    return false;\n  }\n\n  // normalize input\n  var e = normalizeEcdsa(this.params, md);\n  // verify (r, s)\n  var w = s.modInverse(N),\n      u1 = e.multiply(w).mod(N),\n      u2 = r.multiply(w).mod(N);\n\n  var v = G.multiplyTwo(u1, this.point, u2).getX().toBigInteger();\n  v = v.mod(N);\n\n  return v.equals(r);\n};\n\n// ### EC Private Key\n\n/**\n * @param {String} curve The named curve\n * @param {Buffer} key The private key value\n */\nfunction ECPrivateKey(curve, key) {\n  var params = namedCurve(curve);\n  this.curve = curve;\n  this.params = params;\n\n  var size = keySizeBytes(params);\n  this.d = bn2bin(key, size);\n}\n\nECPrivateKey.prototype.toPublicKey = function() {\n  var d = bin2bn(this.d);\n  var P = this.params.getG().multiply(d);\n  return new ECPublicKey(this.curve,\n                         P.getX().toBigInteger(),\n                         P.getY().toBigInteger());\n};\n\n// ECDSA\nECPrivateKey.prototype.sign = function(md) {\n  var keysize = keySizeBytes(this.params),\n      N = this.params.getN(),\n      G = this.params.getG(),\n      e = normalizeEcdsa(this.params, md),\n      d = bin2bn(this.d);\n\n  var r, s;\n  var k, x1, z;\n  do {\n    do {\n      // determine random nonce\n      do {\n        k = bin2bn(forge.random.getBytes(keysize));\n      } while (k.equals(BigInteger.ZERO) || k.compareTo(N) >= 0);\n      // (x1, y1) = k * G\n      x1 = G.multiply(k).getX().toBigInteger();\n      // r = x1 mod N\n      r = x1.mod(N);\n    } while (r.equals(BigInteger.ZERO));\n    // s = (k^-1 * (e + r * d)) mod N\n    z = d.multiply(r);\n    z = e.add(z);\n    s = k.modInverse(N).multiply(z).mod(N);\n  } while (s.equals(BigInteger.ONE));\n\n  // convert (r, s) to bytes\n  var len = keySizeBytes(this.params);\n  r = bn2bin(r, len);\n  s = bn2bin(s, len);\n\n  return {\n    r: r,\n    s: s\n  };\n};\n\n// basics\nECPrivateKey.prototype.isValid = function() {\n  var d = bin2bn(this.d),\n      n1 = this.params.getN().subtract(BigInteger.ONE);\n\n  return (d.compareTo(BigInteger.ONE) >= 0) &&\n         (d.compareTo(n1) < 0);\n}\n\n// ECDH\nECPrivateKey.prototype.computeSecret = function(pubkey) {\n  var d = bin2bn(this.d);\n  var S = pubkey.point.multiply(d).getX().toBigInteger();\n  S = bn2bin(S, keySizeBytes(this.params));\n  return S;\n};\n\n// ### Public API\nexports.generateKeyPair = function(curve) {\n  var params = namedCurve(curve),\n      n = params.getN();\n\n  // generate random within range [1, N-1)\n  var r = forge.random.getBytes(keySizeBytes(params));\n  r = bin2bn(r);\n\n  var n1 = n.subtract(BigInteger.ONE);\n  var d = r.mod(n1).add(BigInteger.ONE);\n\n  var privkey = new ECPrivateKey(curve, d),\n      pubkey = privkey.toPublicKey();\n\n  return {\n    \"private\": privkey,\n    \"public\": pubkey\n  };\n};\n\nexports.asPublicKey = function(curve, x, y) {\n  if (\"string\" === typeof x) {\n    x = hex2bn(x);\n  } else if (Buffer.isBuffer(x)) {\n    x = bin2bn(x);\n  }\n\n  if (\"string\" === typeof y) {\n    y = hex2bn(y);\n  } else if (Buffer.isBuffer(y)) {\n    y = bin2bn(y);\n  }\n\n  var pubkey = new ECPublicKey(curve, x, y);\n  return pubkey;\n};\nexports.asPrivateKey = function(curve, d) {\n  // Elaborate way to get to a Buffer from a (String|Buffer|BigInteger)\n  if (\"string\" === typeof d) {\n    d = hex2bn(d);\n  } else if (Buffer.isBuffer(d)) {\n    d = bin2bn(d);\n  }\n\n  var privkey = new ECPrivateKey(curve, d);\n  return privkey;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBFQUFrQjtBQUN0QztBQUNBLFNBQVMsbUJBQU8sQ0FBQyxzRUFBVztBQUM1QixhQUFhLG1CQUFPLENBQUMsMEVBQWE7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9lY2MvaW5kZXguanM/NzAzMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGRlcHMvZWNjL2luZGV4LmpzIC0gRWxsaXB0aWMgQ3VydmUgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiAgU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBmb3JnZSA9IHJlcXVpcmUoXCIuLi8uLi9kZXBzL2ZvcmdlXCIpLFxuICAgIEJpZ0ludGVnZXIgPSBmb3JnZS5qc2JuLkJpZ0ludGVnZXIsXG4gICAgZWMgPSByZXF1aXJlKFwiLi9tYXRoLmpzXCIpLFxuICAgIENVUlZFUyA9IHJlcXVpcmUoXCIuL2N1cnZlcy5qc1wiKTtcblxuLy8gIyMjIEhlbHBlcnNcbmZ1bmN0aW9uIGhleDJibihzKSB7XG4gIHJldHVybiBuZXcgQmlnSW50ZWdlcihzLCAxNik7XG59XG5cbmZ1bmN0aW9uIGJuMmJpbihibiwgbGVuKSB7XG4gIGlmICghbGVuKSB7XG4gICAgbGVuID0gTWF0aC5jZWlsKGJuLmJpdExlbmd0aCgpIC8gOCk7XG4gIH1cbiAgbGVuID0gbGVuICogMjtcblxuICB2YXIgaGV4ID0gYm4udG9TdHJpbmcoMTYpO1xuICAvLyB0cnVuY2F0ZS1sZWZ0IGlmIHRvbyBsYXJnZVxuICBoZXggPSBoZXguc3Vic3RyaW5nKE1hdGgubWF4KGhleC5sZW5ndGggLSBsZW4sIDApKTtcbiAgLy8gcGFkLWxlZnQgaWYgdG9vIHNtYWxsXG4gIHdoaWxlIChsZW4gPiBoZXgubGVuZ3RoKSB7XG4gICAgaGV4ID0gXCIwXCIgKyBoZXg7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LCBcImhleFwiKTtcbn1cbmZ1bmN0aW9uIGJpbjJibihzKSB7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2Ygcykge1xuICAgIHMgPSBCdWZmZXIuZnJvbShzLCBcImJpbmFyeVwiKTtcbiAgfVxuICByZXR1cm4gaGV4MmJuKHMudG9TdHJpbmcoXCJoZXhcIikpO1xufVxuXG5mdW5jdGlvbiBrZXlTaXplQnl0ZXMocGFyYW1zKSB7XG4gIHJldHVybiBNYXRoLmNlaWwocGFyYW1zLmdldE4oKS5iaXRMZW5ndGgoKSAvIDgpO1xufVxuXG5mdW5jdGlvbiBuYW1lZEN1cnZlKGN1cnZlKSB7XG4gIHZhciBwYXJhbXMgPSBDVVJWRVNbY3VydmVdO1xuICBpZiAoIXBhcmFtcykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1bnN1cHBvcnRlZCBuYW1lZCBjdXJ2ZTogXCIgKyBjdXJ2ZSk7XG4gIH1cblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVFY2RzYShwYXJhbXMsIG1kKSB7XG4gIHZhciBsb2cybiA9IHBhcmFtcy5nZXROKCkuYml0TGVuZ3RoKCksXG4gICAgICBtZExlbiA9IG1kLmxlbmd0aCAqIDg7XG5cbiAgdmFyIGUgPSBiaW4yYm4obWQpO1xuICBpZiAobG9nMm4gPCBtZExlbikge1xuICAgIGUgPSBlLnNoaWZ0UmlnaHQobWRMZW4gLSBsb2cybik7XG4gIH1cblxuICByZXR1cm4gZTtcbn1cblxuLy8gIyMjIEVDIFB1YmxpYyBLZXlcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnZlIFRoZSBuYW1lZCBjdXJ2ZVxuICogQHBhcmFtIHtCaWdJbnRlZ2VyfSB4IFRoZSBYIGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7QmlnSW50ZWdlcn0geSBUaGUgWSBjb29yZGluYXRlXG4gKi9cbmZ1bmN0aW9uIEVDUHVibGljS2V5KGN1cnZlLCB4LCB5KSB7XG4gIHZhciBwYXJhbXMgPSBuYW1lZEN1cnZlKGN1cnZlKSxcbiAgICAgIGMgPSBwYXJhbXMuZ2V0Q3VydmUoKTtcbiAgdmFyIGtleSA9IG5ldyBlYy5FQ1BvaW50RnAoYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5mcm9tQmlnSW50ZWdlcih4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5mcm9tQmlnSW50ZWdlcih5KSk7XG5cbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgdGhpcy5wb2ludCA9IGtleTtcblxuICB2YXIgc2l6ZSA9IGtleVNpemVCeXRlcyhwYXJhbXMpO1xuICB0aGlzLnggPSBibjJiaW4oeCwgc2l6ZSk7XG4gIHRoaXMueSA9IGJuMmJpbih5LCBzaXplKTtcbn1cblxuLy8gYmFzaWNzXG5FQ1B1YmxpY0tleS5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5wYXJhbXMuY3VydmUuY29udGFpbnModGhpcy5wb2ludCk7XG59XG5cbi8vIEVDRFNBXG5FQ1B1YmxpY0tleS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24obWQsIHNpZykge1xuICB2YXIgTiA9IHRoaXMucGFyYW1zLmdldE4oKSxcbiAgICAgIEcgPSB0aGlzLnBhcmFtcy5nZXRHKCk7XG5cbiAgLy8gcHJlcGFyZSBhbmQgdmFsaWRhdGUgKHIsIHMpXG4gIHZhciByID0gYmluMmJuKHNpZy5yKSxcbiAgICAgIHMgPSBiaW4yYm4oc2lnLnMpO1xuICBpZiAoci5jb21wYXJlVG8oQmlnSW50ZWdlci5PTkUpIDwgMCB8fCByLmNvbXBhcmVUbyhOKSA+PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzLmNvbXBhcmVUbyhCaWdJbnRlZ2VyLk9ORSkgPCAwIHx8IHIuY29tcGFyZVRvKE4pID49IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBub3JtYWxpemUgaW5wdXRcbiAgdmFyIGUgPSBub3JtYWxpemVFY2RzYSh0aGlzLnBhcmFtcywgbWQpO1xuICAvLyB2ZXJpZnkgKHIsIHMpXG4gIHZhciB3ID0gcy5tb2RJbnZlcnNlKE4pLFxuICAgICAgdTEgPSBlLm11bHRpcGx5KHcpLm1vZChOKSxcbiAgICAgIHUyID0gci5tdWx0aXBseSh3KS5tb2QoTik7XG5cbiAgdmFyIHYgPSBHLm11bHRpcGx5VHdvKHUxLCB0aGlzLnBvaW50LCB1MikuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO1xuICB2ID0gdi5tb2QoTik7XG5cbiAgcmV0dXJuIHYuZXF1YWxzKHIpO1xufTtcblxuLy8gIyMjIEVDIFByaXZhdGUgS2V5XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGN1cnZlIFRoZSBuYW1lZCBjdXJ2ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGtleSBUaGUgcHJpdmF0ZSBrZXkgdmFsdWVcbiAqL1xuZnVuY3Rpb24gRUNQcml2YXRlS2V5KGN1cnZlLCBrZXkpIHtcbiAgdmFyIHBhcmFtcyA9IG5hbWVkQ3VydmUoY3VydmUpO1xuICB0aGlzLmN1cnZlID0gY3VydmU7XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuXG4gIHZhciBzaXplID0ga2V5U2l6ZUJ5dGVzKHBhcmFtcyk7XG4gIHRoaXMuZCA9IGJuMmJpbihrZXksIHNpemUpO1xufVxuXG5FQ1ByaXZhdGVLZXkucHJvdG90eXBlLnRvUHVibGljS2V5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkID0gYmluMmJuKHRoaXMuZCk7XG4gIHZhciBQID0gdGhpcy5wYXJhbXMuZ2V0RygpLm11bHRpcGx5KGQpO1xuICByZXR1cm4gbmV3IEVDUHVibGljS2V5KHRoaXMuY3VydmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgUC5nZXRYKCkudG9CaWdJbnRlZ2VyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgUC5nZXRZKCkudG9CaWdJbnRlZ2VyKCkpO1xufTtcblxuLy8gRUNEU0FcbkVDUHJpdmF0ZUtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uKG1kKSB7XG4gIHZhciBrZXlzaXplID0ga2V5U2l6ZUJ5dGVzKHRoaXMucGFyYW1zKSxcbiAgICAgIE4gPSB0aGlzLnBhcmFtcy5nZXROKCksXG4gICAgICBHID0gdGhpcy5wYXJhbXMuZ2V0RygpLFxuICAgICAgZSA9IG5vcm1hbGl6ZUVjZHNhKHRoaXMucGFyYW1zLCBtZCksXG4gICAgICBkID0gYmluMmJuKHRoaXMuZCk7XG5cbiAgdmFyIHIsIHM7XG4gIHZhciBrLCB4MSwgejtcbiAgZG8ge1xuICAgIGRvIHtcbiAgICAgIC8vIGRldGVybWluZSByYW5kb20gbm9uY2VcbiAgICAgIGRvIHtcbiAgICAgICAgayA9IGJpbjJibihmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5c2l6ZSkpO1xuICAgICAgfSB3aGlsZSAoay5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSB8fCBrLmNvbXBhcmVUbyhOKSA+PSAwKTtcbiAgICAgIC8vICh4MSwgeTEpID0gayAqIEdcbiAgICAgIHgxID0gRy5tdWx0aXBseShrKS5nZXRYKCkudG9CaWdJbnRlZ2VyKCk7XG4gICAgICAvLyByID0geDEgbW9kIE5cbiAgICAgIHIgPSB4MS5tb2QoTik7XG4gICAgfSB3aGlsZSAoci5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSk7XG4gICAgLy8gcyA9IChrXi0xICogKGUgKyByICogZCkpIG1vZCBOXG4gICAgeiA9IGQubXVsdGlwbHkocik7XG4gICAgeiA9IGUuYWRkKHopO1xuICAgIHMgPSBrLm1vZEludmVyc2UoTikubXVsdGlwbHkoeikubW9kKE4pO1xuICB9IHdoaWxlIChzLmVxdWFscyhCaWdJbnRlZ2VyLk9ORSkpO1xuXG4gIC8vIGNvbnZlcnQgKHIsIHMpIHRvIGJ5dGVzXG4gIHZhciBsZW4gPSBrZXlTaXplQnl0ZXModGhpcy5wYXJhbXMpO1xuICByID0gYm4yYmluKHIsIGxlbik7XG4gIHMgPSBibjJiaW4ocywgbGVuKTtcblxuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgczogc1xuICB9O1xufTtcblxuLy8gYmFzaWNzXG5FQ1ByaXZhdGVLZXkucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGQgPSBiaW4yYm4odGhpcy5kKSxcbiAgICAgIG4xID0gdGhpcy5wYXJhbXMuZ2V0TigpLnN1YnRyYWN0KEJpZ0ludGVnZXIuT05FKTtcblxuICByZXR1cm4gKGQuY29tcGFyZVRvKEJpZ0ludGVnZXIuT05FKSA+PSAwKSAmJlxuICAgICAgICAgKGQuY29tcGFyZVRvKG4xKSA8IDApO1xufVxuXG4vLyBFQ0RIXG5FQ1ByaXZhdGVLZXkucHJvdG90eXBlLmNvbXB1dGVTZWNyZXQgPSBmdW5jdGlvbihwdWJrZXkpIHtcbiAgdmFyIGQgPSBiaW4yYm4odGhpcy5kKTtcbiAgdmFyIFMgPSBwdWJrZXkucG9pbnQubXVsdGlwbHkoZCkuZ2V0WCgpLnRvQmlnSW50ZWdlcigpO1xuICBTID0gYm4yYmluKFMsIGtleVNpemVCeXRlcyh0aGlzLnBhcmFtcykpO1xuICByZXR1cm4gUztcbn07XG5cbi8vICMjIyBQdWJsaWMgQVBJXG5leHBvcnRzLmdlbmVyYXRlS2V5UGFpciA9IGZ1bmN0aW9uKGN1cnZlKSB7XG4gIHZhciBwYXJhbXMgPSBuYW1lZEN1cnZlKGN1cnZlKSxcbiAgICAgIG4gPSBwYXJhbXMuZ2V0TigpO1xuXG4gIC8vIGdlbmVyYXRlIHJhbmRvbSB3aXRoaW4gcmFuZ2UgWzEsIE4tMSlcbiAgdmFyIHIgPSBmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMoa2V5U2l6ZUJ5dGVzKHBhcmFtcykpO1xuICByID0gYmluMmJuKHIpO1xuXG4gIHZhciBuMSA9IG4uc3VidHJhY3QoQmlnSW50ZWdlci5PTkUpO1xuICB2YXIgZCA9IHIubW9kKG4xKS5hZGQoQmlnSW50ZWdlci5PTkUpO1xuXG4gIHZhciBwcml2a2V5ID0gbmV3IEVDUHJpdmF0ZUtleShjdXJ2ZSwgZCksXG4gICAgICBwdWJrZXkgPSBwcml2a2V5LnRvUHVibGljS2V5KCk7XG5cbiAgcmV0dXJuIHtcbiAgICBcInByaXZhdGVcIjogcHJpdmtleSxcbiAgICBcInB1YmxpY1wiOiBwdWJrZXlcbiAgfTtcbn07XG5cbmV4cG9ydHMuYXNQdWJsaWNLZXkgPSBmdW5jdGlvbihjdXJ2ZSwgeCwgeSkge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHgpIHtcbiAgICB4ID0gaGV4MmJuKHgpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih4KSkge1xuICAgIHggPSBiaW4yYm4oeCk7XG4gIH1cblxuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHkpIHtcbiAgICB5ID0gaGV4MmJuKHkpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih5KSkge1xuICAgIHkgPSBiaW4yYm4oeSk7XG4gIH1cblxuICB2YXIgcHVia2V5ID0gbmV3IEVDUHVibGljS2V5KGN1cnZlLCB4LCB5KTtcbiAgcmV0dXJuIHB1YmtleTtcbn07XG5leHBvcnRzLmFzUHJpdmF0ZUtleSA9IGZ1bmN0aW9uKGN1cnZlLCBkKSB7XG4gIC8vIEVsYWJvcmF0ZSB3YXkgdG8gZ2V0IHRvIGEgQnVmZmVyIGZyb20gYSAoU3RyaW5nfEJ1ZmZlcnxCaWdJbnRlZ2VyKVxuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGQpIHtcbiAgICBkID0gaGV4MmJuKGQpO1xuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkKSkge1xuICAgIGQgPSBiaW4yYm4oZCk7XG4gIH1cblxuICB2YXIgcHJpdmtleSA9IG5ldyBFQ1ByaXZhdGVLZXkoY3VydmUsIGQpO1xuICByZXR1cm4gcHJpdmtleTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/ecc/math.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * deps/ecc/math.js - Elliptic Curve Math\n * Original Copyright (c) 2003-2005  Tom Wu.\n * Modifications Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n *\n * Ported from Tom Wu, which is ported from BouncyCastle\n * Modified to reuse existing external NPM modules, restricted to the\n * NIST//SECG/X9.62 prime curves only, and formatted to match project\n * coding styles.\n */\n\n\n// Basic Javascript Elliptic Curve implementation\n// Ported loosely from BouncyCastle's Java EC code\n// Only Fp curves implemented for now\n\nvar BigInteger = (__webpack_require__(/*! ../../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\").jsbn).BigInteger;\n\n// ----------------\n// Helpers\n\nfunction nbi() {\n  return new BigInteger(null);\n}\n\n// ----------------\n// Barrett modular reduction\n\n// constructor\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  if (x.s < 0) { throw Error(\"Barrett reduction on negative input\"); }\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// ----------------\n// ECFieldElementFp\n\n// constructor\nfunction ECFieldElementFp(q, x) {\n  this.x = x;\n  // TODO if(x.compareTo(q) >= 0) error\n  this.p = q;\n}\n\nfunction feFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.x.equals(other.x));\n}\n\nfunction feFpToBigInteger() {\n  return this.x;\n}\n\nfunction feFpNegate() {\n  return new ECFieldElementFp(this.p, this.x.negate().mod(this.p));\n}\n\nfunction feFpAdd(b) {\n  return new ECFieldElementFp(this.p, this.x.add(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSubtract(b) {\n  return new ECFieldElementFp(this.p, this.x.subtract(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpMultiply(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger()).mod(this.p));\n}\n\nfunction feFpSquare() {\n  return new ECFieldElementFp(this.p, this.x.pow(2).mod(this.p));\n}\n\nfunction feFpDivide(b) {\n  return new ECFieldElementFp(this.p, this.x.multiply(b.toBigInteger().modInverse(this.p)).mod(this.p));\n}\n\nECFieldElementFp.prototype.equals = feFpEquals;\nECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;\nECFieldElementFp.prototype.negate = feFpNegate;\nECFieldElementFp.prototype.add = feFpAdd;\nECFieldElementFp.prototype.subtract = feFpSubtract;\nECFieldElementFp.prototype.multiply = feFpMultiply;\nECFieldElementFp.prototype.square = feFpSquare;\nECFieldElementFp.prototype.divide = feFpDivide;\n\n// ----------------\n// ECPointFp\n\n// constructor\nfunction ECPointFp(curve, x, y, z) {\n  this.curve = curve;\n  this.x = x;\n  this.y = y;\n  // Projective coordinates: either zinv == null or z * zinv == 1\n  // z and zinv are just BigIntegers, not fieldElements\n  if (!z) {\n    this.z = BigInteger.ONE;\n  } else {\n    this.z = z;\n  }\n  this.zinv = null;\n  //TODO: compression flag\n}\n\nfunction pointFpGetX() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.x.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpGetY() {\n  if(!this.zinv) {\n    this.zinv = this.z.modInverse(this.curve.p);\n  }\n  var r = this.y.toBigInteger().multiply(this.zinv);\n  this.curve.reduce(r);\n  return this.curve.fromBigInteger(r);\n}\n\nfunction pointFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  if (this.isInfinity()) {\n    return other.isInfinity();\n  }\n  if (other.isInfinity()) {\n    return this.isInfinity();\n  }\n  var u, v;\n  // u = Y2 * Z1 - Y1 * Z2\n  u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  if (!u.equals(BigInteger.ZERO)) {\n    return false;\n  }\n  // v = X2 * Z1 - X1 * Z2\n  v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.p);\n  return v.equals(BigInteger.ZERO);\n}\n\nfunction pointFpIsInfinity() {\n  if ((this.x == null) && (this.y == null)) {\n    return true;\n  }\n  return (this.z.equals(BigInteger.ZERO) && !this.y.toBigInteger().equals(BigInteger.ZERO));\n}\n\nfunction pointFpNegate() {\n    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);\n}\n\nfunction pointFpAdd(b) {\n  if (this.isInfinity()) {\n    return b;\n  }\n  if (b.isInfinity()) {\n    return this;\n  }\n\n  // u = Y2 * Z1 - Y1 * Z2\n  var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.p);\n  // v = X2 * Z1 - X1 * Z2\n  var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.p);\n\n  if (BigInteger.ZERO.equals(v)) {\n    if (BigInteger.ZERO.equals(u)) {\n      return this.twice(); // this == b, so double\n    }\n    return this.curve.getInfinity(); // this = -b, so infinity\n  }\n\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var v2 = v.pow(2);\n  var v3 = v2.multiply(v);\n  var x1v2 = x1.multiply(v2);\n  var zu2 = u.pow(2).multiply(this.z);\n\n  // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)\n  var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.p);\n  // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3\n  var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.p);\n  // z3 = v^3 * z1 * z2\n  var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\nfunction pointFpTwice() {\n  if(this.isInfinity()) {\n    return this;\n  }\n  if (this.y.toBigInteger().signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  // TODO: optimized handling of constants\n  var THREE = new BigInteger(\"3\");\n  var x1 = this.x.toBigInteger();\n  var y1 = this.y.toBigInteger();\n\n  var y1z1 = y1.multiply(this.z);\n  var y1sqz1 = y1z1.multiply(y1).mod(this.curve.p);\n  var a = this.curve.a.toBigInteger();\n\n  // w = 3 * x1^2 + a * z1^2\n  var w = x1.pow(2).multiply(THREE);\n  if (!BigInteger.ZERO.equals(a)) {\n    w = w.add(this.z.pow(2).multiply(a));\n  }\n  w = w.mod(this.curve.p);\n  //this.curve.reduce(w);\n  // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)\n  var x3 = w.pow(2).subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.p);\n  // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3\n  var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.pow(2).multiply(w)).mod(this.curve.p);\n  // z3 = 8 * (y1 * z1)^3\n  var z3 = y1z1.pow(2).multiply(y1z1).shiftLeft(3).mod(this.curve.p);\n\n  return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);\n}\n\n// Simple NAF (Non-Adjacent Form) multiplication algorithm\n// TODO: modularize the multiplication algorithm\nfunction pointFpMultiply(k) {\n  if (this.isInfinity()) {\n    return this;\n  }\n  if (k.signum() === 0) {\n    return this.curve.getInfinity();\n  }\n\n  var e = k;\n  var h = e.multiply(new BigInteger(\"3\"));\n\n  var neg = this.negate();\n  var R = this;\n\n  var i;\n  for(i = h.bitLength() - 2; i > 0; --i) {\n    R = R.twice();\n\n    var hBit = h.testBit(i);\n    var eBit = e.testBit(i);\n\n    if (hBit !== eBit) {\n      R = R.add(hBit ? this : neg);\n    }\n  }\n\n  return R;\n}\n\n// Compute this*j + x*k (simultaneous multiplication)\nfunction pointFpMultiplyTwo(j, x, k) {\n  var i;\n  if (j.bitLength() > k.bitLength()) {\n    i = j.bitLength() - 1;\n  } else {\n    i = k.bitLength() - 1;\n  }\n\n  var R = this.curve.getInfinity();\n  var both = this.add(x);\n  while (i >= 0) {\n    R = R.twice();\n    if (j.testBit(i)) {\n      if (k.testBit(i)) {\n        R = R.add(both);\n      }\n      else {\n        R = R.add(this);\n      }\n    }\n    else {\n      if (k.testBit(i)) {\n        R = R.add(x);\n      }\n    }\n    --i;\n  }\n\n  return R;\n}\n\nECPointFp.prototype.getX = pointFpGetX;\nECPointFp.prototype.getY = pointFpGetY;\nECPointFp.prototype.equals = pointFpEquals;\nECPointFp.prototype.isInfinity = pointFpIsInfinity;\nECPointFp.prototype.negate = pointFpNegate;\nECPointFp.prototype.add = pointFpAdd;\nECPointFp.prototype.twice = pointFpTwice;\nECPointFp.prototype.multiply = pointFpMultiply;\nECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;\n\n// ----------------\n// ECCurveFp\n\n// constructor\nfunction ECCurveFp(p, a, b) {\n  this.p = p;\n  this.a = this.fromBigInteger(a);\n  this.b = this.fromBigInteger(b);\n  this.infinity = new ECPointFp(this, null, null);\n  this.reducer = new Barrett(this.p);\n}\n\nfunction curveFpgetP() {\n  return this.p;\n}\n\nfunction curveFpGetA() {\n  return this.a;\n}\n\nfunction curveFpGetB() {\n  return this.b;\n}\n\nfunction curveFpEquals(other) {\n  if (other === this) {\n    return true;\n  }\n  return (this.p.equals(other.p) && this.a.equals(other.a) && this.b.equals(other.b));\n}\n\nfunction curveFpContains(pt) {\n  // y^2 = x^3 + a*x + b mod p\n  var x = pt.getX().toBigInteger(),\n      y = pt.getY().toBigInteger(),\n      a = this.a.toBigInteger(),\n      b = this.b.toBigInteger(),\n      p = this.p;\n\n  var left = y.pow(2).mod(p),\n      right = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n\n  return left.equals(right);\n}\n\nfunction curveFpGetInfinity() {\n  return this.infinity;\n}\n\nfunction curveFpFromBigInteger(x) {\n  return new ECFieldElementFp(this.p, x);\n}\n\nfunction curveReduce(x) {\n  this.reducer.reduce(x);\n}\n\n// for now, work with hex strings because they're easier in JS\nfunction curveFpDecodePointHex(s) {\n  switch (parseInt(s.substring(0, 2), 16)) {\n    // first byte\n    case 0:\n      return this.infinity;\n    case 2:\n    case 3:\n      // point compression not supported yet\n      return null;\n    case 4:\n    case 6:\n    case 7:\n      var len = (s.length - 2) / 2;\n      var xHex = s.substr(2, len);\n      var yHex = s.substr(len + 2, len);\n\n      return new ECPointFp(this,\n                           this.fromBigInteger(new BigInteger(xHex, 16)),\n                           this.fromBigInteger(new BigInteger(yHex, 16)));\n\n    default: // unsupported\n      return null;\n    }\n}\n\nfunction curveFpEncodePointHex(p) {\n  if (p.isInfinity()) {\n    return \"00\";\n  }\n  var xHex = p.getX().toBigInteger().toString(16);\n  var yHex = p.getY().toBigInteger().toString(16);\n  var oLen = this.getP().toString(16).length;\n  if ((oLen % 2) !== 0) {\n    oLen++;\n  }\n  while (xHex.length < oLen) {\n    xHex = \"0\" + xHex;\n  }\n  while (yHex.length < oLen) {\n    yHex = \"0\" + yHex;\n  }\n  return \"04\" + xHex + yHex;\n}\n\nECCurveFp.prototype.getP = curveFpgetP;\nECCurveFp.prototype.getA = curveFpGetA;\nECCurveFp.prototype.getB = curveFpGetB;\nECCurveFp.prototype.equals = curveFpEquals;\nECCurveFp.prototype.contains = curveFpContains;\nECCurveFp.prototype.getInfinity = curveFpGetInfinity;\nECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;\nECCurveFp.prototype.reduce = curveReduce;\nECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;\nECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;\n\n// Exports\nmodule.exports = {\n  ECFieldElementFp: ECFieldElementFp,\n  ECPointFp: ECPointFp,\n  ECCurveFp: ECCurveFp\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9tYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixzR0FBZ0M7O0FBRWpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZSxhQUFhLGdCQUFnQjtBQUNyRDs7QUFFQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEIsNkJBQTZCLGVBQWU7O0FBRTVDLGtCQUFrQjtBQUNsQiwrQkFBK0IsbUJBQW1COztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2VjYy9tYXRoLmpzPzc2N2EiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBkZXBzL2VjYy9tYXRoLmpzIC0gRWxsaXB0aWMgQ3VydmUgTWF0aFxuICogT3JpZ2luYWwgQ29weXJpZ2h0IChjKSAyMDAzLTIwMDUgIFRvbSBXdS5cbiAqIE1vZGlmaWNhdGlvbnMgQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gIFNlZSBMSUNFTlNFIGZpbGUuXG4gKlxuICogUG9ydGVkIGZyb20gVG9tIFd1LCB3aGljaCBpcyBwb3J0ZWQgZnJvbSBCb3VuY3lDYXN0bGVcbiAqIE1vZGlmaWVkIHRvIHJldXNlIGV4aXN0aW5nIGV4dGVybmFsIE5QTSBtb2R1bGVzLCByZXN0cmljdGVkIHRvIHRoZVxuICogTklTVC8vU0VDRy9YOS42MiBwcmltZSBjdXJ2ZXMgb25seSwgYW5kIGZvcm1hdHRlZCB0byBtYXRjaCBwcm9qZWN0XG4gKiBjb2Rpbmcgc3R5bGVzLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuLy8gQmFzaWMgSmF2YXNjcmlwdCBFbGxpcHRpYyBDdXJ2ZSBpbXBsZW1lbnRhdGlvblxuLy8gUG9ydGVkIGxvb3NlbHkgZnJvbSBCb3VuY3lDYXN0bGUncyBKYXZhIEVDIGNvZGVcbi8vIE9ubHkgRnAgY3VydmVzIGltcGxlbWVudGVkIGZvciBub3dcblxudmFyIEJpZ0ludGVnZXIgPSByZXF1aXJlKFwiLi4vLi4vZGVwcy9mb3JnZVwiKS5qc2JuLkJpZ0ludGVnZXI7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEhlbHBlcnNcblxuZnVuY3Rpb24gbmJpKCkge1xuICByZXR1cm4gbmV3IEJpZ0ludGVnZXIobnVsbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEJhcnJldHQgbW9kdWxhciByZWR1Y3Rpb25cblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIEJhcnJldHQobSkge1xuICAvLyBzZXR1cCBCYXJyZXR0XG4gIHRoaXMucjIgPSBuYmkoKTtcbiAgdGhpcy5xMyA9IG5iaSgpO1xuICBCaWdJbnRlZ2VyLk9ORS5kbFNoaWZ0VG8oMiptLnQsdGhpcy5yMik7XG4gIHRoaXMubXUgPSB0aGlzLnIyLmRpdmlkZShtKTtcbiAgdGhpcy5tID0gbTtcbn1cblxuZnVuY3Rpb24gYmFycmV0dENvbnZlcnQoeCkge1xuICBpZih4LnMgPCAwIHx8IHgudCA+IDIqdGhpcy5tLnQpIHJldHVybiB4Lm1vZCh0aGlzLm0pO1xuICBlbHNlIGlmKHguY29tcGFyZVRvKHRoaXMubSkgPCAwKSByZXR1cm4geDtcbiAgZWxzZSB7IHZhciByID0gbmJpKCk7IHguY29weVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgcmV0dXJuIHI7IH1cbn1cblxuZnVuY3Rpb24gYmFycmV0dFJldmVydCh4KSB7IHJldHVybiB4OyB9XG5cbi8vIHggPSB4IG1vZCBtIChIQUMgMTQuNDIpXG5mdW5jdGlvbiBiYXJyZXR0UmVkdWNlKHgpIHtcbiAgaWYgKHgucyA8IDApIHsgdGhyb3cgRXJyb3IoXCJCYXJyZXR0IHJlZHVjdGlvbiBvbiBuZWdhdGl2ZSBpbnB1dFwiKTsgfVxuICB4LmRyU2hpZnRUbyh0aGlzLm0udC0xLHRoaXMucjIpO1xuICBpZih4LnQgPiB0aGlzLm0udCsxKSB7IHgudCA9IHRoaXMubS50KzE7IHguY2xhbXAoKTsgfVxuICB0aGlzLm11Lm11bHRpcGx5VXBwZXJUbyh0aGlzLnIyLHRoaXMubS50KzEsdGhpcy5xMyk7XG4gIHRoaXMubS5tdWx0aXBseUxvd2VyVG8odGhpcy5xMyx0aGlzLm0udCsxLHRoaXMucjIpO1xuICB3aGlsZSh4LmNvbXBhcmVUbyh0aGlzLnIyKSA8IDApIHguZEFkZE9mZnNldCgxLHRoaXMubS50KzEpO1xuICB4LnN1YlRvKHRoaXMucjIseCk7XG4gIHdoaWxlKHguY29tcGFyZVRvKHRoaXMubSkgPj0gMCkgeC5zdWJUbyh0aGlzLm0seCk7XG59XG5cbi8vIHIgPSB4XjIgbW9kIG07IHggIT0gclxuZnVuY3Rpb24gYmFycmV0dFNxclRvKHgscikgeyB4LnNxdWFyZVRvKHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG4vLyByID0geCp5IG1vZCBtOyB4LHkgIT0gclxuZnVuY3Rpb24gYmFycmV0dE11bFRvKHgseSxyKSB7IHgubXVsdGlwbHlUbyh5LHIpOyB0aGlzLnJlZHVjZShyKTsgfVxuXG5CYXJyZXR0LnByb3RvdHlwZS5jb252ZXJ0ID0gYmFycmV0dENvbnZlcnQ7XG5CYXJyZXR0LnByb3RvdHlwZS5yZXZlcnQgPSBiYXJyZXR0UmV2ZXJ0O1xuQmFycmV0dC5wcm90b3R5cGUucmVkdWNlID0gYmFycmV0dFJlZHVjZTtcbkJhcnJldHQucHJvdG90eXBlLm11bFRvID0gYmFycmV0dE11bFRvO1xuQmFycmV0dC5wcm90b3R5cGUuc3FyVG8gPSBiYXJyZXR0U3FyVG87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEVDRmllbGRFbGVtZW50RnBcblxuLy8gY29uc3RydWN0b3JcbmZ1bmN0aW9uIEVDRmllbGRFbGVtZW50RnAocSwgeCkge1xuICB0aGlzLnggPSB4O1xuICAvLyBUT0RPIGlmKHguY29tcGFyZVRvKHEpID49IDApIGVycm9yXG4gIHRoaXMucCA9IHE7XG59XG5cbmZ1bmN0aW9uIGZlRnBFcXVhbHMob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICh0aGlzLnAuZXF1YWxzKG90aGVyLnApICYmIHRoaXMueC5lcXVhbHMob3RoZXIueCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwVG9CaWdJbnRlZ2VyKCkge1xuICByZXR1cm4gdGhpcy54O1xufVxuXG5mdW5jdGlvbiBmZUZwTmVnYXRlKCkge1xuICByZXR1cm4gbmV3IEVDRmllbGRFbGVtZW50RnAodGhpcy5wLCB0aGlzLngubmVnYXRlKCkubW9kKHRoaXMucCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwQWRkKGIpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54LmFkZChiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5wKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBTdWJ0cmFjdChiKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5zdWJ0cmFjdChiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5wKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBNdWx0aXBseShiKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5tdWx0aXBseShiLnRvQmlnSW50ZWdlcigpKS5tb2QodGhpcy5wKSk7XG59XG5cbmZ1bmN0aW9uIGZlRnBTcXVhcmUoKSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHRoaXMueC5wb3coMikubW9kKHRoaXMucCkpO1xufVxuXG5mdW5jdGlvbiBmZUZwRGl2aWRlKGIpIHtcbiAgcmV0dXJuIG5ldyBFQ0ZpZWxkRWxlbWVudEZwKHRoaXMucCwgdGhpcy54Lm11bHRpcGx5KGIudG9CaWdJbnRlZ2VyKCkubW9kSW52ZXJzZSh0aGlzLnApKS5tb2QodGhpcy5wKSk7XG59XG5cbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmVxdWFscyA9IGZlRnBFcXVhbHM7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS50b0JpZ0ludGVnZXIgPSBmZUZwVG9CaWdJbnRlZ2VyO1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUubmVnYXRlID0gZmVGcE5lZ2F0ZTtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmFkZCA9IGZlRnBBZGQ7XG5FQ0ZpZWxkRWxlbWVudEZwLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZlRnBTdWJ0cmFjdDtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLm11bHRpcGx5ID0gZmVGcE11bHRpcGx5O1xuRUNGaWVsZEVsZW1lbnRGcC5wcm90b3R5cGUuc3F1YXJlID0gZmVGcFNxdWFyZTtcbkVDRmllbGRFbGVtZW50RnAucHJvdG90eXBlLmRpdmlkZSA9IGZlRnBEaXZpZGU7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS1cbi8vIEVDUG9pbnRGcFxuXG4vLyBjb25zdHJ1Y3RvclxuZnVuY3Rpb24gRUNQb2ludEZwKGN1cnZlLCB4LCB5LCB6KSB7XG4gIHRoaXMuY3VydmUgPSBjdXJ2ZTtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgLy8gUHJvamVjdGl2ZSBjb29yZGluYXRlczogZWl0aGVyIHppbnYgPT0gbnVsbCBvciB6ICogemludiA9PSAxXG4gIC8vIHogYW5kIHppbnYgYXJlIGp1c3QgQmlnSW50ZWdlcnMsIG5vdCBmaWVsZEVsZW1lbnRzXG4gIGlmICgheikge1xuICAgIHRoaXMueiA9IEJpZ0ludGVnZXIuT05FO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueiA9IHo7XG4gIH1cbiAgdGhpcy56aW52ID0gbnVsbDtcbiAgLy9UT0RPOiBjb21wcmVzc2lvbiBmbGFnXG59XG5cbmZ1bmN0aW9uIHBvaW50RnBHZXRYKCkge1xuICBpZighdGhpcy56aW52KSB7XG4gICAgdGhpcy56aW52ID0gdGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5wKTtcbiAgfVxuICB2YXIgciA9IHRoaXMueC50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnppbnYpO1xuICB0aGlzLmN1cnZlLnJlZHVjZShyKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIocik7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBHZXRZKCkge1xuICBpZighdGhpcy56aW52KSB7XG4gICAgdGhpcy56aW52ID0gdGhpcy56Lm1vZEludmVyc2UodGhpcy5jdXJ2ZS5wKTtcbiAgfVxuICB2YXIgciA9IHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnppbnYpO1xuICB0aGlzLmN1cnZlLnJlZHVjZShyKTtcbiAgcmV0dXJuIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIocik7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBFcXVhbHMob3RoZXIpIHtcbiAgaWYgKG90aGVyID09PSB0aGlzKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzSW5maW5pdHkoKTtcbiAgfVxuICBpZiAob3RoZXIuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmZpbml0eSgpO1xuICB9XG4gIHZhciB1LCB2O1xuICAvLyB1ID0gWTIgKiBaMSAtIFkxICogWjJcbiAgdSA9IG90aGVyLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkodGhpcy56KS5zdWJ0cmFjdCh0aGlzLnkudG9CaWdJbnRlZ2VyKCkubXVsdGlwbHkob3RoZXIueikpLm1vZCh0aGlzLmN1cnZlLnApO1xuICBpZiAoIXUuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gdiA9IFgyICogWjEgLSBYMSAqIFoyXG4gIHYgPSBvdGhlci54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KG90aGVyLnopKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgcmV0dXJuIHYuZXF1YWxzKEJpZ0ludGVnZXIuWkVSTyk7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBJc0luZmluaXR5KCkge1xuICBpZiAoKHRoaXMueCA9PSBudWxsKSAmJiAodGhpcy55ID09IG51bGwpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuICh0aGlzLnouZXF1YWxzKEJpZ0ludGVnZXIuWkVSTykgJiYgIXRoaXMueS50b0JpZ0ludGVnZXIoKS5lcXVhbHMoQmlnSW50ZWdlci5aRVJPKSk7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBOZWdhdGUoKSB7XG4gICAgcmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSwgdGhpcy54LCB0aGlzLnkubmVnYXRlKCksIHRoaXMueik7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBBZGQoYikge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gYjtcbiAgfVxuICBpZiAoYi5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHUgPSBZMiAqIFoxIC0gWTEgKiBaMlxuICB2YXIgdSA9IGIueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseSh0aGlzLnopLnN1YnRyYWN0KHRoaXMueS50b0JpZ0ludGVnZXIoKS5tdWx0aXBseShiLnopKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy8gdiA9IFgyICogWjEgLSBYMSAqIFoyXG4gIHZhciB2ID0gYi54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KHRoaXMueikuc3VidHJhY3QodGhpcy54LnRvQmlnSW50ZWdlcigpLm11bHRpcGx5KGIueikpLm1vZCh0aGlzLmN1cnZlLnApO1xuXG4gIGlmIChCaWdJbnRlZ2VyLlpFUk8uZXF1YWxzKHYpKSB7XG4gICAgaWYgKEJpZ0ludGVnZXIuWkVSTy5lcXVhbHModSkpIHtcbiAgICAgIHJldHVybiB0aGlzLnR3aWNlKCk7IC8vIHRoaXMgPT0gYiwgc28gZG91YmxlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7IC8vIHRoaXMgPSAtYiwgc28gaW5maW5pdHlcbiAgfVxuXG4gIHZhciBUSFJFRSA9IG5ldyBCaWdJbnRlZ2VyKFwiM1wiKTtcbiAgdmFyIHgxID0gdGhpcy54LnRvQmlnSW50ZWdlcigpO1xuICB2YXIgeTEgPSB0aGlzLnkudG9CaWdJbnRlZ2VyKCk7XG5cbiAgdmFyIHYyID0gdi5wb3coMik7XG4gIHZhciB2MyA9IHYyLm11bHRpcGx5KHYpO1xuICB2YXIgeDF2MiA9IHgxLm11bHRpcGx5KHYyKTtcbiAgdmFyIHp1MiA9IHUucG93KDIpLm11bHRpcGx5KHRoaXMueik7XG5cbiAgLy8geDMgPSB2ICogKHoyICogKHoxICogdV4yIC0gMiAqIHgxICogdl4yKSAtIHZeMylcbiAgdmFyIHgzID0genUyLnN1YnRyYWN0KHgxdjIuc2hpZnRMZWZ0KDEpKS5tdWx0aXBseShiLnopLnN1YnRyYWN0KHYzKS5tdWx0aXBseSh2KS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgLy8geTMgPSB6MiAqICgzICogeDEgKiB1ICogdl4yIC0geTEgKiB2XjMgLSB6MSAqIHVeMykgKyB1ICogdl4zXG4gIHZhciB5MyA9IHgxdjIubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHUpLnN1YnRyYWN0KHkxLm11bHRpcGx5KHYzKSkuc3VidHJhY3QoenUyLm11bHRpcGx5KHUpKS5tdWx0aXBseShiLnopLmFkZCh1Lm11bHRpcGx5KHYzKSkubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vIHozID0gdl4zICogejEgKiB6MlxuICB2YXIgejMgPSB2My5tdWx0aXBseSh0aGlzLnopLm11bHRpcGx5KGIueikubW9kKHRoaXMuY3VydmUucCk7XG5cbiAgcmV0dXJuIG5ldyBFQ1BvaW50RnAodGhpcy5jdXJ2ZSwgdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih4MyksIHRoaXMuY3VydmUuZnJvbUJpZ0ludGVnZXIoeTMpLCB6Myk7XG59XG5cbmZ1bmN0aW9uIHBvaW50RnBUd2ljZSgpIHtcbiAgaWYodGhpcy5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAodGhpcy55LnRvQmlnSW50ZWdlcigpLnNpZ251bSgpID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VydmUuZ2V0SW5maW5pdHkoKTtcbiAgfVxuXG4gIC8vIFRPRE86IG9wdGltaXplZCBoYW5kbGluZyBvZiBjb25zdGFudHNcbiAgdmFyIFRIUkVFID0gbmV3IEJpZ0ludGVnZXIoXCIzXCIpO1xuICB2YXIgeDEgPSB0aGlzLngudG9CaWdJbnRlZ2VyKCk7XG4gIHZhciB5MSA9IHRoaXMueS50b0JpZ0ludGVnZXIoKTtcblxuICB2YXIgeTF6MSA9IHkxLm11bHRpcGx5KHRoaXMueik7XG4gIHZhciB5MXNxejEgPSB5MXoxLm11bHRpcGx5KHkxKS5tb2QodGhpcy5jdXJ2ZS5wKTtcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmEudG9CaWdJbnRlZ2VyKCk7XG5cbiAgLy8gdyA9IDMgKiB4MV4yICsgYSAqIHoxXjJcbiAgdmFyIHcgPSB4MS5wb3coMikubXVsdGlwbHkoVEhSRUUpO1xuICBpZiAoIUJpZ0ludGVnZXIuWkVSTy5lcXVhbHMoYSkpIHtcbiAgICB3ID0gdy5hZGQodGhpcy56LnBvdygyKS5tdWx0aXBseShhKSk7XG4gIH1cbiAgdyA9IHcubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vdGhpcy5jdXJ2ZS5yZWR1Y2Uodyk7XG4gIC8vIHgzID0gMiAqIHkxICogejEgKiAod14yIC0gOCAqIHgxICogeTFeMiAqIHoxKVxuICB2YXIgeDMgPSB3LnBvdygyKS5zdWJ0cmFjdCh4MS5zaGlmdExlZnQoMykubXVsdGlwbHkoeTFzcXoxKSkuc2hpZnRMZWZ0KDEpLm11bHRpcGx5KHkxejEpLm1vZCh0aGlzLmN1cnZlLnApO1xuICAvLyB5MyA9IDQgKiB5MV4yICogejEgKiAoMyAqIHcgKiB4MSAtIDIgKiB5MV4yICogejEpIC0gd14zXG4gIHZhciB5MyA9IHcubXVsdGlwbHkoVEhSRUUpLm11bHRpcGx5KHgxKS5zdWJ0cmFjdCh5MXNxejEuc2hpZnRMZWZ0KDEpKS5zaGlmdExlZnQoMikubXVsdGlwbHkoeTFzcXoxKS5zdWJ0cmFjdCh3LnBvdygyKS5tdWx0aXBseSh3KSkubW9kKHRoaXMuY3VydmUucCk7XG4gIC8vIHozID0gOCAqICh5MSAqIHoxKV4zXG4gIHZhciB6MyA9IHkxejEucG93KDIpLm11bHRpcGx5KHkxejEpLnNoaWZ0TGVmdCgzKS5tb2QodGhpcy5jdXJ2ZS5wKTtcblxuICByZXR1cm4gbmV3IEVDUG9pbnRGcCh0aGlzLmN1cnZlLCB0aGlzLmN1cnZlLmZyb21CaWdJbnRlZ2VyKHgzKSwgdGhpcy5jdXJ2ZS5mcm9tQmlnSW50ZWdlcih5MyksIHozKTtcbn1cblxuLy8gU2ltcGxlIE5BRiAoTm9uLUFkamFjZW50IEZvcm0pIG11bHRpcGxpY2F0aW9uIGFsZ29yaXRobVxuLy8gVE9ETzogbW9kdWxhcml6ZSB0aGUgbXVsdGlwbGljYXRpb24gYWxnb3JpdGhtXG5mdW5jdGlvbiBwb2ludEZwTXVsdGlwbHkoaykge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpZiAoay5zaWdudW0oKSA9PT0gMCkge1xuICAgIHJldHVybiB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7XG4gIH1cblxuICB2YXIgZSA9IGs7XG4gIHZhciBoID0gZS5tdWx0aXBseShuZXcgQmlnSW50ZWdlcihcIjNcIikpO1xuXG4gIHZhciBuZWcgPSB0aGlzLm5lZ2F0ZSgpO1xuICB2YXIgUiA9IHRoaXM7XG5cbiAgdmFyIGk7XG4gIGZvcihpID0gaC5iaXRMZW5ndGgoKSAtIDI7IGkgPiAwOyAtLWkpIHtcbiAgICBSID0gUi50d2ljZSgpO1xuXG4gICAgdmFyIGhCaXQgPSBoLnRlc3RCaXQoaSk7XG4gICAgdmFyIGVCaXQgPSBlLnRlc3RCaXQoaSk7XG5cbiAgICBpZiAoaEJpdCAhPT0gZUJpdCkge1xuICAgICAgUiA9IFIuYWRkKGhCaXQgPyB0aGlzIDogbmVnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gUjtcbn1cblxuLy8gQ29tcHV0ZSB0aGlzKmogKyB4KmsgKHNpbXVsdGFuZW91cyBtdWx0aXBsaWNhdGlvbilcbmZ1bmN0aW9uIHBvaW50RnBNdWx0aXBseVR3byhqLCB4LCBrKSB7XG4gIHZhciBpO1xuICBpZiAoai5iaXRMZW5ndGgoKSA+IGsuYml0TGVuZ3RoKCkpIHtcbiAgICBpID0gai5iaXRMZW5ndGgoKSAtIDE7XG4gIH0gZWxzZSB7XG4gICAgaSA9IGsuYml0TGVuZ3RoKCkgLSAxO1xuICB9XG5cbiAgdmFyIFIgPSB0aGlzLmN1cnZlLmdldEluZmluaXR5KCk7XG4gIHZhciBib3RoID0gdGhpcy5hZGQoeCk7XG4gIHdoaWxlIChpID49IDApIHtcbiAgICBSID0gUi50d2ljZSgpO1xuICAgIGlmIChqLnRlc3RCaXQoaSkpIHtcbiAgICAgIGlmIChrLnRlc3RCaXQoaSkpIHtcbiAgICAgICAgUiA9IFIuYWRkKGJvdGgpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIFIgPSBSLmFkZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAoay50ZXN0Qml0KGkpKSB7XG4gICAgICAgIFIgPSBSLmFkZCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLS1pO1xuICB9XG5cbiAgcmV0dXJuIFI7XG59XG5cbkVDUG9pbnRGcC5wcm90b3R5cGUuZ2V0WCA9IHBvaW50RnBHZXRYO1xuRUNQb2ludEZwLnByb3RvdHlwZS5nZXRZID0gcG9pbnRGcEdldFk7XG5FQ1BvaW50RnAucHJvdG90eXBlLmVxdWFscyA9IHBvaW50RnBFcXVhbHM7XG5FQ1BvaW50RnAucHJvdG90eXBlLmlzSW5maW5pdHkgPSBwb2ludEZwSXNJbmZpbml0eTtcbkVDUG9pbnRGcC5wcm90b3R5cGUubmVnYXRlID0gcG9pbnRGcE5lZ2F0ZTtcbkVDUG9pbnRGcC5wcm90b3R5cGUuYWRkID0gcG9pbnRGcEFkZDtcbkVDUG9pbnRGcC5wcm90b3R5cGUudHdpY2UgPSBwb2ludEZwVHdpY2U7XG5FQ1BvaW50RnAucHJvdG90eXBlLm11bHRpcGx5ID0gcG9pbnRGcE11bHRpcGx5O1xuRUNQb2ludEZwLnByb3RvdHlwZS5tdWx0aXBseVR3byA9IHBvaW50RnBNdWx0aXBseVR3bztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLVxuLy8gRUNDdXJ2ZUZwXG5cbi8vIGNvbnN0cnVjdG9yXG5mdW5jdGlvbiBFQ0N1cnZlRnAocCwgYSwgYikge1xuICB0aGlzLnAgPSBwO1xuICB0aGlzLmEgPSB0aGlzLmZyb21CaWdJbnRlZ2VyKGEpO1xuICB0aGlzLmIgPSB0aGlzLmZyb21CaWdJbnRlZ2VyKGIpO1xuICB0aGlzLmluZmluaXR5ID0gbmV3IEVDUG9pbnRGcCh0aGlzLCBudWxsLCBudWxsKTtcbiAgdGhpcy5yZWR1Y2VyID0gbmV3IEJhcnJldHQodGhpcy5wKTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcGdldFAoKSB7XG4gIHJldHVybiB0aGlzLnA7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBHZXRBKCkge1xuICByZXR1cm4gdGhpcy5hO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZUZwR2V0QigpIHtcbiAgcmV0dXJuIHRoaXMuYjtcbn1cblxuZnVuY3Rpb24gY3VydmVGcEVxdWFscyhvdGhlcikge1xuICBpZiAob3RoZXIgPT09IHRoaXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gKHRoaXMucC5lcXVhbHMob3RoZXIucCkgJiYgdGhpcy5hLmVxdWFscyhvdGhlci5hKSAmJiB0aGlzLmIuZXF1YWxzKG90aGVyLmIpKTtcbn1cblxuZnVuY3Rpb24gY3VydmVGcENvbnRhaW5zKHB0KSB7XG4gIC8vIHleMiA9IHheMyArIGEqeCArIGIgbW9kIHBcbiAgdmFyIHggPSBwdC5nZXRYKCkudG9CaWdJbnRlZ2VyKCksXG4gICAgICB5ID0gcHQuZ2V0WSgpLnRvQmlnSW50ZWdlcigpLFxuICAgICAgYSA9IHRoaXMuYS50b0JpZ0ludGVnZXIoKSxcbiAgICAgIGIgPSB0aGlzLmIudG9CaWdJbnRlZ2VyKCksXG4gICAgICBwID0gdGhpcy5wO1xuXG4gIHZhciBsZWZ0ID0geS5wb3coMikubW9kKHApLFxuICAgICAgcmlnaHQgPSB4LnBvdygzKS5hZGQoYS5tdWx0aXBseSh4KSkuYWRkKGIpLm1vZChwKVxuXG4gIHJldHVybiBsZWZ0LmVxdWFscyhyaWdodCk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBHZXRJbmZpbml0eSgpIHtcbiAgcmV0dXJuIHRoaXMuaW5maW5pdHk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlRnBGcm9tQmlnSW50ZWdlcih4KSB7XG4gIHJldHVybiBuZXcgRUNGaWVsZEVsZW1lbnRGcCh0aGlzLnAsIHgpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVJlZHVjZSh4KSB7XG4gIHRoaXMucmVkdWNlci5yZWR1Y2UoeCk7XG59XG5cbi8vIGZvciBub3csIHdvcmsgd2l0aCBoZXggc3RyaW5ncyBiZWNhdXNlIHRoZXkncmUgZWFzaWVyIGluIEpTXG5mdW5jdGlvbiBjdXJ2ZUZwRGVjb2RlUG9pbnRIZXgocykge1xuICBzd2l0Y2ggKHBhcnNlSW50KHMuc3Vic3RyaW5nKDAsIDIpLCAxNikpIHtcbiAgICAvLyBmaXJzdCBieXRlXG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHRoaXMuaW5maW5pdHk7XG4gICAgY2FzZSAyOlxuICAgIGNhc2UgMzpcbiAgICAgIC8vIHBvaW50IGNvbXByZXNzaW9uIG5vdCBzdXBwb3J0ZWQgeWV0XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDQ6XG4gICAgY2FzZSA2OlxuICAgIGNhc2UgNzpcbiAgICAgIHZhciBsZW4gPSAocy5sZW5ndGggLSAyKSAvIDI7XG4gICAgICB2YXIgeEhleCA9IHMuc3Vic3RyKDIsIGxlbik7XG4gICAgICB2YXIgeUhleCA9IHMuc3Vic3RyKGxlbiArIDIsIGxlbik7XG5cbiAgICAgIHJldHVybiBuZXcgRUNQb2ludEZwKHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21CaWdJbnRlZ2VyKG5ldyBCaWdJbnRlZ2VyKHhIZXgsIDE2KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21CaWdJbnRlZ2VyKG5ldyBCaWdJbnRlZ2VyKHlIZXgsIDE2KSkpO1xuXG4gICAgZGVmYXVsdDogLy8gdW5zdXBwb3J0ZWRcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3VydmVGcEVuY29kZVBvaW50SGV4KHApIHtcbiAgaWYgKHAuaXNJbmZpbml0eSgpKSB7XG4gICAgcmV0dXJuIFwiMDBcIjtcbiAgfVxuICB2YXIgeEhleCA9IHAuZ2V0WCgpLnRvQmlnSW50ZWdlcigpLnRvU3RyaW5nKDE2KTtcbiAgdmFyIHlIZXggPSBwLmdldFkoKS50b0JpZ0ludGVnZXIoKS50b1N0cmluZygxNik7XG4gIHZhciBvTGVuID0gdGhpcy5nZXRQKCkudG9TdHJpbmcoMTYpLmxlbmd0aDtcbiAgaWYgKChvTGVuICUgMikgIT09IDApIHtcbiAgICBvTGVuKys7XG4gIH1cbiAgd2hpbGUgKHhIZXgubGVuZ3RoIDwgb0xlbikge1xuICAgIHhIZXggPSBcIjBcIiArIHhIZXg7XG4gIH1cbiAgd2hpbGUgKHlIZXgubGVuZ3RoIDwgb0xlbikge1xuICAgIHlIZXggPSBcIjBcIiArIHlIZXg7XG4gIH1cbiAgcmV0dXJuIFwiMDRcIiArIHhIZXggKyB5SGV4O1xufVxuXG5FQ0N1cnZlRnAucHJvdG90eXBlLmdldFAgPSBjdXJ2ZUZwZ2V0UDtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZ2V0QSA9IGN1cnZlRnBHZXRBO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRCID0gY3VydmVGcEdldEI7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmVxdWFscyA9IGN1cnZlRnBFcXVhbHM7XG5FQ0N1cnZlRnAucHJvdG90eXBlLmNvbnRhaW5zID0gY3VydmVGcENvbnRhaW5zO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5nZXRJbmZpbml0eSA9IGN1cnZlRnBHZXRJbmZpbml0eTtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZnJvbUJpZ0ludGVnZXIgPSBjdXJ2ZUZwRnJvbUJpZ0ludGVnZXI7XG5FQ0N1cnZlRnAucHJvdG90eXBlLnJlZHVjZSA9IGN1cnZlUmVkdWNlO1xuRUNDdXJ2ZUZwLnByb3RvdHlwZS5kZWNvZGVQb2ludEhleCA9IGN1cnZlRnBEZWNvZGVQb2ludEhleDtcbkVDQ3VydmVGcC5wcm90b3R5cGUuZW5jb2RlUG9pbnRIZXggPSBjdXJ2ZUZwRW5jb2RlUG9pbnRIZXg7XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBFQ0ZpZWxkRWxlbWVudEZwOiBFQ0ZpZWxkRWxlbWVudEZwLFxuICBFQ1BvaW50RnA6IEVDUG9pbnRGcCxcbiAgRUNDdXJ2ZUZwOiBFQ0N1cnZlRnBcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/ecc/math.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/deps/forge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/deps/forge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * deps/forge.js - Forge Package Customization\n *\n * Copyright (c) 2015 Cisco Systems, Inc.  See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! node-forge/lib/forge */ \"(ssr)/./node_modules/node-forge/lib/forge.js\");\n__webpack_require__(/*! node-forge/lib/aes */ \"(ssr)/./node_modules/node-forge/lib/aes.js\");\n__webpack_require__(/*! node-forge/lib/asn1 */ \"(ssr)/./node_modules/node-forge/lib/asn1.js\");\n__webpack_require__(/*! node-forge/lib/cipher */ \"(ssr)/./node_modules/node-forge/lib/cipher.js\");\n__webpack_require__(/*! node-forge/lib/hmac */ \"(ssr)/./node_modules/node-forge/lib/hmac.js\");\n__webpack_require__(/*! node-forge/lib/mgf1 */ \"(ssr)/./node_modules/node-forge/lib/mgf1.js\");\n__webpack_require__(/*! node-forge/lib/pbkdf2 */ \"(ssr)/./node_modules/node-forge/lib/pbkdf2.js\");\n__webpack_require__(/*! node-forge/lib/pem */ \"(ssr)/./node_modules/node-forge/lib/pem.js\");\n__webpack_require__(/*! node-forge/lib/pkcs1 */ \"(ssr)/./node_modules/node-forge/lib/pkcs1.js\");\n__webpack_require__(/*! node-forge/lib/pkcs7 */ \"(ssr)/./node_modules/node-forge/lib/pkcs7.js\");\n__webpack_require__(/*! node-forge/lib/pki */ \"(ssr)/./node_modules/node-forge/lib/pki.js\");\n__webpack_require__(/*! node-forge/lib/prime */ \"(ssr)/./node_modules/node-forge/lib/prime.js\");\n__webpack_require__(/*! node-forge/lib/prng */ \"(ssr)/./node_modules/node-forge/lib/prng.js\");\n__webpack_require__(/*! node-forge/lib/pss */ \"(ssr)/./node_modules/node-forge/lib/pss.js\");\n__webpack_require__(/*! node-forge/lib/random */ \"(ssr)/./node_modules/node-forge/lib/random.js\");\n__webpack_require__(/*! node-forge/lib/sha1 */ \"(ssr)/./node_modules/node-forge/lib/sha1.js\");\n__webpack_require__(/*! node-forge/lib/sha256 */ \"(ssr)/./node_modules/node-forge/lib/sha256.js\");\n__webpack_require__(/*! node-forge/lib/sha512 */ \"(ssr)/./node_modules/node-forge/lib/sha512.js\");\n__webpack_require__(/*! node-forge/lib/util */ \"(ssr)/./node_modules/node-forge/lib/util.js\");\n\n// Define AES \"raw\" cipher mode\nfunction modeRaw(options) {\n  options = options || {};\n  this.name = \"\";\n  this.cipher = options.cipher;\n  this.blockSize = options.blockSize || 16;\n  this._blocks = this.blockSize / 4;\n  this._inBlock = new Array(this._blocks);\n  this._outBlock = new Array(this._blocks);\n}\n\nmodeRaw.prototype.start = function() {};\n\nmodeRaw.prototype.encrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // encrypt block\n  this.cipher.encrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\nmodeRaw.prototype.decrypt = function(input, output, finish) {\n  if(input.length() < this.blockSize && !(finish && input.length() > 0)) {\n    return true;\n  }\n\n  var i;\n\n  // get next block\n  for(i = 0; i < this._blocks; ++i) {\n    this._inBlock[i] = input.getInt32();\n  }\n\n  // decrypt block\n  this.cipher.decrypt(this._inBlock, this._outBlock);\n\n  // write output\n  for(i = 0; i < this._blocks; ++i) {\n    output.putInt32(this._outBlock[i]);\n  }\n};\n\n(function() {\n  var name = \"AES\",\n      mode = modeRaw,\n      factory;\n  factory = function() { return new forge.aes.Algorithm(name, mode); };\n  forge.cipher.registerAlgorithm(name, factory);\n})();\n\n// Ensure that the jsbn modInverse function always returns a positive result\nconst originalModInverse = forge.jsbn.BigInteger.prototype.modInverse;\nconst positiveModInverse = function(m) {\n  const inv = originalModInverse.apply(this, [m]);\n  return inv.mod(m);\n}\n\nforge.jsbn.BigInteger.prototype.modInverse = positiveModInverse;\n\nmodule.exports = forge;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9kZXBzL2ZvcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQXNCO0FBQzFDLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsMEVBQXNCO0FBQzlCLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsc0VBQW9CO0FBQzVCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCO0FBQzdCLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsNEVBQXVCO0FBQy9CLG1CQUFPLENBQUMsd0VBQXFCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvZGVwcy9mb3JnZS5qcz8xN2U3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZGVwcy9mb3JnZS5qcyAtIEZvcmdlIFBhY2thZ2UgQ3VzdG9taXphdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuICBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2ZvcmdlXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2Flc1wiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9hc24xXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL2NpcGhlclwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9obWFjXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL21nZjFcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcGJrZGYyXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3BlbVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wa2NzMVwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wa2NzN1wiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wa2lcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcHJpbWVcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcHJuZ1wiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi9wc3NcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvcmFuZG9tXCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3NoYTFcIik7XG5yZXF1aXJlKFwibm9kZS1mb3JnZS9saWIvc2hhMjU2XCIpO1xucmVxdWlyZShcIm5vZGUtZm9yZ2UvbGliL3NoYTUxMlwiKTtcbnJlcXVpcmUoXCJub2RlLWZvcmdlL2xpYi91dGlsXCIpO1xuXG4vLyBEZWZpbmUgQUVTIFwicmF3XCIgY2lwaGVyIG1vZGVcbmZ1bmN0aW9uIG1vZGVSYXcob3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5uYW1lID0gXCJcIjtcbiAgdGhpcy5jaXBoZXIgPSBvcHRpb25zLmNpcGhlcjtcbiAgdGhpcy5ibG9ja1NpemUgPSBvcHRpb25zLmJsb2NrU2l6ZSB8fCAxNjtcbiAgdGhpcy5fYmxvY2tzID0gdGhpcy5ibG9ja1NpemUgLyA0O1xuICB0aGlzLl9pbkJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2Jsb2Nrcyk7XG4gIHRoaXMuX291dEJsb2NrID0gbmV3IEFycmF5KHRoaXMuX2Jsb2Nrcyk7XG59XG5cbm1vZGVSYXcucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7fTtcblxubW9kZVJhdy5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKGlucHV0LCBvdXRwdXQsIGZpbmlzaCkge1xuICBpZihpbnB1dC5sZW5ndGgoKSA8IHRoaXMuYmxvY2tTaXplICYmICEoZmluaXNoICYmIGlucHV0Lmxlbmd0aCgpID4gMCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBpO1xuXG4gIC8vIGdldCBuZXh0IGJsb2NrXG4gIGZvcihpID0gMDsgaSA8IHRoaXMuX2Jsb2NrczsgKytpKSB7XG4gICAgdGhpcy5faW5CbG9ja1tpXSA9IGlucHV0LmdldEludDMyKCk7XG4gIH1cblxuICAvLyBlbmNyeXB0IGJsb2NrXG4gIHRoaXMuY2lwaGVyLmVuY3J5cHQodGhpcy5faW5CbG9jaywgdGhpcy5fb3V0QmxvY2spO1xuXG4gIC8vIHdyaXRlIG91dHB1dFxuICBmb3IoaSA9IDA7IGkgPCB0aGlzLl9ibG9ja3M7ICsraSkge1xuICAgIG91dHB1dC5wdXRJbnQzMih0aGlzLl9vdXRCbG9ja1tpXSk7XG4gIH1cbn07XG5cbm1vZGVSYXcucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihpbnB1dCwgb3V0cHV0LCBmaW5pc2gpIHtcbiAgaWYoaW5wdXQubGVuZ3RoKCkgPCB0aGlzLmJsb2NrU2l6ZSAmJiAhKGZpbmlzaCAmJiBpbnB1dC5sZW5ndGgoKSA+IDApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgaTtcblxuICAvLyBnZXQgbmV4dCBibG9ja1xuICBmb3IoaSA9IDA7IGkgPCB0aGlzLl9ibG9ja3M7ICsraSkge1xuICAgIHRoaXMuX2luQmxvY2tbaV0gPSBpbnB1dC5nZXRJbnQzMigpO1xuICB9XG5cbiAgLy8gZGVjcnlwdCBibG9ja1xuICB0aGlzLmNpcGhlci5kZWNyeXB0KHRoaXMuX2luQmxvY2ssIHRoaXMuX291dEJsb2NrKTtcblxuICAvLyB3cml0ZSBvdXRwdXRcbiAgZm9yKGkgPSAwOyBpIDwgdGhpcy5fYmxvY2tzOyArK2kpIHtcbiAgICBvdXRwdXQucHV0SW50MzIodGhpcy5fb3V0QmxvY2tbaV0pO1xuICB9XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBuYW1lID0gXCJBRVNcIixcbiAgICAgIG1vZGUgPSBtb2RlUmF3LFxuICAgICAgZmFjdG9yeTtcbiAgZmFjdG9yeSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gbmV3IGZvcmdlLmFlcy5BbGdvcml0aG0obmFtZSwgbW9kZSk7IH07XG4gIGZvcmdlLmNpcGhlci5yZWdpc3RlckFsZ29yaXRobShuYW1lLCBmYWN0b3J5KTtcbn0pKCk7XG5cbi8vIEVuc3VyZSB0aGF0IHRoZSBqc2JuIG1vZEludmVyc2UgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgYSBwb3NpdGl2ZSByZXN1bHRcbmNvbnN0IG9yaWdpbmFsTW9kSW52ZXJzZSA9IGZvcmdlLmpzYm4uQmlnSW50ZWdlci5wcm90b3R5cGUubW9kSW52ZXJzZTtcbmNvbnN0IHBvc2l0aXZlTW9kSW52ZXJzZSA9IGZ1bmN0aW9uKG0pIHtcbiAgY29uc3QgaW52ID0gb3JpZ2luYWxNb2RJbnZlcnNlLmFwcGx5KHRoaXMsIFttXSk7XG4gIHJldHVybiBpbnYubW9kKG0pO1xufVxuXG5mb3JnZS5qc2JuLkJpZ0ludGVnZXIucHJvdG90eXBlLm1vZEludmVyc2UgPSBwb3NpdGl2ZU1vZEludmVyc2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZm9yZ2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/deps/forge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/node-jose/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * index.js - Main Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nif (typeof Promise === \"undefined\") {\n  (__webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\").polyfill)();\n}\n\nif (typeof Buffer === \"undefined\") {\n  (global || window).Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n}\n\nif (typeof process === \"undefined\") {\n  (global || window).process = __webpack_require__(/*! process */ \"process\");\n}\n\nif (!process.version) {\n  process.version = \"\";\n}\n\nvar JWS = __webpack_require__(/*! ./jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\");\n\nmodule.exports = {\n  JWA: __webpack_require__(/*! ./algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n  JWE: __webpack_require__(/*! ./jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWK: __webpack_require__(/*! ./jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n  JWS: JWS,\n  util: __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n  parse: __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/node-jose/lib/parse/index.js\"),\n  canYouSee: JWS.createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxFQUFFLHlHQUErQjtBQUNqQzs7QUFFQTtBQUNBLDhCQUE4QixvREFBd0I7QUFDdEQ7O0FBRUE7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyx3QkFBUztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLDhEQUFPOztBQUV6QjtBQUNBLE9BQU8sbUJBQU8sQ0FBQyw0RUFBYztBQUM3QixPQUFPLG1CQUFPLENBQUMsOERBQU87QUFDdEIsT0FBTyxtQkFBTyxDQUFDLDhEQUFPO0FBQ3RCO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLGdFQUFRO0FBQ3hCLFNBQVMsbUJBQU8sQ0FBQyxrRUFBUztBQUMxQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvaW5kZXguanM/ZmIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGluZGV4LmpzIC0gTWFpbiBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5pZiAodHlwZW9mIFByb21pc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgcmVxdWlyZShcImVzNi1wcm9taXNlXCIpLnBvbHlmaWxsKCk7XG59XG5cbmlmICh0eXBlb2YgQnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIChnbG9iYWwgfHwgd2luZG93KS5CdWZmZXIgPSByZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbn1cblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gIChnbG9iYWwgfHwgd2luZG93KS5wcm9jZXNzID0gcmVxdWlyZShcInByb2Nlc3NcIik7XG59XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uKSB7XG4gIHByb2Nlc3MudmVyc2lvbiA9IFwiXCI7XG59XG5cbnZhciBKV1MgPSByZXF1aXJlKFwiLi9qd3NcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBKV0E6IHJlcXVpcmUoXCIuL2FsZ29yaXRobXNcIiksXG4gIEpXRTogcmVxdWlyZShcIi4vandlXCIpLFxuICBKV0s6IHJlcXVpcmUoXCIuL2p3a1wiKSxcbiAgSldTOiBKV1MsXG4gIHV0aWw6IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gIHBhcnNlOiByZXF1aXJlKFwiLi9wYXJzZVwiKSxcbiAgY2FuWW91U2VlOiBKV1MuY3JlYXRlVmVyaWZ5XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/decrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/decrypt.js - Decrypt from a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\"\n};\n\n/**\n * @class JWE.Decrypter\n * @classdesc Processor of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead\n * call {@link JWE.createDecrypt}.\n */\nfunction JWEDecrypter(ks, globalOpts) {\n  var assumedKey,\n    keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    throw new TypeError(\"Keystore must be provided\");\n  }\n\n  globalOpts = merge({}, DEFAULT_OPTIONS, globalOpts);\n\n  /**\n   * Decrypts the given input.\n   *\n   * {opts}, if provided, is used to customize this specific decrypt operation.\n   * This argument has the same semantics as {JWE.createDecrypt}, and takes\n   * precedence over those options.\n   *\n   * The returned PRomise, when fulfilled, returns an object with the\n   * following members:\n   *\n   * - `header` - The JOSE Header, combined from the relevant \"header\" and\n   *            \"protected\" fields from the original JWE object.\n   * - `protected` - An array containing the names of the protected fields\n   * - `key` - The used to decrypt the content\n   * - `payload` - The decrypted content (as a Buffer)\n   * - `plaintext` - An alias for `payload`\n   *\n   * @param {Object|String} input The encrypted content\n   * @param {Object} [opts] The options for this decryption operation.\n   * @returns {Promise} A promise for the decyprted plaintext\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      /* eslint camelcase: [0] */\n      if (typeof input === \"string\") {\n        input = input.split(\".\");\n        input = {\n          protected: input[0],\n          recipients: [\n            {\n              encrypted_key: input[1]\n            }\n          ],\n          iv: input[2],\n          ciphertext: input[3],\n          tag: input[4]\n        };\n      } else if (!input || typeof input !== \"object\") {\n        throw new Error(\"invalid input\");\n      }\n      if (\"encrypted_key\" in input) {\n        input.recipients = [\n          {\n            encrypted_key: input.encrypted_key\n          }\n        ];\n      }\n\n      var promise;\n\n      // ensure recipients exists\n      var rcptList = input.recipients || [{}];\n      promise = Promise.resolve(rcptList);\n\n      //combine fields\n      var fields,\n          protect;\n      promise = promise.then(function(rcptList) {\n        if (input.protected) {\n          protect = base64url.decode(input.protected).toString(\"utf8\");\n          protect = JSON.parse(protect);\n\n          // verify \"crit\" field first\n          var crit = protect.crit;\n          if (crit) {\n            if (!Array.isArray(crit)) {\n              return Promise.reject(new Error(\"Invalid 'crit' header\"));\n            }\n            for (var idx = 0; crit.length > idx; idx++) {\n              if (-1 === handlerKeys.indexOf(crit[idx])) {\n                return Promise.reject(new Error(\n                    \"Critical extension is not supported: \" + crit[idx]\n                ));\n              }\n            }\n          }\n\n          fields = protect;\n          protect = Object.keys(protect);\n        } else {\n          fields = {};\n          protect = [];\n        }\n        fields = merge(input.unprotected || {}, fields);\n\n        rcptList = rcptList.map(function(r) {\n          var promise = Promise.resolve();\n          var header = r.header || {};\n          header = merge(header, fields);\n          r.header = header;\n          r.protected = protect;\n\n          // check on allowed algorithms\n          if (!algSpec.match(header.alg)) {\n            promise = promise.then(function() {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n            });\n          }\n          if (!algSpec.match(header.enc)) {\n            promise = promise.then(function () {\n              return Promise.reject(new Error(\"Algorithm not allowed: \" + header.enc));\n            });\n          }\n\n          if (header.epk) {\n            promise = promise.then(function() {\n              return JWK.asKey(header.epk);\n            });\n            promise = promise.then(function(epk) {\n              header.epk = epk.toObject(false);\n            });\n          }\n          return promise.then(function() {\n            return r;\n          });\n        });\n\n        return Promise.all(rcptList);\n      });\n\n      // decrypt with first key found\n      var algKey,\n        encKey,\n        kdata;\n      promise = promise.then(function(rcptList) {\n        var jwe = {};\n        return new Promise(function(resolve, reject) {\n          var processKey = function() {\n            var rcpt = rcptList.shift();\n            if (!rcpt) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            var algPromise = Promise.resolve(rcpt);\n            algPromise = algPromise.then(function(rcpt) {\n              // try to unwrap encrypted key\n              var prekey = kdata = rcpt.encrypted_key || \"\";\n              prekey = base64url.decode(prekey);\n              algKey = assumedKey || keystore.get({\n                use: \"enc\",\n                alg: rcpt.header.alg,\n                kid: rcpt.header.kid\n              });\n              if (algKey) {\n                return algKey.unwrap(rcpt.header.alg, prekey, rcpt.header);\n              } else {\n                return Promise.reject();\n              }\n            });\n            algPromise = algPromise.then(function(key) {\n              encKey = {\n                \"kty\": \"oct\",\n                \"k\": base64url.encode(key)\n              };\n              encKey = JWK.asKey(encKey);\n              jwe.key = algKey;\n              jwe.header = rcpt.header;\n              jwe.protected = rcpt.protected;\n              resolve(jwe);\n            });\n            algPromise.catch(processKey);\n          };\n          processKey();\n        });\n      });\n\n      // assign decipher inputs\n      promise = promise.then(function(jwe) {\n        jwe.iv = input.iv;\n        jwe.tag = input.tag;\n        jwe.ciphertext = input.ciphertext;\n\n        return jwe;\n      });\n\n      // process any prepare-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"function\" === typeof h) {\n            p = h(jwe);\n          } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n            p = h.prepare(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      // prepare decrypt inputs\n      promise = promise.then(function(jwe) {\n        if (!Buffer.isBuffer(jwe.ciphertext)) {\n          jwe.ciphertext = base64url.decode(jwe.ciphertext);\n        }\n\n        return jwe;\n      });\n\n      // decrypt it!\n      promise = promise.then(function(jwe) {\n        var adata = input.protected;\n        if (\"aad\" in input && null != input.aad) {\n          adata += \".\" + input.aad;\n        }\n\n        var params = {\n          iv: jwe.iv,\n          adata: adata,\n          tag: jwe.tag,\n          kdata: kdata,\n          epu: jwe.epu,\n          epv: jwe.epv\n        };\n        var cdata = jwe.ciphertext;\n\n        delete jwe.iv;\n        delete jwe.tag;\n        delete jwe.ciphertext;\n\n        return encKey.\n          then(function(enkKey) {\n            return enkKey.decrypt(jwe.header.enc, cdata, params).\n              then(function(pdata) {\n                jwe.payload = jwe.plaintext = pdata;\n                return jwe;\n              });\n          });\n      });\n\n      // (OPTIONAL) decompress plaintext\n      promise = promise.then(function(jwe) {\n        if (\"DEF\" === jwe.header.zip) {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.inflateRaw(Buffer.from(jwe.plaintext))\n\n              jwe.payload = jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (err) {\n              reject(err);\n            }\n          });\n        }\n\n        return jwe;\n      });\n\n      // process any post-decrypt handlers\n      promise = promise.then(function(jwe) {\n        var processing = [];\n        handlerKeys.forEach(function(h) {\n          h = extraHandlers[h];\n          var p;\n          if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n            p = h.complete(jwe);\n          }\n          if (p) {\n            processing.push(Promise.resolve(p));\n          }\n        });\n        return Promise.all(processing).then(function() {\n          // don't actually care about individual handler results\n          // assume {jwe} is updated\n          return jwe;\n        });\n      });\n\n      return promise;\n    }\n  });\n}\n\n/**\n * @description\n * Creates a new Decrypter for the given Key or KeyStore.\n *\n * {opts}, when provided, is used to customize decryption processes. The\n * following options are currently supported:\n *\n * - `handlers` - An object where each name is a JOSE header member name and\n *   the value can be a boolean, function, or an object.\n *\n * Handlers are intended to support 'crit' extensions. When a boolean value,\n * the member is expected to be processed once decryption is fully complete.\n * When a function, it is called just before the ciphertext is decrypted\n * (processed as if it were a `prepare` handler, as decribed below). When an\n * object, it can contain any of the following members:\n *\n * - `recipient` - A function called after a valid key is determined; it takes\n *   an object describing the recipient, and returns a Promise that is\n *   fulfilled once the handler's processing is complete.\n * - `prepare` - A function called just prior to decrypting the ciphertext;\n *   it takes an object describing the decryption result (but containing\n *   `ciphertext` and `tag' instead of `payload` and `plaintext`), and\n *   returns a Promise that is fulfilled once the handler's processing is\n *   complete.\n * - `complete` - A function called once decryption is complete, just prior\n *   to fulfilling the Promise returned by `decrypt()`; it takes the object\n *   that will be returned by `decrypt()`'s fulfilled Promise, and returns\n *   a Promise that is fulfilled once the handler's processing is complete.\n *\n * Note that normal processing of `decrypt()` does not continue until all\n * relevant handlers have completed. Any changes handlers make to the\n * provided objects affects `decrypt()`'s processing.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for decryption.\n * @param {Object} [opts] The options for this Decrypter.\n * @returns {JWE.Decrypter} The new Decrypter.\n */\nfunction createDecrypt(ks, opts) {\n  var dec = new JWEDecrypter(ks, opts);\n  return dec;\n}\n\nmodule.exports = {\n  decrypter: JWEDecrypter,\n  createDecrypt: createDecrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVjcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsK0VBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFLO0FBQ1gsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixXQUFXO0FBQ1gsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBSztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9kZWNyeXB0LmpzPzUzMzQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2UvZGVjcnlwdC5qcyAtIERlY3J5cHQgZnJvbSBhIEpXRVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYmFzZTY0dXJsID0gcmVxdWlyZShcIi4uL3V0aWwvYmFzZTY0dXJsXCIpLFxuICAgIEFsZ0NvbmZpZyA9IHJlcXVpcmUoXCIuLi91dGlsL2FsZ2NvbmZpZ1wiKSxcbiAgICBKV0sgPSByZXF1aXJlKFwiLi4vandrXCIpLFxuICAgIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIiksXG4gICAgcGFrbyA9IHJlcXVpcmUoXCJwYWtvXCIpO1xuXG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBhbGdvcml0aG1zOiBcIipcIlxufTtcblxuLyoqXG4gKiBAY2xhc3MgSldFLkRlY3J5cHRlclxuICogQGNsYXNzZGVzYyBQcm9jZXNzb3Igb2YgZW5jcnlwdGVkIGRhdGEuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogVGhpcyBjbGFzcyBjYW5ub3QgYmUgaW5zdGFudGlhdGVkIGRpcmVjdGx5LiBJbnN0ZWFkXG4gKiBjYWxsIHtAbGluayBKV0UuY3JlYXRlRGVjcnlwdH0uXG4gKi9cbmZ1bmN0aW9uIEpXRURlY3J5cHRlcihrcywgZ2xvYmFsT3B0cykge1xuICB2YXIgYXNzdW1lZEtleSxcbiAgICBrZXlzdG9yZTtcblxuICBpZiAoSldLLmlzS2V5KGtzKSkge1xuICAgIGFzc3VtZWRLZXkgPSBrcztcbiAgICBrZXlzdG9yZSA9IGFzc3VtZWRLZXkua2V5c3RvcmU7XG4gIH0gZWxzZSBpZiAoSldLLmlzS2V5U3RvcmUoa3MpKSB7XG4gICAga2V5c3RvcmUgPSBrcztcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5c3RvcmUgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgfVxuXG4gIGdsb2JhbE9wdHMgPSBtZXJnZSh7fSwgREVGQVVMVF9PUFRJT05TLCBnbG9iYWxPcHRzKTtcblxuICAvKipcbiAgICogRGVjcnlwdHMgdGhlIGdpdmVuIGlucHV0LlxuICAgKlxuICAgKiB7b3B0c30sIGlmIHByb3ZpZGVkLCBpcyB1c2VkIHRvIGN1c3RvbWl6ZSB0aGlzIHNwZWNpZmljIGRlY3J5cHQgb3BlcmF0aW9uLlxuICAgKiBUaGlzIGFyZ3VtZW50IGhhcyB0aGUgc2FtZSBzZW1hbnRpY3MgYXMge0pXRS5jcmVhdGVEZWNyeXB0fSwgYW5kIHRha2VzXG4gICAqIHByZWNlZGVuY2Ugb3ZlciB0aG9zZSBvcHRpb25zLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgUFJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAqIGZvbGxvd2luZyBtZW1iZXJzOlxuICAgKlxuICAgKiAtIGBoZWFkZXJgIC0gVGhlIEpPU0UgSGVhZGVyLCBjb21iaW5lZCBmcm9tIHRoZSByZWxldmFudCBcImhlYWRlclwiIGFuZFxuICAgKiAgICAgICAgICAgIFwicHJvdGVjdGVkXCIgZmllbGRzIGZyb20gdGhlIG9yaWdpbmFsIEpXRSBvYmplY3QuXG4gICAqIC0gYHByb3RlY3RlZGAgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBuYW1lcyBvZiB0aGUgcHJvdGVjdGVkIGZpZWxkc1xuICAgKiAtIGBrZXlgIC0gVGhlIHVzZWQgdG8gZGVjcnlwdCB0aGUgY29udGVudFxuICAgKiAtIGBwYXlsb2FkYCAtIFRoZSBkZWNyeXB0ZWQgY29udGVudCAoYXMgYSBCdWZmZXIpXG4gICAqIC0gYHBsYWludGV4dGAgLSBBbiBhbGlhcyBmb3IgYHBheWxvYWRgXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW5wdXQgVGhlIGVuY3J5cHRlZCBjb250ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gVGhlIG9wdGlvbnMgZm9yIHRoaXMgZGVjcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgZm9yIHRoZSBkZWN5cHJ0ZWQgcGxhaW50ZXh0XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWNyeXB0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaW5wdXQsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBtZXJnZSh7fSwgZ2xvYmFsT3B0cywgb3B0cyB8fCB7fSk7XG4gICAgICB2YXIgZXh0cmFIYW5kbGVycyA9IG9wdHMuaGFuZGxlcnMgfHwge307XG4gICAgICB2YXIgaGFuZGxlcktleXMgPSBPYmplY3Qua2V5cyhleHRyYUhhbmRsZXJzKTtcbiAgICAgIHZhciBhbGdTcGVjID0gbmV3IEFsZ0NvbmZpZyhvcHRzLmFsZ29yaXRobXMpO1xuXG4gICAgICAvKiBlc2xpbnQgY2FtZWxjYXNlOiBbMF0gKi9cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zcGxpdChcIi5cIik7XG4gICAgICAgIGlucHV0ID0ge1xuICAgICAgICAgIHByb3RlY3RlZDogaW5wdXRbMF0sXG4gICAgICAgICAgcmVjaXBpZW50czogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBlbmNyeXB0ZWRfa2V5OiBpbnB1dFsxXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXY6IGlucHV0WzJdLFxuICAgICAgICAgIGNpcGhlcnRleHQ6IGlucHV0WzNdLFxuICAgICAgICAgIHRhZzogaW5wdXRbNF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoIWlucHV0IHx8IHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0XCIpO1xuICAgICAgfVxuICAgICAgaWYgKFwiZW5jcnlwdGVkX2tleVwiIGluIGlucHV0KSB7XG4gICAgICAgIGlucHV0LnJlY2lwaWVudHMgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW5jcnlwdGVkX2tleTogaW5wdXQuZW5jcnlwdGVkX2tleVxuICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgIC8vIGVuc3VyZSByZWNpcGllbnRzIGV4aXN0c1xuICAgICAgdmFyIHJjcHRMaXN0ID0gaW5wdXQucmVjaXBpZW50cyB8fCBbe31dO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShyY3B0TGlzdCk7XG5cbiAgICAgIC8vY29tYmluZSBmaWVsZHNcbiAgICAgIHZhciBmaWVsZHMsXG4gICAgICAgICAgcHJvdGVjdDtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24ocmNwdExpc3QpIHtcbiAgICAgICAgaWYgKGlucHV0LnByb3RlY3RlZCkge1xuICAgICAgICAgIHByb3RlY3QgPSBiYXNlNjR1cmwuZGVjb2RlKGlucHV0LnByb3RlY3RlZCkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgIHByb3RlY3QgPSBKU09OLnBhcnNlKHByb3RlY3QpO1xuXG4gICAgICAgICAgLy8gdmVyaWZ5IFwiY3JpdFwiIGZpZWxkIGZpcnN0XG4gICAgICAgICAgdmFyIGNyaXQgPSBwcm90ZWN0LmNyaXQ7XG4gICAgICAgICAgaWYgKGNyaXQpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjcml0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCAnY3JpdCcgaGVhZGVyXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGNyaXQubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgICAgICAgICAgICBpZiAoLTEgPT09IGhhbmRsZXJLZXlzLmluZGV4T2YoY3JpdFtpZHhdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ3JpdGljYWwgZXh0ZW5zaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiICsgY3JpdFtpZHhdXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZHMgPSBwcm90ZWN0O1xuICAgICAgICAgIHByb3RlY3QgPSBPYmplY3Qua2V5cyhwcm90ZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWVsZHMgPSB7fTtcbiAgICAgICAgICBwcm90ZWN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzID0gbWVyZ2UoaW5wdXQudW5wcm90ZWN0ZWQgfHwge30sIGZpZWxkcyk7XG5cbiAgICAgICAgcmNwdExpc3QgPSByY3B0TGlzdC5tYXAoZnVuY3Rpb24ocikge1xuICAgICAgICAgIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgdmFyIGhlYWRlciA9IHIuaGVhZGVyIHx8IHt9O1xuICAgICAgICAgIGhlYWRlciA9IG1lcmdlKGhlYWRlciwgZmllbGRzKTtcbiAgICAgICAgICByLmhlYWRlciA9IGhlYWRlcjtcbiAgICAgICAgICByLnByb3RlY3RlZCA9IHByb3RlY3Q7XG5cbiAgICAgICAgICAvLyBjaGVjayBvbiBhbGxvd2VkIGFsZ29yaXRobXNcbiAgICAgICAgICBpZiAoIWFsZ1NwZWMubWF0Y2goaGVhZGVyLmFsZykpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJBbGdvcml0aG0gbm90IGFsbG93ZWQ6IFwiICsgaGVhZGVyLmFsZykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYWxnU3BlYy5tYXRjaChoZWFkZXIuZW5jKSkge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJBbGdvcml0aG0gbm90IGFsbG93ZWQ6IFwiICsgaGVhZGVyLmVuYykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhlYWRlci5lcGspIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBKV0suYXNLZXkoaGVhZGVyLmVwayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oZXBrKSB7XG4gICAgICAgICAgICAgIGhlYWRlci5lcGsgPSBlcGsudG9PYmplY3QoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJjcHRMaXN0KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWNyeXB0IHdpdGggZmlyc3Qga2V5IGZvdW5kXG4gICAgICB2YXIgYWxnS2V5LFxuICAgICAgICBlbmNLZXksXG4gICAgICAgIGtkYXRhO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyY3B0TGlzdCkge1xuICAgICAgICB2YXIgandlID0ge307XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgcHJvY2Vzc0tleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJjcHQgPSByY3B0TGlzdC5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKCFyY3B0KSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJubyBrZXkgZm91bmRcIikpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhbGdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHJjcHQpO1xuICAgICAgICAgICAgYWxnUHJvbWlzZSA9IGFsZ1Byb21pc2UudGhlbihmdW5jdGlvbihyY3B0KSB7XG4gICAgICAgICAgICAgIC8vIHRyeSB0byB1bndyYXAgZW5jcnlwdGVkIGtleVxuICAgICAgICAgICAgICB2YXIgcHJla2V5ID0ga2RhdGEgPSByY3B0LmVuY3J5cHRlZF9rZXkgfHwgXCJcIjtcbiAgICAgICAgICAgICAgcHJla2V5ID0gYmFzZTY0dXJsLmRlY29kZShwcmVrZXkpO1xuICAgICAgICAgICAgICBhbGdLZXkgPSBhc3N1bWVkS2V5IHx8IGtleXN0b3JlLmdldCh7XG4gICAgICAgICAgICAgICAgdXNlOiBcImVuY1wiLFxuICAgICAgICAgICAgICAgIGFsZzogcmNwdC5oZWFkZXIuYWxnLFxuICAgICAgICAgICAgICAgIGtpZDogcmNwdC5oZWFkZXIua2lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoYWxnS2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsZ0tleS51bndyYXAocmNwdC5oZWFkZXIuYWxnLCBwcmVrZXksIHJjcHQuaGVhZGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGdQcm9taXNlID0gYWxnUHJvbWlzZS50aGVuKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICBlbmNLZXkgPSB7XG4gICAgICAgICAgICAgICAgXCJrdHlcIjogXCJvY3RcIixcbiAgICAgICAgICAgICAgICBcImtcIjogYmFzZTY0dXJsLmVuY29kZShrZXkpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGVuY0tleSA9IEpXSy5hc0tleShlbmNLZXkpO1xuICAgICAgICAgICAgICBqd2Uua2V5ID0gYWxnS2V5O1xuICAgICAgICAgICAgICBqd2UuaGVhZGVyID0gcmNwdC5oZWFkZXI7XG4gICAgICAgICAgICAgIGp3ZS5wcm90ZWN0ZWQgPSByY3B0LnByb3RlY3RlZDtcbiAgICAgICAgICAgICAgcmVzb2x2ZShqd2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbGdQcm9taXNlLmNhdGNoKHByb2Nlc3NLZXkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcHJvY2Vzc0tleSgpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhc3NpZ24gZGVjaXBoZXIgaW5wdXRzXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICBqd2UuaXYgPSBpbnB1dC5pdjtcbiAgICAgICAgandlLnRhZyA9IGlucHV0LnRhZztcbiAgICAgICAgandlLmNpcGhlcnRleHQgPSBpbnB1dC5jaXBoZXJ0ZXh0O1xuXG4gICAgICAgIHJldHVybiBqd2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJvY2VzcyBhbnkgcHJlcGFyZS1kZWNyeXB0IGhhbmRsZXJzXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgcHJvY2Vzc2luZyA9IFtdO1xuICAgICAgICBoYW5kbGVyS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICBoID0gZXh0cmFIYW5kbGVyc1toXTtcbiAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaCkge1xuICAgICAgICAgICAgcCA9IGgoandlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGgucHJlcGFyZSkge1xuICAgICAgICAgICAgcCA9IGgucHJlcGFyZShqd2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgcHJvY2Vzc2luZy5wdXNoKFByb21pc2UucmVzb2x2ZShwKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIGhhbmRsZXIgcmVzdWx0c1xuICAgICAgICAgIC8vIGFzc3VtZSB7andlfSBpcyB1cGRhdGVkXG4gICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gcHJlcGFyZSBkZWNyeXB0IGlucHV0c1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoandlLmNpcGhlcnRleHQpKSB7XG4gICAgICAgICAgandlLmNpcGhlcnRleHQgPSBiYXNlNjR1cmwuZGVjb2RlKGp3ZS5jaXBoZXJ0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBqd2U7XG4gICAgICB9KTtcblxuICAgICAgLy8gZGVjcnlwdCBpdCFcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIHZhciBhZGF0YSA9IGlucHV0LnByb3RlY3RlZDtcbiAgICAgICAgaWYgKFwiYWFkXCIgaW4gaW5wdXQgJiYgbnVsbCAhPSBpbnB1dC5hYWQpIHtcbiAgICAgICAgICBhZGF0YSArPSBcIi5cIiArIGlucHV0LmFhZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgaXY6IGp3ZS5pdixcbiAgICAgICAgICBhZGF0YTogYWRhdGEsXG4gICAgICAgICAgdGFnOiBqd2UudGFnLFxuICAgICAgICAgIGtkYXRhOiBrZGF0YSxcbiAgICAgICAgICBlcHU6IGp3ZS5lcHUsXG4gICAgICAgICAgZXB2OiBqd2UuZXB2XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjZGF0YSA9IGp3ZS5jaXBoZXJ0ZXh0O1xuXG4gICAgICAgIGRlbGV0ZSBqd2UuaXY7XG4gICAgICAgIGRlbGV0ZSBqd2UudGFnO1xuICAgICAgICBkZWxldGUgandlLmNpcGhlcnRleHQ7XG5cbiAgICAgICAgcmV0dXJuIGVuY0tleS5cbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGVua0tleSkge1xuICAgICAgICAgICAgcmV0dXJuIGVua0tleS5kZWNyeXB0KGp3ZS5oZWFkZXIuZW5jLCBjZGF0YSwgcGFyYW1zKS5cbiAgICAgICAgICAgICAgdGhlbihmdW5jdGlvbihwZGF0YSkge1xuICAgICAgICAgICAgICAgIGp3ZS5wYXlsb2FkID0gandlLnBsYWludGV4dCA9IHBkYXRhO1xuICAgICAgICAgICAgICAgIHJldHVybiBqd2U7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIChPUFRJT05BTCkgZGVjb21wcmVzcyBwbGFpbnRleHRcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgIGlmIChcIkRFRlwiID09PSBqd2UuaGVhZGVyLnppcCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0gcGFrby5pbmZsYXRlUmF3KEJ1ZmZlci5mcm9tKGp3ZS5wbGFpbnRleHQpKVxuXG4gICAgICAgICAgICAgIGp3ZS5wYXlsb2FkID0gandlLnBsYWludGV4dCA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICAgICAgICByZXNvbHZlKGp3ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2Nlc3MgYW55IHBvc3QtZGVjcnlwdCBoYW5kbGVyc1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIHByb2Nlc3NpbmcgPSBbXTtcbiAgICAgICAgaGFuZGxlcktleXMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgaCA9IGV4dHJhSGFuZGxlcnNbaF07XG4gICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBoICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGguY29tcGxldGUpIHtcbiAgICAgICAgICAgIHAgPSBoLmNvbXBsZXRlKGp3ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBwcm9jZXNzaW5nLnB1c2goUHJvbWlzZS5yZXNvbHZlKHApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvY2Vzc2luZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IGluZGl2aWR1YWwgaGFuZGxlciByZXN1bHRzXG4gICAgICAgICAgLy8gYXNzdW1lIHtqd2V9IGlzIHVwZGF0ZWRcbiAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIG5ldyBEZWNyeXB0ZXIgZm9yIHRoZSBnaXZlbiBLZXkgb3IgS2V5U3RvcmUuXG4gKlxuICoge29wdHN9LCB3aGVuIHByb3ZpZGVkLCBpcyB1c2VkIHRvIGN1c3RvbWl6ZSBkZWNyeXB0aW9uIHByb2Nlc3Nlcy4gVGhlXG4gKiBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZDpcbiAqXG4gKiAtIGBoYW5kbGVyc2AgLSBBbiBvYmplY3Qgd2hlcmUgZWFjaCBuYW1lIGlzIGEgSk9TRSBoZWFkZXIgbWVtYmVyIG5hbWUgYW5kXG4gKiAgIHRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuLCBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0LlxuICpcbiAqIEhhbmRsZXJzIGFyZSBpbnRlbmRlZCB0byBzdXBwb3J0ICdjcml0JyBleHRlbnNpb25zLiBXaGVuIGEgYm9vbGVhbiB2YWx1ZSxcbiAqIHRoZSBtZW1iZXIgaXMgZXhwZWN0ZWQgdG8gYmUgcHJvY2Vzc2VkIG9uY2UgZGVjcnlwdGlvbiBpcyBmdWxseSBjb21wbGV0ZS5cbiAqIFdoZW4gYSBmdW5jdGlvbiwgaXQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBjaXBoZXJ0ZXh0IGlzIGRlY3J5cHRlZFxuICogKHByb2Nlc3NlZCBhcyBpZiBpdCB3ZXJlIGEgYHByZXBhcmVgIGhhbmRsZXIsIGFzIGRlY3JpYmVkIGJlbG93KS4gV2hlbiBhblxuICogb2JqZWN0LCBpdCBjYW4gY29udGFpbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBtZW1iZXJzOlxuICpcbiAqIC0gYHJlY2lwaWVudGAgLSBBIGZ1bmN0aW9uIGNhbGxlZCBhZnRlciBhIHZhbGlkIGtleSBpcyBkZXRlcm1pbmVkOyBpdCB0YWtlc1xuICogICBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgcmVjaXBpZW50LCBhbmQgcmV0dXJucyBhIFByb21pc2UgdGhhdCBpc1xuICogICBmdWxmaWxsZWQgb25jZSB0aGUgaGFuZGxlcidzIHByb2Nlc3NpbmcgaXMgY29tcGxldGUuXG4gKiAtIGBwcmVwYXJlYCAtIEEgZnVuY3Rpb24gY2FsbGVkIGp1c3QgcHJpb3IgdG8gZGVjcnlwdGluZyB0aGUgY2lwaGVydGV4dDtcbiAqICAgaXQgdGFrZXMgYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGRlY3J5cHRpb24gcmVzdWx0IChidXQgY29udGFpbmluZ1xuICogICBgY2lwaGVydGV4dGAgYW5kIGB0YWcnIGluc3RlYWQgb2YgYHBheWxvYWRgIGFuZCBgcGxhaW50ZXh0YCksIGFuZFxuICogICByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCBvbmNlIHRoZSBoYW5kbGVyJ3MgcHJvY2Vzc2luZyBpc1xuICogICBjb21wbGV0ZS5cbiAqIC0gYGNvbXBsZXRlYCAtIEEgZnVuY3Rpb24gY2FsbGVkIG9uY2UgZGVjcnlwdGlvbiBpcyBjb21wbGV0ZSwganVzdCBwcmlvclxuICogICB0byBmdWxmaWxsaW5nIHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IGBkZWNyeXB0KClgOyBpdCB0YWtlcyB0aGUgb2JqZWN0XG4gKiAgIHRoYXQgd2lsbCBiZSByZXR1cm5lZCBieSBgZGVjcnlwdCgpYCdzIGZ1bGZpbGxlZCBQcm9taXNlLCBhbmQgcmV0dXJuc1xuICogICBhIFByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgb25jZSB0aGUgaGFuZGxlcidzIHByb2Nlc3NpbmcgaXMgY29tcGxldGUuXG4gKlxuICogTm90ZSB0aGF0IG5vcm1hbCBwcm9jZXNzaW5nIG9mIGBkZWNyeXB0KClgIGRvZXMgbm90IGNvbnRpbnVlIHVudGlsIGFsbFxuICogcmVsZXZhbnQgaGFuZGxlcnMgaGF2ZSBjb21wbGV0ZWQuIEFueSBjaGFuZ2VzIGhhbmRsZXJzIG1ha2UgdG8gdGhlXG4gKiBwcm92aWRlZCBvYmplY3RzIGFmZmVjdHMgYGRlY3J5cHQoKWAncyBwcm9jZXNzaW5nLlxuICpcbiAqIEBwYXJhbSB7SldLLktleXxKV0suS2V5U3RvcmV9IGtzIFRoZSBLZXkgb3IgS2V5U3RvcmUgdG8gdXNlIGZvciBkZWNyeXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXSBUaGUgb3B0aW9ucyBmb3IgdGhpcyBEZWNyeXB0ZXIuXG4gKiBAcmV0dXJucyB7SldFLkRlY3J5cHRlcn0gVGhlIG5ldyBEZWNyeXB0ZXIuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlY3J5cHQoa3MsIG9wdHMpIHtcbiAgdmFyIGRlYyA9IG5ldyBKV0VEZWNyeXB0ZXIoa3MsIG9wdHMpO1xuICByZXR1cm4gZGVjO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVjcnlwdGVyOiBKV0VEZWNyeXB0ZXIsXG4gIGNyZWF0ZURlY3J5cHQ6IGNyZWF0ZURlY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jwe/defaults.js - Defaults for JWEs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWE.createEncrypt}.\n *\n * @property {Boolean|String} zip Determines the compression algorithm to\n *           apply to the plaintext (if any) before it is encrypted. This can\n *           also be `true` (which is equivalent to `\"DEF\"`) or **`false`**\n *           (the default, which is equivalent to no compression).\n * @property {String} format Determines the serialization format of the\n *           output.  Expected to be `\"general\"` for general JSON\n *           Serialization, `\"flattened\"` for flattened JSON Serialization,\n *           or `\"compact\"` for Compact Serialization (default is\n *           **`\"general\"`**).\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String} contentAlg The algorithm used to encrypt the plaintext\n *           (default is **`\"A128CBC-HS256\"`**).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of the header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           header parameters are integrity protected.\n */\nvar JWEDefaults = {\n  zip: false,\n  format: \"general\",\n  contentAlg: \"A128CBC-HS256\",\n  protect: \"*\"\n};\n\nmodule.exports = JWEDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIsd0JBQXdCO0FBQ3BEO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ZS9kZWZhdWx0cy5qcz9hNTZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandlL2RlZmF1bHRzLmpzIC0gRGVmYXVsdHMgZm9yIEpXRXNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBkZWZhdWx0IG9wdGlvbnMgZm9yIHtAbGluayBKV0UuY3JlYXRlRW5jcnlwdH0uXG4gKlxuICogQHByb3BlcnR5IHtCb29sZWFufFN0cmluZ30gemlwIERldGVybWluZXMgdGhlIGNvbXByZXNzaW9uIGFsZ29yaXRobSB0b1xuICogICAgICAgICAgIGFwcGx5IHRvIHRoZSBwbGFpbnRleHQgKGlmIGFueSkgYmVmb3JlIGl0IGlzIGVuY3J5cHRlZC4gVGhpcyBjYW5cbiAqICAgICAgICAgICBhbHNvIGJlIGB0cnVlYCAod2hpY2ggaXMgZXF1aXZhbGVudCB0byBgXCJERUZcImApIG9yICoqYGZhbHNlYCoqXG4gKiAgICAgICAgICAgKHRoZSBkZWZhdWx0LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIG5vIGNvbXByZXNzaW9uKS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBmb3JtYXQgRGV0ZXJtaW5lcyB0aGUgc2VyaWFsaXphdGlvbiBmb3JtYXQgb2YgdGhlXG4gKiAgICAgICAgICAgb3V0cHV0LiAgRXhwZWN0ZWQgdG8gYmUgYFwiZ2VuZXJhbFwiYCBmb3IgZ2VuZXJhbCBKU09OXG4gKiAgICAgICAgICAgU2VyaWFsaXphdGlvbiwgYFwiZmxhdHRlbmVkXCJgIGZvciBmbGF0dGVuZWQgSlNPTiBTZXJpYWxpemF0aW9uLFxuICogICAgICAgICAgIG9yIGBcImNvbXBhY3RcImAgZm9yIENvbXBhY3QgU2VyaWFsaXphdGlvbiAoZGVmYXVsdCBpc1xuICogICAgICAgICAgICoqYFwiZ2VuZXJhbFwiYCoqKS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gY29tcGFjdCBEZXRlcm1pbmVzIGlmIHRoZSBvdXRwdXQgaXMgdGhlIENvbXBhY3RcbiAqICAgICAgICAgICBzZXJpYWxpemF0aW9uIChgdHJ1ZWApIG9yIHRoZSBKU09OIHNlcmlhbGl6YXRpb24gKCoqYGZhbHNlYCoqLFxuICogICAgICAgICAgIHRoZSBkZWZhdWx0KS5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb250ZW50QWxnIFRoZSBhbGdvcml0aG0gdXNlZCB0byBlbmNyeXB0IHRoZSBwbGFpbnRleHRcbiAqICAgICAgICAgICAoZGVmYXVsdCBpcyAqKmBcIkExMjhDQkMtSFMyNTZcImAqKikuXG4gKiBAcHJvcGVydHkge1N0cmluZ3xTdHJpbmdbXX0gcHJvdGVjdCBUaGUgbmFtZXMgb2YgdGhlIGhlYWRlcnMgdG8gaW50ZWdyaXR5XG4gKiAgICAgICAgICAgcHJvdGVjdC4gIFRoZSB2YWx1ZSBgXCJcImAgbWVhbnMgdGhhdCBub25lIG9mIHRoZSBoZWFkZXIgcGFyYW1ldGVyc1xuICogICAgICAgICAgIGFyZSBpbnRlZ3JpdHkgcHJvdGVjdGVkLCB3aGlsZSBgXCIqXCJgICh0aGUgZGVmYXVsdCkgbWVhbnMgdGhhdCBhbGxcbiAqICAgICAgICAgICBoZWFkZXIgcGFyYW1ldGVycyBhcmUgaW50ZWdyaXR5IHByb3RlY3RlZC5cbiAqL1xudmFyIEpXRURlZmF1bHRzID0ge1xuICB6aXA6IGZhbHNlLFxuICBmb3JtYXQ6IFwiZ2VuZXJhbFwiLFxuICBjb250ZW50QWxnOiBcIkExMjhDQkMtSFMyNTZcIixcbiAgcHJvdGVjdDogXCIqXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSldFRGVmYXVsdHM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/encrypt.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/encrypt.js - Encrypt to a JWE\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    generateCEK = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").generateCEK),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\").slice),\n    pako = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/pako/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jwe/defaults.js\");\n\n/**\n * @class JWE.Encrypter\n * @classdesc\n * Generator of encrypted data.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call {@link\n * JWE.createEncrypt}.\n */\nfunction JWEEncrypter(cfg, fields, recipients) {\n  var finalized = false,\n    format = cfg.format || \"general\",\n    protectAll = !!cfg.protectAll,\n    content = Buffer.alloc(0);\n\n  /**\n   * @member {String} JWE.Encrypter#zip\n   * @readonly\n   * @description\n   * Indicates the compression algorithm applied to the plaintext\n   * before it is encrypted.  The possible values are:\n   *\n   * + **`\"DEF\"`**: Compress the plaintext using the DEFLATE algorithm.\n   * + **`\"\"`**: Do not compress the plaintext.\n   */\n  Object.defineProperty(this, \"zip\", {\n    get: function() {\n      return fields.zip || \"\";\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Boolean} JWE.Encrypter#compact\n   * @readonly\n   * @description\n   * Indicates whether the output of this encryption generator is\n   * using the Compact serialization (`true`) or the JSON\n   * serialization (`false`).\n   */\n  Object.defineProperty(this, \"compact\", {\n    get: function() { return \"compact\" === format; },\n    enumerable: true\n  });\n  /**\n   * @member {String} JWE.Encrypter#format\n   * @readonly\n   * @description\n   * Indicates the format the output of this encryption generator takes.\n   */\n  Object.defineProperty(this, \"format\", {\n    get: function() { return format; },\n    enumerable: true\n  });\n  /**\n   * @member {String[]} JWE.Encrypter#protected\n   * @readonly\n   * @description\n   * The header parameter names that are protected. Protected header fields\n   * are first serialized to UTF-8 then encoded as util.base64url, then used as\n   * the additional authenticated data in the encryption operation.\n   */\n  Object.defineProperty(this, \"protected\", {\n    get: function() {\n      return clone(cfg.protect);\n    },\n    enumerable: true\n  });\n  /**\n   * @member {Object} JWE.Encrypter#header\n   * @readonly\n   * @description\n   * The global header parameters, both protected and unprotected. Call\n   * {@link JWE.Encrypter#protected} to determine which parameters will\n   * be protected.\n   */\n  Object.defineProperty(this, \"header\", {\n    get: function() {\n      return clone(fields);\n    },\n    enumerable: true\n  });\n\n  /**\n   * @method JWE.Encrypter#update\n   * @description\n   * Updates the plaintext data for the encryption generator. The plaintext\n   * is appended to the end of any other plaintext already applied.\n   *\n   * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n   * converted to a Buffer internally to {encoding}.\n   *\n   * @param {Buffer|String} [data] The plaintext to apply.\n   * @param {String} [encoding] The encoding of the plaintext.\n   * @returns {JWE.Encrypter} This encryption generator.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n   * @method JWE.Encrypter#final\n   * @description\n   * Finishes the encryption operation.\n   *\n   * The returned Promise, when fulfilled, is the JSON Web Encryption (JWE)\n   * object, either in the Compact (if {@link JWE.Encrypter#compact} is\n   * `true`) or the JSON serialization.\n   *\n   * @param {Buffer|String} [data] The final plaintext data to apply.\n   * @param {String} [encoding] The encoding of the final plaintext data\n   *        (if any).\n   * @returns {Promise} A promise for the encryption operation.\n   * @throws {Error} If ciphertext has already been generated.\n   */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise = Promise.resolve({});\n\n      // determine CEK and IV\n      var encAlg = fields.enc;\n      var encKey;\n      promise = promise.then(function(jwe) {\n        if (cfg.cek) {\n          encKey = JWK.asKey(cfg.cek);\n        }\n        return jwe;\n      });\n\n      // process recipients\n      promise = promise.then(function(jwe) {\n        var procR = function(r, one) {\n          var props = {};\n          props = assign(props, fields);\n          props = assign(props, r.header);\n\n          var algKey = r.key,\n              algAlg = props.alg;\n\n          // generate Ephemeral EC Key\n          var tks,\n              rpromise;\n          if ((props.alg || \"\").indexOf(\"ECDH-ES\") === 0) {\n            tks = algKey.keystore.temp();\n            if (r.epk) {\n              rpromise = Promise.resolve(r.epk).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            } else {\n              rpromise = tks.generate(\"EC\", algKey.get(\"crv\")).\n                then(function(epk) {\n                  r.header.epk = epk.toJSON(false, [\"kid\"]);\n                  props.epk = epk.toObject(true, [\"kid\"]);\n                });\n            }\n          } else {\n            rpromise = Promise.resolve();\n          }\n\n          // encrypt the CEK\n          rpromise = rpromise.then(function() {\n            var cek,\n                p;\n            // special case 'alg=dir'\n            if (\"dir\" === algAlg && one) {\n              encKey = Promise.resolve(algKey);\n              p = encKey.then(function(jwk) {\n                // fixup encAlg\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = jwk.algorithms(JWK.MODE_ENCRYPT)[0];\n                }\n                return {\n                  once: true,\n                  direct: true\n                };\n              });\n            } else {\n              if (!encKey) {\n                if (!encAlg) {\n                  props.enc = fields.enc = encAlg = cfg.contentAlg;\n                }\n                encKey = generateCEK(encAlg);\n              }\n              p = encKey.then(function(jwk) {\n                cek = jwk.get(\"k\", true);\n                // algKey may or may not be a promise\n                return algKey;\n              });\n              p = p.then(function(algKey) {\n                return algKey.wrap(algAlg, cek, props);\n              });\n            }\n            return p;\n          });\n          rpromise = rpromise.then(function(wrapped) {\n            if (wrapped.once && !one) {\n              return Promise.reject(new Error(\"cannot use 'alg':'\" + algAlg + \"' with multiple recipients\"));\n            }\n\n            var rjwe = {},\n                cek;\n            if (wrapped.data) {\n              cek = wrapped.data;\n              cek = util.base64url.encode(cek);\n            }\n\n            if (wrapped.direct && cek) {\n              // replace content key\n              encKey = JWK.asKey({\n                kty: \"oct\",\n                k: cek\n              });\n            } else if (cek) {\n              /* eslint camelcase: [0] */\n              rjwe.encrypted_key = cek;\n            }\n\n            if (r.header && Object.keys(r.header).length) {\n              rjwe.header = clone(r.header || {});\n            }\n            if (wrapped.header) {\n              rjwe.header = assign(rjwe.header || {},\n                                     wrapped.header);\n            }\n\n            return rjwe;\n           });\n           return rpromise;\n        };\n\n        var p = Promise.all(recipients);\n        p = p.then(function(rcpts) {\n          var single = (1 === rcpts.length);\n          rcpts = rcpts.map(function(r) {\n            return procR(r, single);\n          });\n          return Promise.all(rcpts);\n        });\n        p = p.then(function(rcpts) {\n          jwe.recipients = rcpts.filter(function(r) { return !!r; });\n          return jwe;\n        });\n        return p;\n      });\n\n      // normalize headers\n      var props = {};\n      promise = promise.then(function(jwe) {\n        var protect,\n          lenProtect,\n          unprotect,\n          lenUnprotect;\n\n        unprotect = clone(fields);\n        if ((protectAll && jwe.recipients.length === 1) || \"compact\" === format) {\n          // merge single recipient into fields\n          protect = {};\n          protect = assign({},\n                     unprotect,\n                    jwe.recipients[0].header);\n          lenProtect = Object.keys(protect).length;\n\n          unprotect = undefined;\n          lenUnprotect = 0;\n\n          delete jwe.recipients[0].header;\n          if (Object.keys(jwe.recipients[0]).length === 0) {\n            jwe.recipients.splice(0, 1);\n          }\n        } else {\n          protect = {};\n          lenProtect = 0;\n          lenUnprotect = Object.keys(unprotect).length;\n          cfg.protect.forEach(function(f) {\n            // remove protected header values from body unprotected header\n            if (!(f in unprotect)) {\n              return;\n            }\n            protect[f] = unprotect[f];\n            lenProtect++;\n\n            delete unprotect[f];\n            lenUnprotect--;\n          });\n\n          jwe.recipients = (jwe.recipients || []).map(function(rcpt) {\n            rcpt = rcpt || {};\n            var header = rcpt.header;\n            if (header) {\n              Object.keys(header).forEach(function (f) {\n                if (f in protect) { delete header[f]; }\n              });\n              if (!Object.keys(header).length) {\n                delete rcpt.header;\n              }\n            }\n            return rcpt;\n          });\n        }\n\n        if (!jwe.recipients || jwe.recipients.length === 0) {\n          delete jwe.recipients;\n        }\n\n        // \"serialize\" (and setup merged props)\n        if (unprotect && lenUnprotect > 0) {\n          props = assign(props, unprotect);\n          jwe.unprotected = unprotect;\n        }\n        if (protect && lenProtect > 0) {\n          props = assign(props, protect);\n          protect = JSON.stringify(protect);\n          jwe.protected = util.base64url.encode(protect, \"utf8\");\n        }\n\n        return jwe;\n      });\n\n      // (OPTIONAL) compress plaintext\n      promise = promise.then(function(jwe) {\n        var pdata = content;\n        if (!props.zip) {\n          jwe.plaintext = pdata;\n          return jwe;\n        } else if (props.zip === \"DEF\") {\n          return new Promise(function(resolve, reject) {\n            try {\n              var data = pako.deflateRaw(Buffer.from(pdata, \"binary\"));\n\n              jwe.plaintext = Buffer.from(data);\n              resolve(jwe);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        }\n        return Promise.reject(new Error(\"unsupported 'zip' mode\"));\n      });\n\n      // encrypt plaintext\n      promise = promise.then(function(jwe) {\n        props.adata = jwe.protected;\n        if (\"aad\" in cfg && cfg.aad != null) {\n          props.adata += \".\" + cfg.aad;\n          props.adata = Buffer.from(props.adata, \"utf8\");\n        }\n        // calculate IV\n        var iv = cfg.iv ||\n                 util.randomBytes(CONSTANTS.NONCELENGTH[encAlg] / 8);\n        if (\"string\" === typeof iv) {\n          iv = util.base64url.decode(iv);\n        }\n        props.iv = iv;\n\n        if (\"recipients\" in jwe && jwe.recipients.length === 1) {\n          props.kdata = jwe.recipients[0].encrypted_key;\n        }\n\n        if (\"epu\" in cfg && cfg.epu != null) {\n          props.epu = cfg.epu;\n        }\n\n        if (\"epv\" in cfg && cfg.epv != null) {\n          props.epv = cfg.epv;\n        }\n\n        var pdata = jwe.plaintext;\n        delete jwe.plaintext;\n        return encKey.then(function(encKey) {\n          var p = encKey.encrypt(encAlg, pdata, props);\n          p = p.then(function(result) {\n            jwe.iv = util.base64url.encode(iv, \"binary\");\n            if (\"aad\" in cfg && cfg.aad != null) {\n             jwe.aad = cfg.aad;\n            }\n            jwe.ciphertext = util.base64url.encode(result.data, \"binary\");\n            jwe.tag = util.base64url.encode(result.tag, \"binary\");\n            return jwe;\n          });\n          return p;\n        });\n      });\n\n      // (OPTIONAL) compact/flattened results\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jwe) {\n            var compact = new Array(5);\n\n            compact[0] = jwe.protected;\n            if (jwe.recipients && jwe.recipients[0]) {\n              compact[1] = jwe.recipients[0].encrypted_key;\n            }\n\n            compact[2] = jwe.iv;\n            compact[3] = jwe.ciphertext;\n            compact[4] = jwe.tag;\n            compact = compact.join(\".\");\n\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jwe) {\n            var flattened = {},\n                rcpt = jwe.recipients && jwe.recipients[0];\n\n            if (jwe.protected) {\n              flattened.protected = jwe.protected;\n            }\n            if (jwe.unprotected) {\n              flattened.unprotected = jwe.unprotected;\n            }\n            [\"header\", \"encrypted_key\"].forEach(function(f) {\n              if (!rcpt) { return; }\n              if (!(f in rcpt)) { return; }\n              if (!rcpt[f]) { return; }\n              if (\"object\" === typeof rcpt[f] && !Object.keys(rcpt[f]).length) { return; }\n              flattened[f] = rcpt[f];\n            });\n            if (jwe.aad) {\n              flattened.aad = jwe.aad;\n            }\n            flattened.iv = jwe.iv;\n            flattened.ciphertext = jwe.ciphertext;\n            flattened.tag = jwe.tag;\n\n            return flattened;\n          });\n          break;\n        case \"general\":\n          promise = promise.then(function(jwe) {\n            var recipients = jwe.recipients || [];\n            recipients = recipients.map(function (rcpt) {\n              if (!Object.keys(rcpt).length) { return undefined; }\n              return rcpt;\n            });\n            recipients = recipients.filter(function (rcpt) { return !!rcpt; });\n            if (recipients.length) {\n              jwe.recipients = recipients;\n            } else {\n              delete jwe.recipients;\n            }\n\n            return jwe;\n          });\n      }\n\n      return promise;\n    }\n  });\n}\n\nfunction createEncrypt(opts, rcpts) {\n  // fixup recipients\n  var options = opts,\n    rcptStart = 1,\n    rcptList = rcpts;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one recipient must be provided\");\n  }\n  if (arguments.length === 1) {\n    // assume opts is the recipient list\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n        (opts && \"kty\" in opts) ||\n        (opts && \"key\" in opts &&\n        (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    rcptList = opts;\n    rcptStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(rcptList)) {\n    rcptList = slice(arguments, rcptStart);\n  }\n\n  // fixup options\n  options = assign(clone(DEFAULTS), options);\n\n  // setup header fields\n  var fields = clone(options.fields || {});\n  if (options.zip) {\n    fields.zip = (typeof options.zip === \"boolean\") ?\n           (options.zip ? \"DEF\" : false) :\n           options.zip;\n  }\n  options.format = (options.compact ? \"compact\" : options.format) || \"general\";\n  switch (options.format) {\n    case \"compact\":\n      if (\"aad\" in opts) {\n        throw new Error(\"additional authenticated data cannot be used for compact serialization\");\n      }\n      /* eslint no-fallthrough: [0] */\n    case \"flattened\":\n      if (rcptList.length > 1) {\n        throw new Error(\"too many recipients for compact serialization\");\n      }\n      break;\n  }\n\n  // note protected fields (globally)\n  // protected fields are global only\n  var protectAll = false;\n  if (\"compact\" === options.format || \"*\" === options.protect) {\n    protectAll = true;\n    options.protect = Object.keys(fields).concat(\"enc\");\n  } else if (typeof options.protect === \"string\") {\n    options.protect = [options.protect];\n  } else if (Array.isArray(options.protect)) {\n    options.protect = options.protect.concat();\n  } else if (!options.protect) {\n    options.protect = [];\n  } else {\n    throw new Error(\"protect must be a list of fields\");\n  }\n\n  if (protectAll && 1 < rcptList.length) {\n    throw new Error(\"too many recipients to protect all header parameters\");\n  }\n\n  rcptList = rcptList.map(function(r, idx) {\n    var p;\n\n    // resolve a key\n    if (r && \"kty\" in r) {\n      p = JWK.asKey(r);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (r) {\n      p = JWK.asKey(r.key);\n      p = p.then(function(k) {\n        return {\n          header: r.header,\n          reference: r.reference,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for recipient \" + idx));\n    }\n\n    // convert ephemeral key (if present)\n    if (r.epk) {\n      p = p.then(function(recipient) {\n        return JWK.asKey(r.epk).\n          then(function(epk) {\n            recipient.epk = epk;\n            return recipient;\n          });\n      });\n    }\n\n    // resolve the complete recipient\n    p = p.then(function(recipient) {\n      var key = recipient.key;\n\n      // prepare the recipient header\n      var header = recipient.header || {};\n      recipient.header = header;\n      var props = {};\n      props = assign(props, fields);\n      props = assign(props, recipient.header);\n\n      // ensure key protection algorithm is set\n      if (!props.alg) {\n        props.alg = key.algorithms(JWK.MODE_WRAP)[0];\n        header.alg = props.alg;\n      }\n      if (!props.alg) {\n        return Promise.reject(new Error(\"key not valid for encrypting to recipient \" + idx));\n      }\n      header.alg = props.alg;\n\n      // determine the key reference\n      var ref = recipient.reference;\n      delete recipient.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // freeze recipient\n      recipient = Object.freeze(recipient);\n      return recipient;\n    });\n\n    return p;\n  });\n\n  // create and configure encryption\n  var cfg = {\n    aad: (\"aad\" in options) ? util.base64url.encode(options.aad || \"\") : null,\n    contentAlg: options.contentAlg,\n    format: options.format,\n    protect: options.protect,\n    cek: options.cek,\n    iv: options.iv,\n    protectAll: protectAll\n  };\n  var enc = new JWEEncrypter(cfg, fields, rcptList);\n\n  return enc;\n}\n\nmodule.exports = {\n  encrypter: JWEEncrypter,\n  createEncrypt: createEncrypt\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZW5jcnlwdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGlFQUFTO0FBQzVCLGtCQUFrQix1R0FBZ0M7QUFDbEQsVUFBVSxtQkFBTyxDQUFDLCtEQUFRO0FBQzFCLFlBQVksaUdBQTBCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyxnREFBTTtBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQywyRkFBeUI7O0FBRWpELGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLHNFQUFZOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNyRSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxlQUFlO0FBQzlCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw2QkFBNkI7QUFDckU7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzREFBc0QsYUFBYTtBQUNuRTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0Isa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixpRkFBaUY7QUFDakY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxhQUFhO0FBQ2IsNkRBQTZELGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvZW5jcnlwdC5qcz9mNzRiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandlL2VuY3J5cHQuanMgLSBFbmNyeXB0IHRvIGEgSldFXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIiksXG4gICAgZ2VuZXJhdGVDRUsgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpLmdlbmVyYXRlQ0VLLFxuICAgIEpXSyA9IHJlcXVpcmUoXCIuLi9qd2tcIiksXG4gICAgc2xpY2UgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpLnNsaWNlLFxuICAgIHBha28gPSByZXF1aXJlKFwicGFrb1wiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtcy9jb25zdGFudHNcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIik7XG52YXIgREVGQVVMVFMgPSByZXF1aXJlKFwiLi9kZWZhdWx0c1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgSldFLkVuY3J5cHRlclxuICogQGNsYXNzZGVzY1xuICogR2VuZXJhdG9yIG9mIGVuY3J5cHRlZCBkYXRhLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIFRoaXMgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsIHtAbGlua1xuICogSldFLmNyZWF0ZUVuY3J5cHR9LlxuICovXG5mdW5jdGlvbiBKV0VFbmNyeXB0ZXIoY2ZnLCBmaWVsZHMsIHJlY2lwaWVudHMpIHtcbiAgdmFyIGZpbmFsaXplZCA9IGZhbHNlLFxuICAgIGZvcm1hdCA9IGNmZy5mb3JtYXQgfHwgXCJnZW5lcmFsXCIsXG4gICAgcHJvdGVjdEFsbCA9ICEhY2ZnLnByb3RlY3RBbGwsXG4gICAgY29udGVudCA9IEJ1ZmZlci5hbGxvYygwKTtcblxuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0UuRW5jcnlwdGVyI3ppcFxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEluZGljYXRlcyB0aGUgY29tcHJlc3Npb24gYWxnb3JpdGhtIGFwcGxpZWQgdG8gdGhlIHBsYWludGV4dFxuICAgKiBiZWZvcmUgaXQgaXMgZW5jcnlwdGVkLiAgVGhlIHBvc3NpYmxlIHZhbHVlcyBhcmU6XG4gICAqXG4gICAqICsgKipgXCJERUZcImAqKjogQ29tcHJlc3MgdGhlIHBsYWludGV4dCB1c2luZyB0aGUgREVGTEFURSBhbGdvcml0aG0uXG4gICAqICsgKipgXCJcImAqKjogRG8gbm90IGNvbXByZXNzIHRoZSBwbGFpbnRleHQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ6aXBcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmllbGRzLnppcCB8fCBcIlwiO1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge0Jvb2xlYW59IEpXRS5FbmNyeXB0ZXIjY29tcGFjdFxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBvdXRwdXQgb2YgdGhpcyBlbmNyeXB0aW9uIGdlbmVyYXRvciBpc1xuICAgKiB1c2luZyB0aGUgQ29tcGFjdCBzZXJpYWxpemF0aW9uIChgdHJ1ZWApIG9yIHRoZSBKU09OXG4gICAqIHNlcmlhbGl6YXRpb24gKGBmYWxzZWApLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29tcGFjdFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwiY29tcGFjdFwiID09PSBmb3JtYXQ7IH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldFLkVuY3J5cHRlciNmb3JtYXRcbiAgICogQHJlYWRvbmx5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBJbmRpY2F0ZXMgdGhlIGZvcm1hdCB0aGUgb3V0cHV0IG9mIHRoaXMgZW5jcnlwdGlvbiBnZW5lcmF0b3IgdGFrZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBmb3JtYXQ7IH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ1tdfSBKV0UuRW5jcnlwdGVyI3Byb3RlY3RlZFxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBoZWFkZXIgcGFyYW1ldGVyIG5hbWVzIHRoYXQgYXJlIHByb3RlY3RlZC4gUHJvdGVjdGVkIGhlYWRlciBmaWVsZHNcbiAgICogYXJlIGZpcnN0IHNlcmlhbGl6ZWQgdG8gVVRGLTggdGhlbiBlbmNvZGVkIGFzIHV0aWwuYmFzZTY0dXJsLCB0aGVuIHVzZWQgYXNcbiAgICogdGhlIGFkZGl0aW9uYWwgYXV0aGVudGljYXRlZCBkYXRhIGluIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInByb3RlY3RlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjbG9uZShjZmcucHJvdGVjdCk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7T2JqZWN0fSBKV0UuRW5jcnlwdGVyI2hlYWRlclxuICAgKiBAcmVhZG9ubHlcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBnbG9iYWwgaGVhZGVyIHBhcmFtZXRlcnMsIGJvdGggcHJvdGVjdGVkIGFuZCB1bnByb3RlY3RlZC4gQ2FsbFxuICAgKiB7QGxpbmsgSldFLkVuY3J5cHRlciNwcm90ZWN0ZWR9IHRvIGRldGVybWluZSB3aGljaCBwYXJhbWV0ZXJzIHdpbGxcbiAgICogYmUgcHJvdGVjdGVkLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVhZGVyXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNsb25lKGZpZWxkcyk7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXRS5FbmNyeXB0ZXIjdXBkYXRlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVcGRhdGVzIHRoZSBwbGFpbnRleHQgZGF0YSBmb3IgdGhlIGVuY3J5cHRpb24gZ2VuZXJhdG9yLiBUaGUgcGxhaW50ZXh0XG4gICAqIGlzIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgYW55IG90aGVyIHBsYWludGV4dCBhbHJlYWR5IGFwcGxpZWQuXG4gICAqXG4gICAqIElmIHtkYXRhfSBpcyBhIEJ1ZmZlciwge2VuY29kaW5nfSBpcyBpZ25vcmVkLiBPdGhlcndpc2UsIHtkYXRhfSBpc1xuICAgKiBjb252ZXJ0ZWQgdG8gYSBCdWZmZXIgaW50ZXJuYWxseSB0byB7ZW5jb2Rpbmd9LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IFtkYXRhXSBUaGUgcGxhaW50ZXh0IHRvIGFwcGx5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nXSBUaGUgZW5jb2Rpbmcgb2YgdGhlIHBsYWludGV4dC5cbiAgICogQHJldHVybnMge0pXRS5FbmNyeXB0ZXJ9IFRoaXMgZW5jcnlwdGlvbiBnZW5lcmF0b3IuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBjaXBoZXJ0ZXh0IGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXBkYXRlXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIGlmIChmaW5hbGl6ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgZGF0YSA9IHV0aWwuYXNCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZW50ID0gQnVmZmVyLmNvbmNhdChbY29udGVudCwgZGF0YV0sXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudC5sZW5ndGggKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldFLkVuY3J5cHRlciNmaW5hbFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRmluaXNoZXMgdGhlIGVuY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBUaGUgcmV0dXJuZWQgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIGlzIHRoZSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAqIG9iamVjdCwgZWl0aGVyIGluIHRoZSBDb21wYWN0IChpZiB7QGxpbmsgSldFLkVuY3J5cHRlciNjb21wYWN0fSBpc1xuICAgKiBgdHJ1ZWApIG9yIHRoZSBKU09OIHNlcmlhbGl6YXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gW2RhdGFdIFRoZSBmaW5hbCBwbGFpbnRleHQgZGF0YSB0byBhcHBseS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZ10gVGhlIGVuY29kaW5nIG9mIHRoZSBmaW5hbCBwbGFpbnRleHQgZGF0YVxuICAgKiAgICAgICAgKGlmIGFueSkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgZm9yIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNpcGhlcnRleHQgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5hbFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGRhdGEsIGVuY29kaW5nKSB7XG4gICAgICBpZiAoZmluYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbHJlYWR5IGZpbmFsXCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gbGFzdC1taW51dGUgZGF0YVxuICAgICAgdGhpcy51cGRhdGUoZGF0YSwgZW5jb2RpbmcpO1xuXG4gICAgICAvLyBtYXJrIGFzIGRvbmUuLi5pc2hcbiAgICAgIGZpbmFsaXplZCA9IHRydWU7XG4gICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh7fSk7XG5cbiAgICAgIC8vIGRldGVybWluZSBDRUsgYW5kIElWXG4gICAgICB2YXIgZW5jQWxnID0gZmllbGRzLmVuYztcbiAgICAgIHZhciBlbmNLZXk7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICBpZiAoY2ZnLmNlaykge1xuICAgICAgICAgIGVuY0tleSA9IEpXSy5hc0tleShjZmcuY2VrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHByb2Nlc3MgcmVjaXBpZW50c1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIHByb2NSID0gZnVuY3Rpb24ociwgb25lKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIGZpZWxkcyk7XG4gICAgICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIHIuaGVhZGVyKTtcblxuICAgICAgICAgIHZhciBhbGdLZXkgPSByLmtleSxcbiAgICAgICAgICAgICAgYWxnQWxnID0gcHJvcHMuYWxnO1xuXG4gICAgICAgICAgLy8gZ2VuZXJhdGUgRXBoZW1lcmFsIEVDIEtleVxuICAgICAgICAgIHZhciB0a3MsXG4gICAgICAgICAgICAgIHJwcm9taXNlO1xuICAgICAgICAgIGlmICgocHJvcHMuYWxnIHx8IFwiXCIpLmluZGV4T2YoXCJFQ0RILUVTXCIpID09PSAwKSB7XG4gICAgICAgICAgICB0a3MgPSBhbGdLZXkua2V5c3RvcmUudGVtcCgpO1xuICAgICAgICAgICAgaWYgKHIuZXBrKSB7XG4gICAgICAgICAgICAgIHJwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHIuZXBrKS5cbiAgICAgICAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGVwaykge1xuICAgICAgICAgICAgICAgICAgci5oZWFkZXIuZXBrID0gZXBrLnRvSlNPTihmYWxzZSwgW1wia2lkXCJdKTtcbiAgICAgICAgICAgICAgICAgIHByb3BzLmVwayA9IGVway50b09iamVjdCh0cnVlLCBbXCJraWRcIl0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnByb21pc2UgPSB0a3MuZ2VuZXJhdGUoXCJFQ1wiLCBhbGdLZXkuZ2V0KFwiY3J2XCIpKS5cbiAgICAgICAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGVwaykge1xuICAgICAgICAgICAgICAgICAgci5oZWFkZXIuZXBrID0gZXBrLnRvSlNPTihmYWxzZSwgW1wia2lkXCJdKTtcbiAgICAgICAgICAgICAgICAgIHByb3BzLmVwayA9IGVway50b09iamVjdCh0cnVlLCBbXCJraWRcIl0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBycHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGVuY3J5cHQgdGhlIENFS1xuICAgICAgICAgIHJwcm9taXNlID0gcnByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjZWssXG4gICAgICAgICAgICAgICAgcDtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSAnYWxnPWRpcidcbiAgICAgICAgICAgIGlmIChcImRpclwiID09PSBhbGdBbGcgJiYgb25lKSB7XG4gICAgICAgICAgICAgIGVuY0tleSA9IFByb21pc2UucmVzb2x2ZShhbGdLZXkpO1xuICAgICAgICAgICAgICBwID0gZW5jS2V5LnRoZW4oZnVuY3Rpb24oandrKSB7XG4gICAgICAgICAgICAgICAgLy8gZml4dXAgZW5jQWxnXG4gICAgICAgICAgICAgICAgaWYgKCFlbmNBbGcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzLmVuYyA9IGZpZWxkcy5lbmMgPSBlbmNBbGcgPSBqd2suYWxnb3JpdGhtcyhKV0suTU9ERV9FTkNSWVBUKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG9uY2U6IHRydWUsXG4gICAgICAgICAgICAgICAgICBkaXJlY3Q6IHRydWVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghZW5jS2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbmNBbGcpIHtcbiAgICAgICAgICAgICAgICAgIHByb3BzLmVuYyA9IGZpZWxkcy5lbmMgPSBlbmNBbGcgPSBjZmcuY29udGVudEFsZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5jS2V5ID0gZ2VuZXJhdGVDRUsoZW5jQWxnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwID0gZW5jS2V5LnRoZW4oZnVuY3Rpb24oandrKSB7XG4gICAgICAgICAgICAgICAgY2VrID0gandrLmdldChcImtcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gYWxnS2V5IG1heSBvciBtYXkgbm90IGJlIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgIHJldHVybiBhbGdLZXk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGFsZ0tleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGdLZXkud3JhcChhbGdBbGcsIGNlaywgcHJvcHMpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJwcm9taXNlID0gcnByb21pc2UudGhlbihmdW5jdGlvbih3cmFwcGVkKSB7XG4gICAgICAgICAgICBpZiAod3JhcHBlZC5vbmNlICYmICFvbmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCB1c2UgJ2FsZyc6J1wiICsgYWxnQWxnICsgXCInIHdpdGggbXVsdGlwbGUgcmVjaXBpZW50c1wiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByandlID0ge30sXG4gICAgICAgICAgICAgICAgY2VrO1xuICAgICAgICAgICAgaWYgKHdyYXBwZWQuZGF0YSkge1xuICAgICAgICAgICAgICBjZWsgPSB3cmFwcGVkLmRhdGE7XG4gICAgICAgICAgICAgIGNlayA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShjZWspO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod3JhcHBlZC5kaXJlY3QgJiYgY2VrKSB7XG4gICAgICAgICAgICAgIC8vIHJlcGxhY2UgY29udGVudCBrZXlcbiAgICAgICAgICAgICAgZW5jS2V5ID0gSldLLmFzS2V5KHtcbiAgICAgICAgICAgICAgICBrdHk6IFwib2N0XCIsXG4gICAgICAgICAgICAgICAgazogY2VrXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjZWspIHtcbiAgICAgICAgICAgICAgLyogZXNsaW50IGNhbWVsY2FzZTogWzBdICovXG4gICAgICAgICAgICAgIHJqd2UuZW5jcnlwdGVkX2tleSA9IGNlaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHIuaGVhZGVyICYmIE9iamVjdC5rZXlzKHIuaGVhZGVyKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmp3ZS5oZWFkZXIgPSBjbG9uZShyLmhlYWRlciB8fCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod3JhcHBlZC5oZWFkZXIpIHtcbiAgICAgICAgICAgICAgcmp3ZS5oZWFkZXIgPSBhc3NpZ24ocmp3ZS5oZWFkZXIgfHwge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlZC5oZWFkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmp3ZTtcbiAgICAgICAgICAgfSk7XG4gICAgICAgICAgIHJldHVybiBycHJvbWlzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcCA9IFByb21pc2UuYWxsKHJlY2lwaWVudHMpO1xuICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJjcHRzKSB7XG4gICAgICAgICAgdmFyIHNpbmdsZSA9ICgxID09PSByY3B0cy5sZW5ndGgpO1xuICAgICAgICAgIHJjcHRzID0gcmNwdHMubWFwKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jUihyLCBzaW5nbGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyY3B0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJjcHRzKSB7XG4gICAgICAgICAgandlLnJlY2lwaWVudHMgPSByY3B0cy5maWx0ZXIoZnVuY3Rpb24ocikgeyByZXR1cm4gISFyOyB9KTtcbiAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9KTtcblxuICAgICAgLy8gbm9ybWFsaXplIGhlYWRlcnNcbiAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgdmFyIHByb3RlY3QsXG4gICAgICAgICAgbGVuUHJvdGVjdCxcbiAgICAgICAgICB1bnByb3RlY3QsXG4gICAgICAgICAgbGVuVW5wcm90ZWN0O1xuXG4gICAgICAgIHVucHJvdGVjdCA9IGNsb25lKGZpZWxkcyk7XG4gICAgICAgIGlmICgocHJvdGVjdEFsbCAmJiBqd2UucmVjaXBpZW50cy5sZW5ndGggPT09IDEpIHx8IFwiY29tcGFjdFwiID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAvLyBtZXJnZSBzaW5nbGUgcmVjaXBpZW50IGludG8gZmllbGRzXG4gICAgICAgICAgcHJvdGVjdCA9IHt9O1xuICAgICAgICAgIHByb3RlY3QgPSBhc3NpZ24oe30sXG4gICAgICAgICAgICAgICAgICAgICB1bnByb3RlY3QsXG4gICAgICAgICAgICAgICAgICAgIGp3ZS5yZWNpcGllbnRzWzBdLmhlYWRlcik7XG4gICAgICAgICAgbGVuUHJvdGVjdCA9IE9iamVjdC5rZXlzKHByb3RlY3QpLmxlbmd0aDtcblxuICAgICAgICAgIHVucHJvdGVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBsZW5VbnByb3RlY3QgPSAwO1xuXG4gICAgICAgICAgZGVsZXRlIGp3ZS5yZWNpcGllbnRzWzBdLmhlYWRlcjtcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoandlLnJlY2lwaWVudHNbMF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgandlLnJlY2lwaWVudHMuc3BsaWNlKDAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm90ZWN0ID0ge307XG4gICAgICAgICAgbGVuUHJvdGVjdCA9IDA7XG4gICAgICAgICAgbGVuVW5wcm90ZWN0ID0gT2JqZWN0LmtleXModW5wcm90ZWN0KS5sZW5ndGg7XG4gICAgICAgICAgY2ZnLnByb3RlY3QuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgcHJvdGVjdGVkIGhlYWRlciB2YWx1ZXMgZnJvbSBib2R5IHVucHJvdGVjdGVkIGhlYWRlclxuICAgICAgICAgICAgaWYgKCEoZiBpbiB1bnByb3RlY3QpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb3RlY3RbZl0gPSB1bnByb3RlY3RbZl07XG4gICAgICAgICAgICBsZW5Qcm90ZWN0Kys7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB1bnByb3RlY3RbZl07XG4gICAgICAgICAgICBsZW5VbnByb3RlY3QtLTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGp3ZS5yZWNpcGllbnRzID0gKGp3ZS5yZWNpcGllbnRzIHx8IFtdKS5tYXAoZnVuY3Rpb24ocmNwdCkge1xuICAgICAgICAgICAgcmNwdCA9IHJjcHQgfHwge307XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gcmNwdC5oZWFkZXI7XG4gICAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcikuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIGlmIChmIGluIHByb3RlY3QpIHsgZGVsZXRlIGhlYWRlcltmXTsgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhoZWFkZXIpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByY3B0LmhlYWRlcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJjcHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWp3ZS5yZWNpcGllbnRzIHx8IGp3ZS5yZWNpcGllbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGRlbGV0ZSBqd2UucmVjaXBpZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFwic2VyaWFsaXplXCIgKGFuZCBzZXR1cCBtZXJnZWQgcHJvcHMpXG4gICAgICAgIGlmICh1bnByb3RlY3QgJiYgbGVuVW5wcm90ZWN0ID4gMCkge1xuICAgICAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCB1bnByb3RlY3QpO1xuICAgICAgICAgIGp3ZS51bnByb3RlY3RlZCA9IHVucHJvdGVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdGVjdCAmJiBsZW5Qcm90ZWN0ID4gMCkge1xuICAgICAgICAgIHByb3BzID0gYXNzaWduKHByb3BzLCBwcm90ZWN0KTtcbiAgICAgICAgICBwcm90ZWN0ID0gSlNPTi5zdHJpbmdpZnkocHJvdGVjdCk7XG4gICAgICAgICAgandlLnByb3RlY3RlZCA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShwcm90ZWN0LCBcInV0ZjhcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gandlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIChPUFRJT05BTCkgY29tcHJlc3MgcGxhaW50ZXh0XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICB2YXIgcGRhdGEgPSBjb250ZW50O1xuICAgICAgICBpZiAoIXByb3BzLnppcCkge1xuICAgICAgICAgIGp3ZS5wbGFpbnRleHQgPSBwZGF0YTtcbiAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BzLnppcCA9PT0gXCJERUZcIikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0gcGFrby5kZWZsYXRlUmF3KEJ1ZmZlci5mcm9tKHBkYXRhLCBcImJpbmFyeVwiKSk7XG5cbiAgICAgICAgICAgICAgandlLnBsYWludGV4dCA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgICAgICAgICAgICByZXNvbHZlKGp3ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCAnemlwJyBtb2RlXCIpKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBlbmNyeXB0IHBsYWludGV4dFxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihqd2UpIHtcbiAgICAgICAgcHJvcHMuYWRhdGEgPSBqd2UucHJvdGVjdGVkO1xuICAgICAgICBpZiAoXCJhYWRcIiBpbiBjZmcgJiYgY2ZnLmFhZCAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcHMuYWRhdGEgKz0gXCIuXCIgKyBjZmcuYWFkO1xuICAgICAgICAgIHByb3BzLmFkYXRhID0gQnVmZmVyLmZyb20ocHJvcHMuYWRhdGEsIFwidXRmOFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWxjdWxhdGUgSVZcbiAgICAgICAgdmFyIGl2ID0gY2ZnLml2IHx8XG4gICAgICAgICAgICAgICAgIHV0aWwucmFuZG9tQnl0ZXMoQ09OU1RBTlRTLk5PTkNFTEVOR1RIW2VuY0FsZ10gLyA4KTtcbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpdikge1xuICAgICAgICAgIGl2ID0gdXRpbC5iYXNlNjR1cmwuZGVjb2RlKGl2KTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wcy5pdiA9IGl2O1xuXG4gICAgICAgIGlmIChcInJlY2lwaWVudHNcIiBpbiBqd2UgJiYgandlLnJlY2lwaWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcHJvcHMua2RhdGEgPSBqd2UucmVjaXBpZW50c1swXS5lbmNyeXB0ZWRfa2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiZXB1XCIgaW4gY2ZnICYmIGNmZy5lcHUgIT0gbnVsbCkge1xuICAgICAgICAgIHByb3BzLmVwdSA9IGNmZy5lcHU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJlcHZcIiBpbiBjZmcgJiYgY2ZnLmVwdiAhPSBudWxsKSB7XG4gICAgICAgICAgcHJvcHMuZXB2ID0gY2ZnLmVwdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwZGF0YSA9IGp3ZS5wbGFpbnRleHQ7XG4gICAgICAgIGRlbGV0ZSBqd2UucGxhaW50ZXh0O1xuICAgICAgICByZXR1cm4gZW5jS2V5LnRoZW4oZnVuY3Rpb24oZW5jS2V5KSB7XG4gICAgICAgICAgdmFyIHAgPSBlbmNLZXkuZW5jcnlwdChlbmNBbGcsIHBkYXRhLCBwcm9wcyk7XG4gICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGp3ZS5pdiA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShpdiwgXCJiaW5hcnlcIik7XG4gICAgICAgICAgICBpZiAoXCJhYWRcIiBpbiBjZmcgJiYgY2ZnLmFhZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgandlLmFhZCA9IGNmZy5hYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqd2UuY2lwaGVydGV4dCA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShyZXN1bHQuZGF0YSwgXCJiaW5hcnlcIik7XG4gICAgICAgICAgICBqd2UudGFnID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdC50YWcsIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGp3ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gKE9QVElPTkFMKSBjb21wYWN0L2ZsYXR0ZW5lZCByZXN1bHRzXG4gICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICBjYXNlIFwiY29tcGFjdFwiOlxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFjdCA9IG5ldyBBcnJheSg1KTtcblxuICAgICAgICAgICAgY29tcGFjdFswXSA9IGp3ZS5wcm90ZWN0ZWQ7XG4gICAgICAgICAgICBpZiAoandlLnJlY2lwaWVudHMgJiYgandlLnJlY2lwaWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgY29tcGFjdFsxXSA9IGp3ZS5yZWNpcGllbnRzWzBdLmVuY3J5cHRlZF9rZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbXBhY3RbMl0gPSBqd2UuaXY7XG4gICAgICAgICAgICBjb21wYWN0WzNdID0gandlLmNpcGhlcnRleHQ7XG4gICAgICAgICAgICBjb21wYWN0WzRdID0gandlLnRhZztcbiAgICAgICAgICAgIGNvbXBhY3QgPSBjb21wYWN0LmpvaW4oXCIuXCIpO1xuXG4gICAgICAgICAgICByZXR1cm4gY29tcGFjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZsYXR0ZW5lZFwiOlxuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oandlKSB7XG4gICAgICAgICAgICB2YXIgZmxhdHRlbmVkID0ge30sXG4gICAgICAgICAgICAgICAgcmNwdCA9IGp3ZS5yZWNpcGllbnRzICYmIGp3ZS5yZWNpcGllbnRzWzBdO1xuXG4gICAgICAgICAgICBpZiAoandlLnByb3RlY3RlZCkge1xuICAgICAgICAgICAgICBmbGF0dGVuZWQucHJvdGVjdGVkID0gandlLnByb3RlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqd2UudW5wcm90ZWN0ZWQpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLnVucHJvdGVjdGVkID0gandlLnVucHJvdGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgW1wiaGVhZGVyXCIsIFwiZW5jcnlwdGVkX2tleVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgaWYgKCFyY3B0KSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICBpZiAoIShmIGluIHJjcHQpKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICBpZiAoIXJjcHRbZl0pIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgcmNwdFtmXSAmJiAhT2JqZWN0LmtleXMocmNwdFtmXSkubGVuZ3RoKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgICBmbGF0dGVuZWRbZl0gPSByY3B0W2ZdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoandlLmFhZCkge1xuICAgICAgICAgICAgICBmbGF0dGVuZWQuYWFkID0gandlLmFhZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYXR0ZW5lZC5pdiA9IGp3ZS5pdjtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5jaXBoZXJ0ZXh0ID0gandlLmNpcGhlcnRleHQ7XG4gICAgICAgICAgICBmbGF0dGVuZWQudGFnID0gandlLnRhZztcblxuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImdlbmVyYWxcIjpcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3ZSkge1xuICAgICAgICAgICAgdmFyIHJlY2lwaWVudHMgPSBqd2UucmVjaXBpZW50cyB8fCBbXTtcbiAgICAgICAgICAgIHJlY2lwaWVudHMgPSByZWNpcGllbnRzLm1hcChmdW5jdGlvbiAocmNwdCkge1xuICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHJjcHQpLmxlbmd0aCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgICAgICAgICAgIHJldHVybiByY3B0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWNpcGllbnRzID0gcmVjaXBpZW50cy5maWx0ZXIoZnVuY3Rpb24gKHJjcHQpIHsgcmV0dXJuICEhcmNwdDsgfSk7XG4gICAgICAgICAgICBpZiAocmVjaXBpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgandlLnJlY2lwaWVudHMgPSByZWNpcGllbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGp3ZS5yZWNpcGllbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gandlO1xuICAgICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbmNyeXB0KG9wdHMsIHJjcHRzKSB7XG4gIC8vIGZpeHVwIHJlY2lwaWVudHNcbiAgdmFyIG9wdGlvbnMgPSBvcHRzLFxuICAgIHJjcHRTdGFydCA9IDEsXG4gICAgcmNwdExpc3QgPSByY3B0cztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImF0IGxlYXN0IG9uZSByZWNpcGllbnQgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIGFzc3VtZSBvcHRzIGlzIHRoZSByZWNpcGllbnQgbGlzdFxuICAgIHJjcHRMaXN0ID0gb3B0cztcbiAgICByY3B0U3RhcnQgPSAwO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIGlmIChKV0suaXNLZXkob3B0cykgfHxcbiAgICAgICAgKG9wdHMgJiYgXCJrdHlcIiBpbiBvcHRzKSB8fFxuICAgICAgICAob3B0cyAmJiBcImtleVwiIGluIG9wdHMgJiZcbiAgICAgICAgKEpXSy5pc0tleShvcHRzLmtleSkgfHwgXCJrdHlcIiBpbiBvcHRzLmtleSkpKSB7XG4gICAgcmNwdExpc3QgPSBvcHRzO1xuICAgIHJjcHRTdGFydCA9IDA7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9IGVsc2Uge1xuICAgIG9wdGlvbnMgPSBjbG9uZShvcHRzKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkocmNwdExpc3QpKSB7XG4gICAgcmNwdExpc3QgPSBzbGljZShhcmd1bWVudHMsIHJjcHRTdGFydCk7XG4gIH1cblxuICAvLyBmaXh1cCBvcHRpb25zXG4gIG9wdGlvbnMgPSBhc3NpZ24oY2xvbmUoREVGQVVMVFMpLCBvcHRpb25zKTtcblxuICAvLyBzZXR1cCBoZWFkZXIgZmllbGRzXG4gIHZhciBmaWVsZHMgPSBjbG9uZShvcHRpb25zLmZpZWxkcyB8fCB7fSk7XG4gIGlmIChvcHRpb25zLnppcCkge1xuICAgIGZpZWxkcy56aXAgPSAodHlwZW9mIG9wdGlvbnMuemlwID09PSBcImJvb2xlYW5cIikgP1xuICAgICAgICAgICAob3B0aW9ucy56aXAgPyBcIkRFRlwiIDogZmFsc2UpIDpcbiAgICAgICAgICAgb3B0aW9ucy56aXA7XG4gIH1cbiAgb3B0aW9ucy5mb3JtYXQgPSAob3B0aW9ucy5jb21wYWN0ID8gXCJjb21wYWN0XCIgOiBvcHRpb25zLmZvcm1hdCkgfHwgXCJnZW5lcmFsXCI7XG4gIHN3aXRjaCAob3B0aW9ucy5mb3JtYXQpIHtcbiAgICBjYXNlIFwiY29tcGFjdFwiOlxuICAgICAgaWYgKFwiYWFkXCIgaW4gb3B0cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRpdGlvbmFsIGF1dGhlbnRpY2F0ZWQgZGF0YSBjYW5ub3QgYmUgdXNlZCBmb3IgY29tcGFjdCBzZXJpYWxpemF0aW9uXCIpO1xuICAgICAgfVxuICAgICAgLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBbMF0gKi9cbiAgICBjYXNlIFwiZmxhdHRlbmVkXCI6XG4gICAgICBpZiAocmNwdExpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSByZWNpcGllbnRzIGZvciBjb21wYWN0IHNlcmlhbGl6YXRpb25cIik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIG5vdGUgcHJvdGVjdGVkIGZpZWxkcyAoZ2xvYmFsbHkpXG4gIC8vIHByb3RlY3RlZCBmaWVsZHMgYXJlIGdsb2JhbCBvbmx5XG4gIHZhciBwcm90ZWN0QWxsID0gZmFsc2U7XG4gIGlmIChcImNvbXBhY3RcIiA9PT0gb3B0aW9ucy5mb3JtYXQgfHwgXCIqXCIgPT09IG9wdGlvbnMucHJvdGVjdCkge1xuICAgIHByb3RlY3RBbGwgPSB0cnVlO1xuICAgIG9wdGlvbnMucHJvdGVjdCA9IE9iamVjdC5rZXlzKGZpZWxkcykuY29uY2F0KFwiZW5jXCIpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLnByb3RlY3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICBvcHRpb25zLnByb3RlY3QgPSBbb3B0aW9ucy5wcm90ZWN0XTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMucHJvdGVjdCkpIHtcbiAgICBvcHRpb25zLnByb3RlY3QgPSBvcHRpb25zLnByb3RlY3QuY29uY2F0KCk7XG4gIH0gZWxzZSBpZiAoIW9wdGlvbnMucHJvdGVjdCkge1xuICAgIG9wdGlvbnMucHJvdGVjdCA9IFtdO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcInByb3RlY3QgbXVzdCBiZSBhIGxpc3Qgb2YgZmllbGRzXCIpO1xuICB9XG5cbiAgaWYgKHByb3RlY3RBbGwgJiYgMSA8IHJjcHRMaXN0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IHJlY2lwaWVudHMgdG8gcHJvdGVjdCBhbGwgaGVhZGVyIHBhcmFtZXRlcnNcIik7XG4gIH1cblxuICByY3B0TGlzdCA9IHJjcHRMaXN0Lm1hcChmdW5jdGlvbihyLCBpZHgpIHtcbiAgICB2YXIgcDtcblxuICAgIC8vIHJlc29sdmUgYSBrZXlcbiAgICBpZiAociAmJiBcImt0eVwiIGluIHIpIHtcbiAgICAgIHAgPSBKV0suYXNLZXkocik7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocikge1xuICAgICAgcCA9IEpXSy5hc0tleShyLmtleSk7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWFkZXI6IHIuaGVhZGVyLFxuICAgICAgICAgIHJlZmVyZW5jZTogci5yZWZlcmVuY2UsXG4gICAgICAgICAga2V5OiBrXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm1pc3Npbmcga2V5IGZvciByZWNpcGllbnQgXCIgKyBpZHgpKTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGVwaGVtZXJhbCBrZXkgKGlmIHByZXNlbnQpXG4gICAgaWYgKHIuZXBrKSB7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlY2lwaWVudCkge1xuICAgICAgICByZXR1cm4gSldLLmFzS2V5KHIuZXBrKS5cbiAgICAgICAgICB0aGVuKGZ1bmN0aW9uKGVwaykge1xuICAgICAgICAgICAgcmVjaXBpZW50LmVwayA9IGVwaztcbiAgICAgICAgICAgIHJldHVybiByZWNpcGllbnQ7XG4gICAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRoZSBjb21wbGV0ZSByZWNpcGllbnRcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlY2lwaWVudCkge1xuICAgICAgdmFyIGtleSA9IHJlY2lwaWVudC5rZXk7XG5cbiAgICAgIC8vIHByZXBhcmUgdGhlIHJlY2lwaWVudCBoZWFkZXJcbiAgICAgIHZhciBoZWFkZXIgPSByZWNpcGllbnQuaGVhZGVyIHx8IHt9O1xuICAgICAgcmVjaXBpZW50LmhlYWRlciA9IGhlYWRlcjtcbiAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgcHJvcHMgPSBhc3NpZ24ocHJvcHMsIGZpZWxkcyk7XG4gICAgICBwcm9wcyA9IGFzc2lnbihwcm9wcywgcmVjaXBpZW50LmhlYWRlcik7XG5cbiAgICAgIC8vIGVuc3VyZSBrZXkgcHJvdGVjdGlvbiBhbGdvcml0aG0gaXMgc2V0XG4gICAgICBpZiAoIXByb3BzLmFsZykge1xuICAgICAgICBwcm9wcy5hbGcgPSBrZXkuYWxnb3JpdGhtcyhKV0suTU9ERV9XUkFQKVswXTtcbiAgICAgICAgaGVhZGVyLmFsZyA9IHByb3BzLmFsZztcbiAgICAgIH1cbiAgICAgIGlmICghcHJvcHMuYWxnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJrZXkgbm90IHZhbGlkIGZvciBlbmNyeXB0aW5nIHRvIHJlY2lwaWVudCBcIiArIGlkeCkpO1xuICAgICAgfVxuICAgICAgaGVhZGVyLmFsZyA9IHByb3BzLmFsZztcblxuICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBrZXkgcmVmZXJlbmNlXG4gICAgICB2YXIgcmVmID0gcmVjaXBpZW50LnJlZmVyZW5jZTtcbiAgICAgIGRlbGV0ZSByZWNpcGllbnQucmVmZXJlbmNlO1xuICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcmVmKSB7XG4gICAgICAgIC8vIGhlYWRlciBhbHJlYWR5IGNvbnRhaW5zIHRoZSBrZXkgcmVmZXJlbmNlXG4gICAgICAgIHJlZiA9IFtcImtpZFwiLCBcImprdVwiLCBcIng1Y1wiLCBcIng1dFwiLCBcIng1dVwiXS5zb21lKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICByZXR1cm4gKGsgaW4gaGVhZGVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlZiA9ICFyZWYgPyBcImtpZFwiIDogbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoXCJib29sZWFuXCIgPT09IHR5cGVvZiByZWYpIHtcbiAgICAgICAgLy8gZXhwbGljaXQgKHBvc2l0aXZlIHwgbmVnYXRpdmUpIHJlcXVlc3QgZm9yIGtleSByZWZlcmVuY2VcbiAgICAgICAgcmVmID0gcmVmID8gXCJraWRcIiA6IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgandrO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICBqd2sgPSBrZXkudG9KU09OKCk7XG4gICAgICAgIGlmIChcImp3a1wiID09PSByZWYpIHtcbiAgICAgICAgICBpZiAoXCJvY3RcIiA9PT0ga2V5Lmt0eSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImNhbm5vdCBlbWJlZCBrZXlcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoZWFkZXIuandrID0gandrO1xuICAgICAgICB9IGVsc2UgaWYgKHJlZiBpbiBqd2spIHtcbiAgICAgICAgICBoZWFkZXJbcmVmXSA9IGp3a1tyZWZdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZyZWV6ZSByZWNpcGllbnRcbiAgICAgIHJlY2lwaWVudCA9IE9iamVjdC5mcmVlemUocmVjaXBpZW50KTtcbiAgICAgIHJldHVybiByZWNpcGllbnQ7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcDtcbiAgfSk7XG5cbiAgLy8gY3JlYXRlIGFuZCBjb25maWd1cmUgZW5jcnlwdGlvblxuICB2YXIgY2ZnID0ge1xuICAgIGFhZDogKFwiYWFkXCIgaW4gb3B0aW9ucykgPyB1dGlsLmJhc2U2NHVybC5lbmNvZGUob3B0aW9ucy5hYWQgfHwgXCJcIikgOiBudWxsLFxuICAgIGNvbnRlbnRBbGc6IG9wdGlvbnMuY29udGVudEFsZyxcbiAgICBmb3JtYXQ6IG9wdGlvbnMuZm9ybWF0LFxuICAgIHByb3RlY3Q6IG9wdGlvbnMucHJvdGVjdCxcbiAgICBjZWs6IG9wdGlvbnMuY2VrLFxuICAgIGl2OiBvcHRpb25zLml2LFxuICAgIHByb3RlY3RBbGw6IHByb3RlY3RBbGxcbiAgfTtcbiAgdmFyIGVuYyA9IG5ldyBKV0VFbmNyeXB0ZXIoY2ZnLCBmaWVsZHMsIHJjcHRMaXN0KTtcblxuICByZXR1cm4gZW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jcnlwdGVyOiBKV0VFbmNyeXB0ZXIsXG4gIGNyZWF0ZUVuY3J5cHQ6IGNyZWF0ZUVuY3J5cHRcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/helpers.js - JWE Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar CONSTANTS = __webpack_require__(/*! ../algorithms/constants */ \"(ssr)/./node_modules/node-jose/lib/algorithms/constants.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  },\n  generateCEK: function(enc) {\n    var ks = JWK.createKeyStore();\n    var len = CONSTANTS.KEYLENGTH[enc];\n\n    if (len) {\n        return ks.generate(\"oct\", len);\n    }\n\n    throw new Error(\"unsupported encryption algorithm\");\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsMkZBQXlCO0FBQ2pELFVBQVUsbUJBQU8sQ0FBQywrREFBUTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandlL2hlbHBlcnMuanM/MGIwNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ZS9oZWxwZXJzLmpzIC0gSldFIEludGVybmFsIEhlbHBlciBGdW5jdGlvbnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zL2NvbnN0YW50c1wiKSxcbiAgICBKV0sgPSByZXF1aXJlKFwiLi4vandrXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2xpY2U6IGZ1bmN0aW9uKGlucHV0LCBzdGFydCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbnB1dCwgc3RhcnQgfHwgMCk7XG4gIH0sXG4gIGdlbmVyYXRlQ0VLOiBmdW5jdGlvbihlbmMpIHtcbiAgICB2YXIga3MgPSBKV0suY3JlYXRlS2V5U3RvcmUoKTtcbiAgICB2YXIgbGVuID0gQ09OU1RBTlRTLktFWUxFTkdUSFtlbmNdO1xuXG4gICAgaWYgKGxlbikge1xuICAgICAgICByZXR1cm4ga3MuZ2VuZXJhdGUoXCJvY3RcIiwgbGVuKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBlbmNyeXB0aW9uIGFsZ29yaXRobVwiKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwe/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwe/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwe/index.js - JSON Web Encryption (JWE) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWE = {\n  createEncrypt: (__webpack_require__(/*! ./encrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/encrypt.js\").createEncrypt),\n  createDecrypt: (__webpack_require__(/*! ./decrypt */ \"(ssr)/./node_modules/node-jose/lib/jwe/decrypt.js\").createDecrypt)\n};\n\nmodule.exports = JWE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsaUJBQWlCLHlHQUFrQztBQUNuRCxpQkFBaUIseUdBQWtDO0FBQ25EOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandlL2luZGV4LmpzPzdmMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2UvaW5kZXguanMgLSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBKV0UgPSB7XG4gIGNyZWF0ZUVuY3J5cHQ6IHJlcXVpcmUoXCIuL2VuY3J5cHRcIikuY3JlYXRlRW5jcnlwdCxcbiAgY3JlYXRlRGVjcnlwdDogcmVxdWlyZShcIi4vZGVjcnlwdFwiKS5jcmVhdGVEZWNyeXB0XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpXRTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwe/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/basekey.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/basekey.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/basekey.js - JWK Key Base Class Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\");\n\nvar assign = __webpack_require__(/*! lodash/assign */ \"(ssr)/./node_modules/lodash/assign.js\");\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar flatten = __webpack_require__(/*! lodash/flatten */ \"(ssr)/./node_modules/lodash/flatten.js\");\nvar intersection = __webpack_require__(/*! lodash/intersection */ \"(ssr)/./node_modules/lodash/intersection.js\");\nvar omit = __webpack_require__(/*! lodash/omit */ \"(ssr)/./node_modules/lodash/omit.js\");\nvar pick = __webpack_require__(/*! lodash/pick */ \"(ssr)/./node_modules/lodash/pick.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\"),\n    CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\"),\n    HELPERS = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\"),\n    UTIL = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\n/**\n * @class JWK.Key\n * @classdesc\n * Represents a JSON Web Key instance.\n *\n * @description\n * **NOTE:** This class cannot be instantiated directly. Instead call\n * {@link JWK.asKey}, {@link JWK.KeyStore#add}, or\n * {@link JWK.KeyStore#generate}.\n */\nvar JWKBaseKeyObject = function(kty, ks, props, cfg) {\n  // ### validate/coerce arguments ###\n  if (!kty) {\n    throw new Error(\"kty cannot be null\");\n  }\n\n  if (!ks) {\n    throw new Error(\"keystore cannot be null\");\n  }\n\n  if (!props) {\n    throw new Error(\"props cannot be null\");\n  } else if (\"string\" === typeof props) {\n    props = JSON.parse(props);\n  }\n\n  if (!cfg) {\n    throw new Error(\"cfg cannot be null\");\n  }\n\n  var excluded = [];\n  var keys = {},\n      json = {},\n      prints,\n      kid;\n\n  props = clone(props);\n  // strip thumbprints if present\n  prints = assign({}, props[HELPERS.INTERNALS.THUMBPRINT_KEY] || {});\n  delete props[HELPERS.INTERNALS.THUMBPRINT_KEY];\n  Object.keys(prints).forEach(function(a) {\n    var h = prints[a];\n    if (!kid) {\n      kid = h;\n      if (Buffer.isBuffer(kid)) {\n        kid = UTIL.base64url.encode(kid);\n      }\n    }\n    if (!Buffer.isBuffer(h)) {\n      h = UTIL.base64url.decode(h);\n      prints[a] = h;\n    }\n  });\n\n  // force certain values\n  props.kty = kty;\n  props.kid = props.kid || kid || uuidv4();\n\n  // setup base info\n  var included = Object.keys(HELPERS.COMMON_PROPS).map(function(p) {\n    return HELPERS.COMMON_PROPS[p].name;\n  });\n  json.base = pick(props, included);\n  excluded = excluded.concat(Object.keys(json.base));\n\n  // setup public information\n  json.public = clone(props);\n  keys.public = cfg.publicKey(json.public);\n  if (keys.public) {\n    // exclude public values from extra\n    excluded = excluded.concat(Object.keys(json.public));\n  }\n\n  // setup private information\n  json.private = clone(props);\n  keys.private = cfg.privateKey(json.private);\n  if (keys.private) {\n    // exclude private values from extra\n    excluded = excluded.concat(Object.keys(json.private));\n  }\n\n  // setup extra information\n  json.extra = omit(props, excluded);\n\n  // TODO: validate 'alg' against supported algorithms\n\n  // setup calculated values\n  var keyLen;\n  if (keys.public && (\"length\" in keys.public)) {\n    keyLen = keys.public.length;\n  } else if (keys.private && (\"length\" in keys.private)) {\n    keyLen = keys.private.length;\n  } else {\n    keyLen = NaN;\n  }\n\n  // ### Public Properties ###\n  /**\n   * @member {JWK.KeyStore} JWK.Key#keystore\n   * @description\n   * The owning keystore.\n   */\n  Object.defineProperty(this, \"keystore\", {\n    value: ks,\n    enumerable: true\n  });\n  /**\n   * @member {Number} JWK.Key#length\n   * @description\n   * The size of this Key, in bits.\n   */\n  Object.defineProperty(this, \"length\", {\n    value: keyLen,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#kty\n   * @description\n   * The type of Key.\n   */\n  Object.defineProperty(this, \"kty\", {\n    value: kty,\n    enumerable: true\n  });\n\n  /**\n   * @member {String} JWK.Key#kid\n   * @description\n   * The identifier for this Key.\n   */\n  Object.defineProperty(this, \"kid\", {\n    value: json.base.kid,\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#use\n   * @description\n   * The usage for this Key.\n   */\n  Object.defineProperty(this, \"use\", {\n    value: json.base.use || \"\",\n    enumerable: true\n  });\n  /**\n   * @member {String} JWK.Key#alg\n   * @description\n   * The sole algorithm this key can be used for.\n   */\n  Object.defineProperty(this, \"alg\", {\n    value: json.base.alg || \"\",\n    enumerable: true\n  });\n\n  // ### Public Methods ###\n  /**\n   * Generates the thumbprint of this Key.\n   *\n   * @param {String} [] The hash algorithm to use\n   * @returns {Promise} The promise for the thumbprint generation.\n   */\n  Object.defineProperty(this, \"thumbprint\", {\n    value: function(hash) {\n      hash = (hash || HELPERS.INTERNALS.THUMBPRINT_HASH).toUpperCase();\n      if (prints[hash]) {\n        // return cached value\n        return Promise.resolve(prints[hash]);\n      }\n      var p = HELPERS.thumbprint(cfg, json, hash);\n      p = p.then(function(result) {\n        if (result) {\n          prints[hash] = result;\n        }\n        return result;\n      });\n      return p;\n    }\n  });\n  /**\n   * @method JWK.Key#algorithms\n   * @description\n   * The possible algorithms this Key can be used for. The returned\n   * list is not any particular order, but is filtered based on the\n   * Key's intended usage.\n   *\n   * @param {String} mode The operation mode\n   * @returns {String[]} The list of supported algorithms\n   * @see JWK.Key#supports\n   */\n  Object.defineProperty(this, \"algorithms\", {\n    value: function(mode) {\n      var modes = [];\n      if (!this.use || this.use === \"sig\") {\n        if (!mode || CONSTANTS.MODE_SIGN === mode) {\n          modes.push(CONSTANTS.MODE_SIGN);\n        }\n        if (!mode || CONSTANTS.MODE_VERIFY === mode) {\n          modes.push(CONSTANTS.MODE_VERIFY);\n        }\n      }\n      if (!this.use || this.use === \"enc\") {\n        if (!mode || CONSTANTS.MODE_ENCRYPT === mode) {\n          modes.push(CONSTANTS.MODE_ENCRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_DECRYPT === mode) {\n          modes.push(CONSTANTS.MODE_DECRYPT);\n        }\n        if (!mode || CONSTANTS.MODE_WRAP === mode) {\n          modes.push(CONSTANTS.MODE_WRAP);\n        }\n        if (!mode || CONSTANTS.MODE_UNWRAP === mode) {\n          modes.push(CONSTANTS.MODE_UNWRAP);\n        }\n      }\n\n      var self = this;\n      var algs = modes.map(function(m) {\n        return cfg.algorithms.call(self, keys, m);\n      });\n      algs = flatten(algs);\n      algs = uniq(algs);\n      if (this.alg) {\n        // TODO: fix this correctly\n        var valid;\n        if (\"oct\" === kty) {\n          valid = [this.alg, \"dir\"];\n        } else {\n          valid = [this.alg];\n        }\n        algs = intersection(algs, valid);\n      }\n\n      return algs;\n    }\n  });\n  /**\n   * @method JWK.Key#supports\n   * @description\n   * Determines if the given algorithm is supported.\n   *\n   * @param {String} alg The algorithm in question\n   * @param {String} [mode] The operation mode\n   * @returns {Boolean} `true` if {alg} is supported, and `false` otherwise.\n   * @see JWK.Key#algorithms\n   */\n  Object.defineProperty(this, \"supports\", {\n    value: function(alg, mode) {\n      return (this.algorithms(mode).indexOf(alg) !== -1);\n    }\n  });\n  /**\n   * @method JWK.Key#has\n   * @description\n   * Determines if this Key contains the given parameter.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        checked.\n   * @returns {Boolean} `true` if the given parameter is present; `false`\n   *          otherwise.\n   */\n  Object.defineProperty(this, \"has\", {\n    value: function(name, isPrivate) {\n      var contains = false;\n      contains = contains || !!(json.base &&\n                                (name in json.base));\n      contains = contains || !!(keys.public &&\n                                (name in keys.public));\n      contains = contains || !!(json.extra &&\n                                (name in json.extra));\n      contains = contains || !!(isPrivate &&\n                                keys.private &&\n                                (name in keys.private));\n      // TODO: check for export restrictions\n\n      return contains;\n    }\n  });\n  /**\n   * @method JWK.Key#get\n   * @description\n   * Retrieves the value of the given parameter. The value returned by this\n   * method is in its natural format, which might not exactly match its\n   * JSON encoding (e.g., a binary string rather than a base64url-encoded\n   * string).\n   *\n   * **NOTE:** This method can return `false`. Call\n   * {@link JWK.Key#has} to determine if the parameter is present.\n   *\n   * @param {String} name The name of the parameter\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should\n   *        be checked.\n   * @returns {any} The value of the named parameter, or undefined if\n   *          it is not present.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(name, isPrivate) {\n      var src;\n      if (json.base && (name in json.base)) {\n        src = json.base;\n      } else if (keys.public && (name in keys.public)) {\n        src = keys.public;\n      } else if (json.extra && (name in json.extra)) {\n        src = json.extra;\n      } else if (isPrivate && keys.private && (name in keys.private)) {\n        // TODO: check for export restrictions\n        src = keys.private;\n      }\n\n      return src && src[name] || null;\n    }\n  });\n  /**\n   * @method JWK.Key#toJSON\n   * @description\n   * Returns the JSON representation of this Key.  All properties of the\n   * returned JSON object are properly encoded (e.g., base64url encoding for\n   * any binary strings).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned JSON.\n   * @returns {Object} The plain JSON object\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       json.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? json.private : {},\n                       json.extra);\n      result = omit(result, excluded || []);\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#toPEM\n   * @description\n   * Returns the PEM representation of this Key as a string.\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @returns {string} The PEM-encoded string\n   */\n  Object.defineProperty(this, \"toPEM\", {\n    value: function(isPrivate) {\n      if (isPrivate === null) {\n        isPrivate = false;\n      }\n\n      if (!cfg.convertToPEM) {\n        throw new Error(\"Unsupported key type for PEM encoding\");\n      }\n      var k = (isPrivate) ? keys.private : keys.public;\n      if (!k) {\n        throw new Error(\"Invalid key\");\n      }\n      return cfg.convertToPEM.call(this, k, isPrivate);\n    }\n  });\n\n  /**\n   * @method JWK.Key#toObject\n   * @description\n   * Returns the plain object representing this Key.  All properties of the\n   * returned object are in their natural encoding (e.g., binary strings\n   * instead of base64url encoded).\n   *\n   * @param {Boolean} [isPrivate=false] `true` if private parameters should be\n   *        included.\n   * @param {String[]} [excluded] The list of parameters to exclude from\n   *        the returned object.\n   * @returns {Object} The plain Object.\n   */\n  Object.defineProperty(this, \"toObject\", {\n    value: function(isPrivate, excluded) {\n      // coerce arguments\n      if (Array.isArray(isPrivate)) {\n        excluded = isPrivate;\n        isPrivate = false;\n      }\n      var result = {};\n\n      // TODO: check for export restrictions\n      result = merge(result,\n                       json.base,\n                       keys.public,\n                       (\"boolean\" === typeof isPrivate && isPrivate) ? keys.private : {},\n                       json.extra);\n      result = omit(result, (excluded || []).concat(\"length\"));\n\n      return result;\n    }\n  });\n\n  /**\n   * @method JWK.Key#sign\n   * @description\n   * Sign the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive signing operation; the output is\n   * _**NOT**_ a JSON Web Signature (JWS) object.\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was signed (and should be equal to {data}).\n   * + **mac**: The signature or message authentication code (MAC).\n   *\n   * @param {String} alg The signing algorithm\n   * @param {String|Buffer} data The data to sign\n   * @param {Object} [props] Additional properties for the signing\n   *        algorithm.\n   * @returns {Promise} The promise for the signing operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"sign\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"sign\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.signKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.signProps) {\n        props = merge(props, cfg.signProps.call(this, alg, props));\n      }\n      return ALGORITHMS.sign(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#verify\n   * @description\n   * Verify the given data and signature using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive verification operation; the input is\n   * _**NOT**_ a JSON Web Signature.</p>\n   *\n   * The Promise, when fulfilled, returns an Object with the following\n   * properties:\n   *\n   * + **data**: The data that was verified (and should be equal to\n   *   {data}).\n   * + **mac**: The signature or MAC that was verified (and should be equal\n   *   to {mac}).\n   * + **valid**: `true` if {mac} is valid for {data}.\n   *\n   * @param {String} alg The verification algorithm\n   * @param {String|Buffer} data The data to verify\n   * @param {String|Buffer} mac The signature or MAC to verify\n   * @param {Object} [props] Additional properties for the verification\n   *        algorithm.\n   * @returns {Promise} The promise for the verification operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"verify\", {\n    value: function(alg, data, mac, props) {\n      // validate appropriateness\n      if (this.algorithms(\"verify\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.verifyKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.verifyProps) {\n        props = merge(props, cfg.verifyProps.call(this, alg, props));\n      }\n      return ALGORITHMS.verify(alg, k, data, mac, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#encrypt\n   * @description\n   * Encrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#wrap}, as different algorithms and properties are often\n   * used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **mac**: The associated message authentication code (MAC).\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"encrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"encrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.encryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.encryptProps) {\n        props = merge(props, cfg.encryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#decrypt\n   * @description\n   * Decrypts the given data using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive decryption operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#unwrap}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the plaintext data.\n   *\n   * @param {String} alg The decryption algorithm.\n   * @param {Buffer|String} data The data to decypt.\n   * @param {Object} [props] Additional data for the decryption operation.\n   * @returns {Promise} The promise for the decryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"decrypt\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"decrypt\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.decryptKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.decryptProps) {\n        props = merge(props, cfg.decryptProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n\n  /**\n   * @method JWK.Key#wrap\n   * @description\n   * Wraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive encryption operation; the output is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#encrypt}, as different algorithms and properties are\n   * often used for wrapping a key versues encrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns an object with the following\n   * properties:\n   *\n   * + **data**: The ciphertext data\n   * + **headers**: The additional header parameters to apply to a JWE.\n   *\n   * @param {String} alg The encryption algorithm\n   * @param {Buffer|String} data The data to encrypt\n   * @param {Object} [props] Additional properties for the encryption\n   *        algorithm.\n   * @returns {Promise} The promise for the encryption operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         this Key does not contain the appropriate parameters.\n   */\n  Object.defineProperty(this, \"wrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"wrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.wrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.wrapProps) {\n        props = merge(props, cfg.wrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.encrypt(alg, k, data, props);\n    }\n  });\n  /**\n   * @method JWK.Key#unwrap\n   * @description\n   * Unwraps the given key using the specified algorithm.\n   *\n   * **NOTE:** This is the primitive unwrap operation; the input is\n   * _**NOT**_ a JSON Web Encryption (JWE) object.\n   *\n   * **NOTE:** This operation is treated as distinct from {@link\n   * JWK.Key#decrypt}, as different algorithms and properties are often used\n   * for unwrapping a key versues decrypting arbitrary data.\n   *\n   * The Promise, when fulfilled, returns the unwrapped key.\n   *\n   * @param {String} alg The unwrap algorithm.\n   * @param {Buffer|String} data The data to unwrap.\n   * @param {Object} [props] Additional data for the unwrap operation.\n   * @returns {Promise} The promise for the unwrap operation.\n   * @throws {Error} If {alg} is not appropriate for this Key; or if\n   *         the Key does not contain the appropriate properties.\n   */\n  Object.defineProperty(this, \"unwrap\", {\n    value: function(alg, data, props) {\n      // validate appropriateness\n      if (this.algorithms(\"unwrap\").indexOf(alg) === -1) {\n        return Promise.reject(new Error(\"unsupported algorithm\"));\n      }\n      var k = cfg.unwrapKey.call(this, alg, keys);\n      if (!k) {\n        return Promise.reject(new Error(\"improper key\"));\n      }\n\n      // prepare properties (if any)\n      props = (props) ?\n              clone(props) :\n              {};\n      if (cfg.unwrapProps) {\n        props = merge(props, cfg.unwrapProps.call(this, alg, props));\n      }\n      return ALGORITHMS.decrypt(alg, k, data, props);\n    }\n  });\n};\n\nmodule.exports = JWKBaseKeyObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svYmFzZWtleS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMscUZBQU07O0FBRXJDLGFBQWEsbUJBQU8sQ0FBQyw0REFBZTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLDhEQUFnQjtBQUN0QyxtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsV0FBVyxtQkFBTyxDQUFDLHdEQUFhO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyx3REFBYTtBQUNoQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsdUVBQWM7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGlFQUFTOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCLEdBQUcsdUJBQXVCO0FBQzlDLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLCtDQUErQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUyxXQUFXLEtBQUs7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsZUFBZSxTQUFTLDBDQUEwQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1CQUFtQjtBQUN6QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLEtBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsS0FBSztBQUN4RTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsS0FBSztBQUNiO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsNkJBQTZCLEtBQUssY0FBYyxLQUFLO0FBQ3JEO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGNBQWMsT0FBTyxJQUFJLEtBQUssaUNBQWlDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsU0FBUztBQUN4QixjQUFjLE9BQU8sSUFBSSxLQUFLLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSyxpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3ay9iYXNla2V5LmpzP2FkZDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svYmFzZWtleS5qcyAtIEpXSyBLZXkgQmFzZSBDbGFzcyBJbXBsZW1lbnRhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWVyZ2UgPSByZXF1aXJlKFwiLi4vdXRpbC9tZXJnZVwiKTtcbmNvbnN0IHsgdjQ6IHV1aWR2NCB9ID0gcmVxdWlyZShcInV1aWRcIik7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKFwibG9kYXNoL2Fzc2lnblwiKTtcbnZhciBjbG9uZSA9IHJlcXVpcmUoXCJsb2Rhc2gvY2xvbmVcIik7XG52YXIgZmxhdHRlbiA9IHJlcXVpcmUoXCJsb2Rhc2gvZmxhdHRlblwiKTtcbnZhciBpbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwibG9kYXNoL2ludGVyc2VjdGlvblwiKTtcbnZhciBvbWl0ID0gcmVxdWlyZShcImxvZGFzaC9vbWl0XCIpO1xudmFyIHBpY2sgPSByZXF1aXJlKFwibG9kYXNoL3BpY2tcIik7XG52YXIgdW5pcSA9IHJlcXVpcmUoXCJsb2Rhc2gvdW5pcVwiKTtcblxudmFyIEFMR09SSVRITVMgPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtc1wiKSxcbiAgICBDT05TVEFOVFMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIiksXG4gICAgSEVMUEVSUyA9IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIiksXG4gICAgVVRJTCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBKV0suS2V5XG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgSlNPTiBXZWIgS2V5IGluc3RhbmNlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIFRoaXMgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsXG4gKiB7QGxpbmsgSldLLmFzS2V5fSwge0BsaW5rIEpXSy5LZXlTdG9yZSNhZGR9LCBvclxuICoge0BsaW5rIEpXSy5LZXlTdG9yZSNnZW5lcmF0ZX0uXG4gKi9cbnZhciBKV0tCYXNlS2V5T2JqZWN0ID0gZnVuY3Rpb24oa3R5LCBrcywgcHJvcHMsIGNmZykge1xuICAvLyAjIyMgdmFsaWRhdGUvY29lcmNlIGFyZ3VtZW50cyAjIyNcbiAgaWYgKCFrdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJrdHkgY2Fubm90IGJlIG51bGxcIik7XG4gIH1cblxuICBpZiAoIWtzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwia2V5c3RvcmUgY2Fubm90IGJlIG51bGxcIik7XG4gIH1cblxuICBpZiAoIXByb3BzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwicHJvcHMgY2Fubm90IGJlIG51bGxcIik7XG4gIH0gZWxzZSBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzKSB7XG4gICAgcHJvcHMgPSBKU09OLnBhcnNlKHByb3BzKTtcbiAgfVxuXG4gIGlmICghY2ZnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2ZnIGNhbm5vdCBiZSBudWxsXCIpO1xuICB9XG5cbiAgdmFyIGV4Y2x1ZGVkID0gW107XG4gIHZhciBrZXlzID0ge30sXG4gICAgICBqc29uID0ge30sXG4gICAgICBwcmludHMsXG4gICAgICBraWQ7XG5cbiAgcHJvcHMgPSBjbG9uZShwcm9wcyk7XG4gIC8vIHN0cmlwIHRodW1icHJpbnRzIGlmIHByZXNlbnRcbiAgcHJpbnRzID0gYXNzaWduKHt9LCBwcm9wc1tIRUxQRVJTLklOVEVSTkFMUy5USFVNQlBSSU5UX0tFWV0gfHwge30pO1xuICBkZWxldGUgcHJvcHNbSEVMUEVSUy5JTlRFUk5BTFMuVEhVTUJQUklOVF9LRVldO1xuICBPYmplY3Qua2V5cyhwcmludHMpLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIHZhciBoID0gcHJpbnRzW2FdO1xuICAgIGlmICgha2lkKSB7XG4gICAgICBraWQgPSBoO1xuICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihraWQpKSB7XG4gICAgICAgIGtpZCA9IFVUSUwuYmFzZTY0dXJsLmVuY29kZShraWQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihoKSkge1xuICAgICAgaCA9IFVUSUwuYmFzZTY0dXJsLmRlY29kZShoKTtcbiAgICAgIHByaW50c1thXSA9IGg7XG4gICAgfVxuICB9KTtcblxuICAvLyBmb3JjZSBjZXJ0YWluIHZhbHVlc1xuICBwcm9wcy5rdHkgPSBrdHk7XG4gIHByb3BzLmtpZCA9IHByb3BzLmtpZCB8fCBraWQgfHwgdXVpZHY0KCk7XG5cbiAgLy8gc2V0dXAgYmFzZSBpbmZvXG4gIHZhciBpbmNsdWRlZCA9IE9iamVjdC5rZXlzKEhFTFBFUlMuQ09NTU9OX1BST1BTKS5tYXAoZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiBIRUxQRVJTLkNPTU1PTl9QUk9QU1twXS5uYW1lO1xuICB9KTtcbiAganNvbi5iYXNlID0gcGljayhwcm9wcywgaW5jbHVkZWQpO1xuICBleGNsdWRlZCA9IGV4Y2x1ZGVkLmNvbmNhdChPYmplY3Qua2V5cyhqc29uLmJhc2UpKTtcblxuICAvLyBzZXR1cCBwdWJsaWMgaW5mb3JtYXRpb25cbiAganNvbi5wdWJsaWMgPSBjbG9uZShwcm9wcyk7XG4gIGtleXMucHVibGljID0gY2ZnLnB1YmxpY0tleShqc29uLnB1YmxpYyk7XG4gIGlmIChrZXlzLnB1YmxpYykge1xuICAgIC8vIGV4Y2x1ZGUgcHVibGljIHZhbHVlcyBmcm9tIGV4dHJhXG4gICAgZXhjbHVkZWQgPSBleGNsdWRlZC5jb25jYXQoT2JqZWN0LmtleXMoanNvbi5wdWJsaWMpKTtcbiAgfVxuXG4gIC8vIHNldHVwIHByaXZhdGUgaW5mb3JtYXRpb25cbiAganNvbi5wcml2YXRlID0gY2xvbmUocHJvcHMpO1xuICBrZXlzLnByaXZhdGUgPSBjZmcucHJpdmF0ZUtleShqc29uLnByaXZhdGUpO1xuICBpZiAoa2V5cy5wcml2YXRlKSB7XG4gICAgLy8gZXhjbHVkZSBwcml2YXRlIHZhbHVlcyBmcm9tIGV4dHJhXG4gICAgZXhjbHVkZWQgPSBleGNsdWRlZC5jb25jYXQoT2JqZWN0LmtleXMoanNvbi5wcml2YXRlKSk7XG4gIH1cblxuICAvLyBzZXR1cCBleHRyYSBpbmZvcm1hdGlvblxuICBqc29uLmV4dHJhID0gb21pdChwcm9wcywgZXhjbHVkZWQpO1xuXG4gIC8vIFRPRE86IHZhbGlkYXRlICdhbGcnIGFnYWluc3Qgc3VwcG9ydGVkIGFsZ29yaXRobXNcblxuICAvLyBzZXR1cCBjYWxjdWxhdGVkIHZhbHVlc1xuICB2YXIga2V5TGVuO1xuICBpZiAoa2V5cy5wdWJsaWMgJiYgKFwibGVuZ3RoXCIgaW4ga2V5cy5wdWJsaWMpKSB7XG4gICAga2V5TGVuID0ga2V5cy5wdWJsaWMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGtleXMucHJpdmF0ZSAmJiAoXCJsZW5ndGhcIiBpbiBrZXlzLnByaXZhdGUpKSB7XG4gICAga2V5TGVuID0ga2V5cy5wcml2YXRlLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBrZXlMZW4gPSBOYU47XG4gIH1cblxuICAvLyAjIyMgUHVibGljIFByb3BlcnRpZXMgIyMjXG4gIC8qKlxuICAgKiBAbWVtYmVyIHtKV0suS2V5U3RvcmV9IEpXSy5LZXkja2V5c3RvcmVcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBvd25pbmcga2V5c3RvcmUuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlzdG9yZVwiLCB7XG4gICAgdmFsdWU6IGtzLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIC8qKlxuICAgKiBAbWVtYmVyIHtOdW1iZXJ9IEpXSy5LZXkjbGVuZ3RoXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBUaGUgc2l6ZSBvZiB0aGlzIEtleSwgaW4gYml0cy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImxlbmd0aFwiLCB7XG4gICAgdmFsdWU6IGtleUxlbixcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICAvKipcbiAgICogQG1lbWJlciB7U3RyaW5nfSBKV0suS2V5I2t0eVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHR5cGUgb2YgS2V5LlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwia3R5XCIsIHtcbiAgICB2YWx1ZToga3R5LFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldLLktleSNraWRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpZGVudGlmaWVyIGZvciB0aGlzIEtleS5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImtpZFwiLCB7XG4gICAgdmFsdWU6IGpzb24uYmFzZS5raWQsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldLLktleSN1c2VcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSB1c2FnZSBmb3IgdGhpcyBLZXkuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ1c2VcIiwge1xuICAgIHZhbHVlOiBqc29uLmJhc2UudXNlIHx8IFwiXCIsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZW1iZXIge1N0cmluZ30gSldLLktleSNhbGdcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBzb2xlIGFsZ29yaXRobSB0aGlzIGtleSBjYW4gYmUgdXNlZCBmb3IuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGdcIiwge1xuICAgIHZhbHVlOiBqc29uLmJhc2UuYWxnIHx8IFwiXCIsXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICAvLyAjIyMgUHVibGljIE1ldGhvZHMgIyMjXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIHRodW1icHJpbnQgb2YgdGhpcyBLZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbXSBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHRodW1icHJpbnQgZ2VuZXJhdGlvbi5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRodW1icHJpbnRcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgICBoYXNoID0gKGhhc2ggfHwgSEVMUEVSUy5JTlRFUk5BTFMuVEhVTUJQUklOVF9IQVNIKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaWYgKHByaW50c1toYXNoXSkge1xuICAgICAgICAvLyByZXR1cm4gY2FjaGVkIHZhbHVlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJpbnRzW2hhc2hdKTtcbiAgICAgIH1cbiAgICAgIHZhciBwID0gSEVMUEVSUy50aHVtYnByaW50KGNmZywganNvbiwgaGFzaCk7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJpbnRzW2hhc2hdID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjYWxnb3JpdGhtc1xuICAgKiBAZGVzY3JpcHRpb25cbiAgICogVGhlIHBvc3NpYmxlIGFsZ29yaXRobXMgdGhpcyBLZXkgY2FuIGJlIHVzZWQgZm9yLiBUaGUgcmV0dXJuZWRcbiAgICogbGlzdCBpcyBub3QgYW55IHBhcnRpY3VsYXIgb3JkZXIsIGJ1dCBpcyBmaWx0ZXJlZCBiYXNlZCBvbiB0aGVcbiAgICogS2V5J3MgaW50ZW5kZWQgdXNhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIFRoZSBvcGVyYXRpb24gbW9kZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119IFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBhbGdvcml0aG1zXG4gICAqIEBzZWUgSldLLktleSNzdXBwb3J0c1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWxnb3JpdGhtc1wiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgIHZhciBtb2RlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLnVzZSB8fCB0aGlzLnVzZSA9PT0gXCJzaWdcIikge1xuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfU0lHTiA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfU0lHTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX1ZFUklGWSA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfVkVSSUZZKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnVzZSB8fCB0aGlzLnVzZSA9PT0gXCJlbmNcIikge1xuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfRU5DUllQVCA9PT0gbW9kZSkge1xuICAgICAgICAgIG1vZGVzLnB1c2goQ09OU1RBTlRTLk1PREVfRU5DUllQVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtb2RlIHx8IENPTlNUQU5UUy5NT0RFX0RFQ1JZUFQgPT09IG1vZGUpIHtcbiAgICAgICAgICBtb2Rlcy5wdXNoKENPTlNUQU5UUy5NT0RFX0RFQ1JZUFQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9kZSB8fCBDT05TVEFOVFMuTU9ERV9XUkFQID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9XUkFQKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vZGUgfHwgQ09OU1RBTlRTLk1PREVfVU5XUkFQID09PSBtb2RlKSB7XG4gICAgICAgICAgbW9kZXMucHVzaChDT05TVEFOVFMuTU9ERV9VTldSQVApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBhbGdzID0gbW9kZXMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGNmZy5hbGdvcml0aG1zLmNhbGwoc2VsZiwga2V5cywgbSk7XG4gICAgICB9KTtcbiAgICAgIGFsZ3MgPSBmbGF0dGVuKGFsZ3MpO1xuICAgICAgYWxncyA9IHVuaXEoYWxncyk7XG4gICAgICBpZiAodGhpcy5hbGcpIHtcbiAgICAgICAgLy8gVE9ETzogZml4IHRoaXMgY29ycmVjdGx5XG4gICAgICAgIHZhciB2YWxpZDtcbiAgICAgICAgaWYgKFwib2N0XCIgPT09IGt0eSkge1xuICAgICAgICAgIHZhbGlkID0gW3RoaXMuYWxnLCBcImRpclwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZCA9IFt0aGlzLmFsZ107XG4gICAgICAgIH1cbiAgICAgICAgYWxncyA9IGludGVyc2VjdGlvbihhbGdzLCB2YWxpZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbGdzO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjc3VwcG9ydHNcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIGFsZ29yaXRobSBpcyBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIGFsZ29yaXRobSBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21vZGVdIFRoZSBvcGVyYXRpb24gbW9kZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHthbGd9IGlzIHN1cHBvcnRlZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgKiBAc2VlIEpXSy5LZXkjYWxnb3JpdGhtc1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3VwcG9ydHNcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIG1vZGUpIHtcbiAgICAgIHJldHVybiAodGhpcy5hbGdvcml0aG1zKG1vZGUpLmluZGV4T2YoYWxnKSAhPT0gLTEpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjaGFzXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgS2V5IGNvbnRhaW5zIHRoZSBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlPWZhbHNlXSBgdHJ1ZWAgaWYgcHJpdmF0ZSBwYXJhbWV0ZXJzIHNob3VsZCBiZVxuICAgKiAgICAgICAgY2hlY2tlZC5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyIGlzIHByZXNlbnQ7IGBmYWxzZWBcbiAgICogICAgICAgICAgb3RoZXJ3aXNlLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaGFzXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24obmFtZSwgaXNQcml2YXRlKSB7XG4gICAgICB2YXIgY29udGFpbnMgPSBmYWxzZTtcbiAgICAgIGNvbnRhaW5zID0gY29udGFpbnMgfHwgISEoanNvbi5iYXNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIGluIGpzb24uYmFzZSkpO1xuICAgICAgY29udGFpbnMgPSBjb250YWlucyB8fCAhIShrZXlzLnB1YmxpYyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBpbiBrZXlzLnB1YmxpYykpO1xuICAgICAgY29udGFpbnMgPSBjb250YWlucyB8fCAhIShqc29uLmV4dHJhICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIGluIGpzb24uZXh0cmEpKTtcbiAgICAgIGNvbnRhaW5zID0gY29udGFpbnMgfHwgISEoaXNQcml2YXRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHJpdmF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBpbiBrZXlzLnByaXZhdGUpKTtcbiAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleHBvcnQgcmVzdHJpY3Rpb25zXG5cbiAgICAgIHJldHVybiBjb250YWlucztcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I2dldFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0cmlldmVzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcGFyYW1ldGVyLiBUaGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhpc1xuICAgKiBtZXRob2QgaXMgaW4gaXRzIG5hdHVyYWwgZm9ybWF0LCB3aGljaCBtaWdodCBub3QgZXhhY3RseSBtYXRjaCBpdHNcbiAgICogSlNPTiBlbmNvZGluZyAoZS5nLiwgYSBiaW5hcnkgc3RyaW5nIHJhdGhlciB0aGFuIGEgYmFzZTY0dXJsLWVuY29kZWRcbiAgICogc3RyaW5nKS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgbWV0aG9kIGNhbiByZXR1cm4gYGZhbHNlYC4gQ2FsbFxuICAgKiB7QGxpbmsgSldLLktleSNoYXN9IHRvIGRldGVybWluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNQcml2YXRlPWZhbHNlXSBgdHJ1ZWAgaWYgcHJpdmF0ZSBwYXJhbWV0ZXJzIHNob3VsZFxuICAgKiAgICAgICAgYmUgY2hlY2tlZC5cbiAgICogQHJldHVybnMge2FueX0gVGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwYXJhbWV0ZXIsIG9yIHVuZGVmaW5lZCBpZlxuICAgKiAgICAgICAgICBpdCBpcyBub3QgcHJlc2VudC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKG5hbWUsIGlzUHJpdmF0ZSkge1xuICAgICAgdmFyIHNyYztcbiAgICAgIGlmIChqc29uLmJhc2UgJiYgKG5hbWUgaW4ganNvbi5iYXNlKSkge1xuICAgICAgICBzcmMgPSBqc29uLmJhc2U7XG4gICAgICB9IGVsc2UgaWYgKGtleXMucHVibGljICYmIChuYW1lIGluIGtleXMucHVibGljKSkge1xuICAgICAgICBzcmMgPSBrZXlzLnB1YmxpYztcbiAgICAgIH0gZWxzZSBpZiAoanNvbi5leHRyYSAmJiAobmFtZSBpbiBqc29uLmV4dHJhKSkge1xuICAgICAgICBzcmMgPSBqc29uLmV4dHJhO1xuICAgICAgfSBlbHNlIGlmIChpc1ByaXZhdGUgJiYga2V5cy5wcml2YXRlICYmIChuYW1lIGluIGtleXMucHJpdmF0ZSkpIHtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4cG9ydCByZXN0cmljdGlvbnNcbiAgICAgICAgc3JjID0ga2V5cy5wcml2YXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3JjICYmIHNyY1tuYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjdG9KU09OXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXR1cm5zIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgS2V5LiAgQWxsIHByb3BlcnRpZXMgb2YgdGhlXG4gICAqIHJldHVybmVkIEpTT04gb2JqZWN0IGFyZSBwcm9wZXJseSBlbmNvZGVkIChlLmcuLCBiYXNlNjR1cmwgZW5jb2RpbmcgZm9yXG4gICAqIGFueSBiaW5hcnkgc3RyaW5ncykuXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZT1mYWxzZV0gYHRydWVgIGlmIHByaXZhdGUgcGFyYW1ldGVycyBzaG91bGQgYmVcbiAgICogICAgICAgIGluY2x1ZGVkLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBbZXhjbHVkZWRdIFRoZSBsaXN0IG9mIHBhcmFtZXRlcnMgdG8gZXhjbHVkZSBmcm9tXG4gICAqICAgICAgICB0aGUgcmV0dXJuZWQgSlNPTi5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBsYWluIEpTT04gb2JqZWN0XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b0pTT05cIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpc1ByaXZhdGUsIGV4Y2x1ZGVkKSB7XG4gICAgICAvLyBjb2VyY2UgYXJndW1lbnRzXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpc1ByaXZhdGUpKSB7XG4gICAgICAgIGV4Y2x1ZGVkID0gaXNQcml2YXRlO1xuICAgICAgICBpc1ByaXZhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgLy8gVE9ETzogY2hlY2sgZm9yIGV4cG9ydCByZXN0cmljdGlvbnNcbiAgICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAganNvbi5iYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICBqc29uLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgICAgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgaXNQcml2YXRlICYmIGlzUHJpdmF0ZSkgPyBqc29uLnByaXZhdGUgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAganNvbi5leHRyYSk7XG4gICAgICByZXN1bHQgPSBvbWl0KHJlc3VsdCwgZXhjbHVkZWQgfHwgW10pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN0b1BFTVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgUEVNIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgS2V5IGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGU9ZmFsc2VdIGB0cnVlYCBpZiBwcml2YXRlIHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICAgICBpbmNsdWRlZC5cbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIFBFTS1lbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidG9QRU1cIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpc1ByaXZhdGUpIHtcbiAgICAgIGlmIChpc1ByaXZhdGUgPT09IG51bGwpIHtcbiAgICAgICAgaXNQcml2YXRlID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICghY2ZnLmNvbnZlcnRUb1BFTSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBrZXkgdHlwZSBmb3IgUEVNIGVuY29kaW5nXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSAoaXNQcml2YXRlKSA/IGtleXMucHJpdmF0ZSA6IGtleXMucHVibGljO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQga2V5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNmZy5jb252ZXJ0VG9QRU0uY2FsbCh0aGlzLCBrLCBpc1ByaXZhdGUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleSN0b09iamVjdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0dXJucyB0aGUgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGlzIEtleS4gIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgKiByZXR1cm5lZCBvYmplY3QgYXJlIGluIHRoZWlyIG5hdHVyYWwgZW5jb2RpbmcgKGUuZy4sIGJpbmFyeSBzdHJpbmdzXG4gICAqIGluc3RlYWQgb2YgYmFzZTY0dXJsIGVuY29kZWQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1ByaXZhdGU9ZmFsc2VdIGB0cnVlYCBpZiBwcml2YXRlIHBhcmFtZXRlcnMgc2hvdWxkIGJlXG4gICAqICAgICAgICBpbmNsdWRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmdbXX0gW2V4Y2x1ZGVkXSBUaGUgbGlzdCBvZiBwYXJhbWV0ZXJzIHRvIGV4Y2x1ZGUgZnJvbVxuICAgKiAgICAgICAgdGhlIHJldHVybmVkIG9iamVjdC5cbiAgICogQHJldHVybnMge09iamVjdH0gVGhlIHBsYWluIE9iamVjdC5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRvT2JqZWN0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaXNQcml2YXRlLCBleGNsdWRlZCkge1xuICAgICAgLy8gY29lcmNlIGFyZ3VtZW50c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXNQcml2YXRlKSkge1xuICAgICAgICBleGNsdWRlZCA9IGlzUHJpdmF0ZTtcbiAgICAgICAgaXNQcml2YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIC8vIFRPRE86IGNoZWNrIGZvciBleHBvcnQgcmVzdHJpY3Rpb25zXG4gICAgICByZXN1bHQgPSBtZXJnZShyZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgIGpzb24uYmFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgICAgIChcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGlzUHJpdmF0ZSAmJiBpc1ByaXZhdGUpID8ga2V5cy5wcml2YXRlIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgIGpzb24uZXh0cmEpO1xuICAgICAgcmVzdWx0ID0gb21pdChyZXN1bHQsIChleGNsdWRlZCB8fCBbXSkuY29uY2F0KFwibGVuZ3RoXCIpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjc2lnblxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogU2lnbiB0aGUgZ2l2ZW4gZGF0YSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSBzaWduaW5nIG9wZXJhdGlvbjsgdGhlIG91dHB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBTaWduYXR1cmUgKEpXUykgb2JqZWN0LlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgYW4gT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiArICoqZGF0YSoqOiBUaGUgZGF0YSB0aGF0IHdhcyBzaWduZWQgKGFuZCBzaG91bGQgYmUgZXF1YWwgdG8ge2RhdGF9KS5cbiAgICogKyAqKm1hYyoqOiBUaGUgc2lnbmF0dXJlIG9yIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSAoTUFDKS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgc2lnbmluZyBhbGdvcml0aG1cbiAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIHNpZ25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgc2lnbmluZ1xuICAgKiAgICAgICAgYWxnb3JpdGhtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBzaWduaW5nIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhpcyBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcGFyYW1ldGVycy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNpZ25cIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJzaWduXCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy5zaWduS2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcuc2lnblByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy5zaWduUHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5zaWduKGFsZywgaywgZGF0YSwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjdmVyaWZ5XG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBWZXJpZnkgdGhlIGdpdmVuIGRhdGEgYW5kIHNpZ25hdHVyZSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSB2ZXJpZmljYXRpb24gb3BlcmF0aW9uOyB0aGUgaW5wdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgU2lnbmF0dXJlLjwvcD5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIGFuIE9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogKyAqKmRhdGEqKjogVGhlIGRhdGEgdGhhdCB3YXMgdmVyaWZpZWQgKGFuZCBzaG91bGQgYmUgZXF1YWwgdG9cbiAgICogICB7ZGF0YX0pLlxuICAgKiArICoqbWFjKio6IFRoZSBzaWduYXR1cmUgb3IgTUFDIHRoYXQgd2FzIHZlcmlmaWVkIChhbmQgc2hvdWxkIGJlIGVxdWFsXG4gICAqICAgdG8ge21hY30pLlxuICAgKiArICoqdmFsaWQqKjogYHRydWVgIGlmIHttYWN9IGlzIHZhbGlkIGZvciB7ZGF0YX0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIHZlcmlmaWNhdGlvbiBhbGdvcml0aG1cbiAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIHZlcmlmeVxuICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IG1hYyBUaGUgc2lnbmF0dXJlIG9yIE1BQyB0byB2ZXJpZnlcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgdmVyaWZpY2F0aW9uXG4gICAqICAgICAgICBhbGdvcml0aG0uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIHZlcmlmaWNhdGlvbiBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoZSBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcHJvcGVydGllcy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcmlmeVwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKGFsZywgZGF0YSwgbWFjLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwidmVyaWZ5XCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy52ZXJpZnlLZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy52ZXJpZnlQcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcudmVyaWZ5UHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy52ZXJpZnkoYWxnLCBrLCBkYXRhLCBtYWMsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjZW5jcnlwdFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogRW5jcnlwdHMgdGhlIGdpdmVuIGRhdGEgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgZW5jcnlwdGlvbiBvcGVyYXRpb247IHRoZSBvdXRwdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKSBvYmplY3QuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIG9wZXJhdGlvbiBpcyB0cmVhdGVkIGFzIGRpc3RpbmN0IGZyb20ge0BsaW5rXG4gICAqIEpXSy5LZXkjd3JhcH0sIGFzIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBwcm9wZXJ0aWVzIGFyZSBvZnRlblxuICAgKiB1c2VkIGZvciB3cmFwcGluZyBhIGtleSB2ZXJzdWVzIGVuY3J5cHRpbmcgYXJiaXRyYXJ5IGRhdGEuXG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gICAqIHByb3BlcnRpZXM6XG4gICAqXG4gICAqICsgKipkYXRhKio6IFRoZSBjaXBoZXJ0ZXh0IGRhdGFcbiAgICogKyAqKm1hYyoqOiBUaGUgYXNzb2NpYXRlZCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUgKE1BQykuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGcgVGhlIGVuY3J5cHRpb24gYWxnb3JpdGhtXG4gICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBlbmNyeXB0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyBmb3IgdGhlIGVuY3J5cHRpb25cbiAgICogICAgICAgIGFsZ29yaXRobS5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgZW5jcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7YWxnfSBpcyBub3QgYXBwcm9wcmlhdGUgZm9yIHRoaXMgS2V5OyBvciBpZlxuICAgKiAgICAgICAgIHRoaXMgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHBhcmFtZXRlcnMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNyeXB0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwiZW5jcnlwdFwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcuZW5jcnlwdEtleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLmVuY3J5cHRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcuZW5jcnlwdFByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMuZW5jcnlwdChhbGcsIGssIGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5I2RlY3J5cHRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIERlY3J5cHRzIHRoZSBnaXZlbiBkYXRhIHVzaW5nIHRoZSBzcGVjaWZpZWQgYWxnb3JpdGhtLlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBpcyB0aGUgcHJpbWl0aXZlIGRlY3J5cHRpb24gb3BlcmF0aW9uOyB0aGUgaW5wdXQgaXNcbiAgICogXyoqTk9UKipfIGEgSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKSBvYmplY3QuXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIG9wZXJhdGlvbiBpcyB0cmVhdGVkIGFzIGRpc3RpbmN0IGZyb20ge0BsaW5rXG4gICAqIEpXSy5LZXkjdW53cmFwfSwgYXMgZGlmZmVyZW50IGFsZ29yaXRobXMgYW5kIHByb3BlcnRpZXMgYXJlIG9mdGVuIHVzZWRcbiAgICogZm9yIHVud3JhcHBpbmcgYSBrZXkgdmVyc3VlcyBkZWNyeXB0aW5nIGFyYml0cmFyeSBkYXRhLlxuICAgKlxuICAgKiBUaGUgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIHJldHVybnMgdGhlIHBsYWludGV4dCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWxnIFRoZSBkZWNyeXB0aW9uIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGRlY3lwdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBkYXRhIGZvciB0aGUgZGVjcnlwdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGRlY3J5cHRpb24gb3BlcmF0aW9uLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYge2FsZ30gaXMgbm90IGFwcHJvcHJpYXRlIGZvciB0aGlzIEtleTsgb3IgaWZcbiAgICogICAgICAgICB0aGUgS2V5IGRvZXMgbm90IGNvbnRhaW4gdGhlIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkZWNyeXB0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwiZGVjcnlwdFwiKS5pbmRleE9mKGFsZykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG1cIikpO1xuICAgICAgfVxuICAgICAgdmFyIGsgPSBjZmcuZGVjcnlwdEtleS5jYWxsKHRoaXMsIGFsZywga2V5cyk7XG4gICAgICBpZiAoIWspIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImltcHJvcGVyIGtleVwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXBhcmUgcHJvcGVydGllcyAoaWYgYW55KVxuICAgICAgcHJvcHMgPSAocHJvcHMpID9cbiAgICAgICAgICAgICAgY2xvbmUocHJvcHMpIDpcbiAgICAgICAgICAgICAge307XG4gICAgICBpZiAoY2ZnLmRlY3J5cHRQcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcuZGVjcnlwdFByb3BzLmNhbGwodGhpcywgYWxnLCBwcm9wcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFMR09SSVRITVMuZGVjcnlwdChhbGcsIGssIGRhdGEsIHByb3BzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjd3JhcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogV3JhcHMgdGhlIGdpdmVuIGtleSB1c2luZyB0aGUgc3BlY2lmaWVkIGFsZ29yaXRobS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgaXMgdGhlIHByaW1pdGl2ZSBlbmNyeXB0aW9uIG9wZXJhdGlvbjsgdGhlIG91dHB1dCBpc1xuICAgKiBfKipOT1QqKl8gYSBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpIG9iamVjdC5cbiAgICpcbiAgICogKipOT1RFOioqIFRoaXMgb3BlcmF0aW9uIGlzIHRyZWF0ZWQgYXMgZGlzdGluY3QgZnJvbSB7QGxpbmtcbiAgICogSldLLktleSNlbmNyeXB0fSwgYXMgZGlmZmVyZW50IGFsZ29yaXRobXMgYW5kIHByb3BlcnRpZXMgYXJlXG4gICAqIG9mdGVuIHVzZWQgZm9yIHdyYXBwaW5nIGEga2V5IHZlcnN1ZXMgZW5jcnlwdGluZyBhcmJpdHJhcnkgZGF0YS5cbiAgICpcbiAgICogVGhlIFByb21pc2UsIHdoZW4gZnVsZmlsbGVkLCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogcHJvcGVydGllczpcbiAgICpcbiAgICogKyAqKmRhdGEqKjogVGhlIGNpcGhlcnRleHQgZGF0YVxuICAgKiArICoqaGVhZGVycyoqOiBUaGUgYWRkaXRpb25hbCBoZWFkZXIgcGFyYW1ldGVycyB0byBhcHBseSB0byBhIEpXRS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgZW5jcnlwdGlvbiBhbGdvcml0aG1cbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGVuY3J5cHRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIGZvciB0aGUgZW5jcnlwdGlvblxuICAgKiAgICAgICAgYWxnb3JpdGhtLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIHByb21pc2UgZm9yIHRoZSBlbmNyeXB0aW9uIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhpcyBLZXkgZG9lcyBub3QgY29udGFpbiB0aGUgYXBwcm9wcmlhdGUgcGFyYW1ldGVycy5cbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIndyYXBcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihhbGcsIGRhdGEsIHByb3BzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZW5lc3NcbiAgICAgIGlmICh0aGlzLmFsZ29yaXRobXMoXCJ3cmFwXCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy53cmFwS2V5LmNhbGwodGhpcywgYWxnLCBrZXlzKTtcbiAgICAgIGlmICghaykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiaW1wcm9wZXIga2V5XCIpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcHJlcGFyZSBwcm9wZXJ0aWVzIChpZiBhbnkpXG4gICAgICBwcm9wcyA9IChwcm9wcykgP1xuICAgICAgICAgICAgICBjbG9uZShwcm9wcykgOlxuICAgICAgICAgICAgICB7fTtcbiAgICAgIGlmIChjZmcud3JhcFByb3BzKSB7XG4gICAgICAgIHByb3BzID0gbWVyZ2UocHJvcHMsIGNmZy53cmFwUHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5lbmNyeXB0KGFsZywgaywgZGF0YSwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXkjdW53cmFwXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBVbndyYXBzIHRoZSBnaXZlbiBrZXkgdXNpbmcgdGhlIHNwZWNpZmllZCBhbGdvcml0aG0uXG4gICAqXG4gICAqICoqTk9URToqKiBUaGlzIGlzIHRoZSBwcmltaXRpdmUgdW53cmFwIG9wZXJhdGlvbjsgdGhlIGlucHV0IGlzXG4gICAqIF8qKk5PVCoqXyBhIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSkgb2JqZWN0LlxuICAgKlxuICAgKiAqKk5PVEU6KiogVGhpcyBvcGVyYXRpb24gaXMgdHJlYXRlZCBhcyBkaXN0aW5jdCBmcm9tIHtAbGlua1xuICAgKiBKV0suS2V5I2RlY3J5cHR9LCBhcyBkaWZmZXJlbnQgYWxnb3JpdGhtcyBhbmQgcHJvcGVydGllcyBhcmUgb2Z0ZW4gdXNlZFxuICAgKiBmb3IgdW53cmFwcGluZyBhIGtleSB2ZXJzdWVzIGRlY3J5cHRpbmcgYXJiaXRyYXJ5IGRhdGEuXG4gICAqXG4gICAqIFRoZSBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyB0aGUgdW53cmFwcGVkIGtleS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFsZyBUaGUgdW53cmFwIGFsZ29yaXRobS5cbiAgICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIHVud3JhcC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wc10gQWRkaXRpb25hbCBkYXRhIGZvciB0aGUgdW53cmFwIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgdW53cmFwIG9wZXJhdGlvbi5cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHthbGd9IGlzIG5vdCBhcHByb3ByaWF0ZSBmb3IgdGhpcyBLZXk7IG9yIGlmXG4gICAqICAgICAgICAgdGhlIEtleSBkb2VzIG5vdCBjb250YWluIHRoZSBhcHByb3ByaWF0ZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidW53cmFwXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnLCBkYXRhLCBwcm9wcykge1xuICAgICAgLy8gdmFsaWRhdGUgYXBwcm9wcmlhdGVuZXNzXG4gICAgICBpZiAodGhpcy5hbGdvcml0aG1zKFwidW53cmFwXCIpLmluZGV4T2YoYWxnKSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGFsZ29yaXRobVwiKSk7XG4gICAgICB9XG4gICAgICB2YXIgayA9IGNmZy51bndyYXBLZXkuY2FsbCh0aGlzLCBhbGcsIGtleXMpO1xuICAgICAgaWYgKCFrKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbXByb3BlciBrZXlcIikpO1xuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIHByb3BlcnRpZXMgKGlmIGFueSlcbiAgICAgIHByb3BzID0gKHByb3BzKSA/XG4gICAgICAgICAgICAgIGNsb25lKHByb3BzKSA6XG4gICAgICAgICAgICAgIHt9O1xuICAgICAgaWYgKGNmZy51bndyYXBQcm9wcykge1xuICAgICAgICBwcm9wcyA9IG1lcmdlKHByb3BzLCBjZmcudW53cmFwUHJvcHMuY2FsbCh0aGlzLCBhbGcsIHByb3BzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5kZWNyeXB0KGFsZywgaywgZGF0YSwgcHJvcHMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpXS0Jhc2VLZXlPYmplY3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/constants.js ***!
  \*****************************************************/
/***/ ((module) => {

eval("/*!\n * jwk/constants.js - Constants for JWKs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  MODE_SIGN: \"sign\",\n  MODE_VERIFY: \"verify\",\n  MODE_ENCRYPT: \"encrypt\",\n  MODE_DECRYPT: \"decrypt\",\n  MODE_WRAP: \"wrap\",\n  MODE_UNWRAP: \"unwrap\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL2NvbnN0YW50cy5qcz83MzNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL2NvbnN0YW50cy5qcyAtIENvbnN0YW50cyBmb3IgSldLc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTU9ERV9TSUdOOiBcInNpZ25cIixcbiAgTU9ERV9WRVJJRlk6IFwidmVyaWZ5XCIsXG4gIE1PREVfRU5DUllQVDogXCJlbmNyeXB0XCIsXG4gIE1PREVfREVDUllQVDogXCJkZWNyeXB0XCIsXG4gIE1PREVfV1JBUDogXCJ3cmFwXCIsXG4gIE1PREVfVU5XUkFQOiBcInVud3JhcFwiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/eckey.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/eckey.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar ecutil = __webpack_require__(/*! ../algorithms/ec-util.js */ \"(ssr)/./node_modules/node-jose/lib/algorithms/ec-util.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    depsecc = __webpack_require__(/*! ../deps/ecc */ \"(ssr)/./node_modules/node-jose/lib/deps/ecc/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"ES256\",\n  \"ES384\",\n  \"ES512\"\n];\nvar WRAP_ALGS = [\n  \"ECDH-ES\",\n  \"ECDH-ES+A128KW\",\n  \"ECDH-ES+A192KW\",\n  \"ECDH-ES+A256KW\"\n];\n\nvar EC_OID = ecutil.EC_OID;\nfunction oidToCurveName(oid) {\n  switch (oid) {\n    case \"1.2.840.10045.3.1.7\":\n      return \"P-256\";\n    case \"1.3.132.0.34\":\n      return \"P-384\";\n    case \"1.3.132.0.35\":\n      return \"P-521\";\n    default:\n      return null;\n  }\n}\n\nvar JWKEcCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      delete pk.crv;\n      delete pk.x;\n      delete pk.y;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"crv\", type: \"string\"},\n      {name: \"x\", type: \"binary\"},\n      {name: \"y\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"}\n    ]);\n    var pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.crv && pk.x && pk.y && pk.d) {\n      pk.length = ecutil.curveSize(pk.crv);\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      crv: json.crv,\n      kty: \"EC\",\n      x: json.x,\n      y: json.y\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = (keys.public && keys.public.length) ||\n              (keys.private && keys.private.length) ||\n              0;\n    // NOTE: 521 is the actual, but 512 is the expected\n    if (len === 521) {\n        len = 512;\n    }\n\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return [];\n      case \"wrap\":\n        return (keys.public && WRAP_ALGS) || [];\n      case \"unwrap\":\n        return (keys.private && WRAP_ALGS) || [];\n      case \"sign\":\n        if (!keys.private) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n      case \"verify\":\n        if (!keys.public) {\n          return [];\n        }\n        return SIG_ALGS.filter(function(a) {\n          return (a === (\"ES\" + len));\n        });\n    }\n  },\n\n  encryptKey: function(alg, keys) {\n    return keys.public;\n  },\n  decryptKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  }\n};\nJWKEcCfg.convertToPEM = ecutil.convertToPEM;\n\n// Inspired by digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: EC_OID,\n  privateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // EC parameters\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        name: \"ECPrivateKey.parameters\",\n        constructed: true,\n        value: [\n          {\n            // namedCurve (crv)\n            name: \"ECPrivateKey.namedCurve\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.OID,\n            constructed: false,\n            capture: \"crv\"\n          }\n        ]\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  },\n  embeddedPrivateKey: {\n    // ECPrivateKey\n    name: \"ECPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // EC version\n        name: \"ECPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false\n      },\n      {\n        // private value (d)\n        name: \"ECPrivateKey.private\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.OCTETSTRING,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // publicKey\n        name: \"ECPrivateKey.publicKey\",\n        tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n        constructed: true,\n        value: [\n          {\n            name: \"ECPrivateKey.point\",\n            tagClass: forge.asn1.Class.UNIVERSAL,\n            type: forge.asn1.Type.BITSTRING,\n            constructed: false,\n            capture: \"point\"\n          }\n        ]\n      }\n    ]\n  }\n};\n\nvar JWKEcFactory = {\n  kty: \"EC\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKEcCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    var keypair = depsecc.generateKeyPair(size);\n    var result = {\n      \"crv\": size,\n      \"x\": keypair.public.x,\n      \"y\": keypair.public.y,\n      \"d\": keypair.private.d\n    };\n    return Promise.resolve(result);\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    // coerce key params to OID\n    var crv;\n    if (input.keyParams && forge.asn1.Type.OID === input.keyParams.type) {\n      crv = forge.asn1.derToOid(input.keyParams.value);\n      crv = oidToCurveName(crv);\n    } else if (input.crv) {\n      crv = forge.asn1.derToOid(input.crv);\n      crv = oidToCurveName(crv);\n    }\n    if (!crv) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      var capture = {},\n          errors = [];\n      if (\"private\" === input.type) {\n        // coerce capture.value to DER *iff* private\n        if (\"string\" === typeof input.keyValue) {\n          input.keyValue = forge.asn1.fromDer(input.keyValue);\n        } else if (Array.isArray(input.keyValue)) {\n          input.keyValue = input.keyValue[0];\n        }\n\n        if (!forge.asn1.validate(input.keyValue,\n                                 validators.embeddedPrivateKey,\n                                 capture,\n                                 errors)) {\n          return null;\n        }\n      } else {\n        capture.point = input.keyValue;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"EC\",\n      crv: crv\n    };\n    if (input.d) {\n      output.d = Buffer.from(input.d, \"binary\");\n    }\n    if (input.point) {\n      var pt = Buffer.from(input.point, \"binary\");\n      // only support uncompressed\n      if (4 !== pt.readUInt16BE(0)) {\n        return null;\n      }\n      pt = pt.slice(2);\n      var len = pt.length / 2;\n      output.x = pt.slice(0, len);\n      output.y = pt.slice(len);\n    }\n    return output;\n  }\n};\n// public API\nmodule.exports = Object.freeze({\n  config: JWKEcCfg,\n  factory: JWKEcFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKEcFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svZWNrZXkuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGFBQWEsbUJBQU8sQ0FBQywwRkFBMEI7QUFDL0MsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyx5RUFBYTs7QUFFbkM7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0QkFBNEI7QUFDbkMsT0FBTywwQkFBMEI7QUFDakMsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPLDRCQUE0QjtBQUNuQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPLDBCQUEwQjtBQUNqQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL2Vja2V5LmpzPzA0ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svcnNhLmpzIC0gUlNBIEtleSBSZXByZXNlbnRhdGlvblxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZWN1dGlsID0gcmVxdWlyZShcIi4uL2FsZ29yaXRobXMvZWMtdXRpbC5qc1wiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlXCIpLFxuICAgIGRlcHNlY2MgPSByZXF1aXJlKFwiLi4vZGVwcy9lY2NcIik7XG5cbnZhciBKV0sgPSB7XG4gIEJhc2VLZXk6IHJlcXVpcmUoXCIuL2Jhc2VrZXkuanNcIiksXG4gIGhlbHBlcnM6IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIilcbn07XG5cbnZhciBTSUdfQUxHUyA9IFtcbiAgXCJFUzI1NlwiLFxuICBcIkVTMzg0XCIsXG4gIFwiRVM1MTJcIlxuXTtcbnZhciBXUkFQX0FMR1MgPSBbXG4gIFwiRUNESC1FU1wiLFxuICBcIkVDREgtRVMrQTEyOEtXXCIsXG4gIFwiRUNESC1FUytBMTkyS1dcIixcbiAgXCJFQ0RILUVTK0EyNTZLV1wiXG5dO1xuXG52YXIgRUNfT0lEID0gZWN1dGlsLkVDX09JRDtcbmZ1bmN0aW9uIG9pZFRvQ3VydmVOYW1lKG9pZCkge1xuICBzd2l0Y2ggKG9pZCkge1xuICAgIGNhc2UgXCIxLjIuODQwLjEwMDQ1LjMuMS43XCI6XG4gICAgICByZXR1cm4gXCJQLTI1NlwiO1xuICAgIGNhc2UgXCIxLjMuMTMyLjAuMzRcIjpcbiAgICAgIHJldHVybiBcIlAtMzg0XCI7XG4gICAgY2FzZSBcIjEuMy4xMzIuMC4zNVwiOlxuICAgICAgcmV0dXJuIFwiUC01MjFcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxudmFyIEpXS0VjQ2ZnID0ge1xuICBwdWJsaWNLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgICAge25hbWU6IFwiY3J2XCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgICAge25hbWU6IFwieFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcInlcIiwgdHlwZTogXCJiaW5hcnlcIn1cbiAgICBdKTtcbiAgICB2YXIgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcbiAgICBpZiAocGsgJiYgcGsuY3J2ICYmIHBrLnggJiYgcGsueSkge1xuICAgICAgcGsubGVuZ3RoID0gZWN1dGlsLmN1cnZlU2l6ZShway5jcnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcGsuY3J2O1xuICAgICAgZGVsZXRlIHBrLng7XG4gICAgICBkZWxldGUgcGsueTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG4gIHByaXZhdGVLZXk6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgdmFyIGZpZWxkcyA9IEpXSy5oZWxwZXJzLkNPTU1PTl9QUk9QUy5jb25jYXQoW1xuICAgICAge25hbWU6IFwiY3J2XCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgICAge25hbWU6IFwieFwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcInlcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJkXCIsIHR5cGU6IFwiYmluYXJ5XCJ9XG4gICAgXSk7XG4gICAgdmFyIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG4gICAgaWYgKHBrICYmIHBrLmNydiAmJiBway54ICYmIHBrLnkgJiYgcGsuZCkge1xuICAgICAgcGsubGVuZ3RoID0gZWN1dGlsLmN1cnZlU2l6ZShway5jcnYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG4gIHRodW1icHJpbnQ6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICBpZiAoanNvbi5wdWJsaWMpIHtcbiAgICAgIGpzb24gPSBqc29uLnB1YmxpYztcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IHtcbiAgICAgIGNydjoganNvbi5jcnYsXG4gICAgICBrdHk6IFwiRUNcIixcbiAgICAgIHg6IGpzb24ueCxcbiAgICAgIHk6IGpzb24ueVxuICAgIH07XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSxcbiAgYWxnb3JpdGhtczogZnVuY3Rpb24oa2V5cywgbW9kZSkge1xuICAgIHZhciBsZW4gPSAoa2V5cy5wdWJsaWMgJiYga2V5cy5wdWJsaWMubGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAoa2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5sZW5ndGgpIHx8XG4gICAgICAgICAgICAgIDA7XG4gICAgLy8gTk9URTogNTIxIGlzIHRoZSBhY3R1YWwsIGJ1dCA1MTIgaXMgdGhlIGV4cGVjdGVkXG4gICAgaWYgKGxlbiA9PT0gNTIxKSB7XG4gICAgICAgIGxlbiA9IDUxMjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgIGNhc2UgXCJlbmNyeXB0XCI6XG4gICAgICBjYXNlIFwiZGVjcnlwdFwiOlxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjYXNlIFwid3JhcFwiOlxuICAgICAgICByZXR1cm4gKGtleXMucHVibGljICYmIFdSQVBfQUxHUykgfHwgW107XG4gICAgICBjYXNlIFwidW53cmFwXCI6XG4gICAgICAgIHJldHVybiAoa2V5cy5wcml2YXRlICYmIFdSQVBfQUxHUykgfHwgW107XG4gICAgICBjYXNlIFwic2lnblwiOlxuICAgICAgICBpZiAoIWtleXMucHJpdmF0ZSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU0lHX0FMR1MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gKGEgPT09IChcIkVTXCIgKyBsZW4pKTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwidmVyaWZ5XCI6XG4gICAgICAgIGlmICgha2V5cy5wdWJsaWMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNJR19BTEdTLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgcmV0dXJuIChhID09PSAoXCJFU1wiICsgbGVuKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfSxcblxuICBlbmNyeXB0S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wdWJsaWM7XG4gIH0sXG4gIGRlY3J5cHRLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGU7XG4gIH0sXG5cbiAgd3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHVibGljO1xuICB9LFxuICB1bndyYXBLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGU7XG4gIH0sXG5cbiAgc2lnbktleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZTtcbiAgfSxcbiAgdmVyaWZ5S2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wdWJsaWM7XG4gIH1cbn07XG5KV0tFY0NmZy5jb252ZXJ0VG9QRU0gPSBlY3V0aWwuY29udmVydFRvUEVNO1xuXG4vLyBJbnNwaXJlZCBieSBkaWdpdGFsYmFhemFyL25vZGUtZm9yZ2UvanMvcnNhLmpzXG52YXIgdmFsaWRhdG9ycyA9IHtcbiAgb2lkOiBFQ19PSUQsXG4gIHByaXZhdGVLZXk6IHtcbiAgICAvLyBFQ1ByaXZhdGVLZXlcbiAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleVwiLFxuICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFtcbiAgICAgIHtcbiAgICAgICAgLy8gRUMgdmVyc2lvblxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS52ZXJzaW9uXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHJpdmF0ZSB2YWx1ZSAoZClcbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucHJpdmF0ZVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gRUMgcGFyYW1ldGVyc1xuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wYXJhbWV0ZXJzXCIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIG5hbWVkQ3VydmUgKGNydilcbiAgICAgICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5Lm5hbWVkQ3VydmVcIixcbiAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICBjYXB0dXJlOiBcImNydlwiXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwdWJsaWNLZXlcbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucHVibGljS2V5XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLkNPTlRFWFRfU1BFQ0lGSUMsXG4gICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICB2YWx1ZTogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnBvaW50XCIsXG4gICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgY2FwdHVyZTogXCJwb2ludFwiXG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXVxuICB9LFxuICBlbWJlZGRlZFByaXZhdGVLZXk6IHtcbiAgICAvLyBFQ1ByaXZhdGVLZXlcbiAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleVwiLFxuICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFtcbiAgICAgIHtcbiAgICAgICAgLy8gRUMgdmVyc2lvblxuICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS52ZXJzaW9uXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHJpdmF0ZSB2YWx1ZSAoZClcbiAgICAgICAgbmFtZTogXCJFQ1ByaXZhdGVLZXkucHJpdmF0ZVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHVibGljS2V5XG4gICAgICAgIG5hbWU6IFwiRUNQcml2YXRlS2V5LnB1YmxpY0tleVwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkVDUHJpdmF0ZUtleS5wb2ludFwiLFxuICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkJJVFNUUklORyxcbiAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGNhcHR1cmU6IFwicG9pbnRcIlxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfVxufTtcblxudmFyIEpXS0VjRmFjdG9yeSA9IHtcbiAga3R5OiBcIkVDXCIsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnMsXG4gIHByZXBhcmU6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUga2V5IHByb3BlcnRpZXNcbiAgICB2YXIgY2ZnID0gSldLRWNDZmc7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUocHJvcHMpO1xuICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oanNvbikge1xuICAgICAgcmV0dXJuIEpXSy5oZWxwZXJzLnRodW1icHJpbnQoY2ZnLCBqc29uKTtcbiAgICB9KTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGhhc2gpIHtcbiAgICAgIHZhciBwcmludHMgPSB7fTtcbiAgICAgIHByaW50c1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9IQVNIXSA9IGhhc2g7XG4gICAgICBwcm9wc1tKV0suaGVscGVycy5JTlRFUk5BTFMuVEhVTUJQUklOVF9LRVldID0gcHJpbnRzO1xuICAgICAgcmV0dXJuIGNmZztcbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB2YXIga2V5cGFpciA9IGRlcHNlY2MuZ2VuZXJhdGVLZXlQYWlyKHNpemUpO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICBcImNydlwiOiBzaXplLFxuICAgICAgXCJ4XCI6IGtleXBhaXIucHVibGljLngsXG4gICAgICBcInlcIjoga2V5cGFpci5wdWJsaWMueSxcbiAgICAgIFwiZFwiOiBrZXlwYWlyLnByaXZhdGUuZFxuICAgIH07XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICB9LFxuICBpbXBvcnQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHZhbGlkYXRvcnMub2lkICE9PSBpbnB1dC5rZXlPaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNvZXJjZSBrZXkgcGFyYW1zIHRvIE9JRFxuICAgIHZhciBjcnY7XG4gICAgaWYgKGlucHV0LmtleVBhcmFtcyAmJiBmb3JnZS5hc24xLlR5cGUuT0lEID09PSBpbnB1dC5rZXlQYXJhbXMudHlwZSkge1xuICAgICAgY3J2ID0gZm9yZ2UuYXNuMS5kZXJUb09pZChpbnB1dC5rZXlQYXJhbXMudmFsdWUpO1xuICAgICAgY3J2ID0gb2lkVG9DdXJ2ZU5hbWUoY3J2KTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmNydikge1xuICAgICAgY3J2ID0gZm9yZ2UuYXNuMS5kZXJUb09pZChpbnB1dC5jcnYpO1xuICAgICAgY3J2ID0gb2lkVG9DdXJ2ZU5hbWUoY3J2KTtcbiAgICB9XG4gICAgaWYgKCFjcnYpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaW5wdXQucGFyc2VkKSB7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9LFxuICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKFwicHJpdmF0ZVwiID09PSBpbnB1dC50eXBlKSB7XG4gICAgICAgIC8vIGNvZXJjZSBjYXB0dXJlLnZhbHVlIHRvIERFUiAqaWZmKiBwcml2YXRlXG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQua2V5VmFsdWUpIHtcbiAgICAgICAgICBpbnB1dC5rZXlWYWx1ZSA9IGZvcmdlLmFzbjEuZnJvbURlcihpbnB1dC5rZXlWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dC5rZXlWYWx1ZSkpIHtcbiAgICAgICAgICBpbnB1dC5rZXlWYWx1ZSA9IGlucHV0LmtleVZhbHVlWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LmtleVZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5lbWJlZGRlZFByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXB0dXJlLnBvaW50ID0gaW5wdXQua2V5VmFsdWU7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IGNhcHR1cmU7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBmYWN0b3JzIHRvIEJ1ZmZlcnNcbiAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAga3R5OiBcIkVDXCIsXG4gICAgICBjcnY6IGNydlxuICAgIH07XG4gICAgaWYgKGlucHV0LmQpIHtcbiAgICAgIG91dHB1dC5kID0gQnVmZmVyLmZyb20oaW5wdXQuZCwgXCJiaW5hcnlcIik7XG4gICAgfVxuICAgIGlmIChpbnB1dC5wb2ludCkge1xuICAgICAgdmFyIHB0ID0gQnVmZmVyLmZyb20oaW5wdXQucG9pbnQsIFwiYmluYXJ5XCIpO1xuICAgICAgLy8gb25seSBzdXBwb3J0IHVuY29tcHJlc3NlZFxuICAgICAgaWYgKDQgIT09IHB0LnJlYWRVSW50MTZCRSgwKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHB0ID0gcHQuc2xpY2UoMik7XG4gICAgICB2YXIgbGVuID0gcHQubGVuZ3RoIC8gMjtcbiAgICAgIG91dHB1dC54ID0gcHQuc2xpY2UoMCwgbGVuKTtcbiAgICAgIG91dHB1dC55ID0gcHQuc2xpY2UobGVuKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxufTtcbi8vIHB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbmZpZzogSldLRWNDZmcsXG4gIGZhY3Rvcnk6IEpXS0VjRmFjdG9yeVxufSk7XG5cbi8vIHJlZ2lzdHJhdGlvblxuKGZ1bmN0aW9uKFJFR0lTVFJZKSB7XG4gIFJFR0lTVFJZLnJlZ2lzdGVyKEpXS0VjRmFjdG9yeSk7XG59KShyZXF1aXJlKFwiLi9rZXlzdG9yZVwiKS5yZWdpc3RyeSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/helpers.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/helpers.js - JWK Internal Helper Functions and Constants\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar ALGORITHMS = __webpack_require__(/*! ../algorithms */ \"(ssr)/./node_modules/node-jose/lib/algorithms/index.js\");\n\n// ### ASN.1 Validators\n// Adapted from digitalbazaar/node-forge/js/asn1.js\n// PrivateKeyInfo\nvar privateKeyValidator = {\n  name: \"PrivateKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      // Version (INTEGER)\n      name: \"PrivateKeyInfo.version\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.INTEGER,\n      constructed: false,\n      capture: \"keyVersion\"\n    },\n    {\n      name: \"PrivateKeyInfo.privateKeyAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"PrivateKeyInfo\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.OCTETSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar publicKeyValidator = {\n  name: \"SubjectPublicKeyInfo\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"SubjectPublicKeyInfo.AlgorithmIdentifier\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          name: \"AlgorithmIdentifier.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"keyOid\"\n        },\n        {\n          name: \"AlgorithmIdentifier.parameters\",\n          captureAsn1: \"keyParams\"\n        }\n      ]\n    },\n    {\n      name: \"SubjectPublicKeyInfo.subjectPublicKey\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"keyValue\"\n    }\n  ]\n};\n// Adapted from digitalbazaar/node-forge/x509.js\nvar X509CertificateValidator = {\n  name: \"Certificate\",\n  tagClass: forge.asn1.Class.UNIVERSAL,\n  type: forge.asn1.Type.SEQUENCE,\n  constructed: true,\n  value: [\n    {\n      name: \"Certificate.TBSCertificate\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      captureAsn1: \"certificate\",\n      value: [\n        {\n          name: \"Certificate.TBSCertificate.version\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 0,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.version.integer\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.INTEGER,\n              constructed: false,\n              capture: \"certVersion\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.serialNumber\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.INTEGER,\n          constructed: false,\n          capture: \"certSerialNumber\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.signature.algorithm\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.OID,\n              constructed: false,\n              capture: \"certSignatureOid\"\n            }, {\n              name: \"Certificate.TBSCertificate.signature.parameters\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              optional: true,\n              captureAsn1: \"certSignatureParams\"\n            }\n          ]\n        },\n        {\n          name: \"Certificate.TBSCertificate.issuer\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certIssuer\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.validity\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          // Note: UTC and generalized times may both appear so the capture\n          // names are based on their detected order, the names used below\n          // are only for the common case, which validity time really means\n          // \"notBefore\" and which means \"notAfter\" will be determined by order\n          value: [\n            {\n              // notBefore (Time) (UTC time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity1UTCTime\"\n            },\n            {\n              // notBefore (Time) (generalized time case)\n              name: \"Certificate.TBSCertificate.validity.notBefore (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity2GeneralizedTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (utc)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.UTCTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity3UTCTime\"\n            },\n            {\n              // notAfter (Time) (only UTC time is supported)\n              name: \"Certificate.TBSCertificate.validity.notAfter (generalized)\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.GENERALIZEDTIME,\n              constructed: false,\n              optional: true,\n              capture: \"certValidity4GeneralizedTime\"\n            }\n          ]\n        }, {\n          // Name (subject) (RDNSequence)\n          name: \"Certificate.TBSCertificate.subject\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.SEQUENCE,\n          constructed: true,\n          captureAsn1: \"certSubject\"\n        },\n        // SubjectPublicKeyInfo\n        publicKeyValidator,\n        {\n          // issuerUniqueID (optional)\n          name: \"Certificate.TBSCertificate.issuerUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 1,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.issuerUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certIssuerUniqueId\"\n            }\n          ]\n        },\n        {\n          // subjectUniqueID (optional)\n          name: \"Certificate.TBSCertificate.subjectUniqueID\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 2,\n          constructed: true,\n          optional: true,\n          value: [\n            {\n              name: \"Certificate.TBSCertificate.subjectUniqueID.id\",\n              tagClass: forge.asn1.Class.UNIVERSAL,\n              type: forge.asn1.Type.BITSTRING,\n              constructed: false,\n              capture: \"certSubjectUniqueId\"\n            }\n          ]\n        },\n        {\n          // Extensions (optional)\n          name: \"Certificate.TBSCertificate.extensions\",\n          tagClass: forge.asn1.Class.CONTEXT_SPECIFIC,\n          type: 3,\n          constructed: true,\n          captureAsn1: \"certExtensions\",\n          optional: true\n        }\n      ]\n    },\n    {\n      // AlgorithmIdentifier (signature algorithm)\n      name: \"Certificate.signatureAlgorithm\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.SEQUENCE,\n      constructed: true,\n      value: [\n        {\n          // algorithm\n          name: \"Certificate.signatureAlgorithm.algorithm\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          type: forge.asn1.Type.OID,\n          constructed: false,\n          capture: \"certSignatureOid\"\n        },\n        {\n          name: \"Certificate.TBSCertificate.signature.parameters\",\n          tagClass: forge.asn1.Class.UNIVERSAL,\n          optional: true,\n          captureAsn1: \"certSignatureParams\"\n        }\n      ]\n    },\n    {\n      // SignatureValue\n      name: \"Certificate.signatureValue\",\n      tagClass: forge.asn1.Class.UNIVERSAL,\n      type: forge.asn1.Type.BITSTRING,\n      constructed: false,\n      capture: \"certSignature\"\n    }\n  ]\n};\n\nvar INTERNALS = {\n  THUMBPRINT_KEY: \"internal\\u0000thumbprint\",\n  THUMBPRINT_HASH: \"SHA-256\"\n};\n\nmodule.exports = {\n  validators: {\n    privateKey: privateKeyValidator,\n    publicKey: publicKeyValidator,\n    certificate: X509CertificateValidator\n  },\n\n  thumbprint: function(cfg, json, hash) {\n    if (\"function\" !== typeof cfg.thumbprint) {\n      return Promise.reject(new Error(\"thumbprint not supported\"));\n    }\n\n    hash = (hash || INTERNALS.THUMBPRINT_HASH).toUpperCase();\n    var fields = cfg.thumbprint(json);\n    var input = Object.keys(fields).\n                sort().\n                map(function(k) {\n      var v = fields[k];\n      if (Buffer.isBuffer(v)) {\n        v = util.base64url.encode(v);\n      }\n      return JSON.stringify(k) + \":\" + JSON.stringify(v);\n    });\n    input = \"{\" + input.join(\",\") + \"}\";\n    try {\n      return ALGORITHMS.digest(hash, Buffer.from(input, \"utf8\"));\n    } catch (err) {\n      return Promise.reject(err);\n    }\n  },\n  unpackProps: function(props, allowed) {\n    var output;\n\n    // apply all of the existing values\n    allowed.forEach(function(cfg) {\n      if (!(cfg.name in props)) {\n        return;\n      }\n      output = output || {};\n      var value = props[cfg.name];\n      switch (cfg.type) {\n        case \"binary\":\n          if (Buffer.isBuffer(value)) {\n            props[cfg.name] = util.base64url.encode(value);\n          } else {\n            value = util.base64url.decode(value);\n          }\n          break;\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          break;\n        case \"array\":\n          value = [].concat(value);\n          break;\n        case \"object\":\n          value = clone(value);\n          break;\n        default:\n          // TODO: deep clone?\n          break;\n      }\n      output[cfg.name] = value;\n    });\n\n    // remove any from json that didn't apply\n    var check = output || {};\n    Object.keys(props).\n           forEach(function(n) {\n              if (n in check) { return; }\n              delete props[n];\n           });\n\n    return output;\n  },\n  COMMON_PROPS: [\n    {name: \"kty\", type: \"string\"},\n    {name: \"kid\", type: \"string\"},\n    {name: \"use\", type: \"string\"},\n    {name: \"alg\", type: \"string\"},\n    {name: \"x5c\", type: \"array\"},\n    {name: \"x5t\", type: \"binary\"},\n    {name: \"x5u\", type: \"string\"},\n    {name: \"key_ops\", type: \"array\"}\n  ],\n  INTERNALS: INTERNALS\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLDBEQUFjO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DLGlCQUFpQixtQkFBTyxDQUFDLDZFQUFlOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLFlBQVk7O0FBRVo7QUFDQSxHQUFHO0FBQ0g7QUFDQSxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDJCQUEyQjtBQUNoQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLLDRCQUE0QjtBQUNqQyxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL2hlbHBlcnMuanM/NmZkYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3ay9oZWxwZXJzLmpzIC0gSldLIEludGVybmFsIEhlbHBlciBGdW5jdGlvbnMgYW5kIENvbnN0YW50c1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKSxcbiAgICBmb3JnZSA9IHJlcXVpcmUoXCIuLi9kZXBzL2ZvcmdlXCIpO1xuXG52YXIgQUxHT1JJVEhNUyA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zXCIpO1xuXG4vLyAjIyMgQVNOLjEgVmFsaWRhdG9yc1xuLy8gQWRhcHRlZCBmcm9tIGRpZ2l0YWxiYXphYXIvbm9kZS1mb3JnZS9qcy9hc24xLmpzXG4vLyBQcml2YXRlS2V5SW5mb1xudmFyIHByaXZhdGVLZXlWYWxpZGF0b3IgPSB7XG4gIG5hbWU6IFwiUHJpdmF0ZUtleUluZm9cIixcbiAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gIGNvbnN0cnVjdGVkOiB0cnVlLFxuICB2YWx1ZTogW1xuICAgIHtcbiAgICAgIC8vIFZlcnNpb24gKElOVEVHRVIpXG4gICAgICBuYW1lOiBcIlByaXZhdGVLZXlJbmZvLnZlcnNpb25cIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogXCJrZXlWZXJzaW9uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm8ucHJpdmF0ZUtleUFsZ29yaXRobVwiLFxuICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJBbGdvcml0aG1JZGVudGlmaWVyLmFsZ29yaXRobVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuT0lELFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICBjYXB0dXJlOiBcImtleU9pZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIucGFyYW1ldGVyc1wiLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImtleVBhcmFtc1wiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiUHJpdmF0ZUtleUluZm9cIixcbiAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PQ1RFVFNUUklORyxcbiAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgIGNhcHR1cmU6IFwia2V5VmFsdWVcIlxuICAgIH1cbiAgXVxufTtcbi8vIEFkYXB0ZWQgZnJvbSBkaWdpdGFsYmF6YWFyL25vZGUtZm9yZ2UveDUwOS5qc1xudmFyIHB1YmxpY0tleVZhbGlkYXRvciA9IHtcbiAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mb1wiLFxuICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgY29uc3RydWN0ZWQ6IHRydWUsXG4gIHZhbHVlOiBbXG4gICAge1xuICAgICAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mby5BbGdvcml0aG1JZGVudGlmaWVyXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkFsZ29yaXRobUlkZW50aWZpZXIuYWxnb3JpdGhtXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5PSUQsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwia2V5T2lkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQWxnb3JpdGhtSWRlbnRpZmllci5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwia2V5UGFyYW1zXCJcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJTdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5XCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogXCJrZXlWYWx1ZVwiXG4gICAgfVxuICBdXG59O1xuLy8gQWRhcHRlZCBmcm9tIGRpZ2l0YWxiYXphYXIvbm9kZS1mb3JnZS94NTA5LmpzXG52YXIgWDUwOUNlcnRpZmljYXRlVmFsaWRhdG9yID0ge1xuICBuYW1lOiBcIkNlcnRpZmljYXRlXCIsXG4gIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgdmFsdWU6IFtcbiAgICB7XG4gICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRpZmljYXRlXCIsXG4gICAgICB2YWx1ZTogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS52ZXJzaW9uXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICB0eXBlOiAwLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmVyc2lvbi5pbnRlZ2VyXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmVyc2lvblwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zZXJpYWxOdW1iZXJcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFNlcmlhbE51bWJlclwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZVwiLFxuICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zaWduYXR1cmUuYWxnb3JpdGhtXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRTaWduYXR1cmVPaWRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnNpZ25hdHVyZS5wYXJhbWV0ZXJzXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRTaWduYXR1cmVQYXJhbXNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5TRVFVRU5DRSxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgICAgICBjYXB0dXJlQXNuMTogXCJjZXJ0SXNzdWVyXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHlcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIC8vIE5vdGU6IFVUQyBhbmQgZ2VuZXJhbGl6ZWQgdGltZXMgbWF5IGJvdGggYXBwZWFyIHNvIHRoZSBjYXB0dXJlXG4gICAgICAgICAgLy8gbmFtZXMgYXJlIGJhc2VkIG9uIHRoZWlyIGRldGVjdGVkIG9yZGVyLCB0aGUgbmFtZXMgdXNlZCBiZWxvd1xuICAgICAgICAgIC8vIGFyZSBvbmx5IGZvciB0aGUgY29tbW9uIGNhc2UsIHdoaWNoIHZhbGlkaXR5IHRpbWUgcmVhbGx5IG1lYW5zXG4gICAgICAgICAgLy8gXCJub3RCZWZvcmVcIiBhbmQgd2hpY2ggbWVhbnMgXCJub3RBZnRlclwiIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBvcmRlclxuICAgICAgICAgIHZhbHVlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIG5vdEJlZm9yZSAoVGltZSkgKFVUQyB0aW1lIGNhc2UpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QmVmb3JlICh1dGMpXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlVUQ1RJTUUsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFZhbGlkaXR5MVVUQ1RpbWVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gbm90QmVmb3JlIChUaW1lKSAoZ2VuZXJhbGl6ZWQgdGltZSBjYXNlKVxuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEJlZm9yZSAoZ2VuZXJhbGl6ZWQpXCIsXG4gICAgICAgICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLkdFTkVSQUxJWkVEVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHkyR2VuZXJhbGl6ZWRUaW1lXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIG5vdEFmdGVyIChUaW1lKSAob25seSBVVEMgdGltZSBpcyBzdXBwb3J0ZWQpXG4gICAgICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUudmFsaWRpdHkubm90QWZ0ZXIgKHV0YylcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuVVRDVElNRSxcbiAgICAgICAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0VmFsaWRpdHkzVVRDVGltZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBub3RBZnRlciAoVGltZSkgKG9ubHkgVVRDIHRpbWUgaXMgc3VwcG9ydGVkKVxuICAgICAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnZhbGlkaXR5Lm5vdEFmdGVyIChnZW5lcmFsaXplZClcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuR0VORVJBTElaRURUSU1FLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgICAgICAgICBjYXB0dXJlOiBcImNlcnRWYWxpZGl0eTRHZW5lcmFsaXplZFRpbWVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSwge1xuICAgICAgICAgIC8vIE5hbWUgKHN1YmplY3QpIChSRE5TZXF1ZW5jZSlcbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLlRCU0NlcnRpZmljYXRlLnN1YmplY3RcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRTdWJqZWN0XCJcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3ViamVjdFB1YmxpY0tleUluZm9cbiAgICAgICAgcHVibGljS2V5VmFsaWRhdG9yLFxuICAgICAgICB7XG4gICAgICAgICAgLy8gaXNzdWVyVW5pcXVlSUQgKG9wdGlvbmFsKVxuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuaXNzdWVyVW5pcXVlSURcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICAgIHR5cGU6IDEsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5pc3N1ZXJVbmlxdWVJRC5pZFwiLFxuICAgICAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5CSVRTVFJJTkcsXG4gICAgICAgICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgY2FwdHVyZTogXCJjZXJ0SXNzdWVyVW5pcXVlSWRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIC8vIHN1YmplY3RVbmlxdWVJRCAob3B0aW9uYWwpXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0VW5pcXVlSURcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5DT05URVhUX1NQRUNJRklDLFxuICAgICAgICAgIHR5cGU6IDIsXG4gICAgICAgICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5zdWJqZWN0VW5pcXVlSUQuaWRcIixcbiAgICAgICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgIGNhcHR1cmU6IFwiY2VydFN1YmplY3RVbmlxdWVJZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgLy8gRXh0ZW5zaW9ucyAob3B0aW9uYWwpXG4gICAgICAgICAgbmFtZTogXCJDZXJ0aWZpY2F0ZS5UQlNDZXJ0aWZpY2F0ZS5leHRlbnNpb25zXCIsXG4gICAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuQ09OVEVYVF9TUEVDSUZJQyxcbiAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgICAgICAgIGNhcHR1cmVBc24xOiBcImNlcnRFeHRlbnNpb25zXCIsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gQWxnb3JpdGhtSWRlbnRpZmllciAoc2lnbmF0dXJlIGFsZ29yaXRobSlcbiAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuc2lnbmF0dXJlQWxnb3JpdGhtXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgICBjb25zdHJ1Y3RlZDogdHJ1ZSxcbiAgICAgIHZhbHVlOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBhbGdvcml0aG1cbiAgICAgICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG1cIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLk9JRCxcbiAgICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgICAgY2FwdHVyZTogXCJjZXJ0U2lnbmF0dXJlT2lkXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiQ2VydGlmaWNhdGUuVEJTQ2VydGlmaWNhdGUuc2lnbmF0dXJlLnBhcmFtZXRlcnNcIixcbiAgICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAgICAgY2FwdHVyZUFzbjE6IFwiY2VydFNpZ25hdHVyZVBhcmFtc1wiXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFNpZ25hdHVyZVZhbHVlXG4gICAgICBuYW1lOiBcIkNlcnRpZmljYXRlLnNpZ25hdHVyZVZhbHVlXCIsXG4gICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuQklUU1RSSU5HLFxuICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogXCJjZXJ0U2lnbmF0dXJlXCJcbiAgICB9XG4gIF1cbn07XG5cbnZhciBJTlRFUk5BTFMgPSB7XG4gIFRIVU1CUFJJTlRfS0VZOiBcImludGVybmFsXFx1MDAwMHRodW1icHJpbnRcIixcbiAgVEhVTUJQUklOVF9IQVNIOiBcIlNIQS0yNTZcIlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZhbGlkYXRvcnM6IHtcbiAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5VmFsaWRhdG9yLFxuICAgIHB1YmxpY0tleTogcHVibGljS2V5VmFsaWRhdG9yLFxuICAgIGNlcnRpZmljYXRlOiBYNTA5Q2VydGlmaWNhdGVWYWxpZGF0b3JcbiAgfSxcblxuICB0aHVtYnByaW50OiBmdW5jdGlvbihjZmcsIGpzb24sIGhhc2gpIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2ZnLnRodW1icHJpbnQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ0aHVtYnByaW50IG5vdCBzdXBwb3J0ZWRcIikpO1xuICAgIH1cblxuICAgIGhhc2ggPSAoaGFzaCB8fCBJTlRFUk5BTFMuVEhVTUJQUklOVF9IQVNIKS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBmaWVsZHMgPSBjZmcudGh1bWJwcmludChqc29uKTtcbiAgICB2YXIgaW5wdXQgPSBPYmplY3Qua2V5cyhmaWVsZHMpLlxuICAgICAgICAgICAgICAgIHNvcnQoKS5cbiAgICAgICAgICAgICAgICBtYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHYgPSBmaWVsZHNba107XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgIHYgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUodik7XG4gICAgICB9XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaykgKyBcIjpcIiArIEpTT04uc3RyaW5naWZ5KHYpO1xuICAgIH0pO1xuICAgIGlucHV0ID0gXCJ7XCIgKyBpbnB1dC5qb2luKFwiLFwiKSArIFwifVwiO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQUxHT1JJVEhNUy5kaWdlc3QoaGFzaCwgQnVmZmVyLmZyb20oaW5wdXQsIFwidXRmOFwiKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH0sXG4gIHVucGFja1Byb3BzOiBmdW5jdGlvbihwcm9wcywgYWxsb3dlZCkge1xuICAgIHZhciBvdXRwdXQ7XG5cbiAgICAvLyBhcHBseSBhbGwgb2YgdGhlIGV4aXN0aW5nIHZhbHVlc1xuICAgIGFsbG93ZWQuZm9yRWFjaChmdW5jdGlvbihjZmcpIHtcbiAgICAgIGlmICghKGNmZy5uYW1lIGluIHByb3BzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvdXRwdXQgPSBvdXRwdXQgfHwge307XG4gICAgICB2YXIgdmFsdWUgPSBwcm9wc1tjZmcubmFtZV07XG4gICAgICBzd2l0Y2ggKGNmZy50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgcHJvcHNbY2ZnLm5hbWVdID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLmJhc2U2NHVybC5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIHZhbHVlID0gY2xvbmUodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRPRE86IGRlZXAgY2xvbmU/XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvdXRwdXRbY2ZnLm5hbWVdID0gdmFsdWU7XG4gICAgfSk7XG5cbiAgICAvLyByZW1vdmUgYW55IGZyb20ganNvbiB0aGF0IGRpZG4ndCBhcHBseVxuICAgIHZhciBjaGVjayA9IG91dHB1dCB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhwcm9wcykuXG4gICAgICAgICAgIGZvckVhY2goZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICBpZiAobiBpbiBjaGVjaykgeyByZXR1cm47IH1cbiAgICAgICAgICAgICAgZGVsZXRlIHByb3BzW25dO1xuICAgICAgICAgICB9KTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH0sXG4gIENPTU1PTl9QUk9QUzogW1xuICAgIHtuYW1lOiBcImt0eVwiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICB7bmFtZTogXCJraWRcIiwgdHlwZTogXCJzdHJpbmdcIn0sXG4gICAge25hbWU6IFwidXNlXCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgIHtuYW1lOiBcImFsZ1wiLCB0eXBlOiBcInN0cmluZ1wifSxcbiAgICB7bmFtZTogXCJ4NWNcIiwgdHlwZTogXCJhcnJheVwifSxcbiAgICB7bmFtZTogXCJ4NXRcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAge25hbWU6IFwieDV1XCIsIHR5cGU6IFwic3RyaW5nXCJ9LFxuICAgIHtuYW1lOiBcImtleV9vcHNcIiwgdHlwZTogXCJhcnJheVwifVxuICBdLFxuICBJTlRFUk5BTFM6IElOVEVSTkFMU1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/*!\n * jwk/index.js - JSON Web Key (JWK) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWKStore = __webpack_require__(/*! ./keystore.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\");\n\n// Public API -- Key and KeyStore methods\nObject.keys(JWKStore.KeyStore).forEach(function(name) {\n  exports[name] = JWKStore.KeyStore[name];\n});\n\n// Public API -- constants\nvar CONSTANTS = __webpack_require__(/*! ./constants.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/constants.js\");\nObject.keys(CONSTANTS).forEach(function(name) {\n  exports[name] = CONSTANTS[name];\n});\n\n// Registered Key Types\n__webpack_require__(/*! ./octkey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\");\n__webpack_require__(/*! ./rsakey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\");\n__webpack_require__(/*! ./eckey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/eckey.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyx5RUFBZTs7QUFFdEM7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFnQjtBQUN4QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLG1CQUFPLENBQUMscUVBQWE7QUFDckIsbUJBQU8sQ0FBQyxxRUFBYTtBQUNyQixtQkFBTyxDQUFDLG1FQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL2luZGV4LmpzPzkyM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2svaW5kZXguanMgLSBKU09OIFdlYiBLZXkgKEpXSykgRW50cnkgUG9pbnRcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEpXS1N0b3JlID0gcmVxdWlyZShcIi4va2V5c3RvcmUuanNcIik7XG5cbi8vIFB1YmxpYyBBUEkgLS0gS2V5IGFuZCBLZXlTdG9yZSBtZXRob2RzXG5PYmplY3Qua2V5cyhKV0tTdG9yZS5LZXlTdG9yZSkuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBKV0tTdG9yZS5LZXlTdG9yZVtuYW1lXTtcbn0pO1xuXG4vLyBQdWJsaWMgQVBJIC0tIGNvbnN0YW50c1xudmFyIENPTlNUQU5UUyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbk9iamVjdC5rZXlzKENPTlNUQU5UUykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gIGV4cG9ydHNbbmFtZV0gPSBDT05TVEFOVFNbbmFtZV07XG59KTtcblxuLy8gUmVnaXN0ZXJlZCBLZXkgVHlwZXNcbnJlcXVpcmUoXCIuL29jdGtleS5qc1wiKTtcbnJlcXVpcmUoXCIuL3JzYWtleS5qc1wiKTtcbnJlcXVpcmUoXCIuL2Vja2V5LmpzXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/keystore.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/keystore.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/keystore.js - JWK KeyStore Implementation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    forge = __webpack_require__(/*! ../deps/forge */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\n/**\n * @class JWK.KeyStoreRegistry\n * @classdesc\n * A registry of JWK.Key types that can be used.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead use the\n * global {JWK.registry}\n */\nvar JWKRegistry = function() {\n  var types = {};\n\n  Object.defineProperty(this, \"register\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      types[kty] = factory;\n      return this;\n    }\n  });\n  Object.defineProperty(this, \"unregister\", {\n    value: function(factory) {\n      if (!factory || \"string\" !== typeof factory.kty || !factory.kty) {\n        throw new Error(\"invalid Key factory\");\n      }\n\n      var kty = factory.kty;\n      if (factory === types[kty]) {\n        delete types[kty];\n      }\n      return this;\n    }\n  });\n\n  Object.defineProperty(this, \"get\", {\n    value: function(kty) {\n      return types[kty || \"\"] || undefined;\n    }\n  });\n  Object.defineProperty(this, \"all\", {\n    value: function() {\n      return Object.keys(types).map(function(t) { return types[t]; });\n    }\n  });\n};\n\n// Globals\nvar GLOBAL_REGISTRY = new JWKRegistry();\n\n// importer\nfunction processCert(input) {\n  // convert certIssuer to readable attributes\n  [\"certIssuer\", \"certSubject\"].forEach(function(field) {\n    /* eslint new-cap: [0] */\n    var attrs = forge.pki.RDNAttributesAsArray(input[field]);\n    var result = input[field] = {};\n    attrs.forEach(function(a) {\n      result[a.name || a.type] = a.value;\n    });\n  });\n\n  return input;\n}\n\nfunction fromPEM(input) {\n  var result = {};\n  var pems = forge.pem.decode(input);\n  var found = pems.some(function(p) {\n    switch (p.type) {\n      case \"CERTIFICATE\":\n        result.form = \"pkix\";\n        break;\n      case \"PUBLIC KEY\":\n        result.form = \"spki\";\n        break;\n      case \"PRIVATE KEY\":\n        result.form = \"pkcs8\";\n        break;\n      case \"EC PRIVATE KEY\":\n        /* eslint no-fallthrough: [0] */\n      case \"RSA PRIVATE KEY\":\n        result.form = \"private\";\n        break;\n      default:\n        return false;\n    }\n\n    result.body = p.body;\n    return true;\n  });\n  if (!found) {\n    throw new Error(\"supported PEM type not found\");\n  }\n  return result;\n}\nfunction importFrom(registry, input) {\n  // form can be one of:\n  //  'private' | 'pkcs8' | 'public' | 'spki' | 'pkix' | 'x509'\n  var capture = {},\n      errors = [],\n      result;\n\n  // conver from DER to ASN1\n  var form = input.form,\n      der = input.body,\n      thumbprint = null;\n  input = forge.asn1.fromDer(der);\n  switch(form) {\n    case \"private\":\n      registry.all().some(function(factory) {\n        if (result) {\n          return false;\n        }\n        if (!factory.validators) {\n          return false;\n        }\n\n        var oid = factory.validators.oid,\n            validator = factory.validators.privateKey;\n        if (!validator) {\n          return false;\n        }\n        capture = {};\n        errors = [];\n        result = forge.asn1.validate(input, validator, capture, errors);\n        if (result) {\n          capture.keyOid = forge.asn1.oidToDer(oid);\n          capture.parsed = true;\n        }\n        return result;\n      });\n      capture.type = \"private\";\n      break;\n    case \"pkcs8\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.privateKey, capture, errors);\n      capture.type = \"private\";\n      break;\n    case \"public\":\n      // eslint no-fallthrough: [0] */\n    case \"spki\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.publicKey, capture, errors);\n      capture.type = \"public\";\n      break;\n    case \"pkix\":\n      /* eslint no-fallthrough: [0] */\n    case \"x509\":\n      result = forge.asn1.validate(input, JWK.helpers.validators.certificate, capture, errors);\n      if (result) {\n        capture = processCert(capture);\n        var md = forge.md.sha1.create();\n        md.update(der);\n        thumbprint = util.base64url.encode(Buffer.from(md.digest().toHex(), \"hex\"));\n      }\n      capture.type = \"public\";\n      break;\n  }\n  if (!result) {\n    return null;\n  }\n\n  // convert oids\n  if (capture.keyOid) {\n    capture.keyOid = forge.asn1.derToOid(capture.keyOid);\n  }\n\n  // find and invoke the importer\n  result = null;\n  GLOBAL_REGISTRY.all().forEach(function(factory) {\n    if (result) {\n      return;\n    }\n    if (!factory) {\n      return;\n    }\n    if (\"function\" !== typeof factory.import) {\n      return;\n    }\n    result = factory.import(capture);\n  });\n  if (result && capture.certSubject && capture.certSubject.commonName) {\n    result.kid = capture.certSubject.commonName;\n  }\n  if (result && thumbprint) {\n    result.x5t = thumbprint;\n  }\n  return result;\n}\n\n/**\n * @class JWK.KeyStore\n * @classdesc\n * Represents a collection of Keys.\n *\n * @description\n * **NOTE:** This constructor cannot be called directly. Instead call {@link\n * JWK.createKeyStore}.\n */\nvar JWKStore = function(registry, parent) {\n  var keysets = {};\n\n  /**\n   * @method JWK.KeyStore#generate\n   * @description\n   * Generates a new random Key into this KeyStore.\n   *\n   * The type of {size} depends on the value of {kty}:\n   *\n   * + **`EC`**: String naming the curve to use, which can be one of:\n   *   `\"P-256\"`, `\"P-384\"`, or `\"P-521\"` (default is **`\"P-256\"`**).\n   * + **`RSA`**: Number describing the size of the key, in bits (default is\n   *   **`2048`**).\n   * + **`oct`**: Number describing the size of the key, in bits (default is\n   *   **`256`**).\n   *\n   * Any properties in {props} are applied before the key is generated,\n   * and are expected to be data types acceptable in JSON.  This allows the\n   * generated key to have a specific key identifier, or to specify its\n   * acceptable usage.\n   *\n   * The returned Promise, when fulfilled, returns the generated Key.\n   *\n   * @param {String} kty The type of generated key\n   * @param {String|Number} [size] The size of the generated key\n   * @param {Object} [props] Additional properties to apply to the generated\n   *        key.\n   * @returns {Promise} The promise for the generated Key\n   * @throws {Error} If {kty} is not supported\n   */\n  Object.defineProperty(this, \"generate\", {\n    value: function(kty, size, props) {\n      var keytype = registry.get(kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      props = clone(props || {});\n      props.kty = kty;\n\n      var self = this,\n          promise = keytype.generate(size);\n      return promise.then(function(jwk) {\n        jwk = merge(props, jwk, {\n          kty: kty\n        });\n        return self.add(jwk);\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#add\n   * @description\n   * Adds a Key to this KeyStore. If {jwk} is a string, it is first\n   * parsed into a plain JSON object. If {jwk} is already an instance\n   * of JWK.Key, its (public) JSON representation is first obtained\n   * then applied to a new JWK.Key object within this KeyStore.\n   *\n   * @param {String|Object} jwk The JSON Web Key (JWK)\n   * @param {String} [form] The format of a String key to expect\n   * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n   * @returns {Promise} The promise for the added key\n   */\n  Object.defineProperty(this, \"add\", {\n    value: function(jwk, form, extras) {\n      extras = extras || {};\n\n      var factors;\n      if (Buffer.isBuffer(jwk) || typeof jwk === \"string\") {\n        // form can be 'json', 'pkcs8', 'spki', 'pkix', 'x509', 'pem'\n        form = (form || \"json\").toLowerCase();\n        if (\"json\" === form) {\n          jwk = JSON.parse(jwk.toString(\"utf8\"));\n        } else {\n          try {\n            if (\"pem\" === form) {\n              // convert *first* PEM -> DER\n              factors = fromPEM(jwk);\n            } else {\n              factors = {\n                body: jwk.toString(\"binary\"),\n                form: form\n              };\n            }\n            jwk = importFrom(registry, factors);\n            if (!jwk) {\n              throw new Error(\"no importer for key\");\n            }\n            Object.keys(extras).forEach(function(field){\n              jwk[field] = extras[field];\n            });\n          } catch (err) {\n            return Promise.reject(err);\n          }\n        }\n      } else if (JWKStore.isKey(jwk)) {\n        // assume a complete duplicate is desired\n        jwk = jwk.toJSON(true);\n      } else {\n        jwk = clone(jwk);\n      }\n\n      var keytype = registry.get(jwk.kty);\n      if (!keytype) {\n        return Promise.reject(new Error(\"unsupported key type\"));\n      }\n\n      var self = this,\n          promise = keytype.prepare(jwk);\n      return promise.then(function(cfg) {\n        return new JWK.BaseKey(jwk.kty, self, jwk, cfg);\n      }).then(function(jwk) {\n        var kid = jwk.kid || \"\";\n        var keys = keysets[kid] = keysets[kid] || [];\n        keys.push(jwk);\n\n        return jwk;\n      });\n    }\n  });\n  /**\n   * @method JWK.KeyStore#remove\n   * @description\n   * Removes a Key from this KeyStore.\n   *\n   * **NOTE:** The removed Key's {keystore} property is not changed.\n   *\n   * @param {JWK.Key} jwk The key to remove.\n   */\n  Object.defineProperty(this, \"remove\", {\n    value: function(jwk) {\n      if (!jwk) {\n        return;\n      }\n\n      var keys = keysets[jwk.kid];\n      if (!keys) {\n        return;\n      }\n\n      var pos = keys.indexOf(jwk);\n      if (pos === -1) {\n        return;\n      }\n\n      keys.splice(pos, 1);\n      if (!keys.length) {\n        delete keysets[jwk.kid];\n      }\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#all\n   * @description\n   * Retrieves all of the contained Keys that optinally match all of the\n   * given properties.\n   *\n   * If {props} are specified, this method only returns Keys which exactly\n   * match the given properties. The properties can be any of the\n   * following:\n   *\n   * + **alg**: The algorithm for the Key.\n   * + **use**: The usage for the Key.\n   * + **kid**: The identifier for the Key.\n   *\n   * If no properties are given, this method returns all of the Keys for this\n   * KeyStore.\n   *\n   * @param {Object} [props] The properties to match against\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key[]} The list of matching Keys, or an empty array if no\n   *          matches are found.\n   */\n  Object.defineProperty(this, \"all\", {\n    value: function(props, local) {\n      props = props || {};\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n        props.kid = String(props.kid);\n      }\n\n      var candidates = [];\n      var matches = function(key) {\n        // match on 'kty'\n        if (props.kty &&\n            key.kty &&\n            props.kty !== key.kty) {\n          return false;\n        }\n        // match on 'use'\n        if (props.use &&\n            key.use &&\n            props.use !== key.use) {\n          return false;\n        }\n        // match on 'alg'\n        if (props.alg) {\n          if (props.alg !== \"dir\" &&\n              key.alg &&\n              props.alg !== key.alg) {\n            return false;\n          }\n          return key.supports(props.alg);\n        }\n        //TODO: match on 'key_ops'\n\n        return true;\n      };\n      Object.keys(keysets).forEach(function(id) {\n        if (props.kid && props.kid !== id) {\n          return;\n        }\n\n        var keys = keysets[id].filter(matches);\n        if (keys.length) {\n          candidates = candidates.concat(keys);\n        }\n      });\n\n      if (!local && parent) {\n        candidates = candidates.concat(parent.all(props));\n      }\n\n      return candidates;\n    }\n  });\n  /**\n   * @method JWK.KeyStore#get\n   * @description\n   * Retrieves the contained Key matching the given {kid}, and optionally\n   * all of the given properties.  This method equivalent to calling\n   * {@link JWK.Store#all}, then returning the first Key whose\n   * \"kid\" is {kid}. If {kid} is undefined, then the first Key that\n   * is returned from `all()` is returned.\n   *\n   * @param {String} [kid] The key identifier to match against.\n   * @param {Object} [props] The properties to match against.\n   * @param {Boolean} [local = false] `true` if only the Keys\n   *        directly contained by this KeyStore should be returned, or\n   *        `false` if it should return all Keys of this KeyStore and\n   *        its ancestors.\n   * @returns {JWK.Key} The Key matching {kid} and {props}, or `null`\n   *          if no match is found.\n   */\n  Object.defineProperty(this, \"get\", {\n    value: function(kid, props, local) {\n      // reconcile arguments\n      if (typeof kid === \"boolean\") {\n        local = kid;\n        props = kid = null;\n      } else if (typeof kid === \"object\") {\n        local = props;\n        props = kid;\n        kid = null;\n      }\n\n      // fixup props\n      props = props || {};\n      if (kid) {\n        props.kid = kid;\n      }\n\n      // workaround for issues/109\n      if (props.kid !== undefined && props.kid !== null && typeof props.kid !== \"string\") {\n       props.kid = String(props.kid);\n      }\n\n      var candidates = this.all(props, true);\n      if (!candidates.length && parent && !local) {\n        candidates = parent.get(props, local);\n      }\n      return candidates[0] || null;\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#temp\n   * @description\n   * Creates a temporary KeyStore based on this KeyStore.\n   *\n   * @returns {JWK.KeyStore} The temporary KeyStore.\n   */\n  Object.defineProperty(this, \"temp\", {\n    value: function() {\n      return new JWKStore(registry, this);\n    }\n  });\n\n  /**\n   * @method JWK.KeyStore#toJSON\n   * @description\n   * Generates a JSON representation of this KeyStore, which conforms\n   * to a JWK Set from {I-D.ietf-jose-json-web-key}.\n   *\n   * @param {Boolean} [isPrivate = false] `true` if the private fields\n   *        of stored keys are to be included.\n   * @returns {Object} The JSON representation of this KeyStore.\n   */\n  Object.defineProperty(this, \"toJSON\", {\n    value: function(isPrivate) {\n      var keys = [];\n\n      Object.keys(keysets).forEach(function(kid) {\n        var items = keysets[kid].map(function(k) {\n          return k.toJSON(isPrivate);\n        });\n        keys = keys.concat(items);\n      });\n\n      return {\n        keys: keys\n      };\n    }\n  });\n};\n\n/**\n * Determines if the given object is an instance of JWK.KeyStore.\n *\n * @param {Object} obj The object to test\n * @returns {Boolean} `true` if {obj} is an instance of JWK.KeyStore,\n *          and `false` otherwise.\n */\nJWKStore.isKeyStore = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (\"function\" !== typeof obj.get ||\n      \"function\" !== typeof obj.all ||\n      \"function\" !== typeof obj.generate ||\n      \"function\" !== typeof obj.add ||\n      \"function\" !== typeof obj.remove) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new empty KeyStore.\n *\n * @returns {JWK.KeyStore} The empty KeyStore.\n */\nJWKStore.createKeyStore = function() {\n  return new JWKStore(GLOBAL_REGISTRY);\n};\n\n/**\n * Coerces the given object into a KeyStore. This method uses the following\n * algorithm to coerce {ks}:\n *\n * 1. if {ks} is an instance of JWK.KeyStore, it is returned directly\n * 2. if {ks} is a string, it is parsed into a JSON value\n * 3. if {ks} is an array, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the {ks} array.\n * 4. if {ks} is a JSON object, it creates a new JWK.KeyStore and calls {@link\n *    JWK.KeyStore#add} for each element in the \"keys\" property.\n *\n * @param {Object|String} ks The value to coerce into a\n *        KeyStore\n * @returns {Promise(JWK.KeyStore)} A promise for the coerced KeyStore.\n */\nJWKStore.asKeyStore = function(ks) {\n  if (JWKStore.isKeyStore(ks)) {\n    return Promise.resolve(ks);\n  }\n\n  var store = JWKStore.createKeyStore(),\n      keys;\n\n  if (typeof ks === \"string\") {\n    ks = JSON.parse(ks);\n  }\n\n  if (Array.isArray(ks)) {\n    keys = ks;\n  } else if (\"keys\" in ks) {\n    keys = ks.keys;\n  } else {\n    return Promise.reject(new Error(\"invalid keystore\"));\n  }\n\n  keys = keys.map(function(k) {\n    return store.add(k);\n  });\n\n  var promise = Promise.all(keys);\n  promise = promise.then(function() {\n    return store;\n  });\n\n  return promise;\n};\n\n\n/**\n * Determines if the given object is a JWK.Key instance.\n *\n * @param {Object} obj The object to test\n * @returns `true` if {obj} is a JWK.Key\n */\nJWKStore.isKey = function(obj) {\n  if (!obj) {\n    return false;\n  }\n\n  if (\"object\" !== typeof obj) {\n    return false;\n  }\n\n  if (!JWKStore.isKeyStore(obj.keystore)) {\n    return false;\n  }\n\n  if (\"string\" !== typeof obj.kty ||\n      \"number\" !== typeof obj.length ||\n      \"function\" !== typeof obj.algorithms ||\n      \"function\" !== typeof obj.supports ||\n      \"function\" !== typeof obj.encrypt ||\n      \"function\" !== typeof obj.decrypt ||\n      \"function\" !== typeof obj.wrap ||\n      \"function\" !== typeof obj.unwrap ||\n      \"function\" !== typeof obj.sign ||\n      \"function\" !== typeof obj.verify) {\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Creates a new key with the given properties.  This method is a convenience\n * to calling `JWK.createKeyStore()` then `generate()` on the returned keystore.\n *\n * @param {String} kty The type of generated key\n * @param {String|Number} [size] The size of the generated key\n * @param {Object} [props] Additional properties to apply to the generated\n *        key.\n * @returns {Promise} The promise for the generated Key\n * @throws {Error} If {kty} is not supported\n * @see JWKStore#generate\n */\nJWKStore.createKey = function(kty, size, props) {\n  var ks = JWKStore.createKeyStore();\n  return ks.generate(kty, size, props);\n}\n\n/**\n * Coerces the given object into a Key. If {key} is an instance of JWK.Key,\n * it is returned directly. Otherwise, this method first creates a new\n * JWK.KeyStore and calls {@link JWK.KeyStore#add} on this new KeyStore.\n *\n * @param {Object|String} key The value to coerce into a Key\n * @param {String} [form] The format of a String Key to expect\n * @param {Object} [extras] extra jwk fields inserted when importing from a non json string (eg \"pem\")\n * @returns {Promise(JWK.Key)} A promise for the coerced Key.\n */\nJWKStore.asKey = function(key, form, extras) {\n  if (JWKStore.isKey(key)) {\n    return Promise.resolve(key);\n  }\n\n  var ks = JWKStore.createKeyStore();\n  key = ks.add(key, form, extras);\n\n  return key;\n};\n\nmodule.exports = {\n  KeyRegistry: JWKRegistry,\n  KeyStore: JWKStore,\n  registry: GLOBAL_REGISTRY\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2sva2V5c3RvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxZQUFZLG1CQUFPLENBQUMsdUVBQWU7QUFDbkMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUzs7QUFFNUI7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTSx5QkFBeUIsSUFBSTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFNBQVM7QUFDeEIsY0FBYyxPQUFPLElBQUksS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQywwQ0FBMEMsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsSUFBSTtBQUN6RDtBQUNBLE1BQU0sb0JBQW9CO0FBQzFCLGVBQWUsSUFBSSxNQUFNLEtBQUs7QUFDOUI7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxrQkFBa0IsS0FBSyxLQUFLLE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTLFdBQVcsS0FBSztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSTtBQUNkLFVBQVUsSUFBSSxzREFBc0Q7QUFDcEUsd0JBQXdCLHlCQUF5QixJQUFJO0FBQ3JELFVBQVUsSUFBSSwyREFBMkQ7QUFDekUsd0JBQXdCO0FBQ3hCO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFNBQVM7QUFDdEIsWUFBWSxPQUFPLElBQUksS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBLDJCQUEyQix3QkFBd0I7QUFDbkQ7QUFDQSxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL2tleXN0b3JlLmpzP2UwMDIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd2sva2V5c3RvcmUuanMgLSBKV0sgS2V5U3RvcmUgSW1wbGVtZW50YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpLFxuICAgIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuXG52YXIgSldLID0ge1xuICBCYXNlS2V5OiByZXF1aXJlKFwiLi9iYXNla2V5LmpzXCIpLFxuICBoZWxwZXJzOiByZXF1aXJlKFwiLi9oZWxwZXJzLmpzXCIpXG59O1xuXG4vKipcbiAqIEBjbGFzcyBKV0suS2V5U3RvcmVSZWdpc3RyeVxuICogQGNsYXNzZGVzY1xuICogQSByZWdpc3RyeSBvZiBKV0suS2V5IHR5cGVzIHRoYXQgY2FuIGJlIHVzZWQuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiAqKk5PVEU6KiogVGhpcyBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSB0aGVcbiAqIGdsb2JhbCB7SldLLnJlZ2lzdHJ5fVxuICovXG52YXIgSldLUmVnaXN0cnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGVzID0ge307XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVnaXN0ZXJcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICBpZiAoIWZhY3RvcnkgfHwgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGZhY3Rvcnkua3R5IHx8ICFmYWN0b3J5Lmt0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEtleSBmYWN0b3J5XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga3R5ID0gZmFjdG9yeS5rdHk7XG4gICAgICB0eXBlc1trdHldID0gZmFjdG9yeTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInVucmVnaXN0ZXJcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgICBpZiAoIWZhY3RvcnkgfHwgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIGZhY3Rvcnkua3R5IHx8ICFmYWN0b3J5Lmt0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIEtleSBmYWN0b3J5XCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIga3R5ID0gZmFjdG9yeS5rdHk7XG4gICAgICBpZiAoZmFjdG9yeSA9PT0gdHlwZXNba3R5XSkge1xuICAgICAgICBkZWxldGUgdHlwZXNba3R5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oa3R5KSB7XG4gICAgICByZXR1cm4gdHlwZXNba3R5IHx8IFwiXCJdIHx8IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGxcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0eXBlcykubWFwKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHR5cGVzW3RdOyB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuLy8gR2xvYmFsc1xudmFyIEdMT0JBTF9SRUdJU1RSWSA9IG5ldyBKV0tSZWdpc3RyeSgpO1xuXG4vLyBpbXBvcnRlclxuZnVuY3Rpb24gcHJvY2Vzc0NlcnQoaW5wdXQpIHtcbiAgLy8gY29udmVydCBjZXJ0SXNzdWVyIHRvIHJlYWRhYmxlIGF0dHJpYnV0ZXNcbiAgW1wiY2VydElzc3VlclwiLCBcImNlcnRTdWJqZWN0XCJdLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcbiAgICAvKiBlc2xpbnQgbmV3LWNhcDogWzBdICovXG4gICAgdmFyIGF0dHJzID0gZm9yZ2UucGtpLlJETkF0dHJpYnV0ZXNBc0FycmF5KGlucHV0W2ZpZWxkXSk7XG4gICAgdmFyIHJlc3VsdCA9IGlucHV0W2ZpZWxkXSA9IHt9O1xuICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgICAgcmVzdWx0W2EubmFtZSB8fCBhLnR5cGVdID0gYS52YWx1ZTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGlucHV0O1xufVxuXG5mdW5jdGlvbiBmcm9tUEVNKGlucHV0KSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIHBlbXMgPSBmb3JnZS5wZW0uZGVjb2RlKGlucHV0KTtcbiAgdmFyIGZvdW5kID0gcGVtcy5zb21lKGZ1bmN0aW9uKHApIHtcbiAgICBzd2l0Y2ggKHAudHlwZSkge1xuICAgICAgY2FzZSBcIkNFUlRJRklDQVRFXCI6XG4gICAgICAgIHJlc3VsdC5mb3JtID0gXCJwa2l4XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIlBVQkxJQyBLRVlcIjpcbiAgICAgICAgcmVzdWx0LmZvcm0gPSBcInNwa2lcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiUFJJVkFURSBLRVlcIjpcbiAgICAgICAgcmVzdWx0LmZvcm0gPSBcInBrY3M4XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkVDIFBSSVZBVEUgS0VZXCI6XG4gICAgICAgIC8qIGVzbGludCBuby1mYWxsdGhyb3VnaDogWzBdICovXG4gICAgICBjYXNlIFwiUlNBIFBSSVZBVEUgS0VZXCI6XG4gICAgICAgIHJlc3VsdC5mb3JtID0gXCJwcml2YXRlXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJlc3VsdC5ib2R5ID0gcC5ib2R5O1xuICAgIHJldHVybiB0cnVlO1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInN1cHBvcnRlZCBQRU0gdHlwZSBub3QgZm91bmRcIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGltcG9ydEZyb20ocmVnaXN0cnksIGlucHV0KSB7XG4gIC8vIGZvcm0gY2FuIGJlIG9uZSBvZjpcbiAgLy8gICdwcml2YXRlJyB8ICdwa2NzOCcgfCAncHVibGljJyB8ICdzcGtpJyB8ICdwa2l4JyB8ICd4NTA5J1xuICB2YXIgY2FwdHVyZSA9IHt9LFxuICAgICAgZXJyb3JzID0gW10sXG4gICAgICByZXN1bHQ7XG5cbiAgLy8gY29udmVyIGZyb20gREVSIHRvIEFTTjFcbiAgdmFyIGZvcm0gPSBpbnB1dC5mb3JtLFxuICAgICAgZGVyID0gaW5wdXQuYm9keSxcbiAgICAgIHRodW1icHJpbnQgPSBudWxsO1xuICBpbnB1dCA9IGZvcmdlLmFzbjEuZnJvbURlcihkZXIpO1xuICBzd2l0Y2goZm9ybSkge1xuICAgIGNhc2UgXCJwcml2YXRlXCI6XG4gICAgICByZWdpc3RyeS5hbGwoKS5zb21lKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZhY3RvcnkudmFsaWRhdG9ycykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvaWQgPSBmYWN0b3J5LnZhbGlkYXRvcnMub2lkLFxuICAgICAgICAgICAgdmFsaWRhdG9yID0gZmFjdG9yeS52YWxpZGF0b3JzLnByaXZhdGVLZXk7XG4gICAgICAgIGlmICghdmFsaWRhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNhcHR1cmUgPSB7fTtcbiAgICAgICAgZXJyb3JzID0gW107XG4gICAgICAgIHJlc3VsdCA9IGZvcmdlLmFzbjEudmFsaWRhdGUoaW5wdXQsIHZhbGlkYXRvciwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIGNhcHR1cmUua2V5T2lkID0gZm9yZ2UuYXNuMS5vaWRUb0RlcihvaWQpO1xuICAgICAgICAgIGNhcHR1cmUucGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSk7XG4gICAgICBjYXB0dXJlLnR5cGUgPSBcInByaXZhdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwa2NzOFwiOlxuICAgICAgcmVzdWx0ID0gZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dCwgSldLLmhlbHBlcnMudmFsaWRhdG9ycy5wcml2YXRlS2V5LCBjYXB0dXJlLCBlcnJvcnMpO1xuICAgICAgY2FwdHVyZS50eXBlID0gXCJwcml2YXRlXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAvLyBlc2xpbnQgbm8tZmFsbHRocm91Z2g6IFswXSAqL1xuICAgIGNhc2UgXCJzcGtpXCI6XG4gICAgICByZXN1bHQgPSBmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LCBKV0suaGVscGVycy52YWxpZGF0b3JzLnB1YmxpY0tleSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgIGNhcHR1cmUudHlwZSA9IFwicHVibGljXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicGtpeFwiOlxuICAgICAgLyogZXNsaW50IG5vLWZhbGx0aHJvdWdoOiBbMF0gKi9cbiAgICBjYXNlIFwieDUwOVwiOlxuICAgICAgcmVzdWx0ID0gZm9yZ2UuYXNuMS52YWxpZGF0ZShpbnB1dCwgSldLLmhlbHBlcnMudmFsaWRhdG9ycy5jZXJ0aWZpY2F0ZSwgY2FwdHVyZSwgZXJyb3JzKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgY2FwdHVyZSA9IHByb2Nlc3NDZXJ0KGNhcHR1cmUpO1xuICAgICAgICB2YXIgbWQgPSBmb3JnZS5tZC5zaGExLmNyZWF0ZSgpO1xuICAgICAgICBtZC51cGRhdGUoZGVyKTtcbiAgICAgICAgdGh1bWJwcmludCA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShCdWZmZXIuZnJvbShtZC5kaWdlc3QoKS50b0hleCgpLCBcImhleFwiKSk7XG4gICAgICB9XG4gICAgICBjYXB0dXJlLnR5cGUgPSBcInB1YmxpY1wiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaWYgKCFyZXN1bHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGNvbnZlcnQgb2lkc1xuICBpZiAoY2FwdHVyZS5rZXlPaWQpIHtcbiAgICBjYXB0dXJlLmtleU9pZCA9IGZvcmdlLmFzbjEuZGVyVG9PaWQoY2FwdHVyZS5rZXlPaWQpO1xuICB9XG5cbiAgLy8gZmluZCBhbmQgaW52b2tlIHRoZSBpbXBvcnRlclxuICByZXN1bHQgPSBudWxsO1xuICBHTE9CQUxfUkVHSVNUUlkuYWxsKCkuZm9yRWFjaChmdW5jdGlvbihmYWN0b3J5KSB7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGZhY3RvcnkuaW1wb3J0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc3VsdCA9IGZhY3RvcnkuaW1wb3J0KGNhcHR1cmUpO1xuICB9KTtcbiAgaWYgKHJlc3VsdCAmJiBjYXB0dXJlLmNlcnRTdWJqZWN0ICYmIGNhcHR1cmUuY2VydFN1YmplY3QuY29tbW9uTmFtZSkge1xuICAgIHJlc3VsdC5raWQgPSBjYXB0dXJlLmNlcnRTdWJqZWN0LmNvbW1vbk5hbWU7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiB0aHVtYnByaW50KSB7XG4gICAgcmVzdWx0Lng1dCA9IHRodW1icHJpbnQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBAY2xhc3MgSldLLktleVN0b3JlXG4gKiBAY2xhc3NkZXNjXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBLZXlzLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIFRoaXMgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsIHtAbGlua1xuICogSldLLmNyZWF0ZUtleVN0b3JlfS5cbiAqL1xudmFyIEpXS1N0b3JlID0gZnVuY3Rpb24ocmVnaXN0cnksIHBhcmVudCkge1xuICB2YXIga2V5c2V0cyA9IHt9O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSNnZW5lcmF0ZVxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2VuZXJhdGVzIGEgbmV3IHJhbmRvbSBLZXkgaW50byB0aGlzIEtleVN0b3JlLlxuICAgKlxuICAgKiBUaGUgdHlwZSBvZiB7c2l6ZX0gZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2Yge2t0eX06XG4gICAqXG4gICAqICsgKipgRUNgKio6IFN0cmluZyBuYW1pbmcgdGhlIGN1cnZlIHRvIHVzZSwgd2hpY2ggY2FuIGJlIG9uZSBvZjpcbiAgICogICBgXCJQLTI1NlwiYCwgYFwiUC0zODRcImAsIG9yIGBcIlAtNTIxXCJgIChkZWZhdWx0IGlzICoqYFwiUC0yNTZcImAqKikuXG4gICAqICsgKipgUlNBYCoqOiBOdW1iZXIgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0aGUga2V5LCBpbiBiaXRzIChkZWZhdWx0IGlzXG4gICAqICAgKipgMjA0OGAqKikuXG4gICAqICsgKipgb2N0YCoqOiBOdW1iZXIgZGVzY3JpYmluZyB0aGUgc2l6ZSBvZiB0aGUga2V5LCBpbiBiaXRzIChkZWZhdWx0IGlzXG4gICAqICAgKipgMjU2YCoqKS5cbiAgICpcbiAgICogQW55IHByb3BlcnRpZXMgaW4ge3Byb3BzfSBhcmUgYXBwbGllZCBiZWZvcmUgdGhlIGtleSBpcyBnZW5lcmF0ZWQsXG4gICAqIGFuZCBhcmUgZXhwZWN0ZWQgdG8gYmUgZGF0YSB0eXBlcyBhY2NlcHRhYmxlIGluIEpTT04uICBUaGlzIGFsbG93cyB0aGVcbiAgICogZ2VuZXJhdGVkIGtleSB0byBoYXZlIGEgc3BlY2lmaWMga2V5IGlkZW50aWZpZXIsIG9yIHRvIHNwZWNpZnkgaXRzXG4gICAqIGFjY2VwdGFibGUgdXNhZ2UuXG4gICAqXG4gICAqIFRoZSByZXR1cm5lZCBQcm9taXNlLCB3aGVuIGZ1bGZpbGxlZCwgcmV0dXJucyB0aGUgZ2VuZXJhdGVkIEtleS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGt0eSBUaGUgdHlwZSBvZiBnZW5lcmF0ZWQga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhcHBseSB0byB0aGUgZ2VuZXJhdGVkXG4gICAqICAgICAgICBrZXkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGdlbmVyYXRlZCBLZXlcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHtrdHl9IGlzIG5vdCBzdXBwb3J0ZWRcbiAgICovXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdlbmVyYXRlXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oa3R5LCBzaXplLCBwcm9wcykge1xuICAgICAgdmFyIGtleXR5cGUgPSByZWdpc3RyeS5nZXQoa3R5KTtcbiAgICAgIGlmICgha2V5dHlwZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwidW5zdXBwb3J0ZWQga2V5IHR5cGVcIikpO1xuICAgICAgfVxuXG4gICAgICBwcm9wcyA9IGNsb25lKHByb3BzIHx8IHt9KTtcbiAgICAgIHByb3BzLmt0eSA9IGt0eTtcblxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIHByb21pc2UgPSBrZXl0eXBlLmdlbmVyYXRlKHNpemUpO1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihqd2spIHtcbiAgICAgICAgandrID0gbWVyZ2UocHJvcHMsIGp3aywge1xuICAgICAgICAgIGt0eToga3R5XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZi5hZGQoandrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgKiBAbWV0aG9kIEpXSy5LZXlTdG9yZSNhZGRcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEFkZHMgYSBLZXkgdG8gdGhpcyBLZXlTdG9yZS4gSWYge2p3a30gaXMgYSBzdHJpbmcsIGl0IGlzIGZpcnN0XG4gICAqIHBhcnNlZCBpbnRvIGEgcGxhaW4gSlNPTiBvYmplY3QuIElmIHtqd2t9IGlzIGFscmVhZHkgYW4gaW5zdGFuY2VcbiAgICogb2YgSldLLktleSwgaXRzIChwdWJsaWMpIEpTT04gcmVwcmVzZW50YXRpb24gaXMgZmlyc3Qgb2J0YWluZWRcbiAgICogdGhlbiBhcHBsaWVkIHRvIGEgbmV3IEpXSy5LZXkgb2JqZWN0IHdpdGhpbiB0aGlzIEtleVN0b3JlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGp3ayBUaGUgSlNPTiBXZWIgS2V5IChKV0spXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9ybV0gVGhlIGZvcm1hdCBvZiBhIFN0cmluZyBrZXkgdG8gZXhwZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbZXh0cmFzXSBleHRyYSBqd2sgZmllbGRzIGluc2VydGVkIHdoZW4gaW1wb3J0aW5nIGZyb20gYSBub24ganNvbiBzdHJpbmcgKGVnIFwicGVtXCIpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGFkZGVkIGtleVxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiYWRkXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oandrLCBmb3JtLCBleHRyYXMpIHtcbiAgICAgIGV4dHJhcyA9IGV4dHJhcyB8fCB7fTtcblxuICAgICAgdmFyIGZhY3RvcnM7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGp3aykgfHwgdHlwZW9mIGp3ayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBmb3JtIGNhbiBiZSAnanNvbicsICdwa2NzOCcsICdzcGtpJywgJ3BraXgnLCAneDUwOScsICdwZW0nXG4gICAgICAgIGZvcm0gPSAoZm9ybSB8fCBcImpzb25cIikudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKFwianNvblwiID09PSBmb3JtKSB7XG4gICAgICAgICAgandrID0gSlNPTi5wYXJzZShqd2sudG9TdHJpbmcoXCJ1dGY4XCIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKFwicGVtXCIgPT09IGZvcm0pIHtcbiAgICAgICAgICAgICAgLy8gY29udmVydCAqZmlyc3QqIFBFTSAtPiBERVJcbiAgICAgICAgICAgICAgZmFjdG9ycyA9IGZyb21QRU0oandrKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZhY3RvcnMgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogandrLnRvU3RyaW5nKFwiYmluYXJ5XCIpLFxuICAgICAgICAgICAgICAgIGZvcm06IGZvcm1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGp3ayA9IGltcG9ydEZyb20ocmVnaXN0cnksIGZhY3RvcnMpO1xuICAgICAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gaW1wb3J0ZXIgZm9yIGtleVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4dHJhcykuZm9yRWFjaChmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgICAgICAgIGp3a1tmaWVsZF0gPSBleHRyYXNbZmllbGRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoSldLU3RvcmUuaXNLZXkoandrKSkge1xuICAgICAgICAvLyBhc3N1bWUgYSBjb21wbGV0ZSBkdXBsaWNhdGUgaXMgZGVzaXJlZFxuICAgICAgICBqd2sgPSBqd2sudG9KU09OKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgandrID0gY2xvbmUoandrKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXR5cGUgPSByZWdpc3RyeS5nZXQoandrLmt0eSk7XG4gICAgICBpZiAoIWtleXR5cGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleSB0eXBlXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICAgIHByb21pc2UgPSBrZXl0eXBlLnByZXBhcmUoandrKTtcbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oY2ZnKSB7XG4gICAgICAgIHJldHVybiBuZXcgSldLLkJhc2VLZXkoandrLmt0eSwgc2VsZiwgandrLCBjZmcpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbihqd2spIHtcbiAgICAgICAgdmFyIGtpZCA9IGp3ay5raWQgfHwgXCJcIjtcbiAgICAgICAgdmFyIGtleXMgPSBrZXlzZXRzW2tpZF0gPSBrZXlzZXRzW2tpZF0gfHwgW107XG4gICAgICAgIGtleXMucHVzaChqd2spO1xuXG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjcmVtb3ZlXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZW1vdmVzIGEgS2V5IGZyb20gdGhpcyBLZXlTdG9yZS5cbiAgICpcbiAgICogKipOT1RFOioqIFRoZSByZW1vdmVkIEtleSdzIHtrZXlzdG9yZX0gcHJvcGVydHkgaXMgbm90IGNoYW5nZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SldLLktleX0gandrIFRoZSBrZXkgdG8gcmVtb3ZlLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicmVtb3ZlXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oandrKSB7XG4gICAgICBpZiAoIWp3aykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBrZXlzID0ga2V5c2V0c1tqd2sua2lkXTtcbiAgICAgIGlmICgha2V5cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3MgPSBrZXlzLmluZGV4T2YoandrKTtcbiAgICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAga2V5cy5zcGxpY2UocG9zLCAxKTtcbiAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgZGVsZXRlIGtleXNldHNbandrLmtpZF07XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjYWxsXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjb250YWluZWQgS2V5cyB0aGF0IG9wdGluYWxseSBtYXRjaCBhbGwgb2YgdGhlXG4gICAqIGdpdmVuIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIElmIHtwcm9wc30gYXJlIHNwZWNpZmllZCwgdGhpcyBtZXRob2Qgb25seSByZXR1cm5zIEtleXMgd2hpY2ggZXhhY3RseVxuICAgKiBtYXRjaCB0aGUgZ2l2ZW4gcHJvcGVydGllcy4gVGhlIHByb3BlcnRpZXMgY2FuIGJlIGFueSBvZiB0aGVcbiAgICogZm9sbG93aW5nOlxuICAgKlxuICAgKiArICoqYWxnKio6IFRoZSBhbGdvcml0aG0gZm9yIHRoZSBLZXkuXG4gICAqICsgKip1c2UqKjogVGhlIHVzYWdlIGZvciB0aGUgS2V5LlxuICAgKiArICoqa2lkKio6IFRoZSBpZGVudGlmaWVyIGZvciB0aGUgS2V5LlxuICAgKlxuICAgKiBJZiBubyBwcm9wZXJ0aWVzIGFyZSBnaXZlbiwgdGhpcyBtZXRob2QgcmV0dXJucyBhbGwgb2YgdGhlIEtleXMgZm9yIHRoaXNcbiAgICogS2V5U3RvcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIHRvIG1hdGNoIGFnYWluc3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbG9jYWwgPSBmYWxzZV0gYHRydWVgIGlmIG9ubHkgdGhlIEtleXNcbiAgICogICAgICAgIGRpcmVjdGx5IGNvbnRhaW5lZCBieSB0aGlzIEtleVN0b3JlIHNob3VsZCBiZSByZXR1cm5lZCwgb3JcbiAgICogICAgICAgIGBmYWxzZWAgaWYgaXQgc2hvdWxkIHJldHVybiBhbGwgS2V5cyBvZiB0aGlzIEtleVN0b3JlIGFuZFxuICAgKiAgICAgICAgaXRzIGFuY2VzdG9ycy5cbiAgICogQHJldHVybnMge0pXSy5LZXlbXX0gVGhlIGxpc3Qgb2YgbWF0Y2hpbmcgS2V5cywgb3IgYW4gZW1wdHkgYXJyYXkgaWYgbm9cbiAgICogICAgICAgICAgbWF0Y2hlcyBhcmUgZm91bmQuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJhbGxcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihwcm9wcywgbG9jYWwpIHtcbiAgICAgIHByb3BzID0gcHJvcHMgfHwge307XG5cbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIGlzc3Vlcy8xMDlcbiAgICAgIGlmIChwcm9wcy5raWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5raWQgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmtpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwcm9wcy5raWQgPSBTdHJpbmcocHJvcHMua2lkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgICAgIHZhciBtYXRjaGVzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIC8vIG1hdGNoIG9uICdrdHknXG4gICAgICAgIGlmIChwcm9wcy5rdHkgJiZcbiAgICAgICAgICAgIGtleS5rdHkgJiZcbiAgICAgICAgICAgIHByb3BzLmt0eSAhPT0ga2V5Lmt0eSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXRjaCBvbiAndXNlJ1xuICAgICAgICBpZiAocHJvcHMudXNlICYmXG4gICAgICAgICAgICBrZXkudXNlICYmXG4gICAgICAgICAgICBwcm9wcy51c2UgIT09IGtleS51c2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWF0Y2ggb24gJ2FsZydcbiAgICAgICAgaWYgKHByb3BzLmFsZykge1xuICAgICAgICAgIGlmIChwcm9wcy5hbGcgIT09IFwiZGlyXCIgJiZcbiAgICAgICAgICAgICAga2V5LmFsZyAmJlxuICAgICAgICAgICAgICBwcm9wcy5hbGcgIT09IGtleS5hbGcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGtleS5zdXBwb3J0cyhwcm9wcy5hbGcpO1xuICAgICAgICB9XG4gICAgICAgIC8vVE9ETzogbWF0Y2ggb24gJ2tleV9vcHMnXG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgT2JqZWN0LmtleXMoa2V5c2V0cykuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgICAgICBpZiAocHJvcHMua2lkICYmIHByb3BzLmtpZCAhPT0gaWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIga2V5cyA9IGtleXNldHNbaWRdLmZpbHRlcihtYXRjaGVzKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuY29uY2F0KGtleXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFsb2NhbCAmJiBwYXJlbnQpIHtcbiAgICAgICAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuY29uY2F0KHBhcmVudC5hbGwocHJvcHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZXM7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICAqIEBtZXRob2QgSldLLktleVN0b3JlI2dldFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogUmV0cmlldmVzIHRoZSBjb250YWluZWQgS2V5IG1hdGNoaW5nIHRoZSBnaXZlbiB7a2lkfSwgYW5kIG9wdGlvbmFsbHlcbiAgICogYWxsIG9mIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLiAgVGhpcyBtZXRob2QgZXF1aXZhbGVudCB0byBjYWxsaW5nXG4gICAqIHtAbGluayBKV0suU3RvcmUjYWxsfSwgdGhlbiByZXR1cm5pbmcgdGhlIGZpcnN0IEtleSB3aG9zZVxuICAgKiBcImtpZFwiIGlzIHtraWR9LiBJZiB7a2lkfSBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIGZpcnN0IEtleSB0aGF0XG4gICAqIGlzIHJldHVybmVkIGZyb20gYGFsbCgpYCBpcyByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtraWRdIFRoZSBrZXkgaWRlbnRpZmllciB0byBtYXRjaCBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyB0byBtYXRjaCBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtsb2NhbCA9IGZhbHNlXSBgdHJ1ZWAgaWYgb25seSB0aGUgS2V5c1xuICAgKiAgICAgICAgZGlyZWN0bHkgY29udGFpbmVkIGJ5IHRoaXMgS2V5U3RvcmUgc2hvdWxkIGJlIHJldHVybmVkLCBvclxuICAgKiAgICAgICAgYGZhbHNlYCBpZiBpdCBzaG91bGQgcmV0dXJuIGFsbCBLZXlzIG9mIHRoaXMgS2V5U3RvcmUgYW5kXG4gICAqICAgICAgICBpdHMgYW5jZXN0b3JzLlxuICAgKiBAcmV0dXJucyB7SldLLktleX0gVGhlIEtleSBtYXRjaGluZyB7a2lkfSBhbmQge3Byb3BzfSwgb3IgYG51bGxgXG4gICAqICAgICAgICAgIGlmIG5vIG1hdGNoIGlzIGZvdW5kLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oa2lkLCBwcm9wcywgbG9jYWwpIHtcbiAgICAgIC8vIHJlY29uY2lsZSBhcmd1bWVudHNcbiAgICAgIGlmICh0eXBlb2Yga2lkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBsb2NhbCA9IGtpZDtcbiAgICAgICAgcHJvcHMgPSBraWQgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Yga2lkID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxvY2FsID0gcHJvcHM7XG4gICAgICAgIHByb3BzID0ga2lkO1xuICAgICAgICBraWQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXh1cCBwcm9wc1xuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgIGlmIChraWQpIHtcbiAgICAgICAgcHJvcHMua2lkID0ga2lkO1xuICAgICAgfVxuXG4gICAgICAvLyB3b3JrYXJvdW5kIGZvciBpc3N1ZXMvMTA5XG4gICAgICBpZiAocHJvcHMua2lkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMua2lkICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5raWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICBwcm9wcy5raWQgPSBTdHJpbmcocHJvcHMua2lkKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhbmRpZGF0ZXMgPSB0aGlzLmFsbChwcm9wcywgdHJ1ZSk7XG4gICAgICBpZiAoIWNhbmRpZGF0ZXMubGVuZ3RoICYmIHBhcmVudCAmJiAhbG9jYWwpIHtcbiAgICAgICAgY2FuZGlkYXRlcyA9IHBhcmVudC5nZXQocHJvcHMsIGxvY2FsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGVzWzBdIHx8IG51bGw7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjdGVtcFxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogQ3JlYXRlcyBhIHRlbXBvcmFyeSBLZXlTdG9yZSBiYXNlZCBvbiB0aGlzIEtleVN0b3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7SldLLktleVN0b3JlfSBUaGUgdGVtcG9yYXJ5IEtleVN0b3JlLlxuICAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidGVtcFwiLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBKV0tTdG9yZShyZWdpc3RyeSwgdGhpcyk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG1ldGhvZCBKV0suS2V5U3RvcmUjdG9KU09OXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBHZW5lcmF0ZXMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgS2V5U3RvcmUsIHdoaWNoIGNvbmZvcm1zXG4gICAqIHRvIGEgSldLIFNldCBmcm9tIHtJLUQuaWV0Zi1qb3NlLWpzb24td2ViLWtleX0uXG4gICAqXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUHJpdmF0ZSA9IGZhbHNlXSBgdHJ1ZWAgaWYgdGhlIHByaXZhdGUgZmllbGRzXG4gICAqICAgICAgICBvZiBzdG9yZWQga2V5cyBhcmUgdG8gYmUgaW5jbHVkZWQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgS2V5U3RvcmUuXG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0b0pTT05cIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihpc1ByaXZhdGUpIHtcbiAgICAgIHZhciBrZXlzID0gW107XG5cbiAgICAgIE9iamVjdC5rZXlzKGtleXNldHMpLmZvckVhY2goZnVuY3Rpb24oa2lkKSB7XG4gICAgICAgIHZhciBpdGVtcyA9IGtleXNldHNba2lkXS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgICAgIHJldHVybiBrLnRvSlNPTihpc1ByaXZhdGUpO1xuICAgICAgICB9KTtcbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGl0ZW1zKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlzOiBrZXlzXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBKV0suS2V5U3RvcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHRlc3RcbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYge29ian0gaXMgYW4gaW5zdGFuY2Ugb2YgSldLLktleVN0b3JlLFxuICogICAgICAgICAgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5KV0tTdG9yZS5pc0tleVN0b3JlID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmICghb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmopIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmdldCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmFsbCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmdlbmVyYXRlIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouYWRkIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmoucmVtb3ZlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZW1wdHkgS2V5U3RvcmUuXG4gKlxuICogQHJldHVybnMge0pXSy5LZXlTdG9yZX0gVGhlIGVtcHR5IEtleVN0b3JlLlxuICovXG5KV0tTdG9yZS5jcmVhdGVLZXlTdG9yZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEpXS1N0b3JlKEdMT0JBTF9SRUdJU1RSWSk7XG59O1xuXG4vKipcbiAqIENvZXJjZXMgdGhlIGdpdmVuIG9iamVjdCBpbnRvIGEgS2V5U3RvcmUuIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGZvbGxvd2luZ1xuICogYWxnb3JpdGhtIHRvIGNvZXJjZSB7a3N9OlxuICpcbiAqIDEuIGlmIHtrc30gaXMgYW4gaW5zdGFuY2Ugb2YgSldLLktleVN0b3JlLCBpdCBpcyByZXR1cm5lZCBkaXJlY3RseVxuICogMi4gaWYge2tzfSBpcyBhIHN0cmluZywgaXQgaXMgcGFyc2VkIGludG8gYSBKU09OIHZhbHVlXG4gKiAzLiBpZiB7a3N9IGlzIGFuIGFycmF5LCBpdCBjcmVhdGVzIGEgbmV3IEpXSy5LZXlTdG9yZSBhbmQgY2FsbHMge0BsaW5rXG4gKiAgICBKV0suS2V5U3RvcmUjYWRkfSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSB7a3N9IGFycmF5LlxuICogNC4gaWYge2tzfSBpcyBhIEpTT04gb2JqZWN0LCBpdCBjcmVhdGVzIGEgbmV3IEpXSy5LZXlTdG9yZSBhbmQgY2FsbHMge0BsaW5rXG4gKiAgICBKV0suS2V5U3RvcmUjYWRkfSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBcImtleXNcIiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGtzIFRoZSB2YWx1ZSB0byBjb2VyY2UgaW50byBhXG4gKiAgICAgICAgS2V5U3RvcmVcbiAqIEByZXR1cm5zIHtQcm9taXNlKEpXSy5LZXlTdG9yZSl9IEEgcHJvbWlzZSBmb3IgdGhlIGNvZXJjZWQgS2V5U3RvcmUuXG4gKi9cbkpXS1N0b3JlLmFzS2V5U3RvcmUgPSBmdW5jdGlvbihrcykge1xuICBpZiAoSldLU3RvcmUuaXNLZXlTdG9yZShrcykpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtzKTtcbiAgfVxuXG4gIHZhciBzdG9yZSA9IEpXS1N0b3JlLmNyZWF0ZUtleVN0b3JlKCksXG4gICAgICBrZXlzO1xuXG4gIGlmICh0eXBlb2Yga3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICBrcyA9IEpTT04ucGFyc2Uoa3MpO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoa3MpKSB7XG4gICAga2V5cyA9IGtzO1xuICB9IGVsc2UgaWYgKFwia2V5c1wiIGluIGtzKSB7XG4gICAga2V5cyA9IGtzLmtleXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQga2V5c3RvcmVcIikpO1xuICB9XG5cbiAga2V5cyA9IGtleXMubWFwKGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gc3RvcmUuYWRkKGspO1xuICB9KTtcblxuICB2YXIgcHJvbWlzZSA9IFByb21pc2UuYWxsKGtleXMpO1xuICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzdG9yZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgSldLLktleSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gdGVzdFxuICogQHJldHVybnMgYHRydWVgIGlmIHtvYmp9IGlzIGEgSldLLktleVxuICovXG5KV0tTdG9yZS5pc0tleSA9IGZ1bmN0aW9uKG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChcIm9iamVjdFwiICE9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFKV0tTdG9yZS5pc0tleVN0b3JlKG9iai5rZXlzdG9yZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoXCJzdHJpbmdcIiAhPT0gdHlwZW9mIG9iai5rdHkgfHxcbiAgICAgIFwibnVtYmVyXCIgIT09IHR5cGVvZiBvYmoubGVuZ3RoIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouYWxnb3JpdGhtcyB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnN1cHBvcnRzIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouZW5jcnlwdCB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLmRlY3J5cHQgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIG9iai53cmFwIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmoudW53cmFwIHx8XG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBvYmouc2lnbiB8fFxuICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2Ygb2JqLnZlcmlmeSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGtleSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLiAgVGhpcyBtZXRob2QgaXMgYSBjb252ZW5pZW5jZVxuICogdG8gY2FsbGluZyBgSldLLmNyZWF0ZUtleVN0b3JlKClgIHRoZW4gYGdlbmVyYXRlKClgIG9uIHRoZSByZXR1cm5lZCBrZXlzdG9yZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga3R5IFRoZSB0eXBlIG9mIGdlbmVyYXRlZCBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW3NpemVdIFRoZSBzaXplIG9mIHRoZSBnZW5lcmF0ZWQga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYXBwbHkgdG8gdGhlIGdlbmVyYXRlZFxuICogICAgICAgIGtleS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgcHJvbWlzZSBmb3IgdGhlIGdlbmVyYXRlZCBLZXlcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB7a3R5fSBpcyBub3Qgc3VwcG9ydGVkXG4gKiBAc2VlIEpXS1N0b3JlI2dlbmVyYXRlXG4gKi9cbkpXS1N0b3JlLmNyZWF0ZUtleSA9IGZ1bmN0aW9uKGt0eSwgc2l6ZSwgcHJvcHMpIHtcbiAgdmFyIGtzID0gSldLU3RvcmUuY3JlYXRlS2V5U3RvcmUoKTtcbiAgcmV0dXJuIGtzLmdlbmVyYXRlKGt0eSwgc2l6ZSwgcHJvcHMpO1xufVxuXG4vKipcbiAqIENvZXJjZXMgdGhlIGdpdmVuIG9iamVjdCBpbnRvIGEgS2V5LiBJZiB7a2V5fSBpcyBhbiBpbnN0YW5jZSBvZiBKV0suS2V5LFxuICogaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuIE90aGVyd2lzZSwgdGhpcyBtZXRob2QgZmlyc3QgY3JlYXRlcyBhIG5ld1xuICogSldLLktleVN0b3JlIGFuZCBjYWxscyB7QGxpbmsgSldLLktleVN0b3JlI2FkZH0gb24gdGhpcyBuZXcgS2V5U3RvcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBrZXkgVGhlIHZhbHVlIHRvIGNvZXJjZSBpbnRvIGEgS2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW2Zvcm1dIFRoZSBmb3JtYXQgb2YgYSBTdHJpbmcgS2V5IHRvIGV4cGVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtleHRyYXNdIGV4dHJhIGp3ayBmaWVsZHMgaW5zZXJ0ZWQgd2hlbiBpbXBvcnRpbmcgZnJvbSBhIG5vbiBqc29uIHN0cmluZyAoZWcgXCJwZW1cIilcbiAqIEByZXR1cm5zIHtQcm9taXNlKEpXSy5LZXkpfSBBIHByb21pc2UgZm9yIHRoZSBjb2VyY2VkIEtleS5cbiAqL1xuSldLU3RvcmUuYXNLZXkgPSBmdW5jdGlvbihrZXksIGZvcm0sIGV4dHJhcykge1xuICBpZiAoSldLU3RvcmUuaXNLZXkoa2V5KSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgfVxuXG4gIHZhciBrcyA9IEpXS1N0b3JlLmNyZWF0ZUtleVN0b3JlKCk7XG4gIGtleSA9IGtzLmFkZChrZXksIGZvcm0sIGV4dHJhcyk7XG5cbiAgcmV0dXJuIGtleTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBLZXlSZWdpc3RyeTogSldLUmVnaXN0cnksXG4gIEtleVN0b3JlOiBKV0tTdG9yZSxcbiAgcmVnaXN0cnk6IEdMT0JBTF9SRUdJU1RSWVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/octkey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/octkey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/octkey.js - Symmetric Octet Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\");\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"HS256\",\n  \"HS384\",\n  \"HS512\"\n];\nvar ENC_ALGS = [\n  \"A128GCM\",\n  \"A192GCM\",\n  \"A256GCM\",\n  \"A128CBC-HS256\",\n  \"A192CBC-HS384\",\n  \"A256CBC-HS512\",\n  \"A128CBC+HS256\",\n  \"A192CBC+HS384\",\n  \"A256CBC+HS512\"\n];\nvar WRAP_ALGS = [\n  \"A128KW\",\n  \"A192KW\",\n  \"A256KW\",\n  \"A128GCMKW\",\n  \"A192GCMKW\",\n  \"A256GCMKW\",\n  \"PBES2-HS256+A128KW\",\n  \"PBES2-HS384+A192KW\",\n  \"PBES2-HS512+A256KW\",\n  \"dir\"\n];\n\nfunction adjustDecryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n  if (\"mac\" in props) {\n    props.mac = Buffer.isBuffer(props.mac) ?\n                props.mac :\n                util.base64url.decode(props.mac || \"\");\n  }\n  if (\"tag\" in props) {\n    props.tag = Buffer.isBuffer(props.tag) ?\n                props.tag :\n                util.base64url.decode(props.tag || \"\");\n  }\n\n  return props;\n}\nfunction adjustEncryptProps(alg, props) {\n  if (\"iv\" in props) {\n    props.iv = Buffer.isBuffer(props.iv) ?\n               props.iv :\n               util.base64url.decode(props.iv || \"\");\n  }\n  if (\"adata\" in props) {\n    props.adata = Buffer.isBuffer(props.adata) ?\n                  props.adata :\n                  Buffer.from(props.adata || \"\", \"utf8\");\n  }\n\n  return props;\n}\n\nvar JWKOctetCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"k\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.k) {\n      pk.length = pk.k.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n\n  thumbprint: function(json) {\n    if (json.private) {\n      json = json.private;\n    }\n    var fields;\n    fields = {\n      k: json.k || \"\",\n      kty: \"oct\"\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    var len = keys.private && (keys.private.k.length * 8);\n    var mins = [256, 384, 512];\n\n    if (!len) {\n      return [];\n    }\n    switch (mode) {\n      case \"encrypt\":\n      case \"decrypt\":\n        return ENC_ALGS.filter(function(a) {\n          return (a === (\"A\" + (len / 2) + \"CBC-HS\" + len)) ||\n                 (a === (\"A\" + (len / 2) + \"CBC+HS\" + len)) ||\n                 (a === (\"A\" + len + \"GCM\"));\n        });\n      case \"sign\":\n      case \"verify\":\n        // TODO: allow for HS{less-than-keysize}\n        return SIG_ALGS.filter(function(a) {\n          var result = false;\n          mins.forEach(function(m) {\n            if (m > len) { return; }\n            result = result | (a === (\"HS\" + m));\n          });\n          return result;\n        });\n      case \"wrap\":\n      case \"unwrap\":\n        return WRAP_ALGS.filter(function(a) {\n          return (a === (\"A\" + len + \"KW\")) ||\n                 (a === (\"A\" + len + \"GCMKW\")) ||\n                 (a.indexOf(\"PBES2-\") === 0) ||\n                 (a === \"dir\");\n        });\n    }\n\n    return [];\n  },\n  encryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  encryptProps: adjustEncryptProps,\n\n  decryptKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  decryptProps: adjustDecryptProps,\n\n  wrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  wrapProps: adjustEncryptProps,\n\n  unwrapKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  unwrapProps: adjustDecryptProps,\n\n  signKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.private && keys.private.k;\n  }\n};\n\n// Factory\nvar JWKOctetFactory = {\n  kty: \"oct\",\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKOctetCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var key = util.randomBytes(size / 8);\n\n    return Promise.resolve({\n      k: key\n    });\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKOctetCfg,\n  factory: JWKOctetFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKOctetFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svb2N0a2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsaUVBQVM7O0FBRTVCO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyx1RUFBYztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL29jdGtleS5qcz83NGY2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL29jdGtleS5qcyAtIFN5bW1ldHJpYyBPY3RldCBLZXkgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxudmFyIEpXSyA9IHtcbiAgQmFzZUtleTogcmVxdWlyZShcIi4vYmFzZWtleS5qc1wiKSxcbiAgaGVscGVyczogcmVxdWlyZShcIi4vaGVscGVycy5qc1wiKVxufTtcblxudmFyIFNJR19BTEdTID0gW1xuICBcIkhTMjU2XCIsXG4gIFwiSFMzODRcIixcbiAgXCJIUzUxMlwiXG5dO1xudmFyIEVOQ19BTEdTID0gW1xuICBcIkExMjhHQ01cIixcbiAgXCJBMTkyR0NNXCIsXG4gIFwiQTI1NkdDTVwiLFxuICBcIkExMjhDQkMtSFMyNTZcIixcbiAgXCJBMTkyQ0JDLUhTMzg0XCIsXG4gIFwiQTI1NkNCQy1IUzUxMlwiLFxuICBcIkExMjhDQkMrSFMyNTZcIixcbiAgXCJBMTkyQ0JDK0hTMzg0XCIsXG4gIFwiQTI1NkNCQytIUzUxMlwiXG5dO1xudmFyIFdSQVBfQUxHUyA9IFtcbiAgXCJBMTI4S1dcIixcbiAgXCJBMTkyS1dcIixcbiAgXCJBMjU2S1dcIixcbiAgXCJBMTI4R0NNS1dcIixcbiAgXCJBMTkyR0NNS1dcIixcbiAgXCJBMjU2R0NNS1dcIixcbiAgXCJQQkVTMi1IUzI1NitBMTI4S1dcIixcbiAgXCJQQkVTMi1IUzM4NCtBMTkyS1dcIixcbiAgXCJQQkVTMi1IUzUxMitBMjU2S1dcIixcbiAgXCJkaXJcIlxuXTtcblxuZnVuY3Rpb24gYWRqdXN0RGVjcnlwdFByb3BzKGFsZywgcHJvcHMpIHtcbiAgaWYgKFwiaXZcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLml2ID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLml2KSA/XG4gICAgICAgICAgICAgICBwcm9wcy5pdiA6XG4gICAgICAgICAgICAgICB1dGlsLmJhc2U2NHVybC5kZWNvZGUocHJvcHMuaXYgfHwgXCJcIik7XG4gIH1cbiAgaWYgKFwiYWRhdGFcIiBpbiBwcm9wcykge1xuICAgIHByb3BzLmFkYXRhID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLmFkYXRhKSA/XG4gICAgICAgICAgICAgICAgICBwcm9wcy5hZGF0YSA6XG4gICAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShwcm9wcy5hZGF0YSB8fCBcIlwiLCBcInV0ZjhcIik7XG4gIH1cbiAgaWYgKFwibWFjXCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy5tYWMgPSBCdWZmZXIuaXNCdWZmZXIocHJvcHMubWFjKSA/XG4gICAgICAgICAgICAgICAgcHJvcHMubWFjIDpcbiAgICAgICAgICAgICAgICB1dGlsLmJhc2U2NHVybC5kZWNvZGUocHJvcHMubWFjIHx8IFwiXCIpO1xuICB9XG4gIGlmIChcInRhZ1wiIGluIHByb3BzKSB7XG4gICAgcHJvcHMudGFnID0gQnVmZmVyLmlzQnVmZmVyKHByb3BzLnRhZykgP1xuICAgICAgICAgICAgICAgIHByb3BzLnRhZyA6XG4gICAgICAgICAgICAgICAgdXRpbC5iYXNlNjR1cmwuZGVjb2RlKHByb3BzLnRhZyB8fCBcIlwiKTtcbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGFkanVzdEVuY3J5cHRQcm9wcyhhbGcsIHByb3BzKSB7XG4gIGlmIChcIml2XCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy5pdiA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy5pdikgP1xuICAgICAgICAgICAgICAgcHJvcHMuaXYgOlxuICAgICAgICAgICAgICAgdXRpbC5iYXNlNjR1cmwuZGVjb2RlKHByb3BzLml2IHx8IFwiXCIpO1xuICB9XG4gIGlmIChcImFkYXRhXCIgaW4gcHJvcHMpIHtcbiAgICBwcm9wcy5hZGF0YSA9IEJ1ZmZlci5pc0J1ZmZlcihwcm9wcy5hZGF0YSkgP1xuICAgICAgICAgICAgICAgICAgcHJvcHMuYWRhdGEgOlxuICAgICAgICAgICAgICAgICAgQnVmZmVyLmZyb20ocHJvcHMuYWRhdGEgfHwgXCJcIiwgXCJ1dGY4XCIpO1xuICB9XG5cbiAgcmV0dXJuIHByb3BzO1xufVxuXG52YXIgSldLT2N0ZXRDZmcgPSB7XG4gIHB1YmxpY0tleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgXSk7XG5cbiAgICB2YXIgcGs7XG4gICAgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcblxuICAgIHJldHVybiBwaztcbiAgfSxcbiAgcHJpdmF0ZUtleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgICB7bmFtZTogXCJrXCIsIHR5cGU6IFwiYmluYXJ5XCJ9XG4gICAgXSk7XG5cbiAgICB2YXIgcGs7XG4gICAgcGsgPSBKV0suaGVscGVycy51bnBhY2tQcm9wcyhwcm9wcywgZmllbGRzKTtcbiAgICBpZiAocGsgJiYgcGsuaykge1xuICAgICAgcGsubGVuZ3RoID0gcGsuay5sZW5ndGggKiA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBwayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG5cbiAgdGh1bWJwcmludDogZnVuY3Rpb24oanNvbikge1xuICAgIGlmIChqc29uLnByaXZhdGUpIHtcbiAgICAgIGpzb24gPSBqc29uLnByaXZhdGU7XG4gICAgfVxuICAgIHZhciBmaWVsZHM7XG4gICAgZmllbGRzID0ge1xuICAgICAgazoganNvbi5rIHx8IFwiXCIsXG4gICAgICBrdHk6IFwib2N0XCJcbiAgICB9O1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH0sXG4gIGFsZ29yaXRobXM6IGZ1bmN0aW9uKGtleXMsIG1vZGUpIHtcbiAgICB2YXIgbGVuID0ga2V5cy5wcml2YXRlICYmIChrZXlzLnByaXZhdGUuay5sZW5ndGggKiA4KTtcbiAgICB2YXIgbWlucyA9IFsyNTYsIDM4NCwgNTEyXTtcblxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSBcImVuY3J5cHRcIjpcbiAgICAgIGNhc2UgXCJkZWNyeXB0XCI6XG4gICAgICAgIHJldHVybiBFTkNfQUxHUy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHJldHVybiAoYSA9PT0gKFwiQVwiICsgKGxlbiAvIDIpICsgXCJDQkMtSFNcIiArIGxlbikpIHx8XG4gICAgICAgICAgICAgICAgIChhID09PSAoXCJBXCIgKyAobGVuIC8gMikgKyBcIkNCQytIU1wiICsgbGVuKSkgfHxcbiAgICAgICAgICAgICAgICAgKGEgPT09IChcIkFcIiArIGxlbiArIFwiR0NNXCIpKTtcbiAgICAgICAgfSk7XG4gICAgICBjYXNlIFwic2lnblwiOlxuICAgICAgY2FzZSBcInZlcmlmeVwiOlxuICAgICAgICAvLyBUT0RPOiBhbGxvdyBmb3IgSFN7bGVzcy10aGFuLWtleXNpemV9XG4gICAgICAgIHJldHVybiBTSUdfQUxHUy5maWx0ZXIoZnVuY3Rpb24oYSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBtaW5zLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgaWYgKG0gPiBsZW4pIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgfCAoYSA9PT0gKFwiSFNcIiArIG0pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIGNhc2UgXCJ3cmFwXCI6XG4gICAgICBjYXNlIFwidW53cmFwXCI6XG4gICAgICAgIHJldHVybiBXUkFQX0FMR1MuZmlsdGVyKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gKGEgPT09IChcIkFcIiArIGxlbiArIFwiS1dcIikpIHx8XG4gICAgICAgICAgICAgICAgIChhID09PSAoXCJBXCIgKyBsZW4gKyBcIkdDTUtXXCIpKSB8fFxuICAgICAgICAgICAgICAgICAoYS5pbmRleE9mKFwiUEJFUzItXCIpID09PSAwKSB8fFxuICAgICAgICAgICAgICAgICAoYSA9PT0gXCJkaXJcIik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgZW5jcnlwdEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfSxcbiAgZW5jcnlwdFByb3BzOiBhZGp1c3RFbmNyeXB0UHJvcHMsXG5cbiAgZGVjcnlwdEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfSxcbiAgZGVjcnlwdFByb3BzOiBhZGp1c3REZWNyeXB0UHJvcHMsXG5cbiAgd3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfSxcbiAgd3JhcFByb3BzOiBhZGp1c3RFbmNyeXB0UHJvcHMsXG5cbiAgdW53cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlICYmIGtleXMucHJpdmF0ZS5rO1xuICB9LFxuICB1bndyYXBQcm9wczogYWRqdXN0RGVjcnlwdFByb3BzLFxuXG4gIHNpZ25LZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnByaXZhdGUgJiYga2V5cy5wcml2YXRlLms7XG4gIH0sXG4gIHZlcmlmeUtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZSAmJiBrZXlzLnByaXZhdGUuaztcbiAgfVxufTtcblxuLy8gRmFjdG9yeVxudmFyIEpXS09jdGV0RmFjdG9yeSA9IHtcbiAga3R5OiBcIm9jdFwiLFxuICBwcmVwYXJlOiBmdW5jdGlvbihwcm9wcykge1xuICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBwcm9wZXJ0aWVzXG4gICAgdmFyIGNmZyA9IEpXS09jdGV0Q2ZnO1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKHByb3BzKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHJldHVybiBKV0suaGVscGVycy50aHVtYnByaW50KGNmZywganNvbik7XG4gICAgfSk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihoYXNoKSB7XG4gICAgICB2YXIgcHJpbnRzID0ge307XG4gICAgICBwcmludHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfSEFTSF0gPSBoYXNoO1xuICAgICAgcHJvcHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfS0VZXSA9IHByaW50cztcbiAgICAgIHJldHVybiBjZmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH0sXG4gIGdlbmVyYXRlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUga2V5IHNpemVzXG4gICAgdmFyIGtleSA9IHV0aWwucmFuZG9tQnl0ZXMoc2l6ZSAvIDgpO1xuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBrOiBrZXlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcHVibGljIEFQSVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKHtcbiAgY29uZmlnOiBKV0tPY3RldENmZyxcbiAgZmFjdG9yeTogSldLT2N0ZXRGYWN0b3J5XG59KTtcblxuLy8gcmVnaXN0cmF0aW9uXG4oZnVuY3Rpb24oUkVHSVNUUlkpIHtcbiAgUkVHSVNUUlkucmVnaXN0ZXIoSldLT2N0ZXRGYWN0b3J5KTtcbn0pKHJlcXVpcmUoXCIuL2tleXN0b3JlXCIpLnJlZ2lzdHJ5KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/octkey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jwk/rsakey.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jwk/rsa.js - RSA Key Representation\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    rsau = __webpack_require__(/*! ../algorithms/rsa-util */ \"(ssr)/./node_modules/node-jose/lib/algorithms/rsa-util.js\"),\n    nodeCrypto = (__webpack_require__(/*! ../algorithms/helpers */ \"(ssr)/./node_modules/node-jose/lib/algorithms/helpers.js\").nodeCrypto);\n\nvar JWK = {\n  BaseKey: __webpack_require__(/*! ./basekey.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/basekey.js\"),\n  helpers: __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/node-jose/lib/jwk/helpers.js\")\n};\n\nvar SIG_ALGS = [\n  \"RS256\",\n  \"RS384\",\n  \"RS512\",\n  \"PS256\",\n  \"PS384\",\n  \"PS512\"\n];\nvar WRAP_ALGS = [\n  \"RSA-OAEP\",\n  \"RSA-OAEP-256\",\n  \"RSA1_5\"\n];\n\nvar JWKRsaCfg = {\n  publicKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"}\n    ]);\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.n && pk.e) {\n      pk.length = pk.n.length * 8;\n    } else {\n      delete pk.e;\n      delete pk.n;\n    }\n\n    return pk;\n  },\n  privateKey: function(props) {\n    var fields = JWK.helpers.COMMON_PROPS.concat([\n      {name: \"n\", type: \"binary\"},\n      {name: \"e\", type: \"binary\"},\n      {name: \"d\", type: \"binary\"},\n      {name: \"p\", type: \"binary\"},\n      {name: \"q\", type: \"binary\"},\n      {name: \"dp\", type: \"binary\"},\n      {name: \"dq\", type: \"binary\"},\n      {name: \"qi\", type: \"binary\"}\n    ]);\n\n    var pk;\n    pk = JWK.helpers.unpackProps(props, fields);\n    if (pk && pk.d && pk.n && pk.e && pk.p && pk.q && pk.dp && pk.dq && pk.qi) {\n      pk.length = pk.d.length * 8;\n    } else {\n      pk = undefined;\n    }\n\n    return pk;\n  },\n  thumbprint: function(json) {\n    if (json.public) {\n      json = json.public;\n    }\n    var fields = {\n      e: json.e,\n      kty: \"RSA\",\n      n: json.n\n    };\n    return fields;\n  },\n  algorithms: function(keys, mode) {\n    switch (mode) {\n    case \"encrypt\":\n    case \"decrypt\":\n      return [];\n    case \"wrap\":\n      return (keys.public && WRAP_ALGS.slice()) || [];\n    case \"unwrap\":\n      return (keys.private && WRAP_ALGS.slice()) || [];\n    case \"sign\":\n      return (keys.private && SIG_ALGS.slice()) || [];\n    case \"verify\":\n      return (keys.public && SIG_ALGS.slice()) || [];\n    }\n\n    return [];\n  },\n\n  wrapKey: function(alg, keys) {\n    return keys.public;\n  },\n  unwrapKey: function(alg, keys) {\n    return keys.private;\n  },\n\n  signKey: function(alg, keys) {\n    return keys.private;\n  },\n  verifyKey: function(alg, keys) {\n    return keys.public;\n  },\n\n  convertToPEM: function(key, isPrivate) {\n    var k = rsau.convertToForge(key, !isPrivate);\n    if (!isPrivate) {\n      return forge.pki.publicKeyToPem(k);\n    }\n    return forge.pki.privateKeyToPem(k);\n  }\n};\n\nfunction convertBNtoBuffer(bn) {\n  bn = bn.toString(16);\n  if (bn.length % 2) {\n    bn = \"0\" + bn;\n  }\n  return Buffer.from(bn, \"hex\");\n}\n\n// Adapted from digitalbaazar/node-forge/js/rsa.js\nvar validators = {\n  oid: \"1.2.840.113549.1.1.1\",\n  privateKey: {\n    name: \"RSAPrivateKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // Version (INTEGER)\n        name: \"RSAPrivateKey.version\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"version\"\n      },\n      {\n        // modulus (n)\n        name: \"RSAPrivateKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPrivateKey.publicExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      },\n      {\n        // privateExponent (d)\n        name: \"RSAPrivateKey.privateExponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"d\"\n      },\n      {\n        // prime1 (p)\n        name: \"RSAPrivateKey.prime1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"p\"\n      },\n      {\n        // prime2 (q)\n        name: \"RSAPrivateKey.prime2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"q\"\n      },\n      {\n        // exponent1 (d mod (p-1))\n        name: \"RSAPrivateKey.exponent1\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dp\"\n      },\n      {\n        // exponent2 (d mod (q-1))\n        name: \"RSAPrivateKey.exponent2\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"dq\"\n      },\n      {\n        // coefficient ((inverse of q) mod p)\n        name: \"RSAPrivateKey.coefficient\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"qi\"\n      }\n    ]\n  },\n  publicKey: {\n    // RSAPublicKey\n    name: \"RSAPublicKey\",\n    tagClass: forge.asn1.Class.UNIVERSAL,\n    type: forge.asn1.Type.SEQUENCE,\n    constructed: true,\n    value: [\n      {\n        // modulus (n)\n        name: \"RSAPublicKey.modulus\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"n\"\n      },\n      {\n        // publicExponent (e)\n        name: \"RSAPublicKey.exponent\",\n        tagClass: forge.asn1.Class.UNIVERSAL,\n        type: forge.asn1.Type.INTEGER,\n        constructed: false,\n        capture: \"e\"\n      }\n    ]\n  }\n};\n\n// Factory\nvar JWKRsaFactory = {\n  kty: \"RSA\",\n  validators: validators,\n  prepare: function(props) {\n    // TODO: validate key properties\n    var cfg = JWKRsaCfg;\n    var p = Promise.resolve(props);\n    p = p.then(function(json) {\n      return JWK.helpers.thumbprint(cfg, json);\n    });\n    p = p.then(function(hash) {\n      var prints = {};\n      prints[JWK.helpers.INTERNALS.THUMBPRINT_HASH] = hash;\n      props[JWK.helpers.INTERNALS.THUMBPRINT_KEY] = prints;\n      return cfg;\n    });\n    return p;\n  },\n  generate: function(size) {\n    // TODO: validate key sizes\n    var promise;\n\n    if (nodeCrypto) {\n      promise = new Promise(function (resolve, reject) {\n        forge.pki.rsa.generateKeyPair({\n          bits: size,\n          e: 0x010001\n        }, function (err, key) {\n          if (err) return reject(err);\n          resolve(key.privateKey);\n        });\n      });\n    } else {\n      var key = forge.pki.rsa.generateKeyPair({\n        bits: size,\n        e: 0x010001\n      });\n      promise = Promise.resolve(key.privateKey);\n    }\n\n    return promise.then(function (key) {\n\n      // convert to JSON-ish\n      var result = {};\n      [\n        \"e\",\n        \"n\",\n        \"d\",\n        \"p\",\n        \"q\",\n        {incoming: \"dP\", outgoing: \"dp\"},\n        {incoming: \"dQ\", outgoing: \"dq\"},\n        {incoming: \"qInv\", outgoing: \"qi\"}\n      ].forEach(function(f) {\n        var incoming,\n            outgoing;\n\n        if (\"string\" === typeof f) {\n          incoming = outgoing = f;\n        } else {\n          incoming = f.incoming;\n          outgoing = f.outgoing;\n        }\n\n        if (incoming in key) {\n          result[outgoing] = convertBNtoBuffer(key[incoming]);\n        }\n      });\n\n      return result;\n    });\n  },\n  import: function(input) {\n    if (validators.oid !== input.keyOid) {\n      return null;\n    }\n\n    if (!input.parsed) {\n      // coerce capture.keyValue to DER\n      if (\"string\" === typeof input.keyValue) {\n        input.keyValue = forge.asn1.fromDer(input.keyValue);\n      } else if (Array.isArray(input.keyValue)) {\n        input.keyValue = input.keyValue[0];\n      }\n      // capture key factors\n      var validator = (\"private\" === input.type) ?\n                      validators.privateKey :\n                      validators.publicKey;\n      var capture = {},\n          errors = [];\n      if (!forge.asn1.validate(input.keyValue, validator, capture, errors)) {\n        return null;\n      }\n      input = capture;\n    }\n\n    // convert factors to Buffers\n    var output = {\n      kty: \"RSA\"\n    };\n    [\"n\", \"e\", \"d\", \"p\", \"q\", \"dp\", \"dq\", \"qi\"].forEach(function(f) {\n      if (!(f in input)) {\n        return;\n      }\n      var b = Buffer.from(input[f], \"binary\");\n      // remove leading zero padding if any\n      if (0 === b[0]) {\n        b = b.slice(1);\n      }\n      output[f] = b;\n    });\n    return output;\n  }\n};\n\n// public API\nmodule.exports = Object.freeze({\n  config: JWKRsaCfg,\n  factory: JWKRsaFactory\n});\n\n// registration\n(function(REGISTRY) {\n  REGISTRY.register(JWKRsaFactory);\n})((__webpack_require__(/*! ./keystore */ \"(ssr)/./node_modules/node-jose/lib/jwk/keystore.js\").registry));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd2svcnNha2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCO0FBQ3RDLFdBQVcsbUJBQU8sQ0FBQyx5RkFBd0I7QUFDM0MsaUJBQWlCLHlIQUEyQzs7QUFFNUQ7QUFDQSxXQUFXLG1CQUFPLENBQUMsdUVBQWM7QUFDakMsV0FBVyxtQkFBTyxDQUFDLHVFQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMEJBQTBCO0FBQ2pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywwQkFBMEI7QUFDakMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTywyQkFBMkI7QUFDbEMsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBK0I7QUFDeEMsU0FBUywrQkFBK0I7QUFDeEMsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsc0dBQThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandrL3JzYWtleS5qcz85OGRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandrL3JzYS5qcyAtIFJTQSBLZXkgUmVwcmVzZW50YXRpb25cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcmdlID0gcmVxdWlyZShcIi4uL2RlcHMvZm9yZ2UuanNcIiksXG4gICAgcnNhdSA9IHJlcXVpcmUoXCIuLi9hbGdvcml0aG1zL3JzYS11dGlsXCIpLFxuICAgIG5vZGVDcnlwdG8gPSByZXF1aXJlKFwiLi4vYWxnb3JpdGhtcy9oZWxwZXJzXCIpLm5vZGVDcnlwdG87XG5cbnZhciBKV0sgPSB7XG4gIEJhc2VLZXk6IHJlcXVpcmUoXCIuL2Jhc2VrZXkuanNcIiksXG4gIGhlbHBlcnM6IHJlcXVpcmUoXCIuL2hlbHBlcnMuanNcIilcbn07XG5cbnZhciBTSUdfQUxHUyA9IFtcbiAgXCJSUzI1NlwiLFxuICBcIlJTMzg0XCIsXG4gIFwiUlM1MTJcIixcbiAgXCJQUzI1NlwiLFxuICBcIlBTMzg0XCIsXG4gIFwiUFM1MTJcIlxuXTtcbnZhciBXUkFQX0FMR1MgPSBbXG4gIFwiUlNBLU9BRVBcIixcbiAgXCJSU0EtT0FFUC0yNTZcIixcbiAgXCJSU0ExXzVcIlxuXTtcblxudmFyIEpXS1JzYUNmZyA9IHtcbiAgcHVibGljS2V5OiBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBmaWVsZHMgPSBKV0suaGVscGVycy5DT01NT05fUFJPUFMuY29uY2F0KFtcbiAgICAgIHtuYW1lOiBcIm5cIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJlXCIsIHR5cGU6IFwiYmluYXJ5XCJ9XG4gICAgXSk7XG4gICAgdmFyIHBrO1xuICAgIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG4gICAgaWYgKHBrICYmIHBrLm4gJiYgcGsuZSkge1xuICAgICAgcGsubGVuZ3RoID0gcGsubi5sZW5ndGggKiA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcGsuZTtcbiAgICAgIGRlbGV0ZSBway5uO1xuICAgIH1cblxuICAgIHJldHVybiBwaztcbiAgfSxcbiAgcHJpdmF0ZUtleTogZnVuY3Rpb24ocHJvcHMpIHtcbiAgICB2YXIgZmllbGRzID0gSldLLmhlbHBlcnMuQ09NTU9OX1BST1BTLmNvbmNhdChbXG4gICAgICB7bmFtZTogXCJuXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZVwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImRcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJwXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwicVwiLCB0eXBlOiBcImJpbmFyeVwifSxcbiAgICAgIHtuYW1lOiBcImRwXCIsIHR5cGU6IFwiYmluYXJ5XCJ9LFxuICAgICAge25hbWU6IFwiZHFcIiwgdHlwZTogXCJiaW5hcnlcIn0sXG4gICAgICB7bmFtZTogXCJxaVwiLCB0eXBlOiBcImJpbmFyeVwifVxuICAgIF0pO1xuXG4gICAgdmFyIHBrO1xuICAgIHBrID0gSldLLmhlbHBlcnMudW5wYWNrUHJvcHMocHJvcHMsIGZpZWxkcyk7XG4gICAgaWYgKHBrICYmIHBrLmQgJiYgcGsubiAmJiBway5lICYmIHBrLnAgJiYgcGsucSAmJiBway5kcCAmJiBway5kcSAmJiBway5xaSkge1xuICAgICAgcGsubGVuZ3RoID0gcGsuZC5sZW5ndGggKiA4O1xuICAgIH0gZWxzZSB7XG4gICAgICBwayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGs7XG4gIH0sXG4gIHRodW1icHJpbnQ6IGZ1bmN0aW9uKGpzb24pIHtcbiAgICBpZiAoanNvbi5wdWJsaWMpIHtcbiAgICAgIGpzb24gPSBqc29uLnB1YmxpYztcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IHtcbiAgICAgIGU6IGpzb24uZSxcbiAgICAgIGt0eTogXCJSU0FcIixcbiAgICAgIG46IGpzb24ublxuICAgIH07XG4gICAgcmV0dXJuIGZpZWxkcztcbiAgfSxcbiAgYWxnb3JpdGhtczogZnVuY3Rpb24oa2V5cywgbW9kZSkge1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgIGNhc2UgXCJlbmNyeXB0XCI6XG4gICAgY2FzZSBcImRlY3J5cHRcIjpcbiAgICAgIHJldHVybiBbXTtcbiAgICBjYXNlIFwid3JhcFwiOlxuICAgICAgcmV0dXJuIChrZXlzLnB1YmxpYyAmJiBXUkFQX0FMR1Muc2xpY2UoKSkgfHwgW107XG4gICAgY2FzZSBcInVud3JhcFwiOlxuICAgICAgcmV0dXJuIChrZXlzLnByaXZhdGUgJiYgV1JBUF9BTEdTLnNsaWNlKCkpIHx8IFtdO1xuICAgIGNhc2UgXCJzaWduXCI6XG4gICAgICByZXR1cm4gKGtleXMucHJpdmF0ZSAmJiBTSUdfQUxHUy5zbGljZSgpKSB8fCBbXTtcbiAgICBjYXNlIFwidmVyaWZ5XCI6XG4gICAgICByZXR1cm4gKGtleXMucHVibGljICYmIFNJR19BTEdTLnNsaWNlKCkpIHx8IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbXTtcbiAgfSxcblxuICB3cmFwS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wdWJsaWM7XG4gIH0sXG4gIHVud3JhcEtleTogZnVuY3Rpb24oYWxnLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMucHJpdmF0ZTtcbiAgfSxcblxuICBzaWduS2V5OiBmdW5jdGlvbihhbGcsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5wcml2YXRlO1xuICB9LFxuICB2ZXJpZnlLZXk6IGZ1bmN0aW9uKGFsZywga2V5cykge1xuICAgIHJldHVybiBrZXlzLnB1YmxpYztcbiAgfSxcblxuICBjb252ZXJ0VG9QRU06IGZ1bmN0aW9uKGtleSwgaXNQcml2YXRlKSB7XG4gICAgdmFyIGsgPSByc2F1LmNvbnZlcnRUb0ZvcmdlKGtleSwgIWlzUHJpdmF0ZSk7XG4gICAgaWYgKCFpc1ByaXZhdGUpIHtcbiAgICAgIHJldHVybiBmb3JnZS5wa2kucHVibGljS2V5VG9QZW0oayk7XG4gICAgfVxuICAgIHJldHVybiBmb3JnZS5wa2kucHJpdmF0ZUtleVRvUGVtKGspO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjb252ZXJ0Qk50b0J1ZmZlcihibikge1xuICBibiA9IGJuLnRvU3RyaW5nKDE2KTtcbiAgaWYgKGJuLmxlbmd0aCAlIDIpIHtcbiAgICBibiA9IFwiMFwiICsgYm47XG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJuLCBcImhleFwiKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGRpZ2l0YWxiYWF6YXIvbm9kZS1mb3JnZS9qcy9yc2EuanNcbnZhciB2YWxpZGF0b3JzID0ge1xuICBvaWQ6IFwiMS4yLjg0MC4xMTM1NDkuMS4xLjFcIixcbiAgcHJpdmF0ZUtleToge1xuICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleVwiLFxuICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuU0VRVUVOQ0UsXG4gICAgY29uc3RydWN0ZWQ6IHRydWUsXG4gICAgdmFsdWU6IFtcbiAgICAgIHtcbiAgICAgICAgLy8gVmVyc2lvbiAoSU5URUdFUilcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnZlcnNpb25cIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcInZlcnNpb25cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gbW9kdWx1cyAobilcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5Lm1vZHVsdXNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcIm5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5wdWJsaWNFeHBvbmVudFwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwiZVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBwcml2YXRlRXhwb25lbnQgKGQpXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5wcml2YXRlRXhwb25lbnRcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcImRcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHJpbWUxIChwKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkucHJpbWUxXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJwXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHByaW1lMiAocSlcbiAgICAgICAgbmFtZTogXCJSU0FQcml2YXRlS2V5LnByaW1lMlwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBleHBvbmVudDEgKGQgbW9kIChwLTEpKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkuZXhwb25lbnQxXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkcFwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBleHBvbmVudDIgKGQgbW9kIChxLTEpKVxuICAgICAgICBuYW1lOiBcIlJTQVByaXZhdGVLZXkuZXhwb25lbnQyXCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJkcVwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBjb2VmZmljaWVudCAoKGludmVyc2Ugb2YgcSkgbW9kIHApXG4gICAgICAgIG5hbWU6IFwiUlNBUHJpdmF0ZUtleS5jb2VmZmljaWVudFwiLFxuICAgICAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgICAgIHR5cGU6IGZvcmdlLmFzbjEuVHlwZS5JTlRFR0VSLFxuICAgICAgICBjb25zdHJ1Y3RlZDogZmFsc2UsXG4gICAgICAgIGNhcHR1cmU6IFwicWlcIlxuICAgICAgfVxuICAgIF1cbiAgfSxcbiAgcHVibGljS2V5OiB7XG4gICAgLy8gUlNBUHVibGljS2V5XG4gICAgbmFtZTogXCJSU0FQdWJsaWNLZXlcIixcbiAgICB0YWdDbGFzczogZm9yZ2UuYXNuMS5DbGFzcy5VTklWRVJTQUwsXG4gICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLlNFUVVFTkNFLFxuICAgIGNvbnN0cnVjdGVkOiB0cnVlLFxuICAgIHZhbHVlOiBbXG4gICAgICB7XG4gICAgICAgIC8vIG1vZHVsdXMgKG4pXG4gICAgICAgIG5hbWU6IFwiUlNBUHVibGljS2V5Lm1vZHVsdXNcIixcbiAgICAgICAgdGFnQ2xhc3M6IGZvcmdlLmFzbjEuQ2xhc3MuVU5JVkVSU0FMLFxuICAgICAgICB0eXBlOiBmb3JnZS5hc24xLlR5cGUuSU5URUdFUixcbiAgICAgICAgY29uc3RydWN0ZWQ6IGZhbHNlLFxuICAgICAgICBjYXB0dXJlOiBcIm5cIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gcHVibGljRXhwb25lbnQgKGUpXG4gICAgICAgIG5hbWU6IFwiUlNBUHVibGljS2V5LmV4cG9uZW50XCIsXG4gICAgICAgIHRhZ0NsYXNzOiBmb3JnZS5hc24xLkNsYXNzLlVOSVZFUlNBTCxcbiAgICAgICAgdHlwZTogZm9yZ2UuYXNuMS5UeXBlLklOVEVHRVIsXG4gICAgICAgIGNvbnN0cnVjdGVkOiBmYWxzZSxcbiAgICAgICAgY2FwdHVyZTogXCJlXCJcbiAgICAgIH1cbiAgICBdXG4gIH1cbn07XG5cbi8vIEZhY3RvcnlcbnZhciBKV0tSc2FGYWN0b3J5ID0ge1xuICBrdHk6IFwiUlNBXCIsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnMsXG4gIHByZXBhcmU6IGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUga2V5IHByb3BlcnRpZXNcbiAgICB2YXIgY2ZnID0gSldLUnNhQ2ZnO1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKHByb3BzKTtcbiAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgIHJldHVybiBKV0suaGVscGVycy50aHVtYnByaW50KGNmZywganNvbik7XG4gICAgfSk7XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihoYXNoKSB7XG4gICAgICB2YXIgcHJpbnRzID0ge307XG4gICAgICBwcmludHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfSEFTSF0gPSBoYXNoO1xuICAgICAgcHJvcHNbSldLLmhlbHBlcnMuSU5URVJOQUxTLlRIVU1CUFJJTlRfS0VZXSA9IHByaW50cztcbiAgICAgIHJldHVybiBjZmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHA7XG4gIH0sXG4gIGdlbmVyYXRlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgLy8gVE9ETzogdmFsaWRhdGUga2V5IHNpemVzXG4gICAgdmFyIHByb21pc2U7XG5cbiAgICBpZiAobm9kZUNyeXB0bykge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZm9yZ2UucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIoe1xuICAgICAgICAgIGJpdHM6IHNpemUsXG4gICAgICAgICAgZTogMHgwMTAwMDFcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwga2V5KSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJlc29sdmUoa2V5LnByaXZhdGVLZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5ID0gZm9yZ2UucGtpLnJzYS5nZW5lcmF0ZUtleVBhaXIoe1xuICAgICAgICBiaXRzOiBzaXplLFxuICAgICAgICBlOiAweDAxMDAwMVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGtleS5wcml2YXRlS2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChrZXkpIHtcblxuICAgICAgLy8gY29udmVydCB0byBKU09OLWlzaFxuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgW1xuICAgICAgICBcImVcIixcbiAgICAgICAgXCJuXCIsXG4gICAgICAgIFwiZFwiLFxuICAgICAgICBcInBcIixcbiAgICAgICAgXCJxXCIsXG4gICAgICAgIHtpbmNvbWluZzogXCJkUFwiLCBvdXRnb2luZzogXCJkcFwifSxcbiAgICAgICAge2luY29taW5nOiBcImRRXCIsIG91dGdvaW5nOiBcImRxXCJ9LFxuICAgICAgICB7aW5jb21pbmc6IFwicUludlwiLCBvdXRnb2luZzogXCJxaVwifVxuICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgdmFyIGluY29taW5nLFxuICAgICAgICAgICAgb3V0Z29pbmc7XG5cbiAgICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBmKSB7XG4gICAgICAgICAgaW5jb21pbmcgPSBvdXRnb2luZyA9IGY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5jb21pbmcgPSBmLmluY29taW5nO1xuICAgICAgICAgIG91dGdvaW5nID0gZi5vdXRnb2luZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmNvbWluZyBpbiBrZXkpIHtcbiAgICAgICAgICByZXN1bHRbb3V0Z29pbmddID0gY29udmVydEJOdG9CdWZmZXIoa2V5W2luY29taW5nXSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9LFxuICBpbXBvcnQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHZhbGlkYXRvcnMub2lkICE9PSBpbnB1dC5rZXlPaWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaW5wdXQucGFyc2VkKSB7XG4gICAgICAvLyBjb2VyY2UgY2FwdHVyZS5rZXlWYWx1ZSB0byBERVJcbiAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQua2V5VmFsdWUpIHtcbiAgICAgICAgaW5wdXQua2V5VmFsdWUgPSBmb3JnZS5hc24xLmZyb21EZXIoaW5wdXQua2V5VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0LmtleVZhbHVlKSkge1xuICAgICAgICBpbnB1dC5rZXlWYWx1ZSA9IGlucHV0LmtleVZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgLy8gY2FwdHVyZSBrZXkgZmFjdG9yc1xuICAgICAgdmFyIHZhbGlkYXRvciA9IChcInByaXZhdGVcIiA9PT0gaW5wdXQudHlwZSkgP1xuICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvcnMucHJpdmF0ZUtleSA6XG4gICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9ycy5wdWJsaWNLZXk7XG4gICAgICB2YXIgY2FwdHVyZSA9IHt9LFxuICAgICAgICAgIGVycm9ycyA9IFtdO1xuICAgICAgaWYgKCFmb3JnZS5hc24xLnZhbGlkYXRlKGlucHV0LmtleVZhbHVlLCB2YWxpZGF0b3IsIGNhcHR1cmUsIGVycm9ycykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbnB1dCA9IGNhcHR1cmU7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBmYWN0b3JzIHRvIEJ1ZmZlcnNcbiAgICB2YXIgb3V0cHV0ID0ge1xuICAgICAga3R5OiBcIlJTQVwiXG4gICAgfTtcbiAgICBbXCJuXCIsIFwiZVwiLCBcImRcIiwgXCJwXCIsIFwicVwiLCBcImRwXCIsIFwiZHFcIiwgXCJxaVwiXS5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgIGlmICghKGYgaW4gaW5wdXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBiID0gQnVmZmVyLmZyb20oaW5wdXRbZl0sIFwiYmluYXJ5XCIpO1xuICAgICAgLy8gcmVtb3ZlIGxlYWRpbmcgemVybyBwYWRkaW5nIGlmIGFueVxuICAgICAgaWYgKDAgPT09IGJbMF0pIHtcbiAgICAgICAgYiA9IGIuc2xpY2UoMSk7XG4gICAgICB9XG4gICAgICBvdXRwdXRbZl0gPSBiO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbn07XG5cbi8vIHB1YmxpYyBBUElcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGNvbmZpZzogSldLUnNhQ2ZnLFxuICBmYWN0b3J5OiBKV0tSc2FGYWN0b3J5XG59KTtcblxuLy8gcmVnaXN0cmF0aW9uXG4oZnVuY3Rpb24oUkVHSVNUUlkpIHtcbiAgUkVHSVNUUlkucmVnaXN0ZXIoSldLUnNhRmFjdG9yeSk7XG59KShyZXF1aXJlKFwiLi9rZXlzdG9yZVwiKS5yZWdpc3RyeSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jwk/rsakey.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/defaults.js":
/*!****************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/defaults.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/*!\n * jws/defaults.js - Defaults for JWSs\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\n/**\n * @description\n * The default options for {@link JWS.createSign}.\n *\n * @property {Boolean} compact Determines if the output is the Compact\n *           serialization (`true`) or the JSON serialization (**`false`**,\n *           the default).\n * @property {String|String[]} protect The names of the headers to integrity\n *           protect.  The value `\"\"` means that none of header parameters\n *           are integrity protected, while `\"*\"` (the default) means that all\n *           headers parameter sare integrity protected.\n */\nvar JWSDefaults = {\n    compact: false,\n    protect: \"*\"\n};\n\nmodule.exports = JWSDefaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandzL2RlZmF1bHRzLmpzP2Y4OTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd3MvZGVmYXVsdHMuanMgLSBEZWZhdWx0cyBmb3IgSldTc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3Ige0BsaW5rIEpXUy5jcmVhdGVTaWdufS5cbiAqXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGNvbXBhY3QgRGV0ZXJtaW5lcyBpZiB0aGUgb3V0cHV0IGlzIHRoZSBDb21wYWN0XG4gKiAgICAgICAgICAgc2VyaWFsaXphdGlvbiAoYHRydWVgKSBvciB0aGUgSlNPTiBzZXJpYWxpemF0aW9uICgqKmBmYWxzZWAqKixcbiAqICAgICAgICAgICB0aGUgZGVmYXVsdCkuXG4gKiBAcHJvcGVydHkge1N0cmluZ3xTdHJpbmdbXX0gcHJvdGVjdCBUaGUgbmFtZXMgb2YgdGhlIGhlYWRlcnMgdG8gaW50ZWdyaXR5XG4gKiAgICAgICAgICAgcHJvdGVjdC4gIFRoZSB2YWx1ZSBgXCJcImAgbWVhbnMgdGhhdCBub25lIG9mIGhlYWRlciBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgYXJlIGludGVncml0eSBwcm90ZWN0ZWQsIHdoaWxlIGBcIipcImAgKHRoZSBkZWZhdWx0KSBtZWFucyB0aGF0IGFsbFxuICogICAgICAgICAgIGhlYWRlcnMgcGFyYW1ldGVyIHNhcmUgaW50ZWdyaXR5IHByb3RlY3RlZC5cbiAqL1xudmFyIEpXU0RlZmF1bHRzID0ge1xuICAgIGNvbXBhY3Q6IGZhbHNlLFxuICAgIHByb3RlY3Q6IFwiKlwiXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpXU0RlZmF1bHRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/helpers.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/helpers.js ***!
  \***************************************************/
/***/ ((module) => {

eval("/*!\n * jws/helpers.js - JWS Internal Helper Functions\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nmodule.exports = {\n  slice: function(input, start) {\n    return Array.prototype.slice.call(input, start || 0);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9oZWxwZXJzLmpzPzM2MTYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBqd3MvaGVscGVycy5qcyAtIEpXUyBJbnRlcm5hbCBIZWxwZXIgRnVuY3Rpb25zXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzbGljZTogZnVuY3Rpb24oaW5wdXQsIHN0YXJ0KSB7XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGlucHV0LCBzdGFydCB8fCAwKTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/index.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/index.js - JSON Web Signature (JWS) Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar JWS = {\n  createSign: (__webpack_require__(/*! ./sign */ \"(ssr)/./node_modules/node-jose/lib/jws/sign.js\").createSign),\n  createVerify: (__webpack_require__(/*! ./verify */ \"(ssr)/./node_modules/node-jose/lib/jws/verify.js\").createVerify)\n};\n\nmodule.exports = JWS;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViO0FBQ0EsY0FBYyxnR0FBNEI7QUFDMUMsZ0JBQWdCLHNHQUFnQztBQUNoRDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL2p3cy9pbmRleC5qcz9mNDA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandzL2luZGV4LmpzIC0gSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpIEVudHJ5IFBvaW50XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBKV1MgPSB7XG4gIGNyZWF0ZVNpZ246IHJlcXVpcmUoXCIuL3NpZ25cIikuY3JlYXRlU2lnbixcbiAgY3JlYXRlVmVyaWZ5OiByZXF1aXJlKFwiLi92ZXJpZnlcIikuY3JlYXRlVmVyaWZ5XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpXUztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/sign.js":
/*!************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/sign.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/sign.js - Sign to JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    util = __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\"),\n    slice = (__webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/node-jose/lib/jws/helpers.js\").slice);\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\");\nvar uniq = __webpack_require__(/*! lodash/uniq */ \"(ssr)/./node_modules/lodash/uniq.js\");\n\nvar DEFAULTS = __webpack_require__(/*! ./defaults */ \"(ssr)/./node_modules/node-jose/lib/jws/defaults.js\");\n\n/**\n * @class JWS.Signer\n * @classdesc Generator of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createSign}.\n */\nvar JWSSigner = function(cfg, signatories) {\n  var finalized = false,\n      format = cfg.format || \"general\",\n      content = Buffer.alloc(0);\n\n  /**\n  * @member {Boolean} JWS.Signer#compact\n  * @description\n  * Indicates whether the outuput of this signature generator is using\n  * the Compact serialization (`true`) or the JSON serialization\n  * (`false`).\n  */\n  Object.defineProperty(this, \"compact\", {\n    get: function() {\n      return \"compact\" === format;\n    },\n    enumerable: true\n  });\n  Object.defineProperty(this, \"format\", {\n    get: function() {\n      return format;\n    },\n    enumerable: true\n  });\n\n  /**\n  * @method JWS.Signer#update\n  * @description\n  * Updates the signing content for this signature content. The content\n  * is appended to the end of any other content already applied.\n  *\n  * If {data} is a Buffer, {encoding} is ignored. Otherwise, {data} is\n  * converted to a Buffer internally to {encoding}.\n  *\n  * @param {Buffer|String} data The data to sign.\n  * @param {String} [encoding=\"binary\"] The encoding of {data}.\n  * @returns {JWS.Signer} This signature generator.\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"update\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        throw new Error(\"already final\");\n      }\n      if (data != null) {\n        data = util.asBuffer(data, encoding);\n        if (content.length) {\n          content = Buffer.concat([content, data],\n                      content.length + data.length);\n        } else {\n          content = data;\n        }\n      }\n\n      return this;\n    }\n  });\n  /**\n  * @method JWS.Signer#final\n  * @description\n  * Finishes the signature operation.\n  *\n  * The returned Promise, when fulfilled, is the JSON Web Signature (JWS)\n  * object, either in the Compact (if {@link JWS.Signer#format} is\n  * `\"compact\"`), the flattened JSON (if {@link JWS.Signer#format} is\n  * \"flattened\"), or the general JSON serialization.\n  *\n  * @param {Buffer|String} [data] The final content to apply.\n  * @param {String} [encoding=\"binary\"] The encoding of the final content\n  *        (if any).\n  * @returns {Promise} The promise for the signatures\n  * @throws {Error} If a signature has already been generated.\n  */\n  Object.defineProperty(this, \"final\", {\n    value: function(data, encoding) {\n      if (finalized) {\n        return Promise.reject(new Error(\"already final\"));\n      }\n\n      // last-minute data\n      this.update(data, encoding);\n\n      // mark as done...ish\n      finalized = true;\n      var promise;\n\n      // map signatory promises to just signatories\n      promise = Promise.all(signatories);\n      promise = promise.then(function(sigs) {\n        // prepare content\n        content = util.base64url.encode(content);\n\n        sigs = sigs.map(function(s) {\n          // prepare protected\n          var protect = {},\n              lenProtect = 0,\n              unprotect = clone(s.header),\n              lenUnprotect = Object.keys(unprotect).length;\n          s.protected.forEach(function(h) {\n            if (!(h in unprotect)) {\n              return;\n            }\n            protect[h] = unprotect[h];\n            lenProtect++;\n            delete unprotect[h];\n            lenUnprotect--;\n          });\n          if (lenProtect > 0) {\n            protect = JSON.stringify(protect);\n            protect = util.base64url.encode(protect);\n          } else {\n            protect = \"\";\n          }\n\n          // signit!\n          var data = Buffer.from(protect + \".\" + content, \"ascii\");\n          s = s.key.sign(s.header.alg, data, s.header);\n          s = s.then(function(result) {\n            var sig = {};\n            if (0 < lenProtect) {\n              sig.protected = protect;\n            }\n            if (0 < lenUnprotect) {\n              sig.header = unprotect;\n            }\n            sig.signature = util.base64url.encode(result.mac);\n            return sig;\n          });\n          return s;\n        });\n        sigs = [Promise.resolve(content)].concat(sigs);\n        return Promise.all(sigs);\n      });\n      promise = promise.then(function(results) {\n        var content = results[0];\n        return {\n          payload: content,\n          signatures: results.slice(1)\n        };\n      });\n      switch (format) {\n        case \"compact\":\n          promise = promise.then(function(jws) {\n            var compact = [\n              jws.signatures[0].protected,\n              jws.payload,\n              jws.signatures[0].signature\n            ];\n            compact = compact.join(\".\");\n            return compact;\n          });\n          break;\n        case \"flattened\":\n          promise = promise.then(function(jws) {\n            var flattened = {};\n            flattened.payload = jws.payload;\n\n            var sig = jws.signatures[0];\n            if (sig.protected) {\n              flattened.protected = sig.protected;\n            }\n            if (sig.header) {\n              flattened.header = sig.header;\n            }\n            flattened.signature = sig.signature;\n\n            return flattened;\n          });\n          break;\n      }\n\n      return promise;\n    }\n  });\n};\n\n\n/**\n * @description\n * Creates a new JWS.Signer with the given options and signatories.\n *\n * @param {Object} [opts] The signing options\n * @param {Boolean} [opts.compact] Use compact serialization?\n * @param {String} [opts.format] The serialization format to use (\"compact\",\n *                 \"flattened\", \"general\")\n * @param {Object} [opts.fields] Additional header fields\n * @param {JWK.Key[]|Object[]} [signs] Signatories, either as an array of\n *        JWK.Key instances; or an array of objects, each with the following\n *        properties\n * @param {JWK.Key} signs.key Key used to sign content\n * @param {Object} [signs.header] Per-signatory header fields\n * @param {String} [signs.reference] Reference field to identify the key\n * @param {String[]|String} [signs.protect] List of fields to integrity\n *        protect (\"*\" to protect all fields)\n * @returns {JWS.Signer} The signature generator.\n * @throws {Error} If Compact serialization is requested but there are\n *         multiple signatories\n */\nfunction createSign(opts, signs) {\n  // fixup signatories\n  var options = opts,\n      signStart = 1,\n      signList = signs;\n\n  if (arguments.length === 0) {\n    throw new Error(\"at least one signatory must be provided\");\n  }\n  if (arguments.length === 1) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else if (JWK.isKey(opts) ||\n            (opts && \"kty\" in opts) ||\n            (opts && \"key\" in opts &&\n            (JWK.isKey(opts.key) || \"kty\" in opts.key))) {\n    signList = opts;\n    signStart = 0;\n    options = {};\n  } else {\n    options = clone(opts);\n  }\n  if (!Array.isArray(signList)) {\n    signList = slice(arguments, signStart);\n  }\n\n  // fixup options\n  options = merge(clone(DEFAULTS), options);\n\n  // setup header fields\n  var allFields = options.fields || {};\n  // setup serialization format\n  var format = options.format;\n  if (!format) {\n    format = options.compact ? \"compact\" : \"general\";\n  }\n  if ((\"compact\" === format || \"flattened\" === format) && 1 < signList.length) {\n    throw new Error(\"too many signatories for compact or flattened JSON serialization\");\n  }\n\n  // note protected fields (globally)\n  // protected fields are per signature\n  var protectAll = (\"*\" === options.protect);\n  if (options.compact) {\n    protectAll = true;\n  }\n\n  signList = signList.map(function(s, idx) {\n    var p;\n\n    // resolve a key\n    if (s && \"kty\" in s) {\n      p = JWK.asKey(s);\n      p = p.then(function(k) {\n        return {\n          key: k\n        };\n      });\n    } else if (s) {\n      p = JWK.asKey(s.key);\n      p = p.then(function(k) {\n        return {\n          header: s.header,\n          reference: s.reference,\n          protect: s.protect,\n          key: k\n        };\n      });\n    } else {\n      p = Promise.reject(new Error(\"missing key for signatory \" + idx));\n    }\n\n    // resolve the complete signatory\n    p = p.then(function(signatory) {\n      var key = signatory.key;\n\n      // make sure there is a header\n      var header = signatory.header || {};\n      header = merge(merge({}, allFields), header);\n      signatory.header = header;\n\n      // ensure an algorithm\n      if (!header.alg) {\n        header.alg = key.algorithms(JWK.MODE_SIGN)[0] || \"\";\n      }\n\n      // determine the key reference\n      var ref = signatory.reference;\n      delete signatory.reference;\n      if (undefined === ref) {\n        // header already contains the key reference\n        ref = [\"kid\", \"jku\", \"x5c\", \"x5t\", \"x5u\"].some(function(k) {\n          return (k in header);\n        });\n        ref = !ref ? \"kid\" : null;\n      } else if (\"boolean\" === typeof ref) {\n        // explicit (positive | negative) request for key reference\n        ref = ref ? \"kid\" : null;\n      }\n      var jwk;\n      if (ref) {\n        jwk = key.toJSON();\n        if (\"jwk\" === ref) {\n          if (\"oct\" === key.kty) {\n            return Promise.reject(new Error(\"cannot embed key\"));\n          }\n          header.jwk = jwk;\n        } else if (ref in jwk) {\n          header[ref] = jwk[ref];\n        }\n      }\n\n      // determine protected fields\n      var protect = signatory.protect;\n      if (protectAll || \"*\" === protect) {\n        protect = Object.keys(header);\n      } else if (\"string\" === protect) {\n        protect = [protect];\n      } else if (Array.isArray(protect)) {\n        protect = protect.concat();\n      } else if (!protect) {\n        protect = [];\n      } else {\n        return Promise.reject(new Error(\"protect must be a list of fields\"));\n      }\n      protect = uniq(protect);\n      signatory.protected = protect;\n\n      // freeze signatory\n      signatory = Object.freeze(signatory);\n      return signatory;\n    });\n\n    return p;\n  });\n\n  var cfg = {\n    format: format\n  };\n  return new JWSSigner(cfg,\n                       signList);\n}\n\nmodule.exports = {\n  signer: JWSSigner,\n  createSign: createSign\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3Mvc2lnbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxpRUFBUztBQUM1QixVQUFVLG1CQUFPLENBQUMsK0RBQVE7QUFDMUIsWUFBWSxpR0FBMEI7O0FBRXRDLFlBQVksbUJBQU8sQ0FBQywwREFBYztBQUNsQyxXQUFXLG1CQUFPLENBQUMsd0RBQWE7O0FBRWhDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBWTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxNQUFNLGNBQWMsVUFBVSx3QkFBd0IsTUFBTTtBQUNwRSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLFFBQVEscUNBQXFDLEtBQUs7QUFDOUQsY0FBYyxZQUFZO0FBQzFCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyx5QkFBeUI7QUFDaEUsMENBQTBDLHlCQUF5QjtBQUNuRTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWMsU0FBUztBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQkFBb0I7QUFDL0IsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxhQUFhLFlBQVk7QUFDekIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandzL3NpZ24uanM/MmEzYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGp3cy9zaWduLmpzIC0gU2lnbiB0byBKV1NcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIiksXG4gICAgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpLFxuICAgIEpXSyA9IHJlcXVpcmUoXCIuLi9qd2tcIiksXG4gICAgc2xpY2UgPSByZXF1aXJlKFwiLi9oZWxwZXJzXCIpLnNsaWNlO1xuXG52YXIgY2xvbmUgPSByZXF1aXJlKFwibG9kYXNoL2Nsb25lXCIpO1xudmFyIHVuaXEgPSByZXF1aXJlKFwibG9kYXNoL3VuaXFcIik7XG5cbnZhciBERUZBVUxUUyA9IHJlcXVpcmUoXCIuL2RlZmF1bHRzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyBKV1MuU2lnbmVyXG4gKiBAY2xhc3NkZXNjIEdlbmVyYXRvciBvZiBzaWduZWQgY29udGVudC5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqICoqTk9URToqKiB0aGlzIGNsYXNzIGNhbm5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQgY2FsbCB7QGxpbmtcbiAqIEpXUy5jcmVhdGVTaWdufS5cbiAqL1xudmFyIEpXU1NpZ25lciA9IGZ1bmN0aW9uKGNmZywgc2lnbmF0b3JpZXMpIHtcbiAgdmFyIGZpbmFsaXplZCA9IGZhbHNlLFxuICAgICAgZm9ybWF0ID0gY2ZnLmZvcm1hdCB8fCBcImdlbmVyYWxcIixcbiAgICAgIGNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG5cbiAgLyoqXG4gICogQG1lbWJlciB7Qm9vbGVhbn0gSldTLlNpZ25lciNjb21wYWN0XG4gICogQGRlc2NyaXB0aW9uXG4gICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG91dHVwdXQgb2YgdGhpcyBzaWduYXR1cmUgZ2VuZXJhdG9yIGlzIHVzaW5nXG4gICogdGhlIENvbXBhY3Qgc2VyaWFsaXphdGlvbiAoYHRydWVgKSBvciB0aGUgSlNPTiBzZXJpYWxpemF0aW9uXG4gICogKGBmYWxzZWApLlxuICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb21wYWN0XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFwiY29tcGFjdFwiID09PSBmb3JtYXQ7XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmb3JtYXRcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH0sXG4gICAgZW51bWVyYWJsZTogdHJ1ZVxuICB9KTtcblxuICAvKipcbiAgKiBAbWV0aG9kIEpXUy5TaWduZXIjdXBkYXRlXG4gICogQGRlc2NyaXB0aW9uXG4gICogVXBkYXRlcyB0aGUgc2lnbmluZyBjb250ZW50IGZvciB0aGlzIHNpZ25hdHVyZSBjb250ZW50LiBUaGUgY29udGVudFxuICAqIGlzIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgYW55IG90aGVyIGNvbnRlbnQgYWxyZWFkeSBhcHBsaWVkLlxuICAqXG4gICogSWYge2RhdGF9IGlzIGEgQnVmZmVyLCB7ZW5jb2Rpbmd9IGlzIGlnbm9yZWQuIE90aGVyd2lzZSwge2RhdGF9IGlzXG4gICogY29udmVydGVkIHRvIGEgQnVmZmVyIGludGVybmFsbHkgdG8ge2VuY29kaW5nfS5cbiAgKlxuICAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBzaWduLlxuICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9XCJiaW5hcnlcIl0gVGhlIGVuY29kaW5nIG9mIHtkYXRhfS5cbiAgKiBAcmV0dXJucyB7SldTLlNpZ25lcn0gVGhpcyBzaWduYXR1cmUgZ2VuZXJhdG9yLlxuICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHNpZ25hdHVyZSBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZC5cbiAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidXBkYXRlXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oZGF0YSwgZW5jb2RpbmcpIHtcbiAgICAgIGlmIChmaW5hbGl6ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICE9IG51bGwpIHtcbiAgICAgICAgZGF0YSA9IHV0aWwuYXNCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICBpZiAoY29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICBjb250ZW50ID0gQnVmZmVyLmNvbmNhdChbY29udGVudCwgZGF0YV0sXG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudC5sZW5ndGggKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgLyoqXG4gICogQG1ldGhvZCBKV1MuU2lnbmVyI2ZpbmFsXG4gICogQGRlc2NyaXB0aW9uXG4gICogRmluaXNoZXMgdGhlIHNpZ25hdHVyZSBvcGVyYXRpb24uXG4gICpcbiAgKiBUaGUgcmV0dXJuZWQgUHJvbWlzZSwgd2hlbiBmdWxmaWxsZWQsIGlzIHRoZSBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgKiBvYmplY3QsIGVpdGhlciBpbiB0aGUgQ29tcGFjdCAoaWYge0BsaW5rIEpXUy5TaWduZXIjZm9ybWF0fSBpc1xuICAqIGBcImNvbXBhY3RcImApLCB0aGUgZmxhdHRlbmVkIEpTT04gKGlmIHtAbGluayBKV1MuU2lnbmVyI2Zvcm1hdH0gaXNcbiAgKiBcImZsYXR0ZW5lZFwiKSwgb3IgdGhlIGdlbmVyYWwgSlNPTiBzZXJpYWxpemF0aW9uLlxuICAqXG4gICogQHBhcmFtIHtCdWZmZXJ8U3RyaW5nfSBbZGF0YV0gVGhlIGZpbmFsIGNvbnRlbnQgdG8gYXBwbHkuXG4gICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZz1cImJpbmFyeVwiXSBUaGUgZW5jb2Rpbmcgb2YgdGhlIGZpbmFsIGNvbnRlbnRcbiAgKiAgICAgICAgKGlmIGFueSkuXG4gICogQHJldHVybnMge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgc2lnbmF0dXJlc1xuICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhIHNpZ25hdHVyZSBoYXMgYWxyZWFkeSBiZWVuIGdlbmVyYXRlZC5cbiAgKi9cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZmluYWxcIiwge1xuICAgIHZhbHVlOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgaWYgKGZpbmFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiYWxyZWFkeSBmaW5hbFwiKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGxhc3QtbWludXRlIGRhdGFcbiAgICAgIHRoaXMudXBkYXRlKGRhdGEsIGVuY29kaW5nKTtcblxuICAgICAgLy8gbWFyayBhcyBkb25lLi4uaXNoXG4gICAgICBmaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgIC8vIG1hcCBzaWduYXRvcnkgcHJvbWlzZXMgdG8ganVzdCBzaWduYXRvcmllc1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UuYWxsKHNpZ25hdG9yaWVzKTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2lncykge1xuICAgICAgICAvLyBwcmVwYXJlIGNvbnRlbnRcbiAgICAgICAgY29udGVudCA9IHV0aWwuYmFzZTY0dXJsLmVuY29kZShjb250ZW50KTtcblxuICAgICAgICBzaWdzID0gc2lncy5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgIC8vIHByZXBhcmUgcHJvdGVjdGVkXG4gICAgICAgICAgdmFyIHByb3RlY3QgPSB7fSxcbiAgICAgICAgICAgICAgbGVuUHJvdGVjdCA9IDAsXG4gICAgICAgICAgICAgIHVucHJvdGVjdCA9IGNsb25lKHMuaGVhZGVyKSxcbiAgICAgICAgICAgICAgbGVuVW5wcm90ZWN0ID0gT2JqZWN0LmtleXModW5wcm90ZWN0KS5sZW5ndGg7XG4gICAgICAgICAgcy5wcm90ZWN0ZWQuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICBpZiAoIShoIGluIHVucHJvdGVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvdGVjdFtoXSA9IHVucHJvdGVjdFtoXTtcbiAgICAgICAgICAgIGxlblByb3RlY3QrKztcbiAgICAgICAgICAgIGRlbGV0ZSB1bnByb3RlY3RbaF07XG4gICAgICAgICAgICBsZW5VbnByb3RlY3QtLTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobGVuUHJvdGVjdCA+IDApIHtcbiAgICAgICAgICAgIHByb3RlY3QgPSBKU09OLnN0cmluZ2lmeShwcm90ZWN0KTtcbiAgICAgICAgICAgIHByb3RlY3QgPSB1dGlsLmJhc2U2NHVybC5lbmNvZGUocHJvdGVjdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3RlY3QgPSBcIlwiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHNpZ25pdCFcbiAgICAgICAgICB2YXIgZGF0YSA9IEJ1ZmZlci5mcm9tKHByb3RlY3QgKyBcIi5cIiArIGNvbnRlbnQsIFwiYXNjaWlcIik7XG4gICAgICAgICAgcyA9IHMua2V5LnNpZ24ocy5oZWFkZXIuYWxnLCBkYXRhLCBzLmhlYWRlcik7XG4gICAgICAgICAgcyA9IHMudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBzaWcgPSB7fTtcbiAgICAgICAgICAgIGlmICgwIDwgbGVuUHJvdGVjdCkge1xuICAgICAgICAgICAgICBzaWcucHJvdGVjdGVkID0gcHJvdGVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgwIDwgbGVuVW5wcm90ZWN0KSB7XG4gICAgICAgICAgICAgIHNpZy5oZWFkZXIgPSB1bnByb3RlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaWcuc2lnbmF0dXJlID0gdXRpbC5iYXNlNjR1cmwuZW5jb2RlKHJlc3VsdC5tYWMpO1xuICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSk7XG4gICAgICAgIHNpZ3MgPSBbUHJvbWlzZS5yZXNvbHZlKGNvbnRlbnQpXS5jb25jYXQoc2lncyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzaWdzKTtcbiAgICAgIH0pO1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gcmVzdWx0c1swXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXlsb2FkOiBjb250ZW50LFxuICAgICAgICAgIHNpZ25hdHVyZXM6IHJlc3VsdHMuc2xpY2UoMSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBcImNvbXBhY3RcIjpcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3cykge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3QgPSBbXG4gICAgICAgICAgICAgIGp3cy5zaWduYXR1cmVzWzBdLnByb3RlY3RlZCxcbiAgICAgICAgICAgICAgandzLnBheWxvYWQsXG4gICAgICAgICAgICAgIGp3cy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbXBhY3QgPSBjb21wYWN0LmpvaW4oXCIuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhY3Q7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmbGF0dGVuZWRcIjpcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKGp3cykge1xuICAgICAgICAgICAgdmFyIGZsYXR0ZW5lZCA9IHt9O1xuICAgICAgICAgICAgZmxhdHRlbmVkLnBheWxvYWQgPSBqd3MucGF5bG9hZDtcblxuICAgICAgICAgICAgdmFyIHNpZyA9IGp3cy5zaWduYXR1cmVzWzBdO1xuICAgICAgICAgICAgaWYgKHNpZy5wcm90ZWN0ZWQpIHtcbiAgICAgICAgICAgICAgZmxhdHRlbmVkLnByb3RlY3RlZCA9IHNpZy5wcm90ZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2lnLmhlYWRlcikge1xuICAgICAgICAgICAgICBmbGF0dGVuZWQuaGVhZGVyID0gc2lnLmhlYWRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYXR0ZW5lZC5zaWduYXR1cmUgPSBzaWcuc2lnbmF0dXJlO1xuXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIG5ldyBKV1MuU2lnbmVyIHdpdGggdGhlIGdpdmVuIG9wdGlvbnMgYW5kIHNpZ25hdG9yaWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c10gVGhlIHNpZ25pbmcgb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0cy5jb21wYWN0XSBVc2UgY29tcGFjdCBzZXJpYWxpemF0aW9uP1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRzLmZvcm1hdF0gVGhlIHNlcmlhbGl6YXRpb24gZm9ybWF0IHRvIHVzZSAoXCJjb21wYWN0XCIsXG4gKiAgICAgICAgICAgICAgICAgXCJmbGF0dGVuZWRcIiwgXCJnZW5lcmFsXCIpXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdHMuZmllbGRzXSBBZGRpdGlvbmFsIGhlYWRlciBmaWVsZHNcbiAqIEBwYXJhbSB7SldLLktleVtdfE9iamVjdFtdfSBbc2lnbnNdIFNpZ25hdG9yaWVzLCBlaXRoZXIgYXMgYW4gYXJyYXkgb2ZcbiAqICAgICAgICBKV0suS2V5IGluc3RhbmNlczsgb3IgYW4gYXJyYXkgb2Ygb2JqZWN0cywgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqICAgICAgICBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge0pXSy5LZXl9IHNpZ25zLmtleSBLZXkgdXNlZCB0byBzaWduIGNvbnRlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2lnbnMuaGVhZGVyXSBQZXItc2lnbmF0b3J5IGhlYWRlciBmaWVsZHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbc2lnbnMucmVmZXJlbmNlXSBSZWZlcmVuY2UgZmllbGQgdG8gaWRlbnRpZnkgdGhlIGtleVxuICogQHBhcmFtIHtTdHJpbmdbXXxTdHJpbmd9IFtzaWducy5wcm90ZWN0XSBMaXN0IG9mIGZpZWxkcyB0byBpbnRlZ3JpdHlcbiAqICAgICAgICBwcm90ZWN0IChcIipcIiB0byBwcm90ZWN0IGFsbCBmaWVsZHMpXG4gKiBAcmV0dXJucyB7SldTLlNpZ25lcn0gVGhlIHNpZ25hdHVyZSBnZW5lcmF0b3IuXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgQ29tcGFjdCBzZXJpYWxpemF0aW9uIGlzIHJlcXVlc3RlZCBidXQgdGhlcmUgYXJlXG4gKiAgICAgICAgIG11bHRpcGxlIHNpZ25hdG9yaWVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNpZ24ob3B0cywgc2lnbnMpIHtcbiAgLy8gZml4dXAgc2lnbmF0b3JpZXNcbiAgdmFyIG9wdGlvbnMgPSBvcHRzLFxuICAgICAgc2lnblN0YXJ0ID0gMSxcbiAgICAgIHNpZ25MaXN0ID0gc2lnbnM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdCBsZWFzdCBvbmUgc2lnbmF0b3J5IG11c3QgYmUgcHJvdmlkZWRcIik7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBzaWduTGlzdCA9IG9wdHM7XG4gICAgc2lnblN0YXJ0ID0gMDtcbiAgICBvcHRpb25zID0ge307XG4gIH0gZWxzZSBpZiAoSldLLmlzS2V5KG9wdHMpIHx8XG4gICAgICAgICAgICAob3B0cyAmJiBcImt0eVwiIGluIG9wdHMpIHx8XG4gICAgICAgICAgICAob3B0cyAmJiBcImtleVwiIGluIG9wdHMgJiZcbiAgICAgICAgICAgIChKV0suaXNLZXkob3B0cy5rZXkpIHx8IFwia3R5XCIgaW4gb3B0cy5rZXkpKSkge1xuICAgIHNpZ25MaXN0ID0gb3B0cztcbiAgICBzaWduU3RhcnQgPSAwO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gY2xvbmUob3B0cyk7XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNpZ25MaXN0KSkge1xuICAgIHNpZ25MaXN0ID0gc2xpY2UoYXJndW1lbnRzLCBzaWduU3RhcnQpO1xuICB9XG5cbiAgLy8gZml4dXAgb3B0aW9uc1xuICBvcHRpb25zID0gbWVyZ2UoY2xvbmUoREVGQVVMVFMpLCBvcHRpb25zKTtcblxuICAvLyBzZXR1cCBoZWFkZXIgZmllbGRzXG4gIHZhciBhbGxGaWVsZHMgPSBvcHRpb25zLmZpZWxkcyB8fCB7fTtcbiAgLy8gc2V0dXAgc2VyaWFsaXphdGlvbiBmb3JtYXRcbiAgdmFyIGZvcm1hdCA9IG9wdGlvbnMuZm9ybWF0O1xuICBpZiAoIWZvcm1hdCkge1xuICAgIGZvcm1hdCA9IG9wdGlvbnMuY29tcGFjdCA/IFwiY29tcGFjdFwiIDogXCJnZW5lcmFsXCI7XG4gIH1cbiAgaWYgKChcImNvbXBhY3RcIiA9PT0gZm9ybWF0IHx8IFwiZmxhdHRlbmVkXCIgPT09IGZvcm1hdCkgJiYgMSA8IHNpZ25MaXN0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IHNpZ25hdG9yaWVzIGZvciBjb21wYWN0IG9yIGZsYXR0ZW5lZCBKU09OIHNlcmlhbGl6YXRpb25cIik7XG4gIH1cblxuICAvLyBub3RlIHByb3RlY3RlZCBmaWVsZHMgKGdsb2JhbGx5KVxuICAvLyBwcm90ZWN0ZWQgZmllbGRzIGFyZSBwZXIgc2lnbmF0dXJlXG4gIHZhciBwcm90ZWN0QWxsID0gKFwiKlwiID09PSBvcHRpb25zLnByb3RlY3QpO1xuICBpZiAob3B0aW9ucy5jb21wYWN0KSB7XG4gICAgcHJvdGVjdEFsbCA9IHRydWU7XG4gIH1cblxuICBzaWduTGlzdCA9IHNpZ25MaXN0Lm1hcChmdW5jdGlvbihzLCBpZHgpIHtcbiAgICB2YXIgcDtcblxuICAgIC8vIHJlc29sdmUgYSBrZXlcbiAgICBpZiAocyAmJiBcImt0eVwiIGluIHMpIHtcbiAgICAgIHAgPSBKV0suYXNLZXkocyk7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBrZXk6IGtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocykge1xuICAgICAgcCA9IEpXSy5hc0tleShzLmtleSk7XG4gICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBoZWFkZXI6IHMuaGVhZGVyLFxuICAgICAgICAgIHJlZmVyZW5jZTogcy5yZWZlcmVuY2UsXG4gICAgICAgICAgcHJvdGVjdDogcy5wcm90ZWN0LFxuICAgICAgICAgIGtleToga1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJtaXNzaW5nIGtleSBmb3Igc2lnbmF0b3J5IFwiICsgaWR4KSk7XG4gICAgfVxuXG4gICAgLy8gcmVzb2x2ZSB0aGUgY29tcGxldGUgc2lnbmF0b3J5XG4gICAgcCA9IHAudGhlbihmdW5jdGlvbihzaWduYXRvcnkpIHtcbiAgICAgIHZhciBrZXkgPSBzaWduYXRvcnkua2V5O1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlcmUgaXMgYSBoZWFkZXJcbiAgICAgIHZhciBoZWFkZXIgPSBzaWduYXRvcnkuaGVhZGVyIHx8IHt9O1xuICAgICAgaGVhZGVyID0gbWVyZ2UobWVyZ2Uoe30sIGFsbEZpZWxkcyksIGhlYWRlcik7XG4gICAgICBzaWduYXRvcnkuaGVhZGVyID0gaGVhZGVyO1xuXG4gICAgICAvLyBlbnN1cmUgYW4gYWxnb3JpdGhtXG4gICAgICBpZiAoIWhlYWRlci5hbGcpIHtcbiAgICAgICAgaGVhZGVyLmFsZyA9IGtleS5hbGdvcml0aG1zKEpXSy5NT0RFX1NJR04pWzBdIHx8IFwiXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIGRldGVybWluZSB0aGUga2V5IHJlZmVyZW5jZVxuICAgICAgdmFyIHJlZiA9IHNpZ25hdG9yeS5yZWZlcmVuY2U7XG4gICAgICBkZWxldGUgc2lnbmF0b3J5LnJlZmVyZW5jZTtcbiAgICAgIGlmICh1bmRlZmluZWQgPT09IHJlZikge1xuICAgICAgICAvLyBoZWFkZXIgYWxyZWFkeSBjb250YWlucyB0aGUga2V5IHJlZmVyZW5jZVxuICAgICAgICByZWYgPSBbXCJraWRcIiwgXCJqa3VcIiwgXCJ4NWNcIiwgXCJ4NXRcIiwgXCJ4NXVcIl0uc29tZShmdW5jdGlvbihrKSB7XG4gICAgICAgICAgcmV0dXJuIChrIGluIGhlYWRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZWYgPSAhcmVmID8gXCJraWRcIiA6IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKFwiYm9vbGVhblwiID09PSB0eXBlb2YgcmVmKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IChwb3NpdGl2ZSB8IG5lZ2F0aXZlKSByZXF1ZXN0IGZvciBrZXkgcmVmZXJlbmNlXG4gICAgICAgIHJlZiA9IHJlZiA/IFwia2lkXCIgOiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIGp3aztcbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgandrID0ga2V5LnRvSlNPTigpO1xuICAgICAgICBpZiAoXCJqd2tcIiA9PT0gcmVmKSB7XG4gICAgICAgICAgaWYgKFwib2N0XCIgPT09IGtleS5rdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgZW1iZWQga2V5XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGVhZGVyLmp3ayA9IGp3aztcbiAgICAgICAgfSBlbHNlIGlmIChyZWYgaW4gandrKSB7XG4gICAgICAgICAgaGVhZGVyW3JlZl0gPSBqd2tbcmVmXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkZXRlcm1pbmUgcHJvdGVjdGVkIGZpZWxkc1xuICAgICAgdmFyIHByb3RlY3QgPSBzaWduYXRvcnkucHJvdGVjdDtcbiAgICAgIGlmIChwcm90ZWN0QWxsIHx8IFwiKlwiID09PSBwcm90ZWN0KSB7XG4gICAgICAgIHByb3RlY3QgPSBPYmplY3Qua2V5cyhoZWFkZXIpO1xuICAgICAgfSBlbHNlIGlmIChcInN0cmluZ1wiID09PSBwcm90ZWN0KSB7XG4gICAgICAgIHByb3RlY3QgPSBbcHJvdGVjdF07XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocHJvdGVjdCkpIHtcbiAgICAgICAgcHJvdGVjdCA9IHByb3RlY3QuY29uY2F0KCk7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90ZWN0KSB7XG4gICAgICAgIHByb3RlY3QgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJwcm90ZWN0IG11c3QgYmUgYSBsaXN0IG9mIGZpZWxkc1wiKSk7XG4gICAgICB9XG4gICAgICBwcm90ZWN0ID0gdW5pcShwcm90ZWN0KTtcbiAgICAgIHNpZ25hdG9yeS5wcm90ZWN0ZWQgPSBwcm90ZWN0O1xuXG4gICAgICAvLyBmcmVlemUgc2lnbmF0b3J5XG4gICAgICBzaWduYXRvcnkgPSBPYmplY3QuZnJlZXplKHNpZ25hdG9yeSk7XG4gICAgICByZXR1cm4gc2lnbmF0b3J5O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHA7XG4gIH0pO1xuXG4gIHZhciBjZmcgPSB7XG4gICAgZm9ybWF0OiBmb3JtYXRcbiAgfTtcbiAgcmV0dXJuIG5ldyBKV1NTaWduZXIoY2ZnLFxuICAgICAgICAgICAgICAgICAgICAgICBzaWduTGlzdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaWduZXI6IEpXU1NpZ25lcixcbiAgY3JlYXRlU2lnbjogY3JlYXRlU2lnblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/sign.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/jws/verify.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/jws/verify.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * jws/verify.js - Verifies from a JWS\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar clone = __webpack_require__(/*! lodash/clone */ \"(ssr)/./node_modules/lodash/clone.js\"),\n    merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\"),\n    base64url = __webpack_require__(/*! ../util/base64url */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n    AlgConfig = __webpack_require__(/*! ../util/algconfig */ \"(ssr)/./node_modules/node-jose/lib/util/algconfig.js\"),\n    JWK = __webpack_require__(/*! ../jwk */ \"(ssr)/./node_modules/node-jose/lib/jwk/index.js\");\n\nvar DEFAULT_OPTIONS = {\n  algorithms: \"*\",\n  allowEmbeddedKey: false\n};\n\n/**\n * @class JWS.Verifier\n * @classdesc Parser of signed content.\n *\n * @description\n * **NOTE:** this class cannot be instantiated directly. Instead call {@link\n * JWS.createVerify}.\n */\nvar JWSVerifier = function(ks, globalOpts) {\n  var assumedKey,\n      keystore;\n\n  if (JWK.isKey(ks)) {\n    assumedKey = ks;\n    keystore = assumedKey.keystore;\n  } else if (JWK.isKeyStore(ks)) {\n    keystore = ks;\n  } else {\n    keystore = JWK.createKeyStore();\n  }\n\n  globalOpts = merge(DEFAULT_OPTIONS, globalOpts);\n\n  Object.defineProperty(this, \"defaultKey\", {\n    value: assumedKey || undefined,\n    enumerable: true\n  });\n  Object.defineProperty(this, \"keystore\", {\n    value: keystore,\n    enumerable: true\n  });\n\n  Object.defineProperty(this, \"verify\", {\n    value: function(input, opts) {\n      opts = merge({}, globalOpts, opts || {});\n      var extraHandlers = opts.handlers || {};\n      var handlerKeys = Object.keys(extraHandlers);\n      var algSpec = new AlgConfig(opts.algorithms);\n\n      if (\"string\" === typeof input) {\n        input = input.split(\".\");\n        input = {\n          payload: input[1],\n          signatures: [\n            {\n              protected: input[0],\n              signature: input[2]\n            }\n          ]\n        };\n      } else if (!input || \"object\" !== typeof input) {\n        throw new Error(\"invalid input\");\n      }\n\n      // fixup \"flattened JSON\" to look like \"general JSON\"\n      if (input.signature) {\n        input.signatures = [\n          {\n            protected: input.protected || undefined,\n            header: input.header || undefined,\n            signature: input.signature\n          }\n        ];\n      }\n\n      // ensure signatories exists\n      var sigList = input.signatures || [{}];\n\n      // combine fields and decode signature per signatory\n      sigList = sigList.map(function(s) {\n        var header = clone(s.header || {});\n        var protect = s.protected ?\n                      JSON.parse(base64url.decode(s.protected, \"utf8\")) :\n                      {};\n        header = merge(header, protect);\n        var signature = base64url.decode(s.signature);\n\n        // process allowed algorithims\n        if (!algSpec.match(header.alg)) {\n          return Promise.reject(new Error(\"Algorithm not allowed: \" + header.alg));\n        }\n\n        // process \"crit\" first\n        var crit = protect.crit;\n        if (crit) {\n          if (!Array.isArray(crit)) {\n            return Promise.reject(new Error(\"Invalid 'crit' header\"));\n          }\n          for (var idx = 0; crit.length > idx; idx++) {\n            if (-1 === handlerKeys.indexOf(crit[idx])) {\n              return Promise.reject(new Error(\n                  \"Critical extension is not supported: \" + crit[idx]\n              ));\n            }\n          }\n        }\n        protect = Object.keys(protect);\n\n        return Promise.resolve({\n          protected: protect,\n          aad: s.protected || \"\",\n          header: header,\n          signature: signature\n        });\n      });\n\n      var promise = Promise.all(sigList);\n      promise = promise.then(function(sigList) {\n        return new Promise(function(resolve, reject) {\n          var processSig = function() {\n            var sig = sigList.shift();\n            if (!sig) {\n              reject(new Error(\"no key found\"));\n              return;\n            }\n\n            sig = merge({}, sig, {\n              payload: input.payload\n            });\n            var p = Promise.resolve(sig);\n            // find the key\n            p = p.then(function(sig) {\n              var algKey;\n              // TODO: resolve jku, x5c, x5u\n              if (opts.allowEmbeddedKey && sig.header.jwk) {\n                algKey = JWK.asKey(sig.header.jwk);\n              } else if (opts.allowEmbeddedKey && sig.header.x5c) {\n                algKey = sig.header.x5c[0];\n                algKey = Buffer.from(algKey, \"base64\");\n                // TODO: callback to validate chain\n                algKey = JWK.asKey(algKey, \"pkix\");\n              } else {\n                algKey = Promise.resolve(assumedKey || keystore.get({\n                  use: \"sig\",\n                  alg: sig.header.alg,\n                  kid: sig.header.kid\n                }));\n              }\n              return algKey.then(function(k) {\n                if (!k) {\n                  return Promise.reject(new Error(\"key does not match\"));\n                }\n                sig.key = k;\n                return sig;\n              });\n            });\n\n            // process any prepare-verify handlers\n            p = p.then(function(sig) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"function\" === typeof h) {\n                  p = h(sig);\n                } else if (\"object\" === typeof h && \"function\" === typeof h.prepare) {\n                  p = h.prepare(sig);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {sig} is updated\n                return sig;\n              });\n            });\n\n            // prepare verify inputs\n            p = p.then(function(sig) {\n              var aad = sig.aad || \"\",\n                  payload = sig.payload || \"\";\n              var content = Buffer.alloc(1 + aad.length + payload.length),\n                  pos = 0;\n              content.write(aad, pos, \"ascii\");\n              pos += aad.length;\n              content.write(\".\", pos, \"ascii\");\n              pos++;\n\n              if (Buffer.isBuffer(payload)) {\n                payload.copy(content, pos);\n              } else {\n                content.write(payload, pos, \"binary\");\n              }\n              sig.content = content;\n              return sig;\n            });\n\n            p = p.then(function(sig) {\n              return sig.key.verify(sig.header.alg,\n                                    sig.content,\n                                    sig.signature);\n            });\n\n            p = p.then(function(result) {\n              var payload = sig.payload;\n              payload = base64url.decode(payload);\n              return {\n                protected: sig.protected,\n                header: sig.header,\n                payload: payload,\n                signature: result.mac,\n                key: sig.key\n              };\n            });\n\n            // process any post-verify handlers\n            p = p.then(function(jws) {\n              var processing = [];\n              handlerKeys.forEach(function(h) {\n                h = extraHandlers[h];\n                var p;\n                if (\"object\" === typeof h && \"function\" === typeof h.complete) {\n                  p = h.complete(jws);\n                }\n                if (p) {\n                  processing.push(Promise.resolve(p));\n                }\n              });\n              return Promise.all(processing).then(function() {\n                // don't actually care about individual handler results\n                // assume {jws} is updated\n                return jws;\n              });\n            });\n            p.then(resolve, processSig);\n          };\n          processSig();\n        });\n      });\n      return promise;\n    }\n  });\n};\n\n/**\n * @description\n * Creates a new JWS.Verifier with the given Key or KeyStore.\n *\n * @param {JWK.Key|JWK.KeyStore} ks The Key or KeyStore to use for verification.\n * @returns {JWS.Verifier} The new Verifier.\n */\nfunction createVerify(ks, opts) {\n  var vfy = new JWSVerifier(ks, opts);\n\n  return vfy;\n}\n\nmodule.exports = {\n  verifier: JWSVerifier,\n  createVerify: createVerify\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9qd3MvdmVyaWZ5LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMERBQWM7QUFDbEMsWUFBWSxtQkFBTyxDQUFDLHVFQUFlO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLCtFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywrRUFBbUI7QUFDM0MsVUFBVSxtQkFBTyxDQUFDLCtEQUFROztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBLGVBQWU7QUFDZixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvandzL3ZlcmlmeS5qcz8yM2VkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogandzL3ZlcmlmeS5qcyAtIFZlcmlmaWVzIGZyb20gYSBKV1NcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNsb25lID0gcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICBtZXJnZSA9IHJlcXVpcmUoXCIuLi91dGlsL21lcmdlXCIpLFxuICAgIGJhc2U2NHVybCA9IHJlcXVpcmUoXCIuLi91dGlsL2Jhc2U2NHVybFwiKSxcbiAgICBBbGdDb25maWcgPSByZXF1aXJlKFwiLi4vdXRpbC9hbGdjb25maWdcIiksXG4gICAgSldLID0gcmVxdWlyZShcIi4uL2p3a1wiKTtcblxudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgYWxnb3JpdGhtczogXCIqXCIsXG4gIGFsbG93RW1iZWRkZWRLZXk6IGZhbHNlXG59O1xuXG4vKipcbiAqIEBjbGFzcyBKV1MuVmVyaWZpZXJcbiAqIEBjbGFzc2Rlc2MgUGFyc2VyIG9mIHNpZ25lZCBjb250ZW50LlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogKipOT1RFOioqIHRoaXMgY2xhc3MgY2Fubm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS4gSW5zdGVhZCBjYWxsIHtAbGlua1xuICogSldTLmNyZWF0ZVZlcmlmeX0uXG4gKi9cbnZhciBKV1NWZXJpZmllciA9IGZ1bmN0aW9uKGtzLCBnbG9iYWxPcHRzKSB7XG4gIHZhciBhc3N1bWVkS2V5LFxuICAgICAga2V5c3RvcmU7XG5cbiAgaWYgKEpXSy5pc0tleShrcykpIHtcbiAgICBhc3N1bWVkS2V5ID0ga3M7XG4gICAga2V5c3RvcmUgPSBhc3N1bWVkS2V5LmtleXN0b3JlO1xuICB9IGVsc2UgaWYgKEpXSy5pc0tleVN0b3JlKGtzKSkge1xuICAgIGtleXN0b3JlID0ga3M7XG4gIH0gZWxzZSB7XG4gICAga2V5c3RvcmUgPSBKV0suY3JlYXRlS2V5U3RvcmUoKTtcbiAgfVxuXG4gIGdsb2JhbE9wdHMgPSBtZXJnZShERUZBVUxUX09QVElPTlMsIGdsb2JhbE9wdHMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRLZXlcIiwge1xuICAgIHZhbHVlOiBhc3N1bWVkS2V5IHx8IHVuZGVmaW5lZCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJrZXlzdG9yZVwiLCB7XG4gICAgdmFsdWU6IGtleXN0b3JlLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyaWZ5XCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oaW5wdXQsIG9wdHMpIHtcbiAgICAgIG9wdHMgPSBtZXJnZSh7fSwgZ2xvYmFsT3B0cywgb3B0cyB8fCB7fSk7XG4gICAgICB2YXIgZXh0cmFIYW5kbGVycyA9IG9wdHMuaGFuZGxlcnMgfHwge307XG4gICAgICB2YXIgaGFuZGxlcktleXMgPSBPYmplY3Qua2V5cyhleHRyYUhhbmRsZXJzKTtcbiAgICAgIHZhciBhbGdTcGVjID0gbmV3IEFsZ0NvbmZpZyhvcHRzLmFsZ29yaXRobXMpO1xuXG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3BsaXQoXCIuXCIpO1xuICAgICAgICBpbnB1dCA9IHtcbiAgICAgICAgICBwYXlsb2FkOiBpbnB1dFsxXSxcbiAgICAgICAgICBzaWduYXR1cmVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHByb3RlY3RlZDogaW5wdXRbMF0sXG4gICAgICAgICAgICAgIHNpZ25hdHVyZTogaW5wdXRbMl1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKCFpbnB1dCB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gZml4dXAgXCJmbGF0dGVuZWQgSlNPTlwiIHRvIGxvb2sgbGlrZSBcImdlbmVyYWwgSlNPTlwiXG4gICAgICBpZiAoaW5wdXQuc2lnbmF0dXJlKSB7XG4gICAgICAgIGlucHV0LnNpZ25hdHVyZXMgPSBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvdGVjdGVkOiBpbnB1dC5wcm90ZWN0ZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVhZGVyOiBpbnB1dC5oZWFkZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBpbnB1dC5zaWduYXR1cmVcbiAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIC8vIGVuc3VyZSBzaWduYXRvcmllcyBleGlzdHNcbiAgICAgIHZhciBzaWdMaXN0ID0gaW5wdXQuc2lnbmF0dXJlcyB8fCBbe31dO1xuXG4gICAgICAvLyBjb21iaW5lIGZpZWxkcyBhbmQgZGVjb2RlIHNpZ25hdHVyZSBwZXIgc2lnbmF0b3J5XG4gICAgICBzaWdMaXN0ID0gc2lnTGlzdC5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICB2YXIgaGVhZGVyID0gY2xvbmUocy5oZWFkZXIgfHwge30pO1xuICAgICAgICB2YXIgcHJvdGVjdCA9IHMucHJvdGVjdGVkID9cbiAgICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKGJhc2U2NHVybC5kZWNvZGUocy5wcm90ZWN0ZWQsIFwidXRmOFwiKSkgOlxuICAgICAgICAgICAgICAgICAgICAgIHt9O1xuICAgICAgICBoZWFkZXIgPSBtZXJnZShoZWFkZXIsIHByb3RlY3QpO1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gYmFzZTY0dXJsLmRlY29kZShzLnNpZ25hdHVyZSk7XG5cbiAgICAgICAgLy8gcHJvY2VzcyBhbGxvd2VkIGFsZ29yaXRoaW1zXG4gICAgICAgIGlmICghYWxnU3BlYy5tYXRjaChoZWFkZXIuYWxnKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJBbGdvcml0aG0gbm90IGFsbG93ZWQ6IFwiICsgaGVhZGVyLmFsZykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvY2VzcyBcImNyaXRcIiBmaXJzdFxuICAgICAgICB2YXIgY3JpdCA9IHByb3RlY3QuY3JpdDtcbiAgICAgICAgaWYgKGNyaXQpIHtcbiAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY3JpdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkICdjcml0JyBoZWFkZXJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBjcml0Lmxlbmd0aCA+IGlkeDsgaWR4KyspIHtcbiAgICAgICAgICAgIGlmICgtMSA9PT0gaGFuZGxlcktleXMuaW5kZXhPZihjcml0W2lkeF0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICBcIkNyaXRpY2FsIGV4dGVuc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiBcIiArIGNyaXRbaWR4XVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvdGVjdCA9IE9iamVjdC5rZXlzKHByb3RlY3QpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHByb3RlY3RlZDogcHJvdGVjdCxcbiAgICAgICAgICBhYWQ6IHMucHJvdGVjdGVkIHx8IFwiXCIsXG4gICAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLmFsbChzaWdMaXN0KTtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24oc2lnTGlzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIHByb2Nlc3NTaWcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaWcgPSBzaWdMaXN0LnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIXNpZykge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwibm8ga2V5IGZvdW5kXCIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzaWcgPSBtZXJnZSh7fSwgc2lnLCB7XG4gICAgICAgICAgICAgIHBheWxvYWQ6IGlucHV0LnBheWxvYWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoc2lnKTtcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGtleVxuICAgICAgICAgICAgcCA9IHAudGhlbihmdW5jdGlvbihzaWcpIHtcbiAgICAgICAgICAgICAgdmFyIGFsZ0tleTtcbiAgICAgICAgICAgICAgLy8gVE9ETzogcmVzb2x2ZSBqa3UsIHg1YywgeDV1XG4gICAgICAgICAgICAgIGlmIChvcHRzLmFsbG93RW1iZWRkZWRLZXkgJiYgc2lnLmhlYWRlci5qd2spIHtcbiAgICAgICAgICAgICAgICBhbGdLZXkgPSBKV0suYXNLZXkoc2lnLmhlYWRlci5qd2spO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuYWxsb3dFbWJlZGRlZEtleSAmJiBzaWcuaGVhZGVyLng1Yykge1xuICAgICAgICAgICAgICAgIGFsZ0tleSA9IHNpZy5oZWFkZXIueDVjWzBdO1xuICAgICAgICAgICAgICAgIGFsZ0tleSA9IEJ1ZmZlci5mcm9tKGFsZ0tleSwgXCJiYXNlNjRcIik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogY2FsbGJhY2sgdG8gdmFsaWRhdGUgY2hhaW5cbiAgICAgICAgICAgICAgICBhbGdLZXkgPSBKV0suYXNLZXkoYWxnS2V5LCBcInBraXhcIik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxnS2V5ID0gUHJvbWlzZS5yZXNvbHZlKGFzc3VtZWRLZXkgfHwga2V5c3RvcmUuZ2V0KHtcbiAgICAgICAgICAgICAgICAgIHVzZTogXCJzaWdcIixcbiAgICAgICAgICAgICAgICAgIGFsZzogc2lnLmhlYWRlci5hbGcsXG4gICAgICAgICAgICAgICAgICBraWQ6IHNpZy5oZWFkZXIua2lkXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBhbGdLZXkudGhlbihmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwia2V5IGRvZXMgbm90IG1hdGNoXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnLmtleSA9IGs7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcHJvY2VzcyBhbnkgcHJlcGFyZS12ZXJpZnkgaGFuZGxlcnNcbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9jZXNzaW5nID0gW107XG4gICAgICAgICAgICAgIGhhbmRsZXJLZXlzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIGggPSBleHRyYUhhbmRsZXJzW2hdO1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoKSB7XG4gICAgICAgICAgICAgICAgICBwID0gaChzaWcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIGggJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaC5wcmVwYXJlKSB7XG4gICAgICAgICAgICAgICAgICBwID0gaC5wcmVwYXJlKHNpZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICBwcm9jZXNzaW5nLnB1c2goUHJvbWlzZS5yZXNvbHZlKHApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvY2Vzc2luZykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBjYXJlIGFib3V0IGluZGl2aWR1YWwgaGFuZGxlciByZXN1bHRzXG4gICAgICAgICAgICAgICAgLy8gYXNzdW1lIHtzaWd9IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBwcmVwYXJlIHZlcmlmeSBpbnB1dHNcbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgICAgICAgIHZhciBhYWQgPSBzaWcuYWFkIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICBwYXlsb2FkID0gc2lnLnBheWxvYWQgfHwgXCJcIjtcbiAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMSArIGFhZC5sZW5ndGggKyBwYXlsb2FkLmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICAgICAgICBjb250ZW50LndyaXRlKGFhZCwgcG9zLCBcImFzY2lpXCIpO1xuICAgICAgICAgICAgICBwb3MgKz0gYWFkLmxlbmd0aDtcbiAgICAgICAgICAgICAgY29udGVudC53cml0ZShcIi5cIiwgcG9zLCBcImFzY2lpXCIpO1xuICAgICAgICAgICAgICBwb3MrKztcblxuICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5jb3B5KGNvbnRlbnQsIHBvcyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudC53cml0ZShwYXlsb2FkLCBwb3MsIFwiYmluYXJ5XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNpZy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNpZztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwID0gcC50aGVuKGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAgICAgICByZXR1cm4gc2lnLmtleS52ZXJpZnkoc2lnLmhlYWRlci5hbGcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWcuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZy5zaWduYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gc2lnLnBheWxvYWQ7XG4gICAgICAgICAgICAgIHBheWxvYWQgPSBiYXNlNjR1cmwuZGVjb2RlKHBheWxvYWQpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByb3RlY3RlZDogc2lnLnByb3RlY3RlZCxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IHNpZy5oZWFkZXIsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHJlc3VsdC5tYWMsXG4gICAgICAgICAgICAgICAga2V5OiBzaWcua2V5XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gcHJvY2VzcyBhbnkgcG9zdC12ZXJpZnkgaGFuZGxlcnNcbiAgICAgICAgICAgIHAgPSBwLnRoZW4oZnVuY3Rpb24oandzKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9jZXNzaW5nID0gW107XG4gICAgICAgICAgICAgIGhhbmRsZXJLZXlzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgICAgIGggPSBleHRyYUhhbmRsZXJzW2hdO1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgaCAmJiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBoLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICBwID0gaC5jb21wbGV0ZShqd3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy5wdXNoKFByb21pc2UucmVzb2x2ZShwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb2Nlc3NpbmcpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWN0dWFsbHkgY2FyZSBhYm91dCBpbmRpdmlkdWFsIGhhbmRsZXIgcmVzdWx0c1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSB7andzfSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGp3cztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHAudGhlbihyZXNvbHZlLCBwcm9jZXNzU2lnKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHByb2Nlc3NTaWcoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSk7XG59O1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIG5ldyBKV1MuVmVyaWZpZXIgd2l0aCB0aGUgZ2l2ZW4gS2V5IG9yIEtleVN0b3JlLlxuICpcbiAqIEBwYXJhbSB7SldLLktleXxKV0suS2V5U3RvcmV9IGtzIFRoZSBLZXkgb3IgS2V5U3RvcmUgdG8gdXNlIGZvciB2ZXJpZmljYXRpb24uXG4gKiBAcmV0dXJucyB7SldTLlZlcmlmaWVyfSBUaGUgbmV3IFZlcmlmaWVyLlxuICovXG5mdW5jdGlvbiBjcmVhdGVWZXJpZnkoa3MsIG9wdHMpIHtcbiAgdmFyIHZmeSA9IG5ldyBKV1NWZXJpZmllcihrcywgb3B0cyk7XG5cbiAgcmV0dXJuIHZmeTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHZlcmlmaWVyOiBKV1NWZXJpZmllcixcbiAgY3JlYXRlVmVyaWZ5OiBjcmVhdGVWZXJpZnlcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/jws/verify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/compact.js":
/*!*****************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/compact.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE Compact Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseCompact(input) {\n  var parts = input.split(\".\");\n\n  var type,\n      op;\n  if (3 === parts.length) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n  } else if (5 === parts.length) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n  } else {\n    throw new TypeError(\"invalid jose serialization\");\n  }\n\n  // parse header\n  var header;\n  header = jose.util.base64url.decode(parts[0], \"utf8\");\n  header = JSON.parse(header);\n  return {\n    type: type,\n    format: \"compact\",\n    input: input,\n    header: header,\n    perform: op\n  };\n}\n\nmodule.exports = parseCompact;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9jb21wYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYjtBQUNBLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixPQUFPLG1CQUFPLENBQUMsK0RBQVE7QUFDdkIsUUFBUSxtQkFBTyxDQUFDLGlFQUFTO0FBQ3pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3BhcnNlL2NvbXBhY3QuanM/NzU4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHBhcnNlL2NvbXBhY3QuanMgLSBKT1NFIENvbXBhY3QgU2VyaWFsaXphdGlvbiBQYXJzZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGpvc2UgPSB7XG4gIEpXRTogcmVxdWlyZShcIi4uL2p3ZVwiKSxcbiAgSldTOiByZXF1aXJlKFwiLi4vandzXCIpLFxuICB1dGlsOiByZXF1aXJlKFwiLi4vdXRpbFwiKVxufTtcblxuZnVuY3Rpb24gcGFyc2VDb21wYWN0KGlucHV0KSB7XG4gIHZhciBwYXJ0cyA9IGlucHV0LnNwbGl0KFwiLlwiKTtcblxuICB2YXIgdHlwZSxcbiAgICAgIG9wO1xuICBpZiAoMyA9PT0gcGFydHMubGVuZ3RoKSB7XG4gICAgLy8gSldTXG4gICAgdHlwZSA9IFwiSldTXCI7XG4gICAgb3AgPSBmdW5jdGlvbihrcywgb3B0cykge1xuICAgICAgcmV0dXJuIGpvc2UuSldTLmNyZWF0ZVZlcmlmeShrcykuXG4gICAgICAgICAgICAgdmVyaWZ5KGlucHV0LCBvcHRzKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKDUgPT09IHBhcnRzLmxlbmd0aCkge1xuICAgIC8vIEpXRVxuICAgIHR5cGUgPSBcIkpXRVwiO1xuICAgIG9wID0gZnVuY3Rpb24oa3MsIG9wdHMpIHtcbiAgICAgIHJldHVybiBqb3NlLkpXRS5jcmVhdGVEZWNyeXB0KGtzKS5cbiAgICAgICAgICAgICBkZWNyeXB0KGlucHV0LCBvcHRzKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIGpvc2Ugc2VyaWFsaXphdGlvblwiKTtcbiAgfVxuXG4gIC8vIHBhcnNlIGhlYWRlclxuICB2YXIgaGVhZGVyO1xuICBoZWFkZXIgPSBqb3NlLnV0aWwuYmFzZTY0dXJsLmRlY29kZShwYXJ0c1swXSwgXCJ1dGY4XCIpO1xuICBoZWFkZXIgPSBKU09OLnBhcnNlKGhlYWRlcik7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBmb3JtYXQ6IFwiY29tcGFjdFwiLFxuICAgIGlucHV0OiBpbnB1dCxcbiAgICBoZWFkZXI6IGhlYWRlcixcbiAgICBwZXJmb3JtOiBvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlQ29tcGFjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/compact.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/index.js":
/*!***************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/index.js - JOSE Parser Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar compact = __webpack_require__(/*! ./compact */ \"(ssr)/./node_modules/node-jose/lib/parse/compact.js\"),\n    json = __webpack_require__(/*! ./json */ \"(ssr)/./node_modules/node-jose/lib/parse/json.js\");\n\nvar parse = module.exports = function(input) {\n  if (Buffer.isBuffer(input)) {\n    // assume buffer holds a Compact Serialization string\n    return compact(input.toString(\"ascii\"));\n  } else if (\"string\" === typeof input) {\n    return compact(input);\n  } else if (input) {\n    return json(input);\n  } else {\n    throw new TypeError(\"invalid input\");\n  }\n};\n\nparse.compact = compact;\nparse.json = json;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLHNFQUFXO0FBQ2pDLFdBQVcsbUJBQU8sQ0FBQyxnRUFBUTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9pbmRleC5qcz85NzA3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogcGFyc2UvaW5kZXguanMgLSBKT1NFIFBhcnNlciBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29tcGFjdCA9IHJlcXVpcmUoXCIuL2NvbXBhY3RcIiksXG4gICAganNvbiA9IHJlcXVpcmUoXCIuL2pzb25cIik7XG5cbnZhciBwYXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAvLyBhc3N1bWUgYnVmZmVyIGhvbGRzIGEgQ29tcGFjdCBTZXJpYWxpemF0aW9uIHN0cmluZ1xuICAgIHJldHVybiBjb21wYWN0KGlucHV0LnRvU3RyaW5nKFwiYXNjaWlcIikpO1xuICB9IGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBpbnB1dCkge1xuICAgIHJldHVybiBjb21wYWN0KGlucHV0KTtcbiAgfSBlbHNlIGlmIChpbnB1dCkge1xuICAgIHJldHVybiBqc29uKGlucHV0KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBpbnB1dFwiKTtcbiAgfVxufTtcblxucGFyc2UuY29tcGFjdCA9IGNvbXBhY3Q7XG5wYXJzZS5qc29uID0ganNvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/parse/json.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/parse/json.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * parse/compact.js - JOSE JSON Serialization Parser\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar merge = __webpack_require__(/*! ../util/merge */ \"(ssr)/./node_modules/node-jose/lib/util/merge.js\");\n\nvar jose = {\n  JWE: __webpack_require__(/*! ../jwe */ \"(ssr)/./node_modules/node-jose/lib/jwe/index.js\"),\n  JWS: __webpack_require__(/*! ../jws */ \"(ssr)/./node_modules/node-jose/lib/jws/index.js\"),\n  util: __webpack_require__(/*! ../util */ \"(ssr)/./node_modules/node-jose/lib/util/index.js\")\n};\n\nfunction parseJSON(input) {\n  var type,\n      op,\n      headers;\n\n  if (\"signatures\" in input || \"signature\" in input) {\n    // JWS\n    type = \"JWS\";\n    op = function(ks, opts) {\n      return jose.JWS.createVerify(ks).\n             verify(input, opts);\n    };\n    // headers can be (signatures[].protected, signatures[].header, signature.protected, signature.header)\n    headers = input.signatures ||\n              [ {\n                protected: input.protected,\n                header: input.header,\n                signature: input.signature\n              }];\n    headers = headers.map(function(sig) {\n      var all = {};\n      if (sig.header) {\n        all = merge(all, sig.header);\n      }\n\n      var prot;\n      if (sig.protected) {\n        prot = sig.protected;\n        prot = jose.util.base64url.decode(prot, \"utf8\");\n        prot = JSON.parse(prot);\n        all = merge(all, prot);\n      }\n\n      return all;\n    });\n  } else if (\"ciphertext\" in input) {\n    // JWE\n    type = \"JWE\";\n    op = function(ks, opts) {\n      return jose.JWE.createDecrypt(ks).\n             decrypt(input, opts);\n    };\n    // headers can be (protected, unprotected, recipients[].header)\n    var root = {};\n    if (input.protected) {\n      root.protected = input.protected;\n      root.protected = jose.util.base64url.decode(root.protected, \"utf8\");\n      root.protected = JSON.parse(root.protected);\n    }\n    if (input.unprotected) {\n      root.unprotected = input.unprotected;\n    }\n\n    headers = input.recipients || [{}];\n    headers = headers.map(function(rcpt) {\n      var all = {};\n      if (rcpt.header) {\n        all = merge(all, rcpt.header);\n      }\n      if (root.unprotected) {\n        all = merge(all, root.unprotected);\n      }\n      if (root.protected) {\n        all = merge(all, root.protected);\n      }\n\n      return all;\n    });\n  }\n\n  return {\n    type: type,\n    format: \"json\",\n    input: input,\n    all: headers,\n    perform: op\n  };\n}\n\nmodule.exports = parseJSON;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi9wYXJzZS9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsdUVBQWU7O0FBRW5DO0FBQ0EsT0FBTyxtQkFBTyxDQUFDLCtEQUFRO0FBQ3ZCLE9BQU8sbUJBQU8sQ0FBQywrREFBUTtBQUN2QixRQUFRLG1CQUFPLENBQUMsaUVBQVM7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3BhcnNlL2pzb24uanM/MmFmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHBhcnNlL2NvbXBhY3QuanMgLSBKT1NFIEpTT04gU2VyaWFsaXphdGlvbiBQYXJzZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgQ2lzY28gU3lzdGVtcywgSW5jLiBTZWUgTElDRU5TRSBmaWxlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG1lcmdlID0gcmVxdWlyZShcIi4uL3V0aWwvbWVyZ2VcIik7XG5cbnZhciBqb3NlID0ge1xuICBKV0U6IHJlcXVpcmUoXCIuLi9qd2VcIiksXG4gIEpXUzogcmVxdWlyZShcIi4uL2p3c1wiKSxcbiAgdXRpbDogcmVxdWlyZShcIi4uL3V0aWxcIilcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSlNPTihpbnB1dCkge1xuICB2YXIgdHlwZSxcbiAgICAgIG9wLFxuICAgICAgaGVhZGVycztcblxuICBpZiAoXCJzaWduYXR1cmVzXCIgaW4gaW5wdXQgfHwgXCJzaWduYXR1cmVcIiBpbiBpbnB1dCkge1xuICAgIC8vIEpXU1xuICAgIHR5cGUgPSBcIkpXU1wiO1xuICAgIG9wID0gZnVuY3Rpb24oa3MsIG9wdHMpIHtcbiAgICAgIHJldHVybiBqb3NlLkpXUy5jcmVhdGVWZXJpZnkoa3MpLlxuICAgICAgICAgICAgIHZlcmlmeShpbnB1dCwgb3B0cyk7XG4gICAgfTtcbiAgICAvLyBoZWFkZXJzIGNhbiBiZSAoc2lnbmF0dXJlc1tdLnByb3RlY3RlZCwgc2lnbmF0dXJlc1tdLmhlYWRlciwgc2lnbmF0dXJlLnByb3RlY3RlZCwgc2lnbmF0dXJlLmhlYWRlcilcbiAgICBoZWFkZXJzID0gaW5wdXQuc2lnbmF0dXJlcyB8fFxuICAgICAgICAgICAgICBbIHtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQ6IGlucHV0LnByb3RlY3RlZCxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IGlucHV0LmhlYWRlcixcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IGlucHV0LnNpZ25hdHVyZVxuICAgICAgICAgICAgICB9XTtcbiAgICBoZWFkZXJzID0gaGVhZGVycy5tYXAoZnVuY3Rpb24oc2lnKSB7XG4gICAgICB2YXIgYWxsID0ge307XG4gICAgICBpZiAoc2lnLmhlYWRlcikge1xuICAgICAgICBhbGwgPSBtZXJnZShhbGwsIHNpZy5oZWFkZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvdDtcbiAgICAgIGlmIChzaWcucHJvdGVjdGVkKSB7XG4gICAgICAgIHByb3QgPSBzaWcucHJvdGVjdGVkO1xuICAgICAgICBwcm90ID0gam9zZS51dGlsLmJhc2U2NHVybC5kZWNvZGUocHJvdCwgXCJ1dGY4XCIpO1xuICAgICAgICBwcm90ID0gSlNPTi5wYXJzZShwcm90KTtcbiAgICAgICAgYWxsID0gbWVyZ2UoYWxsLCBwcm90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChcImNpcGhlcnRleHRcIiBpbiBpbnB1dCkge1xuICAgIC8vIEpXRVxuICAgIHR5cGUgPSBcIkpXRVwiO1xuICAgIG9wID0gZnVuY3Rpb24oa3MsIG9wdHMpIHtcbiAgICAgIHJldHVybiBqb3NlLkpXRS5jcmVhdGVEZWNyeXB0KGtzKS5cbiAgICAgICAgICAgICBkZWNyeXB0KGlucHV0LCBvcHRzKTtcbiAgICB9O1xuICAgIC8vIGhlYWRlcnMgY2FuIGJlIChwcm90ZWN0ZWQsIHVucHJvdGVjdGVkLCByZWNpcGllbnRzW10uaGVhZGVyKVxuICAgIHZhciByb290ID0ge307XG4gICAgaWYgKGlucHV0LnByb3RlY3RlZCkge1xuICAgICAgcm9vdC5wcm90ZWN0ZWQgPSBpbnB1dC5wcm90ZWN0ZWQ7XG4gICAgICByb290LnByb3RlY3RlZCA9IGpvc2UudXRpbC5iYXNlNjR1cmwuZGVjb2RlKHJvb3QucHJvdGVjdGVkLCBcInV0ZjhcIik7XG4gICAgICByb290LnByb3RlY3RlZCA9IEpTT04ucGFyc2Uocm9vdC5wcm90ZWN0ZWQpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQudW5wcm90ZWN0ZWQpIHtcbiAgICAgIHJvb3QudW5wcm90ZWN0ZWQgPSBpbnB1dC51bnByb3RlY3RlZDtcbiAgICB9XG5cbiAgICBoZWFkZXJzID0gaW5wdXQucmVjaXBpZW50cyB8fCBbe31dO1xuICAgIGhlYWRlcnMgPSBoZWFkZXJzLm1hcChmdW5jdGlvbihyY3B0KSB7XG4gICAgICB2YXIgYWxsID0ge307XG4gICAgICBpZiAocmNwdC5oZWFkZXIpIHtcbiAgICAgICAgYWxsID0gbWVyZ2UoYWxsLCByY3B0LmhlYWRlcik7XG4gICAgICB9XG4gICAgICBpZiAocm9vdC51bnByb3RlY3RlZCkge1xuICAgICAgICBhbGwgPSBtZXJnZShhbGwsIHJvb3QudW5wcm90ZWN0ZWQpO1xuICAgICAgfVxuICAgICAgaWYgKHJvb3QucHJvdGVjdGVkKSB7XG4gICAgICAgIGFsbCA9IG1lcmdlKGFsbCwgcm9vdC5wcm90ZWN0ZWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGZvcm1hdDogXCJqc29uXCIsXG4gICAgaW5wdXQ6IGlucHV0LFxuICAgIGFsbDogaGVhZGVycyxcbiAgICBwZXJmb3JtOiBvcFxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlSlNPTjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/parse/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/algconfig.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/algconfig.js ***!
  \******************************************************/
/***/ ((module) => {

eval("/*!\n * util/algconfig.js - Functions for managing algorithm set options\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nfunction quoteRE(str) {\n  return str.replace(/[.?*+^$[\\]\\\\(){}|-]/g, \"\\\\$&\");\n}\n\nfunction makeRE(prefix, wildcard, suffix) {\n  var parts = [];\n\n  parts.push(\"^\");\n  if (prefix) {\n    prefix = quoteRE(prefix);\n    parts.push(prefix);\n  }\n  if (wildcard) {\n    parts.push((prefix || suffix) ? \".*\" : \".+\");\n  }\n  if (suffix) {\n    suffix = quoteRE(suffix);\n    parts.push(suffix);\n  }\n  parts.push(\"$\");\n\n  return parts.join(\"\");\n}\n\nvar AlgConfig = function(algspec) {\n  if (!algspec) {\n    algspec = [];\n  } else if (\"string\" === typeof algspec) {\n    algspec = algspec.split(\" \");\n  }\n\n  var specAllowed = [], specDisallowed = [];\n  var ptnAllowed = [], ptnDisallowed = [];\n  var ptn = /^(!)?([^*]*)(\\*?)([^*]*)$/, fmt;\n  algspec.forEach(function (a) {\n    if (!a) { return; }\n\n    ptn.lastIndex = 0;\n    var parts = ptn.exec(a);\n    if (!parts) { return; }\n\n    fmt = \"(\" + makeRE(parts[2], parts[3], parts[4]) + \")\";\n    if (!parts[1]) {\n      // allowed pattern\n      ptnAllowed.push(fmt);\n      specAllowed.push(parts[0]);\n    } else {\n      // disallowed pattern\n      ptnDisallowed.push(fmt);\n      specDisallowed.push(parts[0]);\n    }\n  });\n\n  ptnAllowed = (ptnAllowed.length) ?\n            new RegExp(ptnAllowed.join(\"|\")) :\n            null;\n  ptnDisallowed = (ptnDisallowed.length) ?\n               new RegExp(ptnDisallowed.join(\"|\")) :\n               null;\n  if (!specAllowed.length) {\n    specAllowed = [\"*\"];\n  }\n\n  Object.defineProperty(this, \"spec\", {\n    value: specAllowed.join(\" \") + \" \" + specDisallowed.join(\" \"),\n    enumerable: true\n  });\n  Object.defineProperty(this, \"match\", {\n    value: function(alg) {\n      var result = Boolean(alg);\n\n      if (result && ptnAllowed) {\n        ptnAllowed.lastIndex = 0;\n        result = ptnAllowed.test(alg);\n      }\n      if (result && ptnDisallowed) {\n        ptnDisallowed.lastIndex = 0;\n        result = !ptnDisallowed.test(alg);\n      }\n\n      return result;\n    }\n  });\n}\n\nmodule.exports = AlgConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2FsZ2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2FsZ2NvbmZpZy5qcz82MGM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC9hbGdjb25maWcuanMgLSBGdW5jdGlvbnMgZm9yIG1hbmFnaW5nIGFsZ29yaXRobSBzZXQgb3B0aW9uc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBxdW90ZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1suPyorXiRbXFxdXFxcXCgpe318LV0vZywgXCJcXFxcJCZcIik7XG59XG5cbmZ1bmN0aW9uIG1ha2VSRShwcmVmaXgsIHdpbGRjYXJkLCBzdWZmaXgpIHtcbiAgdmFyIHBhcnRzID0gW107XG5cbiAgcGFydHMucHVzaChcIl5cIik7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBwcmVmaXggPSBxdW90ZVJFKHByZWZpeCk7XG4gICAgcGFydHMucHVzaChwcmVmaXgpO1xuICB9XG4gIGlmICh3aWxkY2FyZCkge1xuICAgIHBhcnRzLnB1c2goKHByZWZpeCB8fCBzdWZmaXgpID8gXCIuKlwiIDogXCIuK1wiKTtcbiAgfVxuICBpZiAoc3VmZml4KSB7XG4gICAgc3VmZml4ID0gcXVvdGVSRShzdWZmaXgpO1xuICAgIHBhcnRzLnB1c2goc3VmZml4KTtcbiAgfVxuICBwYXJ0cy5wdXNoKFwiJFwiKTtcblxuICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbn1cblxudmFyIEFsZ0NvbmZpZyA9IGZ1bmN0aW9uKGFsZ3NwZWMpIHtcbiAgaWYgKCFhbGdzcGVjKSB7XG4gICAgYWxnc3BlYyA9IFtdO1xuICB9IGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBhbGdzcGVjKSB7XG4gICAgYWxnc3BlYyA9IGFsZ3NwZWMuc3BsaXQoXCIgXCIpO1xuICB9XG5cbiAgdmFyIHNwZWNBbGxvd2VkID0gW10sIHNwZWNEaXNhbGxvd2VkID0gW107XG4gIHZhciBwdG5BbGxvd2VkID0gW10sIHB0bkRpc2FsbG93ZWQgPSBbXTtcbiAgdmFyIHB0biA9IC9eKCEpPyhbXipdKikoXFwqPykoW14qXSopJC8sIGZtdDtcbiAgYWxnc3BlYy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgaWYgKCFhKSB7IHJldHVybjsgfVxuXG4gICAgcHRuLmxhc3RJbmRleCA9IDA7XG4gICAgdmFyIHBhcnRzID0gcHRuLmV4ZWMoYSk7XG4gICAgaWYgKCFwYXJ0cykgeyByZXR1cm47IH1cblxuICAgIGZtdCA9IFwiKFwiICsgbWFrZVJFKHBhcnRzWzJdLCBwYXJ0c1szXSwgcGFydHNbNF0pICsgXCIpXCI7XG4gICAgaWYgKCFwYXJ0c1sxXSkge1xuICAgICAgLy8gYWxsb3dlZCBwYXR0ZXJuXG4gICAgICBwdG5BbGxvd2VkLnB1c2goZm10KTtcbiAgICAgIHNwZWNBbGxvd2VkLnB1c2gocGFydHNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkaXNhbGxvd2VkIHBhdHRlcm5cbiAgICAgIHB0bkRpc2FsbG93ZWQucHVzaChmbXQpO1xuICAgICAgc3BlY0Rpc2FsbG93ZWQucHVzaChwYXJ0c1swXSk7XG4gICAgfVxuICB9KTtcblxuICBwdG5BbGxvd2VkID0gKHB0bkFsbG93ZWQubGVuZ3RoKSA/XG4gICAgICAgICAgICBuZXcgUmVnRXhwKHB0bkFsbG93ZWQuam9pbihcInxcIikpIDpcbiAgICAgICAgICAgIG51bGw7XG4gIHB0bkRpc2FsbG93ZWQgPSAocHRuRGlzYWxsb3dlZC5sZW5ndGgpID9cbiAgICAgICAgICAgICAgIG5ldyBSZWdFeHAocHRuRGlzYWxsb3dlZC5qb2luKFwifFwiKSkgOlxuICAgICAgICAgICAgICAgbnVsbDtcbiAgaWYgKCFzcGVjQWxsb3dlZC5sZW5ndGgpIHtcbiAgICBzcGVjQWxsb3dlZCA9IFtcIipcIl07XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzcGVjXCIsIHtcbiAgICB2YWx1ZTogc3BlY0FsbG93ZWQuam9pbihcIiBcIikgKyBcIiBcIiArIHNwZWNEaXNhbGxvd2VkLmpvaW4oXCIgXCIpLFxuICAgIGVudW1lcmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1hdGNoXCIsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24oYWxnKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gQm9vbGVhbihhbGcpO1xuXG4gICAgICBpZiAocmVzdWx0ICYmIHB0bkFsbG93ZWQpIHtcbiAgICAgICAgcHRuQWxsb3dlZC5sYXN0SW5kZXggPSAwO1xuICAgICAgICByZXN1bHQgPSBwdG5BbGxvd2VkLnRlc3QoYWxnKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgcHRuRGlzYWxsb3dlZCkge1xuICAgICAgICBwdG5EaXNhbGxvd2VkLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHJlc3VsdCA9ICFwdG5EaXNhbGxvd2VkLnRlc3QoYWxnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEFsZ0NvbmZpZztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/algconfig.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/base64url.js":
/*!******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/base64url.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/base64url.js - Implementation of web-safe Base64 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar impl = __webpack_require__(/*! base64url */ \"(ssr)/./node_modules/base64url/index.js\");\n\n/**\n * @namespace base64url\n * @description\n * Provides methods to encode and decode data according to the\n * base64url alphabet.\n */\nvar base64url = {\n  /**\n   * @function\n   * Encodes the input to base64url.\n   *\n   * If {input} is a Buffer, then {encoding} is ignored. Otherwise,\n   * {encoding} can be one of \"binary\", \"base64\", \"hex\", \"utf8\".\n   *\n   * @param {Buffer|String} input The data to encode.\n   * @param {String} [encoding = binary] The input encoding format.\n   * @returns {String} the base64url encoding of {input}.\n   */\n  encode: function encode(buffer, encoding) {\n    if (buffer instanceof ArrayBuffer) {\n      buffer = new Uint8Array(buffer);\n    }\n\n    if (!Buffer.isBuffer(buffer)) {\n      buffer = Buffer.from(buffer, encoding);\n    }\n\n    return impl.encode(buffer);\n  },\n  /**\n   * @function\n   * Decodes the input from base64url.\n   *\n   * @param {String} input The data to decode.\n   * @returns {Buffer|String} the base64url decoding of {input}.\n   */\n  decode: impl.toBuffer\n};\n\nmodule.exports = base64url;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLDBEQUFXOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPLG1CQUFtQixVQUFVO0FBQzdDLE1BQU0sVUFBVTtBQUNoQjtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRLDJCQUEyQixNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsZUFBZSwyQkFBMkIsTUFBTTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2Jhc2U2NHVybC5qcz83MjVhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC9iYXNlNjR1cmwuanMgLSBJbXBsZW1lbnRhdGlvbiBvZiB3ZWItc2FmZSBCYXNlNjQgRW5jb2Rlci9EZWNvZGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpbXBsID0gcmVxdWlyZShcImJhc2U2NHVybFwiKTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIGJhc2U2NHVybFxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlcyBtZXRob2RzIHRvIGVuY29kZSBhbmQgZGVjb2RlIGRhdGEgYWNjb3JkaW5nIHRvIHRoZVxuICogYmFzZTY0dXJsIGFscGhhYmV0LlxuICovXG52YXIgYmFzZTY0dXJsID0ge1xuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEVuY29kZXMgdGhlIGlucHV0IHRvIGJhc2U2NHVybC5cbiAgICpcbiAgICogSWYge2lucHV0fSBpcyBhIEJ1ZmZlciwgdGhlbiB7ZW5jb2Rpbmd9IGlzIGlnbm9yZWQuIE90aGVyd2lzZSxcbiAgICoge2VuY29kaW5nfSBjYW4gYmUgb25lIG9mIFwiYmluYXJ5XCIsIFwiYmFzZTY0XCIsIFwiaGV4XCIsIFwidXRmOFwiLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGlucHV0IFRoZSBkYXRhIHRvIGVuY29kZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtlbmNvZGluZyA9IGJpbmFyeV0gVGhlIGlucHV0IGVuY29kaW5nIGZvcm1hdC5cbiAgICogQHJldHVybnMge1N0cmluZ30gdGhlIGJhc2U2NHVybCBlbmNvZGluZyBvZiB7aW5wdXR9LlxuICAgKi9cbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUoYnVmZmVyLCBlbmNvZGluZykge1xuICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9XG5cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB7XG4gICAgICBidWZmZXIgPSBCdWZmZXIuZnJvbShidWZmZXIsIGVuY29kaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW1wbC5lbmNvZGUoYnVmZmVyKTtcbiAgfSxcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBEZWNvZGVzIHRoZSBpbnB1dCBmcm9tIGJhc2U2NHVybC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkYXRhIHRvIGRlY29kZS5cbiAgICogQHJldHVybnMge0J1ZmZlcnxTdHJpbmd9IHRoZSBiYXNlNjR1cmwgZGVjb2Rpbmcgb2Yge2lucHV0fS5cbiAgICovXG4gIGRlY29kZTogaW1wbC50b0J1ZmZlclxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlNjR1cmw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/databuffer.js":
/*!*******************************************************!*\
  !*** ./node_modules/node-jose/lib/util/databuffer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/databuffer.js - Forge-compatible Buffer based on Node.js Buffers\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\"),\n    base64url = __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\");\n\n/**\n *\n */\nfunction DataBuffer(b, options) {\n  options = options || {};\n\n  // treat (views of) (Array)Buffers special\n  // NOTE: default implementation creates copies, but efficiently\n  //       wherever possible\n  if (Buffer.isBuffer(b)) {\n    this.data = b;\n  } else if (forge.util.isArrayBuffer(b)) {\n    b = new Uint8Array(b);\n    this.data = Buffer.from(b);\n  } else if (forge.util.isArrayBufferView(b)) {\n    b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    this.data = Buffer.from(b);\n  }\n\n  if (this.data) {\n    this.write = this.data.length;\n    b = undefined;\n  }\n\n  // setup growth rate\n  this.growSize = options.growSize || DataBuffer.DEFAULT_GROW_SIZE;\n\n  // initialize pointers and data\n  this.write = this.write || 0;\n  this.read = this.read || 0;\n  if (b) {\n    this.putBytes(b);\n  } else if (!this.data) {\n    this.accommodate(0);\n  }\n\n  // massage read/write pointers\n  options.readOffset = (\"readOffset\" in options) ?\n                       options.readOffset :\n                       this.read;\n  this.write = (\"writeOffset\" in options) ?\n               options.writeOffset :\n               this.write;\n  this.read = Math.min(options.readOffset, this.write);\n}\nDataBuffer.DEFAULT_GROW_SIZE = 16;\n\nDataBuffer.prototype.length = function() {\n  return this.write - this.read;\n};\nDataBuffer.prototype.available = function() {\n  return this.data.length - this.write;\n};\nDataBuffer.prototype.isEmpty = function() {\n  return this.length() <= 0;\n};\n\nDataBuffer.prototype.accommodate = function(length) {\n  if (!this.data) {\n    // initializes a new buffer\n    length = Math.max(this.write + length, this.growSize);\n\n    this.data = Buffer.alloc(length);\n  } else if (this.available() < length) {\n    length = Math.max(length, this.growSize);\n\n    // create a new empty buffer, and copy current one into it\n    var src = this.data;\n    var dst = Buffer.alloc(src.length + length);\n    src.copy(dst, 0);\n\n    // set data as the new buffer\n    this.data = dst;\n  }\n  // ensure the rest is 0\n  this.data.fill(0, this.write);\n\n  return this;\n};\nDataBuffer.prototype.clear = function() {\n  this.read = this.write = 0;\n  this.data = Buffer.alloc(0);\n  return this;\n};\nDataBuffer.prototype.truncate = function(count) {\n  // chop off <count> bytes from the end\n  this.write = this.read + Math.max(0, this.length() - count);\n  // ensure the remainder is 0\n  this.data.fill(0, this.write);\n  return this;\n};\nDataBuffer.prototype.compact = function() {\n  if (this.read > 0) {\n    if (this.write === this.read) {\n      this.read = this.write = 0;\n    } else {\n      this.data.copy(this.data, 0, this.read, this.write);\n      this.write = this.write - this.read;\n      this.read = 0;\n    }\n    // ensure remainder is 0\n    this.data.fill(0, this.write);\n  }\n  return this;\n};\nDataBuffer.prototype.copy = function() {\n  return new DataBuffer(this, {\n    readOffset: this.read,\n    writeOffset: this.write,\n    growSize: this.growSize\n  });\n};\n\nDataBuffer.prototype.equals = function(test) {\n  if (!DataBuffer.isBuffer(test)) {\n    return false;\n  }\n\n  if (test.length() !== this.length()) {\n    return false;\n  }\n\n  var rval = true,\n      delta = this.read - test.read;\n  // constant time\n  for (var idx = test.read; test.write > idx; idx++) {\n    rval = rval && (this.data[idx + delta] === test.data[idx]);\n  }\n  return rval;\n};\nDataBuffer.prototype.at = function(idx) {\n  return this.data[this.read + idx];\n};\nDataBuffer.prototype.setAt = function(idx, b) {\n  this.data[this.read + idx] = b;\n  return this;\n};\nDataBuffer.prototype.last = function() {\n  return this.data[this.write - 1];\n};\nDataBuffer.prototype.bytes = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = \"\";\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = String.fromCharCode.apply(null, data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.buffer = function(count) {\n  var rval;\n  if (undefined === count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = new ArrayBuffer(0);\n  } else {\n    var begin = this.read,\n        end = begin + count,\n        data = this.data.slice(begin, end);\n    rval = new Uint8Array(end - begin);\n    rval.set(data);\n  }\n\n  return rval;\n};\nDataBuffer.prototype.native = function(count) {\n  var rval;\n  if (\"undefined\" === typeof count) {\n    count = this.length();\n  } else if (count) {\n    count = Math.min(count, this.length());\n  }\n\n  if (0 === count) {\n    rval = Buffer.alloc(0);\n  } else {\n    var begin = this.read,\n        end = begin + count;\n    rval = this.data.slice(begin, end);\n  }\n\n  return rval;\n};\n\nDataBuffer.prototype.toHex = function() {\n  return this.toString(\"hex\");\n};\nDataBuffer.prototype.toString = function(encoding) {\n  // short circuit empty string\n  if (0 === this.length()) {\n    return \"\";\n  }\n\n  var view = this.data.slice(this.read, this.write);\n  encoding = encoding || \"utf8\";\n  // special cases, then built-in support\n  switch (encoding) {\n    case \"raw\":\n      return view.toString(\"binary\");\n    case \"base64url\":\n      return base64url.encode(view);\n    case \"utf16\":\n      return view.toString(\"ucs2\");\n    default:\n      return view.toString(encoding);\n  }\n};\n\nDataBuffer.prototype.fillWithByte = function(b, n) {\n  if (!n) {\n    n = this.available();\n  }\n  this.accommodate(n);\n  this.data.fill(b, this.write, this.write + n);\n  this.write += n;\n\n  return this;\n};\n\nDataBuffer.prototype.getBuffer = function(count) {\n  var rval = this.buffer(count);\n  this.read += rval.byteLength;\n\n  return rval;\n};\nDataBuffer.prototype.putBuffer = function(bytes) {\n  return this.putBytes(bytes);\n};\n\nDataBuffer.prototype.getBytes = function(count) {\n  var rval = this.bytes(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putBytes = function(bytes, encoding) {\n  if (\"string\" === typeof bytes) {\n    // fixup encoding\n    encoding = encoding || \"binary\";\n    switch (encoding) {\n      case \"utf16\":\n        // treat as UCS-2/UTF-16BE\n        encoding = \"ucs-2\";\n        break;\n      case \"raw\":\n        encoding = \"binary\";\n        break;\n      case \"base64url\":\n        // NOTE: this returns a Buffer\n        bytes = base64url.decode(bytes);\n        break;\n    }\n\n    // replace bytes with decoded Buffer (if not already)\n    if (!Buffer.isBuffer(bytes)) {\n      bytes = Buffer.from(bytes, encoding);\n    }\n  }\n\n  var src, dst;\n  if (bytes instanceof DataBuffer) {\n    // be slightly more efficient\n    var orig = bytes;\n    bytes = orig.data.slice(orig.read, orig.write);\n    orig.read = orig.write;\n  } else if (bytes instanceof forge.util.ByteStringBuffer) {\n    bytes = bytes.getBytes();\n  }\n\n  // process array\n  if (Buffer.isBuffer(bytes)) {\n    src = bytes;\n  } else if (Array.isArray(bytes)) {\n    src = Buffer.from(bytes);\n  } else if (forge.util.isArrayBuffer(bytes)) {\n    src = new Uint8Array(bytes);\n    src = Buffer.from(src);\n  } else if (forge.util.isArrayBufferView(bytes)) {\n    src = (bytes instanceof Uint8Array) ?\n              bytes :\n              new Uint8Array(bytes.buffer,\n                             bytes.byteOffset,\n                             bytes.byteLength);\n    src = Buffer.from(src);\n  } else {\n    throw new TypeError(\"invalid source type\");\n  }\n\n  this.accommodate(src.length);\n  dst = this.data;\n  src.copy(dst, this.write);\n  this.write += src.length;\n\n  return this;\n};\n\nDataBuffer.prototype.getNative = function(count) {\n  var rval = this.native(count);\n  this.read += rval.length;\n  return rval;\n};\nDataBuffer.prototype.putNative = DataBuffer.prototype.putBuffer;\n\nDataBuffer.prototype.getByte = function() {\n  var b = this.data[this.read];\n  this.read = Math.min(this.read + 1, this.write);\n  return b;\n};\nDataBuffer.prototype.putByte = function(b) {\n  this.accommodate(1);\n  this.data[this.write] = b & 0xff;\n  this.write++;\n\n  return this;\n};\n\nDataBuffer.prototype.getInt16 = function() {\n  var n = (this.data[this.read] << 8) ^\n          (this.data[this.read + 1]);\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16 = function(n) {\n  this.accommodate(2);\n  this.data[this.write] = (n >>> 8) & 0xff;\n  this.data[this.write + 1] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24 = function() {\n  var n = (this.data[this.read] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read + 2];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24 = function(n) {\n  this.accommodate(3);\n  this.data[this.write] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write + 2] = n & 0xff;\n  this.write += 3;\n  return this;\n};\n\nDataBuffer.prototype.getInt32 = function() {\n  var n = (this.data[this.read] << 24) ^\n          (this.data[this.read + 1] << 16) ^\n          (this.data[this.read + 2] << 8) ^\n          this.data[this.read + 3];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32 = function(n) {\n  this.accommodate(4);\n  this.data[this.write] = (n >>> 24) & 0xff;\n  this.data[this.write + 1] = (n >>> 16) & 0xff;\n  this.data[this.write + 2] = (n >>> 8) & 0xff;\n  this.data[this.write + 3] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt16Le = function() {\n  var n = (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 2, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt16Le = function(n) {\n  this.accommodate(2);\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 2;\n  return this;\n};\n\nDataBuffer.prototype.getInt24Le = function() {\n  var n = (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 3, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt24Le = function(n) {\n  this.accommodate(3);\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 3;\n  return this;\n};\nDataBuffer.prototype.getInt32Le = function() {\n  var n = (this.data[this.read + 3] << 24) ^\n          (this.data[this.read + 2] << 16) ^\n          (this.data[this.read + 1] << 8) ^\n          this.data[this.read];\n  this.read = Math.min(this.read + 4, this.write);\n  return n;\n};\nDataBuffer.prototype.putInt32Le = function(n) {\n  this.accommodate(4);\n  this.data[this.write + 3] = (n >>> 24) & 0xff;\n  this.data[this.write + 2] = (n >>> 16) & 0xff;\n  this.data[this.write + 1] = (n >>> 8) & 0xff;\n  this.data[this.write] = n & 0xff;\n  this.write += 4;\n  return this;\n};\n\nDataBuffer.prototype.getInt = function(bits) {\n  var rval = 0;\n  do {\n    rval = (rval << 8) | this.getByte();\n    bits -= 8;\n  } while (bits > 0);\n  return rval;\n};\nDataBuffer.prototype.putInt = function(n, bits) {\n  this.accommodate(Math.ceil(bits / 8));\n  do {\n    bits -= 8;\n    this.putByte((n >> bits) & 0xff);\n  } while (bits > 0);\n  return this;\n};\n\nDataBuffer.prototype.putSignedInt = function(n, bits) {\n  if (n < 0) {\n    n += 2 << (bits - 1);\n  }\n  return this.putInt(n, bits);\n};\n\nDataBuffer.prototype.putString = function(str) {\n  return this.putBytes(str, \"utf16\");\n};\n\nDataBuffer.isBuffer = function(test) {\n  return (test instanceof DataBuffer);\n};\nDataBuffer.asBuffer = function(orig) {\n  return DataBuffer.isBuffer(orig) ?\n         orig :\n         orig ?\n         new DataBuffer(orig) :\n         new DataBuffer();\n};\n\nmodule.exports = DataBuffer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2RhdGFidWZmZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQywwRUFBa0I7QUFDdEMsZ0JBQWdCLG1CQUFPLENBQUMsNEVBQWdCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2RhdGFidWZmZXIuanM/ZmI5MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIHV0aWwvZGF0YWJ1ZmZlci5qcyAtIEZvcmdlLWNvbXBhdGlibGUgQnVmZmVyIGJhc2VkIG9uIE5vZGUuanMgQnVmZmVyc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKSxcbiAgICBiYXNlNjR1cmwgPSByZXF1aXJlKFwiLi9iYXNlNjR1cmwuanNcIik7XG5cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gRGF0YUJ1ZmZlcihiLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIHRyZWF0ICh2aWV3cyBvZikgKEFycmF5KUJ1ZmZlcnMgc3BlY2lhbFxuICAvLyBOT1RFOiBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNyZWF0ZXMgY29waWVzLCBidXQgZWZmaWNpZW50bHlcbiAgLy8gICAgICAgd2hlcmV2ZXIgcG9zc2libGVcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRoaXMuZGF0YSA9IGI7XG4gIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyKGIpKSB7XG4gICAgYiA9IG5ldyBVaW50OEFycmF5KGIpO1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5mcm9tKGIpO1xuICB9IGVsc2UgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYikpIHtcbiAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYi5idWZmZXIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuZnJvbShiKTtcbiAgfVxuXG4gIGlmICh0aGlzLmRhdGEpIHtcbiAgICB0aGlzLndyaXRlID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICBiID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gc2V0dXAgZ3Jvd3RoIHJhdGVcbiAgdGhpcy5ncm93U2l6ZSA9IG9wdGlvbnMuZ3Jvd1NpemUgfHwgRGF0YUJ1ZmZlci5ERUZBVUxUX0dST1dfU0laRTtcblxuICAvLyBpbml0aWFsaXplIHBvaW50ZXJzIGFuZCBkYXRhXG4gIHRoaXMud3JpdGUgPSB0aGlzLndyaXRlIHx8IDA7XG4gIHRoaXMucmVhZCA9IHRoaXMucmVhZCB8fCAwO1xuICBpZiAoYikge1xuICAgIHRoaXMucHV0Qnl0ZXMoYik7XG4gIH0gZWxzZSBpZiAoIXRoaXMuZGF0YSkge1xuICAgIHRoaXMuYWNjb21tb2RhdGUoMCk7XG4gIH1cblxuICAvLyBtYXNzYWdlIHJlYWQvd3JpdGUgcG9pbnRlcnNcbiAgb3B0aW9ucy5yZWFkT2Zmc2V0ID0gKFwicmVhZE9mZnNldFwiIGluIG9wdGlvbnMpID9cbiAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5yZWFkT2Zmc2V0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkO1xuICB0aGlzLndyaXRlID0gKFwid3JpdGVPZmZzZXRcIiBpbiBvcHRpb25zKSA/XG4gICAgICAgICAgICAgICBvcHRpb25zLndyaXRlT2Zmc2V0IDpcbiAgICAgICAgICAgICAgIHRoaXMud3JpdGU7XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKG9wdGlvbnMucmVhZE9mZnNldCwgdGhpcy53cml0ZSk7XG59XG5EYXRhQnVmZmVyLkRFRkFVTFRfR1JPV19TSVpFID0gMTY7XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy53cml0ZSAtIHRoaXMucmVhZDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLSB0aGlzLndyaXRlO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPD0gMDtcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmFjY29tbW9kYXRlID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gIGlmICghdGhpcy5kYXRhKSB7XG4gICAgLy8gaW5pdGlhbGl6ZXMgYSBuZXcgYnVmZmVyXG4gICAgbGVuZ3RoID0gTWF0aC5tYXgodGhpcy53cml0ZSArIGxlbmd0aCwgdGhpcy5ncm93U2l6ZSk7XG5cbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmF2YWlsYWJsZSgpIDwgbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gTWF0aC5tYXgobGVuZ3RoLCB0aGlzLmdyb3dTaXplKTtcblxuICAgIC8vIGNyZWF0ZSBhIG5ldyBlbXB0eSBidWZmZXIsIGFuZCBjb3B5IGN1cnJlbnQgb25lIGludG8gaXRcbiAgICB2YXIgc3JjID0gdGhpcy5kYXRhO1xuICAgIHZhciBkc3QgPSBCdWZmZXIuYWxsb2Moc3JjLmxlbmd0aCArIGxlbmd0aCk7XG4gICAgc3JjLmNvcHkoZHN0LCAwKTtcblxuICAgIC8vIHNldCBkYXRhIGFzIHRoZSBuZXcgYnVmZmVyXG4gICAgdGhpcy5kYXRhID0gZHN0O1xuICB9XG4gIC8vIGVuc3VyZSB0aGUgcmVzdCBpcyAwXG4gIHRoaXMuZGF0YS5maWxsKDAsIHRoaXMud3JpdGUpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVhZCA9IHRoaXMud3JpdGUgPSAwO1xuICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLnRydW5jYXRlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgLy8gY2hvcCBvZmYgPGNvdW50PiBieXRlcyBmcm9tIHRoZSBlbmRcbiAgdGhpcy53cml0ZSA9IHRoaXMucmVhZCArIE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoKCkgLSBjb3VudCk7XG4gIC8vIGVuc3VyZSB0aGUgcmVtYWluZGVyIGlzIDBcbiAgdGhpcy5kYXRhLmZpbGwoMCwgdGhpcy53cml0ZSk7XG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVhZCA+IDApIHtcbiAgICBpZiAodGhpcy53cml0ZSA9PT0gdGhpcy5yZWFkKSB7XG4gICAgICB0aGlzLnJlYWQgPSB0aGlzLndyaXRlID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kYXRhLmNvcHkodGhpcy5kYXRhLCAwLCB0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICAgICAgdGhpcy53cml0ZSA9IHRoaXMud3JpdGUgLSB0aGlzLnJlYWQ7XG4gICAgICB0aGlzLnJlYWQgPSAwO1xuICAgIH1cbiAgICAvLyBlbnN1cmUgcmVtYWluZGVyIGlzIDBcbiAgICB0aGlzLmRhdGEuZmlsbCgwLCB0aGlzLndyaXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0YUJ1ZmZlcih0aGlzLCB7XG4gICAgcmVhZE9mZnNldDogdGhpcy5yZWFkLFxuICAgIHdyaXRlT2Zmc2V0OiB0aGlzLndyaXRlLFxuICAgIGdyb3dTaXplOiB0aGlzLmdyb3dTaXplXG4gIH0pO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24odGVzdCkge1xuICBpZiAoIURhdGFCdWZmZXIuaXNCdWZmZXIodGVzdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGVzdC5sZW5ndGgoKSAhPT0gdGhpcy5sZW5ndGgoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBydmFsID0gdHJ1ZSxcbiAgICAgIGRlbHRhID0gdGhpcy5yZWFkIC0gdGVzdC5yZWFkO1xuICAvLyBjb25zdGFudCB0aW1lXG4gIGZvciAodmFyIGlkeCA9IHRlc3QucmVhZDsgdGVzdC53cml0ZSA+IGlkeDsgaWR4KyspIHtcbiAgICBydmFsID0gcnZhbCAmJiAodGhpcy5kYXRhW2lkeCArIGRlbHRhXSA9PT0gdGVzdC5kYXRhW2lkeF0pO1xuICB9XG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaWR4KSB7XG4gIHJldHVybiB0aGlzLmRhdGFbdGhpcy5yZWFkICsgaWR4XTtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5zZXRBdCA9IGZ1bmN0aW9uKGlkeCwgYikge1xuICB0aGlzLmRhdGFbdGhpcy5yZWFkICsgaWR4XSA9IGI7XG4gIHJldHVybiB0aGlzO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLndyaXRlIC0gMV07XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbDtcbiAgaWYgKHVuZGVmaW5lZCA9PT0gY291bnQpIHtcbiAgICBjb3VudCA9IHRoaXMubGVuZ3RoKCk7XG4gIH0gZWxzZSBpZiAoY291bnQpIHtcbiAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCB0aGlzLmxlbmd0aCgpKTtcbiAgfVxuXG4gIGlmICgwID09PSBjb3VudCkge1xuICAgIHJ2YWwgPSBcIlwiO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZWdpbiA9IHRoaXMucmVhZCxcbiAgICAgICAgZW5kID0gYmVnaW4gKyBjb3VudCxcbiAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZShiZWdpbiwgZW5kKTtcbiAgICBydmFsID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZiAodW5kZWZpbmVkID09PSBjb3VudCkge1xuICAgIGNvdW50ID0gdGhpcy5sZW5ndGgoKTtcbiAgfSBlbHNlIGlmIChjb3VudCkge1xuICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIHRoaXMubGVuZ3RoKCkpO1xuICB9XG5cbiAgaWYgKDAgPT09IGNvdW50KSB7XG4gICAgcnZhbCA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYmVnaW4gPSB0aGlzLnJlYWQsXG4gICAgICAgIGVuZCA9IGJlZ2luICsgY291bnQsXG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoYmVnaW4sIGVuZCk7XG4gICAgcnZhbCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIGJlZ2luKTtcbiAgICBydmFsLnNldChkYXRhKTtcbiAgfVxuXG4gIHJldHVybiBydmFsO1xufTtcbkRhdGFCdWZmZXIucHJvdG90eXBlLm5hdGl2ZSA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsO1xuICBpZiAoXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGNvdW50KSB7XG4gICAgY291bnQgPSB0aGlzLmxlbmd0aCgpO1xuICB9IGVsc2UgaWYgKGNvdW50KSB7XG4gICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgdGhpcy5sZW5ndGgoKSk7XG4gIH1cblxuICBpZiAoMCA9PT0gY291bnQpIHtcbiAgICBydmFsID0gQnVmZmVyLmFsbG9jKDApO1xuICB9IGVsc2Uge1xuICAgIHZhciBiZWdpbiA9IHRoaXMucmVhZCxcbiAgICAgICAgZW5kID0gYmVnaW4gKyBjb3VudDtcbiAgICBydmFsID0gdGhpcy5kYXRhLnNsaWNlKGJlZ2luLCBlbmQpO1xuICB9XG5cbiAgcmV0dXJuIHJ2YWw7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS50b0hleCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZyhcImhleFwiKTtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIC8vIHNob3J0IGNpcmN1aXQgZW1wdHkgc3RyaW5nXG4gIGlmICgwID09PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICB2YXIgdmlldyA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnJlYWQsIHRoaXMud3JpdGUpO1xuICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IFwidXRmOFwiO1xuICAvLyBzcGVjaWFsIGNhc2VzLCB0aGVuIGJ1aWx0LWluIHN1cHBvcnRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgXCJyYXdcIjpcbiAgICAgIHJldHVybiB2aWV3LnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcbiAgICAgIHJldHVybiBiYXNlNjR1cmwuZW5jb2RlKHZpZXcpO1xuICAgIGNhc2UgXCJ1dGYxNlwiOlxuICAgICAgcmV0dXJuIHZpZXcudG9TdHJpbmcoXCJ1Y3MyXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmlldy50b1N0cmluZyhlbmNvZGluZyk7XG4gIH1cbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmZpbGxXaXRoQnl0ZSA9IGZ1bmN0aW9uKGIsIG4pIHtcbiAgaWYgKCFuKSB7XG4gICAgbiA9IHRoaXMuYXZhaWxhYmxlKCk7XG4gIH1cbiAgdGhpcy5hY2NvbW1vZGF0ZShuKTtcbiAgdGhpcy5kYXRhLmZpbGwoYiwgdGhpcy53cml0ZSwgdGhpcy53cml0ZSArIG4pO1xuICB0aGlzLndyaXRlICs9IG47XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbihjb3VudCkge1xuICB2YXIgcnZhbCA9IHRoaXMuYnVmZmVyKGNvdW50KTtcbiAgdGhpcy5yZWFkICs9IHJ2YWwuYnl0ZUxlbmd0aDtcblxuICByZXR1cm4gcnZhbDtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCdWZmZXIgPSBmdW5jdGlvbihieXRlcykge1xuICByZXR1cm4gdGhpcy5wdXRCeXRlcyhieXRlcyk7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gIHZhciBydmFsID0gdGhpcy5ieXRlcyhjb3VudCk7XG4gIHRoaXMucmVhZCArPSBydmFsLmxlbmd0aDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcywgZW5jb2RpbmcpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBieXRlcykge1xuICAgIC8vIGZpeHVwIGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBcImJpbmFyeVwiO1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgXCJ1dGYxNlwiOlxuICAgICAgICAvLyB0cmVhdCBhcyBVQ1MtMi9VVEYtMTZCRVxuICAgICAgICBlbmNvZGluZyA9IFwidWNzLTJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmF3XCI6XG4gICAgICAgIGVuY29kaW5nID0gXCJiaW5hcnlcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgIC8vIE5PVEU6IHRoaXMgcmV0dXJucyBhIEJ1ZmZlclxuICAgICAgICBieXRlcyA9IGJhc2U2NHVybC5kZWNvZGUoYnl0ZXMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyByZXBsYWNlIGJ5dGVzIHdpdGggZGVjb2RlZCBCdWZmZXIgKGlmIG5vdCBhbHJlYWR5KVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKSkge1xuICAgICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzcmMsIGRzdDtcbiAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgRGF0YUJ1ZmZlcikge1xuICAgIC8vIGJlIHNsaWdodGx5IG1vcmUgZWZmaWNpZW50XG4gICAgdmFyIG9yaWcgPSBieXRlcztcbiAgICBieXRlcyA9IG9yaWcuZGF0YS5zbGljZShvcmlnLnJlYWQsIG9yaWcud3JpdGUpO1xuICAgIG9yaWcucmVhZCA9IG9yaWcud3JpdGU7XG4gIH0gZWxzZSBpZiAoYnl0ZXMgaW5zdGFuY2VvZiBmb3JnZS51dGlsLkJ5dGVTdHJpbmdCdWZmZXIpIHtcbiAgICBieXRlcyA9IGJ5dGVzLmdldEJ5dGVzKCk7XG4gIH1cblxuICAvLyBwcm9jZXNzIGFycmF5XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYnl0ZXMpKSB7XG4gICAgc3JjID0gYnl0ZXM7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBzcmMgPSBCdWZmZXIuZnJvbShieXRlcyk7XG4gIH0gZWxzZSBpZiAoZm9yZ2UudXRpbC5pc0FycmF5QnVmZmVyKGJ5dGVzKSkge1xuICAgIHNyYyA9IG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICBzcmMgPSBCdWZmZXIuZnJvbShzcmMpO1xuICB9IGVsc2UgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoYnl0ZXMpKSB7XG4gICAgc3JjID0gKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkgP1xuICAgICAgICAgICAgICBieXRlcyA6XG4gICAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KGJ5dGVzLmJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgc3JjID0gQnVmZmVyLmZyb20oc3JjKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBzb3VyY2UgdHlwZVwiKTtcbiAgfVxuXG4gIHRoaXMuYWNjb21tb2RhdGUoc3JjLmxlbmd0aCk7XG4gIGRzdCA9IHRoaXMuZGF0YTtcbiAgc3JjLmNvcHkoZHN0LCB0aGlzLndyaXRlKTtcbiAgdGhpcy53cml0ZSArPSBzcmMubGVuZ3RoO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0TmF0aXZlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHJ2YWwgPSB0aGlzLm5hdGl2ZShjb3VudCk7XG4gIHRoaXMucmVhZCArPSBydmFsLmxlbmd0aDtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0TmF0aXZlID0gRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0QnVmZmVyO1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRCeXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBiID0gdGhpcy5kYXRhW3RoaXMucmVhZF07XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDEsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gYjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRCeXRlID0gZnVuY3Rpb24oYikge1xuICB0aGlzLmFjY29tbW9kYXRlKDEpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZV0gPSBiICYgMHhmZjtcbiAgdGhpcy53cml0ZSsrO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MTYgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZF0gPDwgOCkgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0pO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyAyLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MTYgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMik7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMV0gPSBuICYgMHhmZjtcbiAgdGhpcy53cml0ZSArPSAyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkRhdGFCdWZmZXIucHJvdG90eXBlLmdldEludDI0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWRdIDw8IDE2KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSA8PCA4KSBeXG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMucmVhZCArIDJdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyAzLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjQgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoMyk7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IChuID4+PiAxNikgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAyXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSAodGhpcy5kYXRhW3RoaXMucmVhZF0gPDwgMjQpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDFdIDw8IDE2KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAyXSA8PCA4KSBeXG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMucmVhZCArIDNdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyA0LCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MzIgPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMuYWNjb21tb2RhdGUoNCk7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IChuID4+PiAyNCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gKG4gPj4+IDE2KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMl0gPSAobiA+Pj4gOCkgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDNdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gNDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQxNkxlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSA8PCA4KSBeXG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMucmVhZF07XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDIsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQxNkxlID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDIpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gMjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5nZXRJbnQyNExlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAyXSA8PCAxNikgXlxuICAgICAgICAgICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgMV0gPDwgOCkgXlxuICAgICAgICAgIHRoaXMuZGF0YVt0aGlzLnJlYWRdO1xuICB0aGlzLnJlYWQgPSBNYXRoLm1pbih0aGlzLnJlYWQgKyAzLCB0aGlzLndyaXRlKTtcbiAgcmV0dXJuIG47XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50MjRMZSA9IGZ1bmN0aW9uKG4pIHtcbiAgdGhpcy5hY2NvbW1vZGF0ZSgzKTtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAyXSA9IChuID4+PiAxNikgJiAweGZmO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDFdID0gKG4gPj4+IDgpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGVdID0gbiAmIDB4ZmY7XG4gIHRoaXMud3JpdGUgKz0gMztcbiAgcmV0dXJuIHRoaXM7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50MzJMZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9ICh0aGlzLmRhdGFbdGhpcy5yZWFkICsgM10gPDwgMjQpIF5cbiAgICAgICAgICAodGhpcy5kYXRhW3RoaXMucmVhZCArIDJdIDw8IDE2KSBeXG4gICAgICAgICAgKHRoaXMuZGF0YVt0aGlzLnJlYWQgKyAxXSA8PCA4KSBeXG4gICAgICAgICAgdGhpcy5kYXRhW3RoaXMucmVhZF07XG4gIHRoaXMucmVhZCA9IE1hdGgubWluKHRoaXMucmVhZCArIDQsIHRoaXMud3JpdGUpO1xuICByZXR1cm4gbjtcbn07XG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRJbnQzMkxlID0gZnVuY3Rpb24obikge1xuICB0aGlzLmFjY29tbW9kYXRlKDQpO1xuICB0aGlzLmRhdGFbdGhpcy53cml0ZSArIDNdID0gKG4gPj4+IDI0KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlICsgMl0gPSAobiA+Pj4gMTYpICYgMHhmZjtcbiAgdGhpcy5kYXRhW3RoaXMud3JpdGUgKyAxXSA9IChuID4+PiA4KSAmIDB4ZmY7XG4gIHRoaXMuZGF0YVt0aGlzLndyaXRlXSA9IG4gJiAweGZmO1xuICB0aGlzLndyaXRlICs9IDQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUuZ2V0SW50ID0gZnVuY3Rpb24oYml0cykge1xuICB2YXIgcnZhbCA9IDA7XG4gIGRvIHtcbiAgICBydmFsID0gKHJ2YWwgPDwgOCkgfCB0aGlzLmdldEJ5dGUoKTtcbiAgICBiaXRzIC09IDg7XG4gIH0gd2hpbGUgKGJpdHMgPiAwKTtcbiAgcmV0dXJuIHJ2YWw7XG59O1xuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0SW50ID0gZnVuY3Rpb24obiwgYml0cykge1xuICB0aGlzLmFjY29tbW9kYXRlKE1hdGguY2VpbChiaXRzIC8gOCkpO1xuICBkbyB7XG4gICAgYml0cyAtPSA4O1xuICAgIHRoaXMucHV0Qnl0ZSgobiA+PiBiaXRzKSAmIDB4ZmYpO1xuICB9IHdoaWxlIChiaXRzID4gMCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRGF0YUJ1ZmZlci5wcm90b3R5cGUucHV0U2lnbmVkSW50ID0gZnVuY3Rpb24obiwgYml0cykge1xuICBpZiAobiA8IDApIHtcbiAgICBuICs9IDIgPDwgKGJpdHMgLSAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5wdXRJbnQobiwgYml0cyk7XG59O1xuXG5EYXRhQnVmZmVyLnByb3RvdHlwZS5wdXRTdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgcmV0dXJuIHRoaXMucHV0Qnl0ZXMoc3RyLCBcInV0ZjE2XCIpO1xufTtcblxuRGF0YUJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgcmV0dXJuICh0ZXN0IGluc3RhbmNlb2YgRGF0YUJ1ZmZlcik7XG59O1xuRGF0YUJ1ZmZlci5hc0J1ZmZlciA9IGZ1bmN0aW9uKG9yaWcpIHtcbiAgcmV0dXJuIERhdGFCdWZmZXIuaXNCdWZmZXIob3JpZykgP1xuICAgICAgICAgb3JpZyA6XG4gICAgICAgICBvcmlnID9cbiAgICAgICAgIG5ldyBEYXRhQnVmZmVyKG9yaWcpIDpcbiAgICAgICAgIG5ldyBEYXRhQnVmZmVyKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFCdWZmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/databuffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/index.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/index.js - Utilities Entry Point\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar forge = __webpack_require__(/*! ../deps/forge.js */ \"(ssr)/./node_modules/node-jose/lib/deps/forge.js\");\n\nvar util;\n\nfunction asBuffer(input, encoding) {\n  if (Buffer.isBuffer(input)) {\n    return input;\n  }\n\n  if (\"string\" === typeof input) {\n    encoding = encoding || \"binary\";\n    if (\"base64url\" === encoding) {\n      return util.base64url.decode(input);\n    }\n    return Buffer.from(input, encoding);\n  }\n\n  // assume input is an Array, ArrayBuffer, or ArrayBufferView\n  if (forge.util.isArrayBufferView(input)) {\n    input = (input instanceof Uint8Array) ?\n            input :\n            new Uint8Array(input.buffer, input.byteOffset, input.byteOffset + input.byteLength);\n  } else if (forge.util.isArrayBuffer(input)) {\n    input = new Uint8Array(input);\n  }\n\n  var output;\n  output = Buffer.from(input);\n\n  return output;\n}\n\nfunction randomBytes(len) {\n  return Buffer.from(forge.random.getBytes(len), \"binary\");\n}\n\nutil = {\n  base64url: __webpack_require__(/*! ./base64url.js */ \"(ssr)/./node_modules/node-jose/lib/util/base64url.js\"),\n  utf8: __webpack_require__(/*! ./utf8.js */ \"(ssr)/./node_modules/node-jose/lib/util/utf8.js\"),\n  asBuffer: asBuffer,\n  randomBytes: randomBytes\n};\nmodule.exports = util;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsMEVBQWtCOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDckMsUUFBUSxtQkFBTyxDQUFDLGtFQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9pbmRleC5qcz84NGU5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC9pbmRleC5qcyAtIFV0aWxpdGllcyBFbnRyeSBQb2ludFxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBDaXNjbyBTeXN0ZW1zLCBJbmMuIFNlZSBMSUNFTlNFIGZpbGUuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZm9yZ2UgPSByZXF1aXJlKFwiLi4vZGVwcy9mb3JnZS5qc1wiKTtcblxudmFyIHV0aWw7XG5cbmZ1bmN0aW9uIGFzQnVmZmVyKGlucHV0LCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dDtcbiAgfVxuXG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgaW5wdXQpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IFwiYmluYXJ5XCI7XG4gICAgaWYgKFwiYmFzZTY0dXJsXCIgPT09IGVuY29kaW5nKSB7XG4gICAgICByZXR1cm4gdXRpbC5iYXNlNjR1cmwuZGVjb2RlKGlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhc3N1bWUgaW5wdXQgaXMgYW4gQXJyYXksIEFycmF5QnVmZmVyLCBvciBBcnJheUJ1ZmZlclZpZXdcbiAgaWYgKGZvcmdlLnV0aWwuaXNBcnJheUJ1ZmZlclZpZXcoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSAoaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSA/XG4gICAgICAgICAgICBpbnB1dCA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIsIGlucHV0LmJ5dGVPZmZzZXQsIGlucHV0LmJ5dGVPZmZzZXQgKyBpbnB1dC5ieXRlTGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChmb3JnZS51dGlsLmlzQXJyYXlCdWZmZXIoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gIH1cblxuICB2YXIgb3V0cHV0O1xuICBvdXRwdXQgPSBCdWZmZXIuZnJvbShpbnB1dCk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShmb3JnZS5yYW5kb20uZ2V0Qnl0ZXMobGVuKSwgXCJiaW5hcnlcIik7XG59XG5cbnV0aWwgPSB7XG4gIGJhc2U2NHVybDogcmVxdWlyZShcIi4vYmFzZTY0dXJsLmpzXCIpLFxuICB1dGY4OiByZXF1aXJlKFwiLi91dGY4LmpzXCIpLFxuICBhc0J1ZmZlcjogYXNCdWZmZXIsXG4gIHJhbmRvbUJ5dGVzOiByYW5kb21CeXRlc1xufTtcbm1vZHVsZS5leHBvcnRzID0gdXRpbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/merge.js":
/*!**************************************************!*\
  !*** ./node_modules/node-jose/lib/util/merge.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar partialRight = __webpack_require__(/*! lodash/partialRight */ \"(ssr)/./node_modules/lodash/partialRight.js\");\nvar merge = __webpack_require__(/*! lodash/merge */ \"(ssr)/./node_modules/lodash/merge.js\");\n\nvar typedArrayCtors = (function() {\n  var ctors = [];\n  if (\"undefined\" !== typeof Uint8ClampedArray) {\n    ctors.push(Uint8ClampedArray);\n  }\n  if (\"undefined\" !== typeof Uint8Array) {\n    ctors.push(Uint8Array);\n  }\n  if (\"undefined\" !== typeof Uint16Array) {\n    ctors.push(Uint16Array);\n  }\n  if (\"undefined\" !== typeof Uint32Array) {\n    ctors.push(Uint32Array);\n  }\n  if (\"undefined\" !== typeof Float32Array) {\n    ctors.push(Float32Array);\n  }\n  if (\"undefined\" !== typeof Float64Array) {\n    ctors.push(Float64Array);\n  }\n  return ctors;\n})();\n\nfunction findTypedArrayFor(ta) {\n  var ctor;\n  for (var idx = 0; !ctor && typedArrayCtors.length > idx; idx++) {\n    if (ta instanceof typedArrayCtors[idx]) {\n      ctor = typedArrayCtors[idx];\n    }\n  }\n  return ctor;\n}\n\nfunction mergeBuffer(a, b) {\n  // TODO: should this be a copy, or the reference itself?\n  if (Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  } else {\n    var Ctor = findTypedArrayFor(b);\n    b = Ctor ?\n        new Ctor(b, b.byteOffset, b.byteLength) :\n        undefined;\n  }\n\n  // TODO: QUESTION: create a merged <whatever-a-is>??\n  // for now, a is b\n  a = b;\n\n  return b;\n}\n\nmodule.exports = partialRight(merge, mergeBuffer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL21lcmdlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTs7QUFFYixtQkFBbUIsbUJBQU8sQ0FBQyx3RUFBcUI7QUFDaEQsWUFBWSxtQkFBTyxDQUFDLDBEQUFjOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9saWIvdXRpbC9tZXJnZS5qcz9kYzM1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC91dGY4LmpzIC0gSW1wbGVtZW50YXRpb24gb2YgVVRGLTggRW5jb2Rlci9EZWNvZGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBwYXJ0aWFsUmlnaHQgPSByZXF1aXJlKFwibG9kYXNoL3BhcnRpYWxSaWdodFwiKTtcbnZhciBtZXJnZSA9IHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIik7XG5cbnZhciB0eXBlZEFycmF5Q3RvcnMgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBjdG9ycyA9IFtdO1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XG4gICAgY3RvcnMucHVzaChVaW50OENsYW1wZWRBcnJheSk7XG4gIH1cbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBVaW50OEFycmF5KSB7XG4gICAgY3RvcnMucHVzaChVaW50OEFycmF5KTtcbiAgfVxuICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIFVpbnQxNkFycmF5KSB7XG4gICAgY3RvcnMucHVzaChVaW50MTZBcnJheSk7XG4gIH1cbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBVaW50MzJBcnJheSkge1xuICAgIGN0b3JzLnB1c2goVWludDMyQXJyYXkpO1xuICB9XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgY3RvcnMucHVzaChGbG9hdDMyQXJyYXkpO1xuICB9XG4gIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgY3RvcnMucHVzaChGbG9hdDY0QXJyYXkpO1xuICB9XG4gIHJldHVybiBjdG9ycztcbn0pKCk7XG5cbmZ1bmN0aW9uIGZpbmRUeXBlZEFycmF5Rm9yKHRhKSB7XG4gIHZhciBjdG9yO1xuICBmb3IgKHZhciBpZHggPSAwOyAhY3RvciAmJiB0eXBlZEFycmF5Q3RvcnMubGVuZ3RoID4gaWR4OyBpZHgrKykge1xuICAgIGlmICh0YSBpbnN0YW5jZW9mIHR5cGVkQXJyYXlDdG9yc1tpZHhdKSB7XG4gICAgICBjdG9yID0gdHlwZWRBcnJheUN0b3JzW2lkeF07XG4gICAgfVxuICB9XG4gIHJldHVybiBjdG9yO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJ1ZmZlcihhLCBiKSB7XG4gIC8vIFRPRE86IHNob3VsZCB0aGlzIGJlIGEgY29weSwgb3IgdGhlIHJlZmVyZW5jZSBpdHNlbGY/XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICBiID0gQnVmZmVyLmZyb20oYik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIEN0b3IgPSBmaW5kVHlwZWRBcnJheUZvcihiKTtcbiAgICBiID0gQ3RvciA/XG4gICAgICAgIG5ldyBDdG9yKGIsIGIuYnl0ZU9mZnNldCwgYi5ieXRlTGVuZ3RoKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRPRE86IFFVRVNUSU9OOiBjcmVhdGUgYSBtZXJnZWQgPHdoYXRldmVyLWEtaXM+Pz9cbiAgLy8gZm9yIG5vdywgYSBpcyBiXG4gIGEgPSBiO1xuXG4gIHJldHVybiBiO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnRpYWxSaWdodChtZXJnZSwgbWVyZ2VCdWZmZXIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/merge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/lib/util/utf8.js":
/*!*************************************************!*\
  !*** ./node_modules/node-jose/lib/util/utf8.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*!\n * util/utf8.js - Implementation of UTF-8 Encoder/Decoder\n *\n * Copyright (c) 2015 Cisco Systems, Inc. See LICENSE file.\n */\n\n\nvar utf8 = exports;\n\nutf8.encode = function(input) {\n  var output = encodeURIComponent(input || \"\");\n  output = output.replace(/%([0-9a-fA-F]{2})/g, function(m, code) {\n    code = parseInt(code, 16);\n    return String.fromCharCode(code);\n  });\n\n  return output;\n};\nutf8.decode = function(input) {\n  var output = (input || \"\").replace(/[\\u0080-\\u00ff]/g, function(m) {\n    var code = (0x100 | m.charCodeAt(0)).toString(16).substring(1);\n    return \"%\" + code;\n  });\n  output = decodeURIComponent(output);\n\n  return output;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL2xpYi91dGlsL3V0ZjguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2UvbGliL3V0aWwvdXRmOC5qcz9hZmNhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogdXRpbC91dGY4LmpzIC0gSW1wbGVtZW50YXRpb24gb2YgVVRGLTggRW5jb2Rlci9EZWNvZGVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IENpc2NvIFN5c3RlbXMsIEluYy4gU2VlIExJQ0VOU0UgZmlsZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGY4ID0gZXhwb3J0cztcblxudXRmOC5lbmNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0IHx8IFwiXCIpO1xuICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvJShbMC05YS1mQS1GXXsyfSkvZywgZnVuY3Rpb24obSwgY29kZSkge1xuICAgIGNvZGUgPSBwYXJzZUludChjb2RlLCAxNik7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH0pO1xuXG4gIHJldHVybiBvdXRwdXQ7XG59O1xudXRmOC5kZWNvZGUgPSBmdW5jdGlvbihpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gKGlucHV0IHx8IFwiXCIpLnJlcGxhY2UoL1tcXHUwMDgwLVxcdTAwZmZdL2csIGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgY29kZSA9ICgweDEwMCB8IG0uY2hhckNvZGVBdCgwKSkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICByZXR1cm4gXCIlXCIgKyBjb2RlO1xuICB9KTtcbiAgb3V0cHV0ID0gZGVjb2RlVVJJQ29tcG9uZW50KG91dHB1dCk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/lib/util/utf8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvaW5kZXguanM/ZjNlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsU0FBUyx3REFBaUI7QUFDMUI7O0FBRUEsaUVBQWUsR0FBRyIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9tZDUuanM/YTY1YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnbWQ1JykudXBkYXRlKGJ5dGVzKS5kaWdlc3QoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  randomUUID: (crypto__WEBPACK_IMPORTED_MODULE_0___default().randomUUID)\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1QixpRUFBZTtBQUNmLGNBQWMsMERBQWlCO0FBQy9CLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmF0aXZlLmpzPzM1YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nO1xuZXhwb3J0IGRlZmF1bHQge1xuICByYW5kb21VVUlEOiBjcnlwdG8ucmFuZG9tVVVJRFxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvbmlsLmpzPzRmYzMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/nil.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcGFyc2UuanM/MjZhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcmVnZXguanM/NGE5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE0QjtBQUM1Qix1Q0FBdUM7O0FBRXZDO0FBQ2U7QUFDZjtBQUNBLElBQUksNERBQXFCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS9ybmcuanM/NGUwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0byc7XG5jb25zdCBybmRzOFBvb2wgPSBuZXcgVWludDhBcnJheSgyNTYpOyAvLyAjIG9mIHJhbmRvbSB2YWx1ZXMgdG8gcHJlLWFsbG9jYXRlXG5cbmxldCBwb29sUHRyID0gcm5kczhQb29sLmxlbmd0aDtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgaWYgKHBvb2xQdHIgPiBybmRzOFBvb2wubGVuZ3RoIC0gMTYpIHtcbiAgICBjcnlwdG8ucmFuZG9tRmlsbFN5bmMocm5kczhQb29sKTtcbiAgICBwb29sUHRyID0gMDtcbiAgfVxuXG4gIHJldHVybiBybmRzOFBvb2wuc2xpY2UocG9vbFB0ciwgcG9vbFB0ciArPSAxNik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLFNBQVMsd0RBQWlCO0FBQzFCOztBQUVBLGlFQUFlLElBQUkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc2hhMS5qcz9jMDk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICBpZiAoQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICBieXRlcyA9IEJ1ZmZlci5mcm9tKGJ5dGVzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgYnl0ZXMgPSBCdWZmZXIuZnJvbShieXRlcywgJ3V0ZjgnKTtcbiAgfVxuXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShieXRlcykuZGlnZXN0KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL25vZGUtam9zZS9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1ub2RlL3N0cmluZ2lmeS5qcz8yM2QyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zYWZlU3RyaW5naWZ5KGFyciwgb2Zmc2V0ID0gMCkge1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgcmV0dXJuIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ3NCLENBQUM7QUFDbEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWU7OztBQUdmO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0QsK0NBQUc7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0Esd0VBQXdFO0FBQ3hFOztBQUVBLDRFQUE0RTs7QUFFNUUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7O0FBRXhCLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCLG9DQUFvQzs7QUFFcEMsOEJBQThCOztBQUU5QixrQ0FBa0M7O0FBRWxDLDRCQUE0Qjs7QUFFNUIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQSxnQkFBZ0IsOERBQWU7QUFDL0I7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MS5qcz9jNzFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsV0FBVyxtREFBRyxhQUFhLCtDQUFHO0FBQzlCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjMuanM/OTA2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v3.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js":
/*!***********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* binding */ v35)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ2xCOztBQUUvQjtBQUNBLDJDQUEyQzs7QUFFM0M7O0FBRUEsa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDQTtBQUNRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyw4REFBZTtBQUMxQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9ub2RlLWpvc2Uvbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tbm9kZS92MzUuanM/NjAxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICBjb25zdCBieXRlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCBjb25zdCBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBjb25zdCBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHYzNShuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgX25hbWVzcGFjZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAoKChfbmFtZXNwYWNlID0gbmFtZXNwYWNlKSA9PT0gbnVsbCB8fCBfbmFtZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmFtZXNwYWNlLmxlbmd0aCkgIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpQztBQUNOO0FBQ3NCOztBQUVqRDtBQUNBLE1BQU0sa0RBQU07QUFDWixXQUFXLGtEQUFNO0FBQ2pCOztBQUVBO0FBQ0EsaURBQWlELCtDQUFHLEtBQUs7O0FBRXpEO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDhEQUFlO0FBQ3hCOztBQUVBLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjQuanM/NGU4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v4.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsV0FBVyxtREFBRyxhQUFhLGdEQUFJO0FBQy9CLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdjUuanM/OTJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/v5.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmFsaWRhdGUuanM/YjdkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvbm9kZS1qb3NlL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLW5vZGUvdmVyc2lvbi5qcz9iNTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE1KSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/node-jose/node_modules/uuid/dist/esm-node/version.js\n");

/***/ })

};
;