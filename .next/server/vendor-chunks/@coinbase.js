"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@coinbase";
exports.ids = ["vendor-chunks/@coinbase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js":
/*!****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/api.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OnchainIdentityApiAxiosParamCreator = exports.NetworksApi = exports.NetworksApiFactory = exports.NetworksApiFp = exports.NetworksApiAxiosParamCreator = exports.FundApi = exports.FundApiFactory = exports.FundApiFp = exports.FundApiAxiosParamCreator = exports.ExternalAddressesApi = exports.ExternalAddressesApiFactory = exports.ExternalAddressesApiFp = exports.ExternalAddressesApiAxiosParamCreator = exports.ContractInvocationsApi = exports.ContractInvocationsApiFactory = exports.ContractInvocationsApiFp = exports.ContractInvocationsApiAxiosParamCreator = exports.ContractEventsApi = exports.ContractEventsApiFactory = exports.ContractEventsApiFp = exports.ContractEventsApiAxiosParamCreator = exports.BalanceHistoryApi = exports.BalanceHistoryApiFactory = exports.BalanceHistoryApiFp = exports.BalanceHistoryApiAxiosParamCreator = exports.AssetsApi = exports.AssetsApiFactory = exports.AssetsApiFp = exports.AssetsApiAxiosParamCreator = exports.AddressesApi = exports.AddressesApiFactory = exports.AddressesApiFp = exports.AddressesApiAxiosParamCreator = exports.WebhookEventType = exports.WalletServerSignerStatusEnum = exports.ValidatorStatus = exports.TransferStatusEnum = exports.TransactionType = exports.TransactionStatusEnum = exports.TokenTransferType = exports.StakingRewardFormat = exports.StakingRewardStateEnum = exports.StakingOperationStatusEnum = exports.SponsoredSendStatusEnum = exports.SolidityValueTypeEnum = exports.SmartContractType = exports.PayloadSignatureStatusEnum = exports.NetworkIdentifier = exports.NetworkProtocolFamilyEnum = exports.FundOperationStatusEnum = void 0;\nexports.WebhooksApi = exports.WebhooksApiFactory = exports.WebhooksApiFp = exports.WebhooksApiAxiosParamCreator = exports.WalletsApi = exports.WalletsApiFactory = exports.WalletsApiFp = exports.WalletsApiAxiosParamCreator = exports.WalletStakeApi = exports.WalletStakeApiFactory = exports.WalletStakeApiFp = exports.WalletStakeApiAxiosParamCreator = exports.ValidatorsApi = exports.ValidatorsApiFactory = exports.ValidatorsApiFp = exports.ValidatorsApiAxiosParamCreator = exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.TransfersApi = exports.TransfersApiFactory = exports.TransfersApiFp = exports.TransfersApiAxiosParamCreator = exports.TransactionHistoryApi = exports.TransactionHistoryApiFactory = exports.TransactionHistoryApiFp = exports.TransactionHistoryApiAxiosParamCreator = exports.TradesApi = exports.TradesApiFactory = exports.TradesApiFp = exports.TradesApiAxiosParamCreator = exports.StakeApi = exports.StakeApiFactory = exports.StakeApiFp = exports.StakeApiAxiosParamCreator = exports.SmartContractsApi = exports.SmartContractsApiFactory = exports.SmartContractsApiFp = exports.SmartContractsApiAxiosParamCreator = exports.ServerSignersApi = exports.ServerSignersApiFactory = exports.ServerSignersApiFp = exports.ServerSignersApiAxiosParamCreator = exports.ResolveIdentityByAddressRolesEnum = exports.OnchainIdentityApi = exports.OnchainIdentityApiFactory = exports.OnchainIdentityApiFp = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\n// Some imports not used depending on template conditions\n// @ts-ignore\nconst common_1 = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\");\n// @ts-ignore\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nexports.FundOperationStatusEnum = {\n    Pending: 'pending',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.NetworkProtocolFamilyEnum = {\n    Evm: 'evm',\n    Solana: 'solana'\n};\n/**\n * The ID of the blockchain network. This is unique across all networks, and takes the form of `<blockchain>-<network>`.\n * @export\n * @enum {string}\n */\nexports.NetworkIdentifier = {\n    BaseSepolia: 'base-sepolia',\n    BaseMainnet: 'base-mainnet',\n    EthereumHolesky: 'ethereum-holesky',\n    EthereumMainnet: 'ethereum-mainnet',\n    PolygonMainnet: 'polygon-mainnet',\n    SolanaDevnet: 'solana-devnet',\n    SolanaMainnet: 'solana-mainnet',\n    ArbitrumMainnet: 'arbitrum-mainnet'\n};\nexports.PayloadSignatureStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Failed: 'failed'\n};\n/**\n * The type of the smart contract.\n * @export\n * @enum {string}\n */\nexports.SmartContractType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155'\n};\nexports.SolidityValueTypeEnum = {\n    Uint8: 'uint8',\n    Uint16: 'uint16',\n    Uint32: 'uint32',\n    Uint64: 'uint64',\n    Uint128: 'uint128',\n    Uint256: 'uint256',\n    Int8: 'int8',\n    Int16: 'int16',\n    Int32: 'int32',\n    Int64: 'int64',\n    Int128: 'int128',\n    Int256: 'int256',\n    Address: 'address',\n    Bool: 'bool',\n    String: 'string',\n    Bytes: 'bytes',\n    Bytes1: 'bytes1',\n    Bytes2: 'bytes2',\n    Bytes3: 'bytes3',\n    Bytes4: 'bytes4',\n    Bytes5: 'bytes5',\n    Bytes6: 'bytes6',\n    Bytes7: 'bytes7',\n    Bytes8: 'bytes8',\n    Bytes9: 'bytes9',\n    Bytes10: 'bytes10',\n    Bytes11: 'bytes11',\n    Bytes12: 'bytes12',\n    Bytes13: 'bytes13',\n    Bytes14: 'bytes14',\n    Bytes15: 'bytes15',\n    Bytes16: 'bytes16',\n    Bytes17: 'bytes17',\n    Bytes18: 'bytes18',\n    Bytes19: 'bytes19',\n    Bytes20: 'bytes20',\n    Bytes21: 'bytes21',\n    Bytes22: 'bytes22',\n    Bytes23: 'bytes23',\n    Bytes24: 'bytes24',\n    Bytes25: 'bytes25',\n    Bytes26: 'bytes26',\n    Bytes27: 'bytes27',\n    Bytes28: 'bytes28',\n    Bytes29: 'bytes29',\n    Bytes30: 'bytes30',\n    Bytes31: 'bytes31',\n    Bytes32: 'bytes32',\n    Array: 'array',\n    Tuple: 'tuple'\n};\nexports.SponsoredSendStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Submitted: 'submitted',\n    Complete: 'complete',\n    Failed: 'failed'\n};\nexports.StakingOperationStatusEnum = {\n    Initialized: 'initialized',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\nexports.StakingRewardStateEnum = {\n    Pending: 'pending',\n    Distributed: 'distributed'\n};\n/**\n * The format in which the rewards are to be fetched i.e native or in equivalent USD\n * @export\n * @enum {string}\n */\nexports.StakingRewardFormat = {\n    Usd: 'usd',\n    Native: 'native'\n};\n/**\n * The type of the token transfer.\n * @export\n * @enum {string}\n */\nexports.TokenTransferType = {\n    Erc20: 'erc20',\n    Erc721: 'erc721',\n    Erc1155: 'erc1155',\n    Unknown: 'unknown'\n};\nexports.TransactionStatusEnum = {\n    Pending: 'pending',\n    Signed: 'signed',\n    Broadcast: 'broadcast',\n    Complete: 'complete',\n    Failed: 'failed',\n    Unspecified: 'unspecified'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.TransactionType = {\n    Transfer: 'transfer'\n};\nexports.TransferStatusEnum = {\n    Pending: 'pending',\n    Broadcast: 'broadcast',\n    Complete: 'complete',\n    Failed: 'failed'\n};\n/**\n * The status of the validator.\n * @export\n * @enum {string}\n */\nexports.ValidatorStatus = {\n    Unknown: 'unknown',\n    Provisioning: 'provisioning',\n    Provisioned: 'provisioned',\n    Deposited: 'deposited',\n    PendingActivation: 'pending_activation',\n    Active: 'active',\n    Exiting: 'exiting',\n    Exited: 'exited',\n    WithdrawalAvailable: 'withdrawal_available',\n    WithdrawalComplete: 'withdrawal_complete',\n    ActiveSlashed: 'active_slashed',\n    ExitedSlashed: 'exited_slashed',\n    Reaped: 'reaped'\n};\nexports.WalletServerSignerStatusEnum = {\n    PendingSeedCreation: 'pending_seed_creation',\n    ActiveSeed: 'active_seed'\n};\n/**\n *\n * @export\n * @enum {string}\n */\nexports.WebhookEventType = {\n    Unspecified: 'unspecified',\n    Erc20Transfer: 'erc20_transfer',\n    Erc721Transfer: 'erc721_transfer',\n    WalletActivity: 'wallet_activity'\n};\n/**\n * AddressesApi - axios parameter creator\n * @export\n */\nconst AddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress: async (walletId, createAddressRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createAddress', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAddressRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature: async (walletId, addressId, createPayloadSignatureRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createPayloadSignature', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createPayloadSignatureRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress: async (walletId, addressId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddress', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature: async (walletId, addressId, payloadSignatureId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'addressId', addressId);\n            // verify required parameter 'payloadSignatureId' is not null or undefined\n            (0, common_1.assertParamExists)('getPayloadSignature', 'payloadSignatureId', payloadSignatureId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures/{payload_signature_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"payload_signature_id\"}}`, encodeURIComponent(String(payloadSignatureId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances: async (walletId, addressId, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses: async (walletId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddresses', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listPayloadSignatures', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/payload_signatures`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds: async (walletId, addressId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AddressesApiAxiosParamCreator = AddressesApiAxiosParamCreator;\n/**\n * AddressesApi - functional programming interface\n * @export\n */\nconst AddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createAddress(walletId, createAddressRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createAddress(walletId, createAddressRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.createPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddress(walletId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddress(walletId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAddressBalance(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressBalance(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayloadSignature(walletId, addressId, payloadSignatureId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.getPayloadSignature']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressBalances(walletId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressBalances(walletId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddresses(walletId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddresses(walletId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listAddresses']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listPayloadSignatures(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listPayloadSignatures(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.listPayloadSignatures']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async requestFaucetFunds(walletId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestFaucetFunds(walletId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AddressesApi.requestFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AddressesApiFp = AddressesApiFp;\n/**\n * AddressesApi - factory interface\n * @export\n */\nconst AddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AddressesApiFp)(configuration);\n    return {\n        /**\n         * Create a new address scoped to the wallet.\n         * @summary Create a new address\n         * @param {string} walletId The ID of the wallet to create the address in.\n         * @param {CreateAddressRequest} [createAddressRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createAddress(walletId, createAddressRequest, options) {\n            return localVarFp.createAddress(walletId, createAddressRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new payload signature with an address.\n         * @summary Create a new payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to sign the payload with.\n         * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n            return localVarFp.createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address\n         * @summary Get address by onchain address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddress(walletId, addressId, options) {\n            return localVarFp.getAddress(walletId, addressId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balance\n         * @summary Get address balance for asset\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAddressBalance(walletId, addressId, assetId, options) {\n            return localVarFp.getAddressBalance(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get payload signature.\n         * @summary Get payload signature.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that signed the payload.\n         * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n            return localVarFp.getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get address balances\n         * @summary Get all balances for address\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressBalances(walletId, addressId, page, options) {\n            return localVarFp.listAddressBalances(walletId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List addresses in the wallet.\n         * @summary List addresses in a wallet.\n         * @param {string} walletId The ID of the wallet whose addresses to fetch\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddresses(walletId, limit, page, options) {\n            return localVarFp.listAddresses(walletId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List payload signatures for an address.\n         * @summary List payload signatures for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listPayloadSignatures(walletId, addressId, limit, page, options) {\n            return localVarFp.listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to onchain address.\n         * @summary Request faucet funds for onchain address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        requestFaucetFunds(walletId, addressId, assetId, options) {\n            return localVarFp.requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AddressesApiFactory = AddressesApiFactory;\n/**\n * AddressesApi - object-oriented interface\n * @export\n * @class AddressesApi\n * @extends {BaseAPI}\n */\nclass AddressesApi extends base_1.BaseAPI {\n    /**\n     * Create a new address scoped to the wallet.\n     * @summary Create a new address\n     * @param {string} walletId The ID of the wallet to create the address in.\n     * @param {CreateAddressRequest} [createAddressRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createAddress(walletId, createAddressRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createAddress(walletId, createAddressRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new payload signature with an address.\n     * @summary Create a new payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to sign the payload with.\n     * @param {CreatePayloadSignatureRequest} [createPayloadSignatureRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).createPayloadSignature(walletId, addressId, createPayloadSignatureRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address\n     * @summary Get address by onchain address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddress(walletId, addressId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddress(walletId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balance\n     * @summary Get address balance for asset\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getAddressBalance(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getAddressBalance(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get payload signature.\n     * @summary Get payload signature.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that signed the payload.\n     * @param {string} payloadSignatureId The ID of the payload signature to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    getPayloadSignature(walletId, addressId, payloadSignatureId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).getPayloadSignature(walletId, addressId, payloadSignatureId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get address balances\n     * @summary Get all balances for address\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddressBalances(walletId, addressId, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddressBalances(walletId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List addresses in the wallet.\n     * @summary List addresses in a wallet.\n     * @param {string} walletId The ID of the wallet whose addresses to fetch\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listAddresses(walletId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listAddresses(walletId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List payload signatures for an address.\n     * @summary List payload signatures for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address whose payload signatures to fetch.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    listPayloadSignatures(walletId, addressId, limit, page, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).listPayloadSignatures(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to onchain address.\n     * @summary Request faucet funds for onchain address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof AddressesApi\n     */\n    requestFaucetFunds(walletId, addressId, assetId, options) {\n        return (0, exports.AddressesApiFp)(this.configuration).requestFaucetFunds(walletId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AddressesApi = AddressesApi;\n/**\n * AssetsApi - axios parameter creator\n * @export\n */\nconst AssetsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset: async (networkId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getAsset', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.AssetsApiAxiosParamCreator = AssetsApiAxiosParamCreator;\n/**\n * AssetsApi - functional programming interface\n * @export\n */\nconst AssetsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.AssetsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getAsset(networkId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getAsset(networkId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['AssetsApi.getAsset']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.AssetsApiFp = AssetsApiFp;\n/**\n * AssetsApi - factory interface\n * @export\n */\nconst AssetsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.AssetsApiFp)(configuration);\n    return {\n        /**\n         * Get the asset for the specified asset ID.\n         * @summary Get the asset for the specified asset ID.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getAsset(networkId, assetId, options) {\n            return localVarFp.getAsset(networkId, assetId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.AssetsApiFactory = AssetsApiFactory;\n/**\n * AssetsApi - object-oriented interface\n * @export\n * @class AssetsApi\n * @extends {BaseAPI}\n */\nclass AssetsApi extends base_1.BaseAPI {\n    /**\n     * Get the asset for the specified asset ID.\n     * @summary Get the asset for the specified asset ID.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} assetId The ID of the asset to fetch. This could be a symbol or an ERC20 contract address.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof AssetsApi\n     */\n    getAsset(networkId, assetId, options) {\n        return (0, exports.AssetsApiFp)(this.configuration).getAsset(networkId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.AssetsApi = AssetsApi;\n/**\n * BalanceHistoryApi - axios parameter creator\n * @export\n */\nconst BalanceHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance: async (networkId, addressId, assetId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressHistoricalBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balance_history/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.BalanceHistoryApiAxiosParamCreator = BalanceHistoryApiAxiosParamCreator;\n/**\n * BalanceHistoryApi - functional programming interface\n * @export\n */\nconst BalanceHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.BalanceHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['BalanceHistoryApi.listAddressHistoricalBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.BalanceHistoryApiFp = BalanceHistoryApiFp;\n/**\n * BalanceHistoryApi - factory interface\n * @export\n */\nconst BalanceHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.BalanceHistoryApiFp)(configuration);\n    return {\n        /**\n         * List the historical balance of an asset in a specific address.\n         * @summary Get address balance history for asset\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the historical balance for.\n         * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n            return localVarFp.listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.BalanceHistoryApiFactory = BalanceHistoryApiFactory;\n/**\n * BalanceHistoryApi - object-oriented interface\n * @export\n * @class BalanceHistoryApi\n * @extends {BaseAPI}\n */\nclass BalanceHistoryApi extends base_1.BaseAPI {\n    /**\n     * List the historical balance of an asset in a specific address.\n     * @summary Get address balance history for asset\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the historical balance for.\n     * @param {string} assetId The symbol of the asset to fetch the historical balance for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof BalanceHistoryApi\n     */\n    listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options) {\n        return (0, exports.BalanceHistoryApiFp)(this.configuration).listAddressHistoricalBalance(networkId, addressId, assetId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.BalanceHistoryApi = BalanceHistoryApi;\n/**\n * ContractEventsApi - axios parameter creator\n * @export\n */\nconst ContractEventsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents: async (networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'networkId', networkId);\n            // verify required parameter 'protocolName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'protocolName', protocolName);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractAddress', contractAddress);\n            // verify required parameter 'contractName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'contractName', contractName);\n            // verify required parameter 'eventName' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'eventName', eventName);\n            // verify required parameter 'fromBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'fromBlockHeight', fromBlockHeight);\n            // verify required parameter 'toBlockHeight' is not null or undefined\n            (0, common_1.assertParamExists)('listContractEvents', 'toBlockHeight', toBlockHeight);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/events`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (protocolName !== undefined) {\n                localVarQueryParameter['protocol_name'] = protocolName;\n            }\n            if (contractName !== undefined) {\n                localVarQueryParameter['contract_name'] = contractName;\n            }\n            if (eventName !== undefined) {\n                localVarQueryParameter['event_name'] = eventName;\n            }\n            if (fromBlockHeight !== undefined) {\n                localVarQueryParameter['from_block_height'] = fromBlockHeight;\n            }\n            if (toBlockHeight !== undefined) {\n                localVarQueryParameter['to_block_height'] = toBlockHeight;\n            }\n            if (nextPage !== undefined) {\n                localVarQueryParameter['next_page'] = nextPage;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractEventsApiAxiosParamCreator = ContractEventsApiAxiosParamCreator;\n/**\n * ContractEventsApi - functional programming interface\n * @export\n */\nconst ContractEventsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractEventsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractEventsApi.listContractEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractEventsApiFp = ContractEventsApiFp;\n/**\n * ContractEventsApi - factory interface\n * @export\n */\nconst ContractEventsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractEventsApiFp)(configuration);\n    return {\n        /**\n         * Retrieve events for a specific contract\n         * @summary List contract events\n         * @param {string} networkId Unique identifier for the blockchain network\n         * @param {string} protocolName Case-sensitive name of the blockchain protocol\n         * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n         * @param {string} contractName Case-sensitive name of the specific contract within the project\n         * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n         * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n         * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n         * @param {string} [nextPage] Pagination token for retrieving the next set of results\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n            return localVarFp.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractEventsApiFactory = ContractEventsApiFactory;\n/**\n * ContractEventsApi - object-oriented interface\n * @export\n * @class ContractEventsApi\n * @extends {BaseAPI}\n */\nclass ContractEventsApi extends base_1.BaseAPI {\n    /**\n     * Retrieve events for a specific contract\n     * @summary List contract events\n     * @param {string} networkId Unique identifier for the blockchain network\n     * @param {string} protocolName Case-sensitive name of the blockchain protocol\n     * @param {string} contractAddress EVM address of the smart contract (42 characters, including \\&#39;0x\\&#39;, in lowercase)\n     * @param {string} contractName Case-sensitive name of the specific contract within the project\n     * @param {string} eventName Case-sensitive name of the event to filter for in the contract\\&#39;s logs\n     * @param {number} fromBlockHeight Lower bound of the block range to query (inclusive)\n     * @param {number} toBlockHeight Upper bound of the block range to query (inclusive)\n     * @param {string} [nextPage] Pagination token for retrieving the next set of results\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractEventsApi\n     */\n    listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options) {\n        return (0, exports.ContractEventsApiFp)(this.configuration).listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, nextPage, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractEventsApi = ContractEventsApi;\n/**\n * ContractInvocationsApi - axios parameter creator\n * @export\n */\nconst ContractInvocationsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation: async (walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'contractInvocationId', contractInvocationId);\n            // verify required parameter 'broadcastContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastContractInvocation', 'broadcastContractInvocationRequest', broadcastContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation: async (walletId, addressId, createContractInvocationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'addressId', addressId);\n            // verify required parameter 'createContractInvocationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createContractInvocation', 'createContractInvocationRequest', createContractInvocationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContractInvocationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation: async (walletId, addressId, contractInvocationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'addressId', addressId);\n            // verify required parameter 'contractInvocationId' is not null or undefined\n            (0, common_1.assertParamExists)('getContractInvocation', 'contractInvocationId', contractInvocationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations/{contract_invocation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"contract_invocation_id\"}}`, encodeURIComponent(String(contractInvocationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listContractInvocations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/contract_invocations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ContractInvocationsApiAxiosParamCreator = ContractInvocationsApiAxiosParamCreator;\n/**\n * ContractInvocationsApi - functional programming interface\n * @export\n */\nconst ContractInvocationsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ContractInvocationsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.broadcastContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractInvocation(walletId, addressId, createContractInvocationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.createContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractInvocation(walletId, addressId, contractInvocationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.getContractInvocation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listContractInvocations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listContractInvocations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ContractInvocationsApi.listContractInvocations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ContractInvocationsApiFp = ContractInvocationsApiFp;\n/**\n * ContractInvocationsApi - factory interface\n * @export\n */\nconst ContractInvocationsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ContractInvocationsApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a contract invocation.\n         * @summary Broadcast a contract invocation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n         * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n            return localVarFp.broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new contract invocation.\n         * @summary Create a new contract invocation for an address.\n         * @param {string} walletId The ID of the wallet the source address belongs to.\n         * @param {string} addressId The ID of the address to invoke the contract from.\n         * @param {CreateContractInvocationRequest} createContractInvocationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n            return localVarFp.createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a contract invocation by ID.\n         * @summary Get a contract invocation by ID.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the contract invocation belongs to.\n         * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getContractInvocation(walletId, addressId, contractInvocationId, options) {\n            return localVarFp.getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List contract invocations for an address.\n         * @summary List contract invocations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to list contract invocations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listContractInvocations(walletId, addressId, limit, page, options) {\n            return localVarFp.listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ContractInvocationsApiFactory = ContractInvocationsApiFactory;\n/**\n * ContractInvocationsApi - object-oriented interface\n * @export\n * @class ContractInvocationsApi\n * @extends {BaseAPI}\n */\nclass ContractInvocationsApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a contract invocation.\n     * @summary Broadcast a contract invocation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to broadcast.\n     * @param {BroadcastContractInvocationRequest} broadcastContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).broadcastContractInvocation(walletId, addressId, contractInvocationId, broadcastContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new contract invocation.\n     * @summary Create a new contract invocation for an address.\n     * @param {string} walletId The ID of the wallet the source address belongs to.\n     * @param {string} addressId The ID of the address to invoke the contract from.\n     * @param {CreateContractInvocationRequest} createContractInvocationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    createContractInvocation(walletId, addressId, createContractInvocationRequest, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).createContractInvocation(walletId, addressId, createContractInvocationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a contract invocation by ID.\n     * @summary Get a contract invocation by ID.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the contract invocation belongs to.\n     * @param {string} contractInvocationId The ID of the contract invocation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    getContractInvocation(walletId, addressId, contractInvocationId, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).getContractInvocation(walletId, addressId, contractInvocationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List contract invocations for an address.\n     * @summary List contract invocations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to list contract invocations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ContractInvocationsApi\n     */\n    listContractInvocations(walletId, addressId, limit, page, options) {\n        return (0, exports.ContractInvocationsApiFp)(this.configuration).listContractInvocations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ContractInvocationsApi = ContractInvocationsApi;\n/**\n * ExternalAddressesApi - axios parameter creator\n * @export\n */\nconst ExternalAddressesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance: async (networkId, addressId, assetId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'addressId', addressId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalAddressBalance', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances/{asset_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction: async (networkId, addressId, txHash, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'addressId', addressId);\n            // verify required parameter 'txHash' is not null or undefined\n            (0, common_1.assertParamExists)('getFaucetTransaction', 'txHash', txHash);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet/{tx_hash}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"tx_hash\"}}`, encodeURIComponent(String(txHash)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances: async (networkId, addressId, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listExternalAddressBalances', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds: async (networkId, addressId, assetId, skipWait, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('requestExternalFaucetFunds', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/faucet`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (skipWait !== undefined) {\n                localVarQueryParameter['skip_wait'] = skipWait;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ExternalAddressesApiAxiosParamCreator = ExternalAddressesApiAxiosParamCreator;\n/**\n * ExternalAddressesApi - functional programming interface\n * @export\n */\nconst ExternalAddressesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ExternalAddressesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalAddressBalance(networkId, addressId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAddressBalance(networkId, addressId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getExternalAddressBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFaucetTransaction(networkId, addressId, txHash, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaucetTransaction(networkId, addressId, txHash, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.getFaucetTransaction']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listExternalAddressBalances(networkId, addressId, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listExternalAddressBalances(networkId, addressId, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.listExternalAddressBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ExternalAddressesApi.requestExternalFaucetFunds']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ExternalAddressesApiFp = ExternalAddressesApiFp;\n/**\n * ExternalAddressesApi - factory interface\n * @export\n */\nconst ExternalAddressesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ExternalAddressesApiFp)(configuration);\n    return {\n        /**\n         * Get the balance of an asset in an external address\n         * @summary Get the balance of an asset in an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} assetId The ID of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalAddressBalance(networkId, addressId, assetId, options) {\n            return localVarFp.getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the status of a faucet transaction\n         * @summary Get the status of a faucet transaction\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the faucet transaction for\n         * @param {string} txHash The hash of the faucet transaction\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFaucetTransaction(networkId, addressId, txHash, options) {\n            return localVarFp.getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all of the balances of an external address\n         * @summary Get the balances of an external address\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the balance for\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listExternalAddressBalances(networkId, addressId, page, options) {\n            return localVarFp.listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Request faucet funds to be sent to external address.\n         * @summary Request faucet funds for external address.\n         * @param {string} networkId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that is being fetched.\n         * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n         * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n            return localVarFp.requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ExternalAddressesApiFactory = ExternalAddressesApiFactory;\n/**\n * ExternalAddressesApi - object-oriented interface\n * @export\n * @class ExternalAddressesApi\n * @extends {BaseAPI}\n */\nclass ExternalAddressesApi extends base_1.BaseAPI {\n    /**\n     * Get the balance of an asset in an external address\n     * @summary Get the balance of an asset in an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} assetId The ID of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getExternalAddressBalance(networkId, addressId, assetId, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getExternalAddressBalance(networkId, addressId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the status of a faucet transaction\n     * @summary Get the status of a faucet transaction\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the faucet transaction for\n     * @param {string} txHash The hash of the faucet transaction\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    getFaucetTransaction(networkId, addressId, txHash, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).getFaucetTransaction(networkId, addressId, txHash, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List all of the balances of an external address\n     * @summary Get the balances of an external address\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the balance for\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    listExternalAddressBalances(networkId, addressId, page, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).listExternalAddressBalances(networkId, addressId, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Request faucet funds to be sent to external address.\n     * @summary Request faucet funds for external address.\n     * @param {string} networkId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that is being fetched.\n     * @param {string} [assetId] The ID of the asset to transfer from the faucet.\n     * @param {boolean} [skipWait] Whether to skip waiting for the transaction to be mined. This will become the default behavior in the future.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ExternalAddressesApi\n     */\n    requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options) {\n        return (0, exports.ExternalAddressesApiFp)(this.configuration).requestExternalFaucetFunds(networkId, addressId, assetId, skipWait, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ExternalAddressesApi = ExternalAddressesApi;\n/**\n * FundApi - axios parameter creator\n * @export\n */\nconst FundApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation: async (walletId, addressId, createFundOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'addressId', addressId);\n            // verify required parameter 'createFundOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundOperation', 'createFundOperationRequest', createFundOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote: async (walletId, addressId, createFundQuoteRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'addressId', addressId);\n            // verify required parameter 'createFundQuoteRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createFundQuote', 'createFundQuoteRequest', createFundQuoteRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/quote`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createFundQuoteRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation: async (walletId, addressId, fundOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'addressId', addressId);\n            // verify required parameter 'fundOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getFundOperation', 'fundOperationId', fundOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations/{fund_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"fund_operation_id\"}}`, encodeURIComponent(String(fundOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listFundOperations', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/fund_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.FundApiAxiosParamCreator = FundApiAxiosParamCreator;\n/**\n * FundApi - functional programming interface\n * @export\n */\nconst FundApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.FundApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundOperation(walletId, addressId, createFundOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createFundQuote(walletId, addressId, createFundQuoteRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.createFundQuote']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getFundOperation(walletId, addressId, fundOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundOperation(walletId, addressId, fundOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.getFundOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listFundOperations(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listFundOperations(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['FundApi.listFundOperations']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.FundApiFp = FundApiFp;\n/**\n * FundApi - factory interface\n * @export\n */\nconst FundApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.FundApiFp)(configuration);\n    return {\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a new fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundOperationRequest} createFundOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n            return localVarFp.createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new fund operation with an address.\n         * @summary Create a Fund Operation quote.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address to be funded.\n         * @param {CreateFundQuoteRequest} createFundQuoteRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n            return localVarFp.createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get fund operation.\n         * @summary Get fund operation.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address that created the fund operation.\n         * @param {string} fundOperationId The ID of the fund operation to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getFundOperation(walletId, addressId, fundOperationId, options) {\n            return localVarFp.getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List fund operations for an address.\n         * @summary List fund operations for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The onchain address of the address to list fund operations for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listFundOperations(walletId, addressId, limit, page, options) {\n            return localVarFp.listFundOperations(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.FundApiFactory = FundApiFactory;\n/**\n * FundApi - object-oriented interface\n * @export\n * @class FundApi\n * @extends {BaseAPI}\n */\nclass FundApi extends base_1.BaseAPI {\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a new fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundOperationRequest} createFundOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundOperation(walletId, addressId, createFundOperationRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundOperation(walletId, addressId, createFundOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new fund operation with an address.\n     * @summary Create a Fund Operation quote.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address to be funded.\n     * @param {CreateFundQuoteRequest} createFundQuoteRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    createFundQuote(walletId, addressId, createFundQuoteRequest, options) {\n        return (0, exports.FundApiFp)(this.configuration).createFundQuote(walletId, addressId, createFundQuoteRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get fund operation.\n     * @summary Get fund operation.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address that created the fund operation.\n     * @param {string} fundOperationId The ID of the fund operation to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    getFundOperation(walletId, addressId, fundOperationId, options) {\n        return (0, exports.FundApiFp)(this.configuration).getFundOperation(walletId, addressId, fundOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List fund operations for an address.\n     * @summary List fund operations for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The onchain address of the address to list fund operations for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof FundApi\n     */\n    listFundOperations(walletId, addressId, limit, page, options) {\n        return (0, exports.FundApiFp)(this.configuration).listFundOperations(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.FundApi = FundApi;\n/**\n * NetworksApi - axios parameter creator\n * @export\n */\nconst NetworksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork: async (networkId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getNetwork', 'networkId', networkId);\n            const localVarPath = `/v1/networks/{network_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.NetworksApiAxiosParamCreator = NetworksApiAxiosParamCreator;\n/**\n * NetworksApi - functional programming interface\n * @export\n */\nconst NetworksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.NetworksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getNetwork(networkId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['NetworksApi.getNetwork']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.NetworksApiFp = NetworksApiFp;\n/**\n * NetworksApi - factory interface\n * @export\n */\nconst NetworksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.NetworksApiFp)(configuration);\n    return {\n        /**\n         * Get network\n         * @summary Get network by ID\n         * @param {string} networkId The ID of the network to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getNetwork(networkId, options) {\n            return localVarFp.getNetwork(networkId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.NetworksApiFactory = NetworksApiFactory;\n/**\n * NetworksApi - object-oriented interface\n * @export\n * @class NetworksApi\n * @extends {BaseAPI}\n */\nclass NetworksApi extends base_1.BaseAPI {\n    /**\n     * Get network\n     * @summary Get network by ID\n     * @param {string} networkId The ID of the network to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof NetworksApi\n     */\n    getNetwork(networkId, options) {\n        return (0, exports.NetworksApiFp)(this.configuration).getNetwork(networkId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.NetworksApi = NetworksApi;\n/**\n * OnchainIdentityApi - axios parameter creator\n * @export\n */\nconst OnchainIdentityApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress: async (networkId, addressId, roles, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('resolveIdentityByAddress', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/identity`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (roles) {\n                localVarQueryParameter['roles'] = roles.join(base_1.COLLECTION_FORMATS.csv);\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.OnchainIdentityApiAxiosParamCreator = OnchainIdentityApiAxiosParamCreator;\n/**\n * OnchainIdentityApi - functional programming interface\n * @export\n */\nconst OnchainIdentityApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.OnchainIdentityApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['OnchainIdentityApi.resolveIdentityByAddress']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.OnchainIdentityApiFp = OnchainIdentityApiFp;\n/**\n * OnchainIdentityApi - factory interface\n * @export\n */\nconst OnchainIdentityApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.OnchainIdentityApiFp)(configuration);\n    return {\n        /**\n         * Obtains onchain identity for an address on a specific network\n         * @summary Obtains onchain identity for an address on a specific network\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the identity for\n         * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n            return localVarFp.resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.OnchainIdentityApiFactory = OnchainIdentityApiFactory;\n/**\n * OnchainIdentityApi - object-oriented interface\n * @export\n * @class OnchainIdentityApi\n * @extends {BaseAPI}\n */\nclass OnchainIdentityApi extends base_1.BaseAPI {\n    /**\n     * Obtains onchain identity for an address on a specific network\n     * @summary Obtains onchain identity for an address on a specific network\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the identity for\n     * @param {Array<ResolveIdentityByAddressRolesEnum>} [roles] A filter by role of the names related to this address (managed or owned)\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof OnchainIdentityApi\n     */\n    resolveIdentityByAddress(networkId, addressId, roles, limit, page, options) {\n        return (0, exports.OnchainIdentityApiFp)(this.configuration).resolveIdentityByAddress(networkId, addressId, roles, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.OnchainIdentityApi = OnchainIdentityApi;\n/**\n * @export\n */\nexports.ResolveIdentityByAddressRolesEnum = {\n    Managed: 'managed',\n    Owned: 'owned'\n};\n/**\n * ServerSignersApi - axios parameter creator\n * @export\n */\nconst ServerSignersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner: async (createServerSignerRequest, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createServerSignerRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner: async (serverSignerId, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('getServerSigner', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents: async (serverSignerId, limit, page, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('listServerSignerEvents', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/events`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/server_signers`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult: async (serverSignerId, seedCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSeedEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/seed_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(seedCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult: async (serverSignerId, signatureCreationEventResult, options = {}) => {\n            // verify required parameter 'serverSignerId' is not null or undefined\n            (0, common_1.assertParamExists)('submitServerSignerSignatureEventResult', 'serverSignerId', serverSignerId);\n            const localVarPath = `/v1/server_signers/{server_signer_id}/signature_event_result`\n                .replace(`{${\"server_signer_id\"}}`, encodeURIComponent(String(serverSignerId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signatureCreationEventResult, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ServerSignersApiAxiosParamCreator = ServerSignersApiAxiosParamCreator;\n/**\n * ServerSignersApi - functional programming interface\n * @export\n */\nconst ServerSignersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ServerSignersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createServerSigner(createServerSignerRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createServerSigner(createServerSignerRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.createServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getServerSigner(serverSignerId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerSigner(serverSignerId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.getServerSigner']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        async listServerSignerEvents(serverSignerId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSignerEvents(serverSignerId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSignerEvents']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listServerSigners(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listServerSigners(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.listServerSigners']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSeedEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ServerSignersApi.submitServerSignerSignatureEventResult']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ServerSignersApiFp = ServerSignersApiFp;\n/**\n * ServerSignersApi - factory interface\n * @export\n */\nconst ServerSignersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ServerSignersApiFp)(configuration);\n    return {\n        /**\n         * Create a new Server-Signer\n         * @summary Create a new Server-Signer\n         * @param {CreateServerSignerRequest} [createServerSignerRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createServerSigner(createServerSignerRequest, options) {\n            return localVarFp.createServerSigner(createServerSignerRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a server signer by ID\n         * @summary Get a server signer by ID\n         * @param {string} serverSignerId The ID of the server signer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getServerSigner(serverSignerId, options) {\n            return localVarFp.getServerSigner(serverSignerId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List events for a server signer\n         * @summary List events for a server signer\n         * @param {string} serverSignerId The ID of the server signer to fetch events for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @deprecated\n         * @throws {RequiredError}\n         */\n        listServerSignerEvents(serverSignerId, limit, page, options) {\n            return localVarFp.listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List server signers for the current project\n         * @summary List server signers for the current project\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listServerSigners(limit, page, options) {\n            return localVarFp.listServerSigners(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SeedCreationEventResult} [seedCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n            return localVarFp.submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Submit the result of a server signer event\n         * @summary Submit the result of a server signer event\n         * @param {string} serverSignerId The ID of the server signer to submit the event result for\n         * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n            return localVarFp.submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ServerSignersApiFactory = ServerSignersApiFactory;\n/**\n * ServerSignersApi - object-oriented interface\n * @export\n * @class ServerSignersApi\n * @extends {BaseAPI}\n */\nclass ServerSignersApi extends base_1.BaseAPI {\n    /**\n     * Create a new Server-Signer\n     * @summary Create a new Server-Signer\n     * @param {CreateServerSignerRequest} [createServerSignerRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    createServerSigner(createServerSignerRequest, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).createServerSigner(createServerSignerRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a server signer by ID\n     * @summary Get a server signer by ID\n     * @param {string} serverSignerId The ID of the server signer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    getServerSigner(serverSignerId, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).getServerSigner(serverSignerId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List events for a server signer\n     * @summary List events for a server signer\n     * @param {string} serverSignerId The ID of the server signer to fetch events for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @deprecated\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSignerEvents(serverSignerId, limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSignerEvents(serverSignerId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List server signers for the current project\n     * @summary List server signers for the current project\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    listServerSigners(limit, page, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).listServerSigners(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SeedCreationEventResult} [seedCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSeedEventResult(serverSignerId, seedCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Submit the result of a server signer event\n     * @summary Submit the result of a server signer event\n     * @param {string} serverSignerId The ID of the server signer to submit the event result for\n     * @param {SignatureCreationEventResult} [signatureCreationEventResult]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ServerSignersApi\n     */\n    submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options) {\n        return (0, exports.ServerSignersApiFp)(this.configuration).submitServerSignerSignatureEventResult(serverSignerId, signatureCreationEventResult, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ServerSignersApi = ServerSignersApi;\n/**\n * SmartContractsApi - axios parameter creator\n * @export\n */\nconst SmartContractsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract: async (walletId, addressId, createSmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'addressId', addressId);\n            // verify required parameter 'createSmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createSmartContract', 'createSmartContractRequest', createSmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createSmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract: async (walletId, addressId, smartContractId, deploySmartContractRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'smartContractId', smartContractId);\n            // verify required parameter 'deploySmartContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('deploySmartContract', 'deploySmartContractRequest', deploySmartContractRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}/deploy`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(deploySmartContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract: async (walletId, addressId, smartContractId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'addressId', addressId);\n            // verify required parameter 'smartContractId' is not null or undefined\n            (0, common_1.assertParamExists)('getSmartContract', 'smartContractId', smartContractId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts/{smart_contract_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"smart_contract_id\"}}`, encodeURIComponent(String(smartContractId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List all smart contracts deployed by address.\n         * @summary List smart contracts deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contracts for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts: async (walletId, addressId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listSmartContracts', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listSmartContracts', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/smart_contracts`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract: async (networkId, contractAddress, readContractRequest, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'networkId', networkId);\n            // verify required parameter 'contractAddress' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'contractAddress', contractAddress);\n            // verify required parameter 'readContractRequest' is not null or undefined\n            (0, common_1.assertParamExists)('readContract', 'readContractRequest', readContractRequest);\n            const localVarPath = `/v1/networks/{network_id}/smart_contracts/{contract_address}/read`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"contract_address\"}}`, encodeURIComponent(String(contractAddress)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(readContractRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.SmartContractsApiAxiosParamCreator = SmartContractsApiAxiosParamCreator;\n/**\n * SmartContractsApi - functional programming interface\n * @export\n */\nconst SmartContractsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.SmartContractsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createSmartContract(walletId, addressId, createSmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.createSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.deploySmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getSmartContract(walletId, addressId, smartContractId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getSmartContract(walletId, addressId, smartContractId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.getSmartContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List all smart contracts deployed by address.\n         * @summary List smart contracts deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contracts for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listSmartContracts(walletId, addressId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listSmartContracts(walletId, addressId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.listSmartContracts']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async readContract(networkId, contractAddress, readContractRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.readContract(networkId, contractAddress, readContractRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['SmartContractsApi.readContract']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.SmartContractsApiFp = SmartContractsApiFp;\n/**\n * SmartContractsApi - factory interface\n * @export\n */\nconst SmartContractsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.SmartContractsApiFp)(configuration);\n    return {\n        /**\n         * Create a new smart contract\n         * @summary Create a new smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to deploy the smart contract from.\n         * @param {CreateSmartContractRequest} createSmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n            return localVarFp.createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Deploys a smart contract, by broadcasting the transaction to the network.\n         * @summary Deploy a smart contract\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to broadcast the transaction from.\n         * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n         * @param {DeploySmartContractRequest} deploySmartContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n            return localVarFp.deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a specific smart contract deployed by address.\n         * @summary Get a specific smart contract deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contract for.\n         * @param {string} smartContractId The UUID of the smart contract to fetch.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getSmartContract(walletId, addressId, smartContractId, options) {\n            return localVarFp.getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List all smart contracts deployed by address.\n         * @summary List smart contracts deployed by address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to fetch the smart contracts for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listSmartContracts(walletId, addressId, options) {\n            return localVarFp.listSmartContracts(walletId, addressId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Perform a read operation on a smart contract without creating a transaction\n         * @summary Read data from a smart contract\n         * @param {string} networkId\n         * @param {string} contractAddress\n         * @param {ReadContractRequest} readContractRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        readContract(networkId, contractAddress, readContractRequest, options) {\n            return localVarFp.readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.SmartContractsApiFactory = SmartContractsApiFactory;\n/**\n * SmartContractsApi - object-oriented interface\n * @export\n * @class SmartContractsApi\n * @extends {BaseAPI}\n */\nclass SmartContractsApi extends base_1.BaseAPI {\n    /**\n     * Create a new smart contract\n     * @summary Create a new smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to deploy the smart contract from.\n     * @param {CreateSmartContractRequest} createSmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    createSmartContract(walletId, addressId, createSmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).createSmartContract(walletId, addressId, createSmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Deploys a smart contract, by broadcasting the transaction to the network.\n     * @summary Deploy a smart contract\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to broadcast the transaction from.\n     * @param {string} smartContractId The UUID of the smart contract to broadcast the transaction to.\n     * @param {DeploySmartContractRequest} deploySmartContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).deploySmartContract(walletId, addressId, smartContractId, deploySmartContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a specific smart contract deployed by address.\n     * @summary Get a specific smart contract deployed by address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to fetch the smart contract for.\n     * @param {string} smartContractId The UUID of the smart contract to fetch.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    getSmartContract(walletId, addressId, smartContractId, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).getSmartContract(walletId, addressId, smartContractId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List all smart contracts deployed by address.\n     * @summary List smart contracts deployed by address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to fetch the smart contracts for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    listSmartContracts(walletId, addressId, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).listSmartContracts(walletId, addressId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Perform a read operation on a smart contract without creating a transaction\n     * @summary Read data from a smart contract\n     * @param {string} networkId\n     * @param {string} contractAddress\n     * @param {ReadContractRequest} readContractRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof SmartContractsApi\n     */\n    readContract(networkId, contractAddress, readContractRequest, options) {\n        return (0, exports.SmartContractsApiFp)(this.configuration).readContract(networkId, contractAddress, readContractRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.SmartContractsApi = SmartContractsApi;\n/**\n * StakeApi - axios parameter creator\n * @export\n */\nconst StakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation: async (buildStakingOperationRequest, options = {}) => {\n            // verify required parameter 'buildStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('buildStakingOperation', 'buildStakingOperationRequest', buildStakingOperationRequest);\n            const localVarPath = `/v1/stake/build`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(buildStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances: async (networkId, assetId, addressId, startTime, endTime, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'assetId', assetId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'addressId', addressId);\n            // verify required parameter 'startTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'startTime', startTime);\n            // verify required parameter 'endTime' is not null or undefined\n            (0, common_1.assertParamExists)('fetchHistoricalStakingBalances', 'endTime', endTime);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/stake/balances`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            if (assetId !== undefined) {\n                localVarQueryParameter['asset_id'] = assetId;\n            }\n            if (startTime !== undefined) {\n                localVarQueryParameter['start_time'] = (startTime instanceof Date) ?\n                    startTime.toISOString() :\n                    startTime;\n            }\n            if (endTime !== undefined) {\n                localVarQueryParameter['end_time'] = (endTime instanceof Date) ?\n                    endTime.toISOString() :\n                    endTime;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards: async (fetchStakingRewardsRequest, limit, page, options = {}) => {\n            // verify required parameter 'fetchStakingRewardsRequest' is not null or undefined\n            (0, common_1.assertParamExists)('fetchStakingRewards', 'fetchStakingRewardsRequest', fetchStakingRewardsRequest);\n            const localVarPath = `/v1/stake/rewards/search`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(fetchStakingRewardsRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation: async (networkId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getExternalStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext: async (getStakingContextRequest, options = {}) => {\n            // verify required parameter 'getStakingContextRequest' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingContext', 'getStakingContextRequest', getStakingContextRequest);\n            const localVarPath = `/v1/stake/context`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(getStakingContextRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.StakeApiAxiosParamCreator = StakeApiAxiosParamCreator;\n/**\n * StakeApi - functional programming interface\n * @export\n */\nconst StakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.StakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async buildStakingOperation(buildStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.buildStakingOperation(buildStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.buildStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchHistoricalStakingBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.fetchStakingRewards']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalStakingOperation(networkId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getExternalStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingContext(getStakingContextRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingContext(getStakingContextRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['StakeApi.getStakingContext']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.StakeApiFp = StakeApiFp;\n/**\n * StakeApi - factory interface\n * @export\n */\nconst StakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.StakeApiFp)(configuration);\n    return {\n        /**\n         * Build a new staking operation\n         * @summary Build a new staking operation\n         * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        buildStakingOperation(buildStakingOperationRequest, options) {\n            return localVarFp.buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch historical staking balances for given address.\n         * @summary Fetch historical staking balances\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n         * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n         * @param {string} startTime The start time of this historical staking balance period.\n         * @param {string} endTime The end time of this historical staking balance period.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n            return localVarFp.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Fetch staking rewards for a list of addresses\n         * @summary Fetch staking rewards\n         * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n            return localVarFp.fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation\n         * @summary Get the latest state of a staking operation\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the staking operation for\n         * @param {string} stakingOperationId The ID of the staking operation\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n            return localVarFp.getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get staking context for an address\n         * @summary Get staking context\n         * @param {GetStakingContextRequest} getStakingContextRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingContext(getStakingContextRequest, options) {\n            return localVarFp.getStakingContext(getStakingContextRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.StakeApiFactory = StakeApiFactory;\n/**\n * StakeApi - object-oriented interface\n * @export\n * @class StakeApi\n * @extends {BaseAPI}\n */\nclass StakeApi extends base_1.BaseAPI {\n    /**\n     * Build a new staking operation\n     * @summary Build a new staking operation\n     * @param {BuildStakingOperationRequest} buildStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    buildStakingOperation(buildStakingOperationRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).buildStakingOperation(buildStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch historical staking balances for given address.\n     * @summary Fetch historical staking balances\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The ID of the asset for which the historical staking balances are being fetched.\n     * @param {string} addressId The onchain address for which the historical staking balances are being fetched.\n     * @param {string} startTime The start time of this historical staking balance period.\n     * @param {string} endTime The end time of this historical staking balance period.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Fetch staking rewards for a list of addresses\n     * @summary Fetch staking rewards\n     * @param {FetchStakingRewardsRequest} fetchStakingRewardsRequest\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options) {\n        return (0, exports.StakeApiFp)(this.configuration).fetchStakingRewards(fetchStakingRewardsRequest, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation\n     * @summary Get the latest state of a staking operation\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the staking operation for\n     * @param {string} stakingOperationId The ID of the staking operation\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getExternalStakingOperation(networkId, addressId, stakingOperationId, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getExternalStakingOperation(networkId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get staking context for an address\n     * @summary Get staking context\n     * @param {GetStakingContextRequest} getStakingContextRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof StakeApi\n     */\n    getStakingContext(getStakingContextRequest, options) {\n        return (0, exports.StakeApiFp)(this.configuration).getStakingContext(getStakingContextRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.StakeApi = StakeApi;\n/**\n * TradesApi - axios parameter creator\n * @export\n */\nconst TradesApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade: async (walletId, addressId, tradeId, broadcastTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'tradeId', tradeId);\n            // verify required parameter 'broadcastTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTrade', 'broadcastTradeRequest', broadcastTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade: async (walletId, addressId, createTradeRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'addressId', addressId);\n            // verify required parameter 'createTradeRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTrade', 'createTradeRequest', createTradeRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTradeRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade: async (walletId, addressId, tradeId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'addressId', addressId);\n            // verify required parameter 'tradeId' is not null or undefined\n            (0, common_1.assertParamExists)('getTrade', 'tradeId', tradeId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades/{trade_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"trade_id\"}}`, encodeURIComponent(String(tradeId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTrades', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/trades`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TradesApiAxiosParamCreator = TradesApiAxiosParamCreator;\n/**\n * TradesApi - functional programming interface\n * @export\n */\nconst TradesApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TradesApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.broadcastTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTrade(walletId, addressId, createTradeRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTrade(walletId, addressId, createTradeRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.createTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTrade(walletId, addressId, tradeId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrade(walletId, addressId, tradeId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.getTrade']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTrades(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTrades(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TradesApi.listTrades']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TradesApiFp = TradesApiFp;\n/**\n * TradesApi - factory interface\n * @export\n */\nconst TradesApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TradesApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a trade\n         * @summary Broadcast a trade\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to broadcast\n         * @param {BroadcastTradeRequest} broadcastTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n            return localVarFp.broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new trade\n         * @summary Create a new trade for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to conduct the trade from\n         * @param {CreateTradeRequest} createTradeRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTrade(walletId, addressId, createTradeRequest, options) {\n            return localVarFp.createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a trade by ID\n         * @summary Get a trade by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the trade belongs to\n         * @param {string} tradeId The ID of the trade to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTrade(walletId, addressId, tradeId, options) {\n            return localVarFp.getTrade(walletId, addressId, tradeId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List trades for an address.\n         * @summary List trades for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list trades for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTrades(walletId, addressId, limit, page, options) {\n            return localVarFp.listTrades(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TradesApiFactory = TradesApiFactory;\n/**\n * TradesApi - object-oriented interface\n * @export\n * @class TradesApi\n * @extends {BaseAPI}\n */\nclass TradesApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a trade\n     * @summary Broadcast a trade\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to broadcast\n     * @param {BroadcastTradeRequest} broadcastTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).broadcastTrade(walletId, addressId, tradeId, broadcastTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new trade\n     * @summary Create a new trade for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to conduct the trade from\n     * @param {CreateTradeRequest} createTradeRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    createTrade(walletId, addressId, createTradeRequest, options) {\n        return (0, exports.TradesApiFp)(this.configuration).createTrade(walletId, addressId, createTradeRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a trade by ID\n     * @summary Get a trade by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the trade belongs to\n     * @param {string} tradeId The ID of the trade to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    getTrade(walletId, addressId, tradeId, options) {\n        return (0, exports.TradesApiFp)(this.configuration).getTrade(walletId, addressId, tradeId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List trades for an address.\n     * @summary List trades for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list trades for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TradesApi\n     */\n    listTrades(walletId, addressId, limit, page, options) {\n        return (0, exports.TradesApiFp)(this.configuration).listTrades(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TradesApi = TradesApi;\n/**\n * TransactionHistoryApi - axios parameter creator\n * @export\n */\nconst TransactionHistoryApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions: async (networkId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'networkId', networkId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listAddressTransactions', 'addressId', addressId);\n            const localVarPath = `/v1/networks/{network_id}/addresses/{address_id}/transactions`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransactionHistoryApiAxiosParamCreator = TransactionHistoryApiAxiosParamCreator;\n/**\n * TransactionHistoryApi - functional programming interface\n * @export\n */\nconst TransactionHistoryApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransactionHistoryApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listAddressTransactions(networkId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddressTransactions(networkId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransactionHistoryApi.listAddressTransactions']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransactionHistoryApiFp = TransactionHistoryApiFp;\n/**\n * TransactionHistoryApi - factory interface\n * @export\n */\nconst TransactionHistoryApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransactionHistoryApiFp)(configuration);\n    return {\n        /**\n         * List all transactions that interact with the address.\n         * @summary List transactions for an address.\n         * @param {string} networkId The ID of the blockchain network\n         * @param {string} addressId The ID of the address to fetch the transactions for.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listAddressTransactions(networkId, addressId, limit, page, options) {\n            return localVarFp.listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransactionHistoryApiFactory = TransactionHistoryApiFactory;\n/**\n * TransactionHistoryApi - object-oriented interface\n * @export\n * @class TransactionHistoryApi\n * @extends {BaseAPI}\n */\nclass TransactionHistoryApi extends base_1.BaseAPI {\n    /**\n     * List all transactions that interact with the address.\n     * @summary List transactions for an address.\n     * @param {string} networkId The ID of the blockchain network\n     * @param {string} addressId The ID of the address to fetch the transactions for.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransactionHistoryApi\n     */\n    listAddressTransactions(networkId, addressId, limit, page, options) {\n        return (0, exports.TransactionHistoryApiFp)(this.configuration).listAddressTransactions(networkId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransactionHistoryApi = TransactionHistoryApi;\n/**\n * TransfersApi - axios parameter creator\n * @export\n */\nconst TransfersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer: async (walletId, addressId, transferId, broadcastTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'transferId', transferId);\n            // verify required parameter 'broadcastTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastTransfer', 'broadcastTransferRequest', broadcastTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer: async (walletId, addressId, createTransferRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'addressId', addressId);\n            // verify required parameter 'createTransferRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createTransfer', 'createTransferRequest', createTransferRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createTransferRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer: async (walletId, addressId, transferId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'addressId', addressId);\n            // verify required parameter 'transferId' is not null or undefined\n            (0, common_1.assertParamExists)('getTransfer', 'transferId', transferId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers/{transfer_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"transfer_id\"}}`, encodeURIComponent(String(transferId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers: async (walletId, addressId, limit, page, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('listTransfers', 'addressId', addressId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/transfers`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.TransfersApiAxiosParamCreator = TransfersApiAxiosParamCreator;\n/**\n * TransfersApi - functional programming interface\n * @export\n */\nconst TransfersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.TransfersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.broadcastTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createTransfer(walletId, addressId, createTransferRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createTransfer(walletId, addressId, createTransferRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.createTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getTransfer(walletId, addressId, transferId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransfer(walletId, addressId, transferId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.getTransfer']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listTransfers(walletId, addressId, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listTransfers(walletId, addressId, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['TransfersApi.listTransfers']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.TransfersApiFp = TransfersApiFp;\n/**\n * TransfersApi - factory interface\n * @export\n */\nconst TransfersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.TransfersApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a transfer\n         * @summary Broadcast a transfer\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to broadcast\n         * @param {BroadcastTransferRequest} broadcastTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n            return localVarFp.broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new transfer\n         * @summary Create a new transfer for an address\n         * @param {string} walletId The ID of the wallet the source address belongs to\n         * @param {string} addressId The ID of the address to transfer from\n         * @param {CreateTransferRequest} createTransferRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createTransfer(walletId, addressId, createTransferRequest, options) {\n            return localVarFp.createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get a transfer by ID\n         * @summary Get a transfer by ID\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address the transfer belongs to\n         * @param {string} transferId The ID of the transfer to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getTransfer(walletId, addressId, transferId, options) {\n            return localVarFp.getTransfer(walletId, addressId, transferId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List transfers for an address.\n         * @summary List transfers for an address.\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to list transfers for\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listTransfers(walletId, addressId, limit, page, options) {\n            return localVarFp.listTransfers(walletId, addressId, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.TransfersApiFactory = TransfersApiFactory;\n/**\n * TransfersApi - object-oriented interface\n * @export\n * @class TransfersApi\n * @extends {BaseAPI}\n */\nclass TransfersApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a transfer\n     * @summary Broadcast a transfer\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to broadcast\n     * @param {BroadcastTransferRequest} broadcastTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).broadcastTransfer(walletId, addressId, transferId, broadcastTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new transfer\n     * @summary Create a new transfer for an address\n     * @param {string} walletId The ID of the wallet the source address belongs to\n     * @param {string} addressId The ID of the address to transfer from\n     * @param {CreateTransferRequest} createTransferRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    createTransfer(walletId, addressId, createTransferRequest, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).createTransfer(walletId, addressId, createTransferRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get a transfer by ID\n     * @summary Get a transfer by ID\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address the transfer belongs to\n     * @param {string} transferId The ID of the transfer to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    getTransfer(walletId, addressId, transferId, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).getTransfer(walletId, addressId, transferId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List transfers for an address.\n     * @summary List transfers for an address.\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to list transfers for\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof TransfersApi\n     */\n    listTransfers(walletId, addressId, limit, page, options) {\n        return (0, exports.TransfersApiFp)(this.configuration).listTransfers(walletId, addressId, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.TransfersApi = TransfersApi;\n/**\n * UsersApi - axios parameter creator\n * @export\n */\nconst UsersApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser: async (options = {}) => {\n            const localVarPath = `/v1/users/me`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;\n/**\n * UsersApi - functional programming interface\n * @export\n */\nconst UsersApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getCurrentUser(options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.UsersApiFp = UsersApiFp;\n/**\n * UsersApi - factory interface\n * @export\n */\nconst UsersApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.UsersApiFp)(configuration);\n    return {\n        /**\n         * Get current user\n         * @summary Get current user\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getCurrentUser(options) {\n            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.UsersApiFactory = UsersApiFactory;\n/**\n * UsersApi - object-oriented interface\n * @export\n * @class UsersApi\n * @extends {BaseAPI}\n */\nclass UsersApi extends base_1.BaseAPI {\n    /**\n     * Get current user\n     * @summary Get current user\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof UsersApi\n     */\n    getCurrentUser(options) {\n        return (0, exports.UsersApiFp)(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.UsersApi = UsersApi;\n/**\n * ValidatorsApi - axios parameter creator\n * @export\n */\nconst ValidatorsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator: async (networkId, assetId, validatorId, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'assetId', assetId);\n            // verify required parameter 'validatorId' is not null or undefined\n            (0, common_1.assertParamExists)('getValidator', 'validatorId', validatorId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators/{validator_id}`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)))\n                .replace(`{${\"validator_id\"}}`, encodeURIComponent(String(validatorId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators: async (networkId, assetId, status, limit, page, options = {}) => {\n            // verify required parameter 'networkId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'networkId', networkId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('listValidators', 'assetId', assetId);\n            const localVarPath = `/v1/networks/{network_id}/assets/{asset_id}/validators`\n                .replace(`{${\"network_id\"}}`, encodeURIComponent(String(networkId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (status !== undefined) {\n                localVarQueryParameter['status'] = status;\n            }\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.ValidatorsApiAxiosParamCreator = ValidatorsApiAxiosParamCreator;\n/**\n * ValidatorsApi - functional programming interface\n * @export\n */\nconst ValidatorsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.ValidatorsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getValidator(networkId, assetId, validatorId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(networkId, assetId, validatorId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ValidatorsApi.getValidator']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listValidators(networkId, assetId, status, limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listValidators(networkId, assetId, status, limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['ValidatorsApi.listValidators']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.ValidatorsApiFp = ValidatorsApiFp;\n/**\n * ValidatorsApi - factory interface\n * @export\n */\nconst ValidatorsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.ValidatorsApiFp)(configuration);\n    return {\n        /**\n         * Get a validator belonging to the user for a given network, asset and id.\n         * @summary Get a validator belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validator for.\n         * @param {string} validatorId The unique id of the validator to fetch details for.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getValidator(networkId, assetId, validatorId, options) {\n            return localVarFp.getValidator(networkId, assetId, validatorId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List validators belonging to the user for a given network and asset.\n         * @summary List validators belonging to the CDP project\n         * @param {string} networkId The ID of the blockchain network.\n         * @param {string} assetId The symbol of the asset to get the validators for.\n         * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listValidators(networkId, assetId, status, limit, page, options) {\n            return localVarFp.listValidators(networkId, assetId, status, limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.ValidatorsApiFactory = ValidatorsApiFactory;\n/**\n * ValidatorsApi - object-oriented interface\n * @export\n * @class ValidatorsApi\n * @extends {BaseAPI}\n */\nclass ValidatorsApi extends base_1.BaseAPI {\n    /**\n     * Get a validator belonging to the user for a given network, asset and id.\n     * @summary Get a validator belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validator for.\n     * @param {string} validatorId The unique id of the validator to fetch details for.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ValidatorsApi\n     */\n    getValidator(networkId, assetId, validatorId, options) {\n        return (0, exports.ValidatorsApiFp)(this.configuration).getValidator(networkId, assetId, validatorId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List validators belonging to the user for a given network and asset.\n     * @summary List validators belonging to the CDP project\n     * @param {string} networkId The ID of the blockchain network.\n     * @param {string} assetId The symbol of the asset to get the validators for.\n     * @param {ValidatorStatus} [status] A filter to list validators based on a status.\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 50.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof ValidatorsApi\n     */\n    listValidators(networkId, assetId, status, limit, page, options) {\n        return (0, exports.ValidatorsApiFp)(this.configuration).listValidators(networkId, assetId, status, limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.ValidatorsApi = ValidatorsApi;\n/**\n * WalletStakeApi - axios parameter creator\n * @export\n */\nconst WalletStakeApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation: async (walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'stakingOperationId', stakingOperationId);\n            // verify required parameter 'broadcastStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('broadcastStakingOperation', 'broadcastStakingOperationRequest', broadcastStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}/broadcast`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(broadcastStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation: async (walletId, addressId, createStakingOperationRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'addressId', addressId);\n            // verify required parameter 'createStakingOperationRequest' is not null or undefined\n            (0, common_1.assertParamExists)('createStakingOperation', 'createStakingOperationRequest', createStakingOperationRequest);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createStakingOperationRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation: async (walletId, addressId, stakingOperationId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'walletId', walletId);\n            // verify required parameter 'addressId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'addressId', addressId);\n            // verify required parameter 'stakingOperationId' is not null or undefined\n            (0, common_1.assertParamExists)('getStakingOperation', 'stakingOperationId', stakingOperationId);\n            const localVarPath = `/v1/wallets/{wallet_id}/addresses/{address_id}/staking_operations/{staking_operation_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"address_id\"}}`, encodeURIComponent(String(addressId)))\n                .replace(`{${\"staking_operation_id\"}}`, encodeURIComponent(String(stakingOperationId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WalletStakeApiAxiosParamCreator = WalletStakeApiAxiosParamCreator;\n/**\n * WalletStakeApi - functional programming interface\n * @export\n */\nconst WalletStakeApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WalletStakeApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletStakeApi.broadcastStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createStakingOperation(walletId, addressId, createStakingOperationRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletStakeApi.createStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getStakingOperation(walletId, addressId, stakingOperationId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletStakeApi.getStakingOperation']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WalletStakeApiFp = WalletStakeApiFp;\n/**\n * WalletStakeApi - factory interface\n * @export\n */\nconst WalletStakeApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WalletStakeApiFp)(configuration);\n    return {\n        /**\n         * Broadcast a staking operation.\n         * @summary Broadcast a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address the staking operation belongs to.\n         * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n         * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n            return localVarFp.broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new staking operation.\n         * @summary Create a new staking operation for an address\n         * @param {string} walletId The ID of the wallet the address belongs to.\n         * @param {string} addressId The ID of the address to create the staking operation for.\n         * @param {CreateStakingOperationRequest} createStakingOperationRequest\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n            return localVarFp.createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the latest state of a staking operation.\n         * @summary Get the latest state of a staking operation\n         * @param {string} walletId The ID of the wallet the address belongs to\n         * @param {string} addressId The ID of the address to fetch the staking operation for.\n         * @param {string} stakingOperationId The ID of the staking operation.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getStakingOperation(walletId, addressId, stakingOperationId, options) {\n            return localVarFp.getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WalletStakeApiFactory = WalletStakeApiFactory;\n/**\n * WalletStakeApi - object-oriented interface\n * @export\n * @class WalletStakeApi\n * @extends {BaseAPI}\n */\nclass WalletStakeApi extends base_1.BaseAPI {\n    /**\n     * Broadcast a staking operation.\n     * @summary Broadcast a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address the staking operation belongs to.\n     * @param {string} stakingOperationId The ID of the staking operation to broadcast.\n     * @param {BroadcastStakingOperationRequest} broadcastStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletStakeApi\n     */\n    broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options) {\n        return (0, exports.WalletStakeApiFp)(this.configuration).broadcastStakingOperation(walletId, addressId, stakingOperationId, broadcastStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new staking operation.\n     * @summary Create a new staking operation for an address\n     * @param {string} walletId The ID of the wallet the address belongs to.\n     * @param {string} addressId The ID of the address to create the staking operation for.\n     * @param {CreateStakingOperationRequest} createStakingOperationRequest\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletStakeApi\n     */\n    createStakingOperation(walletId, addressId, createStakingOperationRequest, options) {\n        return (0, exports.WalletStakeApiFp)(this.configuration).createStakingOperation(walletId, addressId, createStakingOperationRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the latest state of a staking operation.\n     * @summary Get the latest state of a staking operation\n     * @param {string} walletId The ID of the wallet the address belongs to\n     * @param {string} addressId The ID of the address to fetch the staking operation for.\n     * @param {string} stakingOperationId The ID of the staking operation.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletStakeApi\n     */\n    getStakingOperation(walletId, addressId, stakingOperationId, options) {\n        return (0, exports.WalletStakeApiFp)(this.configuration).getStakingOperation(walletId, addressId, stakingOperationId, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WalletStakeApi = WalletStakeApi;\n/**\n * WalletsApi - axios parameter creator\n * @export\n */\nconst WalletsApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet: async (createWalletRequest, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWallet', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance: async (walletId, assetId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'walletId', walletId);\n            // verify required parameter 'assetId' is not null or undefined\n            (0, common_1.assertParamExists)('getWalletBalance', 'assetId', assetId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances/{asset_id}`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)))\n                .replace(`{${\"asset_id\"}}`, encodeURIComponent(String(assetId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances: async (walletId, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('listWalletBalances', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/balances`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/wallets`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WalletsApiAxiosParamCreator = WalletsApiAxiosParamCreator;\n/**\n * WalletsApi - functional programming interface\n * @export\n */\nconst WalletsApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WalletsApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWallet(createWalletRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWallet(createWalletRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.createWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWallet(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWallet(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWallet']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async getWalletBalance(walletId, assetId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.getWalletBalance(walletId, assetId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.getWalletBalance']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWalletBalances(walletId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWalletBalances(walletId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWalletBalances']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWallets(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWallets(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WalletsApi.listWallets']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WalletsApiFp = WalletsApiFp;\n/**\n * WalletsApi - factory interface\n * @export\n */\nconst WalletsApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WalletsApiFp)(configuration);\n    return {\n        /**\n         * Create a new wallet scoped to the user.\n         * @summary Create a new wallet\n         * @param {CreateWalletRequest} [createWalletRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWallet(createWalletRequest, options) {\n            return localVarFp.createWallet(createWalletRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get wallet\n         * @summary Get wallet by ID\n         * @param {string} walletId The ID of the wallet to fetch\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWallet(walletId, options) {\n            return localVarFp.getWallet(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Get the aggregated balance of an asset across all of the addresses in the wallet.\n         * @summary Get the balance of an asset in the wallet\n         * @param {string} walletId The ID of the wallet to fetch the balance for\n         * @param {string} assetId The symbol of the asset to fetch the balance for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        getWalletBalance(walletId, assetId, options) {\n            return localVarFp.getWalletBalance(walletId, assetId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List the balances of all of the addresses in the wallet aggregated by asset.\n         * @summary List wallet balances\n         * @param {string} walletId The ID of the wallet to fetch the balances for\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWalletBalances(walletId, options) {\n            return localVarFp.listWalletBalances(walletId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List wallets belonging to the user.\n         * @summary List wallets\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWallets(limit, page, options) {\n            return localVarFp.listWallets(limit, page, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WalletsApiFactory = WalletsApiFactory;\n/**\n * WalletsApi - object-oriented interface\n * @export\n * @class WalletsApi\n * @extends {BaseAPI}\n */\nclass WalletsApi extends base_1.BaseAPI {\n    /**\n     * Create a new wallet scoped to the user.\n     * @summary Create a new wallet\n     * @param {CreateWalletRequest} [createWalletRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    createWallet(createWalletRequest, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).createWallet(createWalletRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get wallet\n     * @summary Get wallet by ID\n     * @param {string} walletId The ID of the wallet to fetch\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWallet(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWallet(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Get the aggregated balance of an asset across all of the addresses in the wallet.\n     * @summary Get the balance of an asset in the wallet\n     * @param {string} walletId The ID of the wallet to fetch the balance for\n     * @param {string} assetId The symbol of the asset to fetch the balance for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    getWalletBalance(walletId, assetId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).getWalletBalance(walletId, assetId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List the balances of all of the addresses in the wallet aggregated by asset.\n     * @summary List wallet balances\n     * @param {string} walletId The ID of the wallet to fetch the balances for\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWalletBalances(walletId, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWalletBalances(walletId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List wallets belonging to the user.\n     * @summary List wallets\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WalletsApi\n     */\n    listWallets(limit, page, options) {\n        return (0, exports.WalletsApiFp)(this.configuration).listWallets(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WalletsApi = WalletsApi;\n/**\n * WebhooksApi - axios parameter creator\n * @export\n */\nconst WebhooksApiAxiosParamCreator = function (configuration) {\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook: async (walletId, createWalletWebhookRequest, options = {}) => {\n            // verify required parameter 'walletId' is not null or undefined\n            (0, common_1.assertParamExists)('createWalletWebhook', 'walletId', walletId);\n            const localVarPath = `/v1/wallets/{wallet_id}/webhooks`\n                .replace(`{${\"wallet_id\"}}`, encodeURIComponent(String(walletId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWalletWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook: async (createWebhookRequest, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook: async (webhookId, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('deleteWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks: async (limit, page, options = {}) => {\n            const localVarPath = `/v1/webhooks`;\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            if (limit !== undefined) {\n                localVarQueryParameter['limit'] = limit;\n            }\n            if (page !== undefined) {\n                localVarQueryParameter['page'] = page;\n            }\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook: async (webhookId, updateWebhookRequest, options = {}) => {\n            // verify required parameter 'webhookId' is not null or undefined\n            (0, common_1.assertParamExists)('updateWebhook', 'webhookId', webhookId);\n            const localVarPath = `/v1/webhooks/{webhook_id}`\n                .replace(`{${\"webhook_id\"}}`, encodeURIComponent(String(webhookId)));\n            // use dummy base URL string because the URL constructor only accepts absolute URLs.\n            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);\n            let baseOptions;\n            if (configuration) {\n                baseOptions = configuration.baseOptions;\n            }\n            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };\n            const localVarHeaderParameter = {};\n            const localVarQueryParameter = {};\n            localVarHeaderParameter['Content-Type'] = 'application/json';\n            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);\n            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};\n            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };\n            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWebhookRequest, localVarRequestOptions, configuration);\n            return {\n                url: (0, common_1.toPathString)(localVarUrlObj),\n                options: localVarRequestOptions,\n            };\n        },\n    };\n};\nexports.WebhooksApiAxiosParamCreator = WebhooksApiAxiosParamCreator;\n/**\n * WebhooksApi - functional programming interface\n * @export\n */\nconst WebhooksApiFp = function (configuration) {\n    const localVarAxiosParamCreator = (0, exports.WebhooksApiAxiosParamCreator)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWalletWebhook(walletId, createWalletWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWalletWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async createWebhook(createWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.createWebhook(createWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.createWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async deleteWebhook(webhookId, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWebhook(webhookId, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.deleteWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async listWebhooks(limit, page, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.listWebhooks(limit, page, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.listWebhooks']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        async updateWebhook(webhookId, updateWebhookRequest, options) {\n            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWebhook(webhookId, updateWebhookRequest, options);\n            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;\n            const localVarOperationServerBasePath = base_1.operationServerMap['WebhooksApi.updateWebhook']?.[localVarOperationServerIndex]?.url;\n            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);\n        },\n    };\n};\nexports.WebhooksApiFp = WebhooksApiFp;\n/**\n * WebhooksApi - factory interface\n * @export\n */\nconst WebhooksApiFactory = function (configuration, basePath, axios) {\n    const localVarFp = (0, exports.WebhooksApiFp)(configuration);\n    return {\n        /**\n         * Create a new webhook scoped to a wallet\n         * @summary Create a new webhook scoped to a wallet\n         * @param {string} walletId The ID of the wallet to create the webhook for.\n         * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n            return localVarFp.createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Create a new webhook\n         * @summary Create a new webhook\n         * @param {CreateWebhookRequest} [createWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        createWebhook(createWebhookRequest, options) {\n            return localVarFp.createWebhook(createWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Delete a webhook\n         * @summary Delete a webhook\n         * @param {string} webhookId The Webhook uuid that needs to be deleted\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        deleteWebhook(webhookId, options) {\n            return localVarFp.deleteWebhook(webhookId, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * List webhooks, optionally filtered by event type.\n         * @summary List webhooks\n         * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n         * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        listWebhooks(limit, page, options) {\n            return localVarFp.listWebhooks(limit, page, options).then((request) => request(axios, basePath));\n        },\n        /**\n         * Update a webhook\n         * @summary Update a webhook\n         * @param {string} webhookId The Webhook id that needs to be updated\n         * @param {UpdateWebhookRequest} [updateWebhookRequest]\n         * @param {*} [options] Override http request option.\n         * @throws {RequiredError}\n         */\n        updateWebhook(webhookId, updateWebhookRequest, options) {\n            return localVarFp.updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(axios, basePath));\n        },\n    };\n};\nexports.WebhooksApiFactory = WebhooksApiFactory;\n/**\n * WebhooksApi - object-oriented interface\n * @export\n * @class WebhooksApi\n * @extends {BaseAPI}\n */\nclass WebhooksApi extends base_1.BaseAPI {\n    /**\n     * Create a new webhook scoped to a wallet\n     * @summary Create a new webhook scoped to a wallet\n     * @param {string} walletId The ID of the wallet to create the webhook for.\n     * @param {CreateWalletWebhookRequest} [createWalletWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWalletWebhook(walletId, createWalletWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWalletWebhook(walletId, createWalletWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Create a new webhook\n     * @summary Create a new webhook\n     * @param {CreateWebhookRequest} [createWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    createWebhook(createWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).createWebhook(createWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Delete a webhook\n     * @summary Delete a webhook\n     * @param {string} webhookId The Webhook uuid that needs to be deleted\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    deleteWebhook(webhookId, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).deleteWebhook(webhookId, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * List webhooks, optionally filtered by event type.\n     * @summary List webhooks\n     * @param {number} [limit] A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 10.\n     * @param {string} [page] A cursor for pagination across multiple pages of results. Don\\&#39;t include this parameter on the first call. Use the next_page value returned in a previous response to request subsequent results.\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    listWebhooks(limit, page, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).listWebhooks(limit, page, options).then((request) => request(this.axios, this.basePath));\n    }\n    /**\n     * Update a webhook\n     * @summary Update a webhook\n     * @param {string} webhookId The Webhook id that needs to be updated\n     * @param {UpdateWebhookRequest} [updateWebhookRequest]\n     * @param {*} [options] Override http request option.\n     * @throws {RequiredError}\n     * @memberof WebhooksApi\n     */\n    updateWebhook(webhookId, updateWebhookRequest, options) {\n        return (0, exports.WebhooksApiFp)(this.configuration).updateWebhook(webhookId, updateWebhookRequest, options).then((request) => request(this.axios, this.basePath));\n    }\n}\nexports.WebhooksApi = WebhooksApi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJDQUEyQyxHQUFHLG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG9DQUFvQyxHQUFHLGVBQWUsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxnQ0FBZ0MsR0FBRyw0QkFBNEIsR0FBRyxtQ0FBbUMsR0FBRyw4QkFBOEIsR0FBRyw2Q0FBNkMsR0FBRyw4QkFBOEIsR0FBRyxxQ0FBcUMsR0FBRyxnQ0FBZ0MsR0FBRywrQ0FBK0MsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyx5QkFBeUIsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRywwQ0FBMEMsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyxrQ0FBa0MsR0FBRyxvQkFBb0IsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyxxQ0FBcUMsR0FBRyx3QkFBd0IsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRywyQkFBMkIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyw2QkFBNkIsR0FBRyx5QkFBeUIsR0FBRyxrQ0FBa0MsR0FBRyx5QkFBeUIsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0I7QUFDL2pELG1CQUFtQixHQUFHLDBCQUEwQixHQUFHLHFCQUFxQixHQUFHLG9DQUFvQyxHQUFHLGtCQUFrQixHQUFHLHlCQUF5QixHQUFHLG9CQUFv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QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0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Q1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLHVCQUF1QjtBQUMxQyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVEsMEVBQTBFO0FBQ3JHLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQiwwQkFBMEI7QUFDN0MsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsdUJBQXVCO0FBQzFDLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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Q3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsUUFBUSwwRUFBMEU7QUFDckcsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QyxtQkFBbUIsR0FBRztBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixHQUFHO0FBQ3RCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLEdBQUc7QUFDdEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixtQkFBbUIsR0FBRztBQUN0Qixv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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLHNCQUFzQjtBQUNyQyxlQUFlLEdBQUc7QUFDbEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2FwaS5qcz9iMzY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyogdHNsaW50OmRpc2FibGUgKi9cbi8qIGVzbGludC1kaXNhYmxlICovXG4vKipcbiAqIENvaW5iYXNlIFBsYXRmb3JtIEFQSVxuICogVGhpcyBpcyB0aGUgT3BlbkFQSSAzLjAgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMsIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gU0RLcy5cbiAqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgT3BlbkFQSSBkb2N1bWVudDogMC4wLjEtYWxwaGFcbiAqXG4gKlxuICogTk9URTogVGhpcyBjbGFzcyBpcyBhdXRvIGdlbmVyYXRlZCBieSBPcGVuQVBJIEdlbmVyYXRvciAoaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoKS5cbiAqIGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaFxuICogRG8gbm90IGVkaXQgdGhlIGNsYXNzIG1hbnVhbGx5LlxuICovXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5OZXR3b3Jrc0FwaSA9IGV4cG9ydHMuTmV0d29ya3NBcGlGYWN0b3J5ID0gZXhwb3J0cy5OZXR3b3Jrc0FwaUZwID0gZXhwb3J0cy5OZXR3b3Jrc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5GdW5kQXBpID0gZXhwb3J0cy5GdW5kQXBpRmFjdG9yeSA9IGV4cG9ydHMuRnVuZEFwaUZwID0gZXhwb3J0cy5GdW5kQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpID0gZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnAgPSBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGkgPSBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGYWN0b3J5ID0gZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnAgPSBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGkgPSBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeSA9IGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCA9IGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGkgPSBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeSA9IGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGcCA9IGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuQXNzZXRzQXBpID0gZXhwb3J0cy5Bc3NldHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5Bc3NldHNBcGlGcCA9IGV4cG9ydHMuQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLkFkZHJlc3Nlc0FwaSA9IGV4cG9ydHMuQWRkcmVzc2VzQXBpRmFjdG9yeSA9IGV4cG9ydHMuQWRkcmVzc2VzQXBpRnAgPSBleHBvcnRzLkFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5XZWJob29rRXZlbnRUeXBlID0gZXhwb3J0cy5XYWxsZXRTZXJ2ZXJTaWduZXJTdGF0dXNFbnVtID0gZXhwb3J0cy5WYWxpZGF0b3JTdGF0dXMgPSBleHBvcnRzLlRyYW5zZmVyU3RhdHVzRW51bSA9IGV4cG9ydHMuVHJhbnNhY3Rpb25UeXBlID0gZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1c0VudW0gPSBleHBvcnRzLlRva2VuVHJhbnNmZXJUeXBlID0gZXhwb3J0cy5TdGFraW5nUmV3YXJkRm9ybWF0ID0gZXhwb3J0cy5TdGFraW5nUmV3YXJkU3RhdGVFbnVtID0gZXhwb3J0cy5TdGFraW5nT3BlcmF0aW9uU3RhdHVzRW51bSA9IGV4cG9ydHMuU3BvbnNvcmVkU2VuZFN0YXR1c0VudW0gPSBleHBvcnRzLlNvbGlkaXR5VmFsdWVUeXBlRW51bSA9IGV4cG9ydHMuU21hcnRDb250cmFjdFR5cGUgPSBleHBvcnRzLlBheWxvYWRTaWduYXR1cmVTdGF0dXNFbnVtID0gZXhwb3J0cy5OZXR3b3JrSWRlbnRpZmllciA9IGV4cG9ydHMuTmV0d29ya1Byb3RvY29sRmFtaWx5RW51bSA9IGV4cG9ydHMuRnVuZE9wZXJhdGlvblN0YXR1c0VudW0gPSB2b2lkIDA7XG5leHBvcnRzLldlYmhvb2tzQXBpID0gZXhwb3J0cy5XZWJob29rc0FwaUZhY3RvcnkgPSBleHBvcnRzLldlYmhvb2tzQXBpRnAgPSBleHBvcnRzLldlYmhvb2tzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLldhbGxldHNBcGkgPSBleHBvcnRzLldhbGxldHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5XYWxsZXRzQXBpRnAgPSBleHBvcnRzLldhbGxldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuV2FsbGV0U3Rha2VBcGkgPSBleHBvcnRzLldhbGxldFN0YWtlQXBpRmFjdG9yeSA9IGV4cG9ydHMuV2FsbGV0U3Rha2VBcGlGcCA9IGV4cG9ydHMuV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuVmFsaWRhdG9yc0FwaSA9IGV4cG9ydHMuVmFsaWRhdG9yc0FwaUZhY3RvcnkgPSBleHBvcnRzLlZhbGlkYXRvcnNBcGlGcCA9IGV4cG9ydHMuVmFsaWRhdG9yc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5Vc2Vyc0FwaSA9IGV4cG9ydHMuVXNlcnNBcGlGYWN0b3J5ID0gZXhwb3J0cy5Vc2Vyc0FwaUZwID0gZXhwb3J0cy5Vc2Vyc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5UcmFuc2ZlcnNBcGkgPSBleHBvcnRzLlRyYW5zZmVyc0FwaUZhY3RvcnkgPSBleHBvcnRzLlRyYW5zZmVyc0FwaUZwID0gZXhwb3J0cy5UcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5ID0gZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGcCA9IGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlRyYWRlc0FwaSA9IGV4cG9ydHMuVHJhZGVzQXBpRmFjdG9yeSA9IGV4cG9ydHMuVHJhZGVzQXBpRnAgPSBleHBvcnRzLlRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TdGFrZUFwaSA9IGV4cG9ydHMuU3Rha2VBcGlGYWN0b3J5ID0gZXhwb3J0cy5TdGFrZUFwaUZwID0gZXhwb3J0cy5TdGFrZUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaSA9IGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGYWN0b3J5ID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwID0gZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IGV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaUZwID0gZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBleHBvcnRzLlJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bSA9IGV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGYWN0b3J5ID0gZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGcCA9IHZvaWQgMDtcbmNvbnN0IGF4aW9zXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImF4aW9zXCIpKTtcbi8vIFNvbWUgaW1wb3J0cyBub3QgdXNlZCBkZXBlbmRpbmcgb24gdGVtcGxhdGUgY29uZGl0aW9uc1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG4vLyBAdHMtaWdub3JlXG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuZXhwb3J0cy5GdW5kT3BlcmF0aW9uU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgQ29tcGxldGU6ICdjb21wbGV0ZScsXG4gICAgRmFpbGVkOiAnZmFpbGVkJ1xufTtcbmV4cG9ydHMuTmV0d29ya1Byb3RvY29sRmFtaWx5RW51bSA9IHtcbiAgICBFdm06ICdldm0nLFxuICAgIFNvbGFuYTogJ3NvbGFuYSdcbn07XG4vKipcbiAqIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLiBUaGlzIGlzIHVuaXF1ZSBhY3Jvc3MgYWxsIG5ldHdvcmtzLCBhbmQgdGFrZXMgdGhlIGZvcm0gb2YgYDxibG9ja2NoYWluPi08bmV0d29yaz5gLlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5OZXR3b3JrSWRlbnRpZmllciA9IHtcbiAgICBCYXNlU2Vwb2xpYTogJ2Jhc2Utc2Vwb2xpYScsXG4gICAgQmFzZU1haW5uZXQ6ICdiYXNlLW1haW5uZXQnLFxuICAgIEV0aGVyZXVtSG9sZXNreTogJ2V0aGVyZXVtLWhvbGVza3knLFxuICAgIEV0aGVyZXVtTWFpbm5ldDogJ2V0aGVyZXVtLW1haW5uZXQnLFxuICAgIFBvbHlnb25NYWlubmV0OiAncG9seWdvbi1tYWlubmV0JyxcbiAgICBTb2xhbmFEZXZuZXQ6ICdzb2xhbmEtZGV2bmV0JyxcbiAgICBTb2xhbmFNYWlubmV0OiAnc29sYW5hLW1haW5uZXQnLFxuICAgIEFyYml0cnVtTWFpbm5ldDogJ2FyYml0cnVtLW1haW5uZXQnXG59O1xuZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnXG59O1xuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLlNtYXJ0Q29udHJhY3RUeXBlID0ge1xuICAgIEVyYzIwOiAnZXJjMjAnLFxuICAgIEVyYzcyMTogJ2VyYzcyMScsXG4gICAgRXJjMTE1NTogJ2VyYzExNTUnXG59O1xuZXhwb3J0cy5Tb2xpZGl0eVZhbHVlVHlwZUVudW0gPSB7XG4gICAgVWludDg6ICd1aW50OCcsXG4gICAgVWludDE2OiAndWludDE2JyxcbiAgICBVaW50MzI6ICd1aW50MzInLFxuICAgIFVpbnQ2NDogJ3VpbnQ2NCcsXG4gICAgVWludDEyODogJ3VpbnQxMjgnLFxuICAgIFVpbnQyNTY6ICd1aW50MjU2JyxcbiAgICBJbnQ4OiAnaW50OCcsXG4gICAgSW50MTY6ICdpbnQxNicsXG4gICAgSW50MzI6ICdpbnQzMicsXG4gICAgSW50NjQ6ICdpbnQ2NCcsXG4gICAgSW50MTI4OiAnaW50MTI4JyxcbiAgICBJbnQyNTY6ICdpbnQyNTYnLFxuICAgIEFkZHJlc3M6ICdhZGRyZXNzJyxcbiAgICBCb29sOiAnYm9vbCcsXG4gICAgU3RyaW5nOiAnc3RyaW5nJyxcbiAgICBCeXRlczogJ2J5dGVzJyxcbiAgICBCeXRlczE6ICdieXRlczEnLFxuICAgIEJ5dGVzMjogJ2J5dGVzMicsXG4gICAgQnl0ZXMzOiAnYnl0ZXMzJyxcbiAgICBCeXRlczQ6ICdieXRlczQnLFxuICAgIEJ5dGVzNTogJ2J5dGVzNScsXG4gICAgQnl0ZXM2OiAnYnl0ZXM2JyxcbiAgICBCeXRlczc6ICdieXRlczcnLFxuICAgIEJ5dGVzODogJ2J5dGVzOCcsXG4gICAgQnl0ZXM5OiAnYnl0ZXM5JyxcbiAgICBCeXRlczEwOiAnYnl0ZXMxMCcsXG4gICAgQnl0ZXMxMTogJ2J5dGVzMTEnLFxuICAgIEJ5dGVzMTI6ICdieXRlczEyJyxcbiAgICBCeXRlczEzOiAnYnl0ZXMxMycsXG4gICAgQnl0ZXMxNDogJ2J5dGVzMTQnLFxuICAgIEJ5dGVzMTU6ICdieXRlczE1JyxcbiAgICBCeXRlczE2OiAnYnl0ZXMxNicsXG4gICAgQnl0ZXMxNzogJ2J5dGVzMTcnLFxuICAgIEJ5dGVzMTg6ICdieXRlczE4JyxcbiAgICBCeXRlczE5OiAnYnl0ZXMxOScsXG4gICAgQnl0ZXMyMDogJ2J5dGVzMjAnLFxuICAgIEJ5dGVzMjE6ICdieXRlczIxJyxcbiAgICBCeXRlczIyOiAnYnl0ZXMyMicsXG4gICAgQnl0ZXMyMzogJ2J5dGVzMjMnLFxuICAgIEJ5dGVzMjQ6ICdieXRlczI0JyxcbiAgICBCeXRlczI1OiAnYnl0ZXMyNScsXG4gICAgQnl0ZXMyNjogJ2J5dGVzMjYnLFxuICAgIEJ5dGVzMjc6ICdieXRlczI3JyxcbiAgICBCeXRlczI4OiAnYnl0ZXMyOCcsXG4gICAgQnl0ZXMyOTogJ2J5dGVzMjknLFxuICAgIEJ5dGVzMzA6ICdieXRlczMwJyxcbiAgICBCeXRlczMxOiAnYnl0ZXMzMScsXG4gICAgQnl0ZXMzMjogJ2J5dGVzMzInLFxuICAgIEFycmF5OiAnYXJyYXknLFxuICAgIFR1cGxlOiAndHVwbGUnXG59O1xuZXhwb3J0cy5TcG9uc29yZWRTZW5kU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgU2lnbmVkOiAnc2lnbmVkJyxcbiAgICBTdWJtaXR0ZWQ6ICdzdWJtaXR0ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCdcbn07XG5leHBvcnRzLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtID0ge1xuICAgIEluaXRpYWxpemVkOiAnaW5pdGlhbGl6ZWQnLFxuICAgIENvbXBsZXRlOiAnY29tcGxldGUnLFxuICAgIEZhaWxlZDogJ2ZhaWxlZCcsXG4gICAgVW5zcGVjaWZpZWQ6ICd1bnNwZWNpZmllZCdcbn07XG5leHBvcnRzLlN0YWtpbmdSZXdhcmRTdGF0ZUVudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIERpc3RyaWJ1dGVkOiAnZGlzdHJpYnV0ZWQnXG59O1xuLyoqXG4gKiBUaGUgZm9ybWF0IGluIHdoaWNoIHRoZSByZXdhcmRzIGFyZSB0byBiZSBmZXRjaGVkIGkuZSBuYXRpdmUgb3IgaW4gZXF1aXZhbGVudCBVU0RcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuU3Rha2luZ1Jld2FyZEZvcm1hdCA9IHtcbiAgICBVc2Q6ICd1c2QnLFxuICAgIE5hdGl2ZTogJ25hdGl2ZSdcbn07XG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbiB0cmFuc2Zlci5cbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuVG9rZW5UcmFuc2ZlclR5cGUgPSB7XG4gICAgRXJjMjA6ICdlcmMyMCcsXG4gICAgRXJjNzIxOiAnZXJjNzIxJyxcbiAgICBFcmMxMTU1OiAnZXJjMTE1NScsXG4gICAgVW5rbm93bjogJ3Vua25vd24nXG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvblN0YXR1c0VudW0gPSB7XG4gICAgUGVuZGluZzogJ3BlbmRpbmcnLFxuICAgIFNpZ25lZDogJ3NpZ25lZCcsXG4gICAgQnJvYWRjYXN0OiAnYnJvYWRjYXN0JyxcbiAgICBDb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnLFxuICAgIFVuc3BlY2lmaWVkOiAndW5zcGVjaWZpZWQnXG59O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICogQGVudW0ge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSB7XG4gICAgVHJhbnNmZXI6ICd0cmFuc2Zlcidcbn07XG5leHBvcnRzLlRyYW5zZmVyU3RhdHVzRW51bSA9IHtcbiAgICBQZW5kaW5nOiAncGVuZGluZycsXG4gICAgQnJvYWRjYXN0OiAnYnJvYWRjYXN0JyxcbiAgICBDb21wbGV0ZTogJ2NvbXBsZXRlJyxcbiAgICBGYWlsZWQ6ICdmYWlsZWQnXG59O1xuLyoqXG4gKiBUaGUgc3RhdHVzIG9mIHRoZSB2YWxpZGF0b3IuXG4gKiBAZXhwb3J0XG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5leHBvcnRzLlZhbGlkYXRvclN0YXR1cyA9IHtcbiAgICBVbmtub3duOiAndW5rbm93bicsXG4gICAgUHJvdmlzaW9uaW5nOiAncHJvdmlzaW9uaW5nJyxcbiAgICBQcm92aXNpb25lZDogJ3Byb3Zpc2lvbmVkJyxcbiAgICBEZXBvc2l0ZWQ6ICdkZXBvc2l0ZWQnLFxuICAgIFBlbmRpbmdBY3RpdmF0aW9uOiAncGVuZGluZ19hY3RpdmF0aW9uJyxcbiAgICBBY3RpdmU6ICdhY3RpdmUnLFxuICAgIEV4aXRpbmc6ICdleGl0aW5nJyxcbiAgICBFeGl0ZWQ6ICdleGl0ZWQnLFxuICAgIFdpdGhkcmF3YWxBdmFpbGFibGU6ICd3aXRoZHJhd2FsX2F2YWlsYWJsZScsXG4gICAgV2l0aGRyYXdhbENvbXBsZXRlOiAnd2l0aGRyYXdhbF9jb21wbGV0ZScsXG4gICAgQWN0aXZlU2xhc2hlZDogJ2FjdGl2ZV9zbGFzaGVkJyxcbiAgICBFeGl0ZWRTbGFzaGVkOiAnZXhpdGVkX3NsYXNoZWQnLFxuICAgIFJlYXBlZDogJ3JlYXBlZCdcbn07XG5leHBvcnRzLldhbGxldFNlcnZlclNpZ25lclN0YXR1c0VudW0gPSB7XG4gICAgUGVuZGluZ1NlZWRDcmVhdGlvbjogJ3BlbmRpbmdfc2VlZF9jcmVhdGlvbicsXG4gICAgQWN0aXZlU2VlZDogJ2FjdGl2ZV9zZWVkJ1xufTtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuV2ViaG9va0V2ZW50VHlwZSA9IHtcbiAgICBVbnNwZWNpZmllZDogJ3Vuc3BlY2lmaWVkJyxcbiAgICBFcmMyMFRyYW5zZmVyOiAnZXJjMjBfdHJhbnNmZXInLFxuICAgIEVyYzcyMVRyYW5zZmVyOiAnZXJjNzIxX3RyYW5zZmVyJyxcbiAgICBXYWxsZXRBY3Rpdml0eTogJ3dhbGxldF9hY3Rpdml0eSdcbn07XG4vKipcbiAqIEFkZHJlc3Nlc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGFkZHJlc3Mgc2NvcGVkIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIGFkZHJlc3MgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQWRkcmVzc1JlcXVlc3R9IFtjcmVhdGVBZGRyZXNzUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUFkZHJlc3M6IGFzeW5jICh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlQWRkcmVzcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVBZGRyZXNzUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIHNpZ24gdGhlIHBheWxvYWQgd2l0aC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdH0gW2NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZTogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVBheWxvYWRTaWduYXR1cmUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlUGF5bG9hZFNpZ25hdHVyZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vcGF5bG9hZF9zaWduYXR1cmVzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBieSBvbmNoYWluIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBZGRyZXNzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFkZHJlc3MnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFkZHJlc3NCYWxhbmNlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRBZGRyZXNzQmFsYW5jZScsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlcy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIHRoZSBwYXlsb2FkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZFNpZ25hdHVyZUlkIFRoZSBJRCBvZiB0aGUgcGF5bG9hZCBzaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXlsb2FkU2lnbmF0dXJlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFBheWxvYWRTaWduYXR1cmUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0UGF5bG9hZFNpZ25hdHVyZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncGF5bG9hZFNpZ25hdHVyZUlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFBheWxvYWRTaWduYXR1cmUnLCAncGF5bG9hZFNpZ25hdHVyZUlkJywgcGF5bG9hZFNpZ25hdHVyZUlkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3BheWxvYWRfc2lnbmF0dXJlcy97cGF5bG9hZF9zaWduYXR1cmVfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInBheWxvYWRfc2lnbmF0dXJlX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcocGF5bG9hZFNpZ25hdHVyZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3MgYmFsYW5jZXNcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFsbCBiYWxhbmNlcyBmb3IgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3NCYWxhbmNlczogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NCYWxhbmNlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgd2hvc2UgYWRkcmVzc2VzIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzZXM6IGFzeW5jICh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHdob3NlIHBheWxvYWQgc2lnbmF0dXJlcyB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFBheWxvYWRTaWduYXR1cmVzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFBheWxvYWRTaWduYXR1cmVzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RQYXlsb2FkU2lnbmF0dXJlcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vcGF5bG9hZF9zaWduYXR1cmVzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RmF1Y2V0RnVuZHM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlcXVlc3RGYXVjZXRGdW5kcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXF1ZXN0RmF1Y2V0RnVuZHMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2ZhdWNldGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFzc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Fzc2V0X2lkJ10gPSBhc3NldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZGRyZXNzZXNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGFkZHJlc3Mgc2NvcGVkIHRvIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBjcmVhdGUgdGhlIGFkZHJlc3MgaW4uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQWRkcmVzc1JlcXVlc3R9IFtjcmVhdGVBZGRyZXNzUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUFkZHJlc3Mod2FsbGV0SWQsIGNyZWF0ZUFkZHJlc3NSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmNyZWF0ZUFkZHJlc3MnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIHNpZ24gdGhlIHBheWxvYWQgd2l0aC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdH0gW2NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYnkgb25jaGFpbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5nZXRBZGRyZXNzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFkZHJlc3NCYWxhbmNlKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5nZXRBZGRyZXNzQmFsYW5jZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IHNpZ25lZCB0aGUgcGF5bG9hZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBheWxvYWRTaWduYXR1cmVJZCBUaGUgSUQgb2YgdGhlIHBheWxvYWQgc2lnbmF0dXJlIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0UGF5bG9hZFNpZ25hdHVyZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYXlsb2FkU2lnbmF0dXJlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkuZ2V0UGF5bG9hZFNpZ25hdHVyZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWxsIGJhbGFuY2VzIGZvciBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmxpc3RBZGRyZXNzQmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBhZGRyZXNzZXMgaW4gYSB3YWxsZXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBZGRyZXNzZXNBcGkubGlzdEFkZHJlc3NlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHBheWxvYWQgc2lnbmF0dXJlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3Mgd2hvc2UgcGF5bG9hZCBzaWduYXR1cmVzIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQWRkcmVzc2VzQXBpLmxpc3RQYXlsb2FkU2lnbmF0dXJlcyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlcXVlc3RGYXVjZXRGdW5kcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0FkZHJlc3Nlc0FwaS5yZXF1ZXN0RmF1Y2V0RnVuZHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCA9IEFkZHJlc3Nlc0FwaUZwO1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBZGRyZXNzZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSBhZGRyZXNzIGluLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVBZGRyZXNzKHdhbGxldElkLCBjcmVhdGVBZGRyZXNzUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUgd2l0aCBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gc2lnbiB0aGUgcGF5bG9hZCB3aXRoLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0fSBbY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVBheWxvYWRTaWduYXR1cmVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYnkgb25jaGFpbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QWRkcmVzcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBZGRyZXNzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYWRkcmVzcyBiYWxhbmNlXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBZGRyZXNzQmFsYW5jZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHBheWxvYWQgc2lnbmF0dXJlLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBzaWduZWQgdGhlIHBheWxvYWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhbGwgYmFsYW5jZXMgZm9yIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzQmFsYW5jZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBhZGRyZXNzZXMgaW4gYSB3YWxsZXQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEFkZHJlc3Nlcyh3YWxsZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBwYXlsb2FkIHNpZ25hdHVyZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHdob3NlIHBheWxvYWQgc2lnbmF0dXJlcyB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFBheWxvYWRTaWduYXR1cmVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgUmVxdWVzdCBmYXVjZXQgZnVuZHMgZm9yIG9uY2hhaW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFkZHJlc3Nlc0FwaUZhY3RvcnkgPSBBZGRyZXNzZXNBcGlGYWN0b3J5O1xuLyoqXG4gKiBBZGRyZXNzZXNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQWRkcmVzc2VzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQWRkcmVzc2VzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBhZGRyZXNzIHNjb3BlZCB0byB0aGUgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgYWRkcmVzcyBpbi5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUFkZHJlc3NSZXF1ZXN0fSBbY3JlYXRlQWRkcmVzc1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVBZGRyZXNzKHdhbGxldElkLCBjcmVhdGVBZGRyZXNzUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlQWRkcmVzcyh3YWxsZXRJZCwgY3JlYXRlQWRkcmVzc1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcGF5bG9hZCBzaWduYXR1cmUgd2l0aCBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdG8gc2lnbiB0aGUgcGF5bG9hZCB3aXRoLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3R9IFtjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlUGF5bG9hZFNpZ25hdHVyZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJ5IG9uY2hhaW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEFkZHJlc3Mod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VcbiAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGZvciBhc3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0QWRkcmVzc0JhbGFuY2Uod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBwYXlsb2FkIHNpZ25hdHVyZS5cbiAgICAgKiBAc3VtbWFyeSBHZXQgcGF5bG9hZCBzaWduYXR1cmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgc2lnbmVkIHRoZSBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXlsb2FkU2lnbmF0dXJlSWQgVGhlIElEIG9mIHRoZSBwYXlsb2FkIHNpZ25hdHVyZSB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGdldFBheWxvYWRTaWduYXR1cmUod2FsbGV0SWQsIGFkZHJlc3NJZCwgcGF5bG9hZFNpZ25hdHVyZUlkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRQYXlsb2FkU2lnbmF0dXJlKHdhbGxldElkLCBhZGRyZXNzSWQsIHBheWxvYWRTaWduYXR1cmVJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhZGRyZXNzIGJhbGFuY2VzXG4gICAgICogQHN1bW1hcnkgR2V0IGFsbCBiYWxhbmNlcyBmb3IgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZXMgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgbGlzdEFkZHJlc3NCYWxhbmNlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0QWRkcmVzc0JhbGFuY2VzKHdhbGxldElkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IExpc3QgYWRkcmVzc2VzIGluIGEgd2FsbGV0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB3aG9zZSBhZGRyZXNzZXMgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEFkZHJlc3Nlc0FwaVxuICAgICAqL1xuICAgIGxpc3RBZGRyZXNzZXMod2FsbGV0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5BZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0QWRkcmVzc2VzKHdhbGxldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgcGF5bG9hZCBzaWduYXR1cmVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB3aG9zZSBwYXlsb2FkIHNpZ25hdHVyZXMgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0UGF5bG9hZFNpZ25hdHVyZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RQYXlsb2FkU2lnbmF0dXJlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIHRvIGJlIHNlbnQgdG8gb25jaGFpbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBvbmNoYWluIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICByZXF1ZXN0RmF1Y2V0RnVuZHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVxdWVzdEZhdWNldEZ1bmRzKHdhbGxldElkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzc2VzQXBpID0gQWRkcmVzc2VzQXBpO1xuLyoqXG4gKiBBc3NldHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3NldHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXNzZXQ6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFzc2V0JywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEFzc2V0JywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2Fzc2V0cy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFzc2V0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIEFzc2V0c0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEFzc2V0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQXNzZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGFzc2V0IGZvciB0aGUgc3BlY2lmaWVkIGFzc2V0IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2guIFRoaXMgY291bGQgYmUgYSBzeW1ib2wgb3IgYW4gRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEFzc2V0KG5ldHdvcmtJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydBc3NldHNBcGkuZ2V0QXNzZXQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Bc3NldHNBcGlGcCA9IEFzc2V0c0FwaUZwO1xuLyoqXG4gKiBBc3NldHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBBc3NldHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Bc3NldHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkFzc2V0c0FwaUZhY3RvcnkgPSBBc3NldHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBBc3NldHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQXNzZXRzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgQXNzZXRzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXNzZXQgZm9yIHRoZSBzcGVjaWZpZWQgYXNzZXQgSUQuXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBhc3NldCBmb3IgdGhlIHNwZWNpZmllZCBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaC4gVGhpcyBjb3VsZCBiZSBhIHN5bWJvbCBvciBhbiBFUkMyMCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQXNzZXRzQXBpXG4gICAgICovXG4gICAgZ2V0QXNzZXQobmV0d29ya0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Bc3NldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRBc3NldChuZXR3b3JrSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXRzQXBpID0gQXNzZXRzQXBpO1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbGFuY2VIaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRoZSBoaXN0b3JpY2FsIGJhbGFuY2Ugb2YgYW4gYXNzZXQgaW4gYSBzcGVjaWZpYyBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYWRkcmVzcyBiYWxhbmNlIGhpc3RvcnkgZm9yIGFzc2V0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBoaXN0b3JpY2FsIGJhbGFuY2UgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlJywgJ2Fzc2V0SWQnLCBhc3NldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vYmFsYW5jZV9oaXN0b3J5L3thc3NldF9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5CYWxhbmNlSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQmFsYW5jZUhpc3RvcnlBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBCYWxhbmNlSGlzdG9yeUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgaGlzdG9yeSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQmFsYW5jZUhpc3RvcnlBcGkubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnAgPSBCYWxhbmNlSGlzdG9yeUFwaUZwO1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEJhbGFuY2VIaXN0b3J5QXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhZGRyZXNzIGJhbGFuY2UgaGlzdG9yeSBmb3IgYXNzZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzSGlzdG9yaWNhbEJhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0QWRkcmVzc0hpc3RvcmljYWxCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5ID0gQmFsYW5jZUhpc3RvcnlBcGlGYWN0b3J5O1xuLyoqXG4gKiBCYWxhbmNlSGlzdG9yeUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBCYWxhbmNlSGlzdG9yeUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEJhbGFuY2VIaXN0b3J5QXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIExpc3QgdGhlIGhpc3RvcmljYWwgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhIHNwZWNpZmljIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgR2V0IGFkZHJlc3MgYmFsYW5jZSBoaXN0b3J5IGZvciBhc3NldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEJhbGFuY2VIaXN0b3J5QXBpXG4gICAgICovXG4gICAgbGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkJhbGFuY2VIaXN0b3J5QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZUhpc3RvcnlBcGkgPSBCYWxhbmNlSGlzdG9yeUFwaTtcbi8qKlxuICogQ29udHJhY3RFdmVudHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBDb250cmFjdEV2ZW50c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IExvd2VyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0RXZlbnRzOiBhc3luYyAobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncHJvdG9jb2xOYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdwcm90b2NvbE5hbWUnLCBwcm90b2NvbE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3ROYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdjb250cmFjdE5hbWUnLCBjb250cmFjdE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZXZlbnROYW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdldmVudE5hbWUnLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZnJvbUJsb2NrSGVpZ2h0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RDb250cmFjdEV2ZW50cycsICdmcm9tQmxvY2tIZWlnaHQnLCBmcm9tQmxvY2tIZWlnaHQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndG9CbG9ja0hlaWdodCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0Q29udHJhY3RFdmVudHMnLCAndG9CbG9ja0hlaWdodCcsIHRvQmxvY2tIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vc21hcnRfY29udHJhY3RzL3tjb250cmFjdF9hZGRyZXNzfS9ldmVudHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2FkZHJlc3NcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEFkZHJlc3MpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAocHJvdG9jb2xOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwcm90b2NvbF9uYW1lJ10gPSBwcm90b2NvbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udHJhY3ROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydjb250cmFjdF9uYW1lJ10gPSBjb250cmFjdE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydldmVudF9uYW1lJ10gPSBldmVudE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJvbUJsb2NrSGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydmcm9tX2Jsb2NrX2hlaWdodCddID0gZnJvbUJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvQmxvY2tIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3RvX2Jsb2NrX2hlaWdodCddID0gdG9CbG9ja0hlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0UGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbmV4dF9wYWdlJ10gPSBuZXh0UGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RFdmVudHNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZSBldmVudHMgZm9yIGEgc3BlY2lmaWMgY29udHJhY3RcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBjb250cmFjdCBldmVudHNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBVbmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xOYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGJsb2NrY2hhaW4gcHJvdG9jb2xcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzcyBFVk0gYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QgKDQyIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBcXCYjMzk7MHhcXCYjMzk7LCBpbiBsb3dlcmNhc2UpXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgc3BlY2lmaWMgY29udHJhY3Qgd2l0aGluIHRoZSBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlsdGVyIGZvciBpbiB0aGUgY29udHJhY3RcXCYjMzk7cyBsb2dzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tQmxvY2tIZWlnaHQgTG93ZXIgYm91bmQgb2YgdGhlIGJsb2NrIHJhbmdlIHRvIHF1ZXJ5IChpbmNsdXNpdmUpXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0Jsb2NrSGVpZ2h0IFVwcGVyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25leHRQYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RFdmVudHNBcGkubGlzdENvbnRyYWN0RXZlbnRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCA9IENvbnRyYWN0RXZlbnRzQXBpRnA7XG4vKipcbiAqIENvbnRyYWN0RXZlbnRzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RFdmVudHNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Db250cmFjdEV2ZW50c0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmUgZXZlbnRzIGZvciBhIHNwZWNpZmljIGNvbnRyYWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgZXZlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sTmFtZSBDYXNlLXNlbnNpdGl2ZSBuYW1lIG9mIHRoZSBibG9ja2NoYWluIHByb3RvY29sXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEFkZHJlc3MgRVZNIGFkZHJlc3Mgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0ICg0MiBjaGFyYWN0ZXJzLCBpbmNsdWRpbmcgXFwmIzM5OzB4XFwmIzM5OywgaW4gbG93ZXJjYXNlKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGZpbHRlciBmb3IgaW4gdGhlIGNvbnRyYWN0XFwmIzM5O3MgbG9nc1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUJsb2NrSGVpZ2h0IExvd2VyIGJvdW5kIG9mIHRoZSBibG9jayByYW5nZSB0byBxdWVyeSAoaW5jbHVzaXZlKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtuZXh0UGFnZV0gUGFnaW5hdGlvbiB0b2tlbiBmb3IgcmV0cmlldmluZyB0aGUgbmV4dCBzZXQgb2YgcmVzdWx0c1xuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0RXZlbnRzKG5ldHdvcmtJZCwgcHJvdG9jb2xOYW1lLCBjb250cmFjdEFkZHJlc3MsIGNvbnRyYWN0TmFtZSwgZXZlbnROYW1lLCBmcm9tQmxvY2tIZWlnaHQsIHRvQmxvY2tIZWlnaHQsIG5leHRQYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeSA9IENvbnRyYWN0RXZlbnRzQXBpRmFjdG9yeTtcbi8qKlxuICogQ29udHJhY3RFdmVudHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQ29udHJhY3RFdmVudHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBDb250cmFjdEV2ZW50c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBldmVudHMgZm9yIGEgc3BlY2lmaWMgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGV2ZW50c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvdG9jb2xOYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIGJsb2NrY2hhaW4gcHJvdG9jb2xcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzIEVWTSBhZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdCAoNDIgY2hhcmFjdGVycywgaW5jbHVkaW5nIFxcJiMzOTsweFxcJiMzOTssIGluIGxvd2VyY2FzZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3ROYW1lIENhc2Utc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHNwZWNpZmljIGNvbnRyYWN0IHdpdGhpbiB0aGUgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgQ2FzZS1zZW5zaXRpdmUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZmlsdGVyIGZvciBpbiB0aGUgY29udHJhY3RcXCYjMzk7cyBsb2dzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21CbG9ja0hlaWdodCBMb3dlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9CbG9ja0hlaWdodCBVcHBlciBib3VuZCBvZiB0aGUgYmxvY2sgcmFuZ2UgdG8gcXVlcnkgKGluY2x1c2l2ZSlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25leHRQYWdlXSBQYWdpbmF0aW9uIHRva2VuIGZvciByZXRyaWV2aW5nIHRoZSBuZXh0IHNldCBvZiByZXN1bHRzXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEV2ZW50c0FwaVxuICAgICAqL1xuICAgIGxpc3RDb250cmFjdEV2ZW50cyhuZXR3b3JrSWQsIHByb3RvY29sTmFtZSwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0LCBuZXh0UGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0Q29udHJhY3RFdmVudHMobmV0d29ya0lkLCBwcm90b2NvbE5hbWUsIGNvbnRyYWN0QWRkcmVzcywgY29udHJhY3ROYW1lLCBldmVudE5hbWUsIGZyb21CbG9ja0hlaWdodCwgdG9CbG9ja0hlaWdodCwgbmV4dFBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RFdmVudHNBcGkgPSBDb250cmFjdEV2ZW50c0FwaTtcbi8qKlxuICogQ29udHJhY3RJbnZvY2F0aW9uc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjb250cmFjdEludm9jYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nLCAnY29udHJhY3RJbnZvY2F0aW9uSWQnLCBjb250cmFjdEludm9jYXRpb25JZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbicsICdicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JywgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9jb250cmFjdF9pbnZvY2F0aW9ucy97Y29udHJhY3RfaW52b2NhdGlvbl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImNvbnRyYWN0X2ludm9jYXRpb25faWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhjb250cmFjdEludm9jYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW52b2NhdGlvbiBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBpbnZva2UgdGhlIGNvbnRyYWN0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVDb250cmFjdEludm9jYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbicsICdjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0JywgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9jb250cmFjdF9pbnZvY2F0aW9uc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBjb250cmFjdCBpbnZvY2F0aW9uIGJ5IElELlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0SW52b2NhdGlvbklkIFRoZSBJRCBvZiB0aGUgY29udHJhY3QgaW52b2NhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldENvbnRyYWN0SW52b2NhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldENvbnRyYWN0SW52b2NhdGlvbicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRDb250cmFjdEludm9jYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NvbnRyYWN0SW52b2NhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldENvbnRyYWN0SW52b2NhdGlvbicsICdjb250cmFjdEludm9jYXRpb25JZCcsIGNvbnRyYWN0SW52b2NhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2NvbnRyYWN0X2ludm9jYXRpb25zL3tjb250cmFjdF9pbnZvY2F0aW9uX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9pbnZvY2F0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RJbnZvY2F0aW9uSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RDb250cmFjdEludm9jYXRpb25zOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdENvbnRyYWN0SW52b2NhdGlvbnMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdENvbnRyYWN0SW52b2NhdGlvbnMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2NvbnRyYWN0X2ludm9jYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogQ29udHJhY3RJbnZvY2F0aW9uc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IENvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5icm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnQ29udHJhY3RJbnZvY2F0aW9uc0FwaS5icm9hZGNhc3RDb250cmFjdEludm9jYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGludm9rZSB0aGUgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0SW52b2NhdGlvbnNBcGkuY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0NvbnRyYWN0SW52b2NhdGlvbnNBcGkuZ2V0Q29udHJhY3RJbnZvY2F0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0Q29udHJhY3RJbnZvY2F0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydDb250cmFjdEludm9jYXRpb25zQXBpLmxpc3RDb250cmFjdEludm9jYXRpb25zJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwID0gQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwO1xuLyoqXG4gKiBDb250cmFjdEludm9jYXRpb25zQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RJbnZvY2F0aW9uSWQgVGhlIElEIG9mIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgY29udHJhY3QgaW52b2NhdGlvbiBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBpbnZva2UgdGhlIGNvbnRyYWN0IGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY29udHJhY3RJbnZvY2F0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RDb250cmFjdEludm9jYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRmFjdG9yeSA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBDb250cmFjdEludm9jYXRpb25zQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIENvbnRyYWN0SW52b2NhdGlvbnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBDb250cmFjdEludm9jYXRpb25zQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIGNvbnRyYWN0IGludm9jYXRpb24uXG4gICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgY29udHJhY3QgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdH0gYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udHJhY3RJbnZvY2F0aW9uc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjb250cmFjdEludm9jYXRpb25JZCwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBjb250cmFjdCBpbnZvY2F0aW9uIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBpbnZva2UgdGhlIGNvbnRyYWN0IGZyb20uXG4gICAgICogQHBhcmFtIHtDcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0fSBjcmVhdGVDb250cmFjdEludm9jYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUNvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVDb250cmFjdEludm9jYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIGNvbnRyYWN0IGludm9jYXRpb24gYnkgSUQuXG4gICAgICogQHN1bW1hcnkgR2V0IGEgY29udHJhY3QgaW52b2NhdGlvbiBieSBJRC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgY29udHJhY3QgaW52b2NhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cmFjdEludm9jYXRpb25JZCBUaGUgSUQgb2YgdGhlIGNvbnRyYWN0IGludm9jYXRpb24gdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBDb250cmFjdEludm9jYXRpb25zQXBpXG4gICAgICovXG4gICAgZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0Q29udHJhY3RJbnZvY2F0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNvbnRyYWN0SW52b2NhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBjb250cmFjdCBpbnZvY2F0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IGNvbnRyYWN0IGludm9jYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgY29udHJhY3QgaW52b2NhdGlvbnMgZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29udHJhY3RJbnZvY2F0aW9uc0FwaVxuICAgICAqL1xuICAgIGxpc3RDb250cmFjdEludm9jYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5Db250cmFjdEludm9jYXRpb25zQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdENvbnRyYWN0SW52b2NhdGlvbnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uc0FwaSA9IENvbnRyYWN0SW52b2NhdGlvbnNBcGk7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UnLCAnYXNzZXRJZCcsIGFzc2V0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9iYWxhbmNlcy97YXNzZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYXNzZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhc3NldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHhIYXNoIFRoZSBoYXNoIG9mIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZhdWNldFRyYW5zYWN0aW9uOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RmF1Y2V0VHJhbnNhY3Rpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRGYXVjZXRUcmFuc2FjdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHhIYXNoJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZhdWNldFRyYW5zYWN0aW9uJywgJ3R4SGFzaCcsIHR4SGFzaCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2ZhdWNldC97dHhfaGFzaH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0eF9oYXNoXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHhIYXNoKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgb2YgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXM6IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBXYWl0XSBXaGV0aGVyIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLiBUaGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kczogYXN5bmMgKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mYXVjZXRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGFzc2V0SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2Fzc2V0X2lkJ10gPSBhc3NldElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNraXBXYWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydza2lwX3dhaXQnXSA9IHNraXBXYWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogRXh0ZXJuYWxBZGRyZXNzZXNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBFeHRlcm5hbEFkZHJlc3Nlc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgc3RhdHVzIG9mIGEgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGZhdWNldCB0cmFuc2FjdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR4SGFzaCBUaGUgaGFzaCBvZiB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5nZXRGYXVjZXRUcmFuc2FjdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCBvZiB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGJhbGFuY2VzIG9mIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RFeHRlcm5hbEFkZHJlc3NCYWxhbmNlcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydFeHRlcm5hbEFkZHJlc3Nlc0FwaS5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXF1ZXN0IGZhdWNldCBmdW5kcyBmb3IgZXh0ZXJuYWwgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Fzc2V0SWRdIFRoZSBJRCBvZiB0aGUgYXNzZXQgdG8gdHJhbnNmZXIgZnJvbSB0aGUgZmF1Y2V0LlxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwV2FpdF0gV2hldGhlciB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBiZSBtaW5lZC4gVGhpcyB3aWxsIGJlY29tZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0V4dGVybmFsQWRkcmVzc2VzQXBpLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCA9IEV4dGVybmFsQWRkcmVzc2VzQXBpRnA7XG4vKipcbiAqIEV4dGVybmFsQWRkcmVzc2VzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldEV4dGVybmFsQWRkcmVzc0JhbGFuY2UobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBmYXVjZXQgdHJhbnNhY3Rpb24gZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggVGhlIGhhc2ggb2YgdGhlIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHR4SGFzaCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgYWxsIG9mIHRoZSBiYWxhbmNlcyBvZiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXF1ZXN0IGZhdWNldCBmdW5kcyB0byBiZSBzZW50IHRvIGV4dGVybmFsIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGlzIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBXYWl0XSBXaGV0aGVyIHRvIHNraXAgd2FpdGluZyBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIG1pbmVkLiBUaGlzIHdpbGwgYmVjb21lIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgc2tpcFdhaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5ID0gRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5O1xuLyoqXG4gKiBFeHRlcm5hbEFkZHJlc3Nlc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBFeHRlcm5hbEFkZHJlc3Nlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIEV4dGVybmFsQWRkcmVzc2VzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiBhbiBleHRlcm5hbCBhZGRyZXNzXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBiYWxhbmNlIG9mIGFuIGFzc2V0IGluIGFuIGV4dGVybmFsIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgZ2V0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZShuZXR3b3JrSWQsIGFkZHJlc3NJZCwgYXNzZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGF0dXMgb2YgYSBmYXVjZXQgdHJhbnNhY3Rpb25cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIHN0YXR1cyBvZiBhIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eEhhc2ggVGhlIGhhc2ggb2YgdGhlIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBnZXRGYXVjZXRUcmFuc2FjdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgdHhIYXNoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldEZhdWNldFRyYW5zYWN0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCB0eEhhc2gsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBvZiB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZXMgb2YgYW4gZXh0ZXJuYWwgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgRXh0ZXJuYWxBZGRyZXNzZXNBcGlcbiAgICAgKi9cbiAgICBsaXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXMobmV0d29ya0lkLCBhZGRyZXNzSWQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkV4dGVybmFsQWRkcmVzc2VzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEV4dGVybmFsQWRkcmVzc0JhbGFuY2VzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBmYXVjZXQgZnVuZHMgdG8gYmUgc2VudCB0byBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IFJlcXVlc3QgZmF1Y2V0IGZ1bmRzIGZvciBleHRlcm5hbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBpcyBiZWluZyBmZXRjaGVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYXNzZXRJZF0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFdhaXRdIFdoZXRoZXIgdG8gc2tpcCB3YWl0aW5nIGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gYmUgbWluZWQuIFRoaXMgd2lsbCBiZWNvbWUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEV4dGVybmFsQWRkcmVzc2VzQXBpXG4gICAgICovXG4gICAgcmVxdWVzdEV4dGVybmFsRmF1Y2V0RnVuZHMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGFzc2V0SWQsIHNraXBXYWl0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLnJlcXVlc3RFeHRlcm5hbEZhdWNldEZ1bmRzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBhc3NldElkLCBza2lwV2FpdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5FeHRlcm5hbEFkZHJlc3Nlc0FwaSA9IEV4dGVybmFsQWRkcmVzc2VzQXBpO1xuLyoqXG4gKiBGdW5kQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnVuZEFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRPcGVyYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRPcGVyYXRpb24nLCAnY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QnLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9mdW5kX29wZXJhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIEZ1bmQgT3BlcmF0aW9uIHF1b3RlLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVGdW5kUXVvdGVSZXF1ZXN0fSBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGdW5kUXVvdGU6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZUZ1bmRRdW90ZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVGdW5kUXVvdGUnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlRnVuZFF1b3RlJywgJ2NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QnLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2Z1bmRfb3BlcmF0aW9ucy9xdW90ZWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0aGF0IGNyZWF0ZWQgdGhlIGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuZE9wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgZnVuZCBvcGVyYXRpb24gdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRGdW5kT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZ1bmRPcGVyYXRpb24nLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0RnVuZE9wZXJhdGlvbicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnZnVuZE9wZXJhdGlvbklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldEZ1bmRPcGVyYXRpb24nLCAnZnVuZE9wZXJhdGlvbklkJywgZnVuZE9wZXJhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2Z1bmRfb3BlcmF0aW9ucy97ZnVuZF9vcGVyYXRpb25faWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImZ1bmRfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoZnVuZE9wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdEZ1bmRPcGVyYXRpb25zOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdEZ1bmRPcGVyYXRpb25zJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RGdW5kT3BlcmF0aW9ucycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vZnVuZF9vcGVyYXRpb25zYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLkZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IEZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogRnVuZEFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IEZ1bmRBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLkZ1bmRBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlRnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGdW5kQXBpLmNyZWF0ZUZ1bmRPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlRnVuZFF1b3RlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnRnVuZEFwaS5jcmVhdGVGdW5kUXVvdGUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBjcmVhdGVkIHRoZSBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZ1bmRPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIGZ1bmQgb3BlcmF0aW9uIHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0RnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydGdW5kQXBpLmdldEZ1bmRPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBmdW5kIG9wZXJhdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgZnVuZCBvcGVyYXRpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ0Z1bmRBcGkubGlzdEZ1bmRPcGVyYXRpb25zJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuRnVuZEFwaUZwID0gRnVuZEFwaUZwO1xuLyoqXG4gKiBGdW5kQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgRnVuZEFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uIHdpdGggYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgdG8gYmUgZnVuZGVkLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIG9mIHRoZSBhZGRyZXNzIHRoYXQgY3JlYXRlZCB0aGUgZnVuZCBvcGVyYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmdW5kT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBmdW5kIG9wZXJhdGlvbiB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEZ1bmRPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgZnVuZE9wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RGdW5kT3BlcmF0aW9ucyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5GdW5kQXBpRmFjdG9yeSA9IEZ1bmRBcGlGYWN0b3J5O1xuLyoqXG4gKiBGdW5kQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIEZ1bmRBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBGdW5kQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyB0byBiZSBmdW5kZWQuXG4gICAgICogQHBhcmFtIHtDcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlRnVuZE9wZXJhdGlvblJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZUZ1bmRPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GdW5kQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlRnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBmdW5kIG9wZXJhdGlvbiB3aXRoIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgRnVuZCBPcGVyYXRpb24gcXVvdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgb25jaGFpbiBhZGRyZXNzIHRvIGJlIGZ1bmRlZC5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUZ1bmRRdW90ZVJlcXVlc3R9IGNyZWF0ZUZ1bmRRdW90ZVJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIEZ1bmRBcGlcbiAgICAgKi9cbiAgICBjcmVhdGVGdW5kUXVvdGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlRnVuZFF1b3RlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuRnVuZEFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZUZ1bmRRdW90ZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVGdW5kUXVvdGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZ1bmQgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IEdldCBmdW5kIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIGFkZHJlc3MgdGhhdCBjcmVhdGVkIHRoZSBmdW5kIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZnVuZE9wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgZnVuZCBvcGVyYXRpb24gdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGdW5kQXBpXG4gICAgICovXG4gICAgZ2V0RnVuZE9wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBmdW5kT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLkZ1bmRBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRGdW5kT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGZ1bmRPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgZnVuZCBvcGVyYXRpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IGZ1bmQgb3BlcmF0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBGdW5kQXBpXG4gICAgICovXG4gICAgbGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5GdW5kQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEZ1bmRPcGVyYXRpb25zKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLkZ1bmRBcGkgPSBGdW5kQXBpO1xuLyoqXG4gKiBOZXR3b3Jrc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE5ldHdvcmtzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgbmV0d29yayBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5ldHdvcms6IGFzeW5jIChuZXR3b3JrSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldE5ldHdvcmsnLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk5ldHdvcmtzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBOZXR3b3Jrc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBOZXR3b3Jrc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IE5ldHdvcmtzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5OZXR3b3Jrc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IG5ldHdvcmsgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIG5ldHdvcmsgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ05ldHdvcmtzQXBpLmdldE5ldHdvcmsnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5OZXR3b3Jrc0FwaUZwID0gTmV0d29ya3NBcGlGcDtcbi8qKlxuICogTmV0d29ya3NBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBOZXR3b3Jrc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLk5ldHdvcmtzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgbmV0d29ya1xuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgbmV0d29yayBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldE5ldHdvcmsobmV0d29ya0lkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXROZXR3b3JrKG5ldHdvcmtJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuTmV0d29ya3NBcGlGYWN0b3J5ID0gTmV0d29ya3NBcGlGYWN0b3J5O1xuLyoqXG4gKiBOZXR3b3Jrc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBOZXR3b3Jrc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIE5ldHdvcmtzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEdldCBuZXR3b3JrXG4gICAgICogQHN1bW1hcnkgR2V0IG5ldHdvcmsgYnkgSURcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgbmV0d29yayB0byBmZXRjaC5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIE5ldHdvcmtzQXBpXG4gICAgICovXG4gICAgZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLk5ldHdvcmtzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0TmV0d29yayhuZXR3b3JrSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29ya3NBcGkgPSBOZXR3b3Jrc0FwaTtcbi8qKlxuICogT25jaGFpbklkZW50aXR5QXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgT25jaGFpbklkZW50aXR5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICAgICAqIEBzdW1tYXJ5IE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgaWRlbnRpdHkgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXk8UmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtPn0gW3JvbGVzXSBBIGZpbHRlciBieSByb2xlIG9mIHRoZSBuYW1lcyByZWxhdGVkIHRvIHRoaXMgYWRkcmVzcyAobWFuYWdlZCBvciBvd25lZClcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgncmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L2lkZW50aXR5YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKHJvbGVzKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncm9sZXMnXSA9IHJvbGVzLmpvaW4oYmFzZV8xLkNPTExFQ1RJT05fRk9STUFUUy5jc3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBPbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogT25jaGFpbklkZW50aXR5QXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgT25jaGFpbklkZW50aXR5QXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBpZGVudGl0eSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxSZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3NSb2xlc0VudW0+fSBbcm9sZXNdIEEgZmlsdGVyIGJ5IHJvbGUgb2YgdGhlIG5hbWVzIHJlbGF0ZWQgdG8gdGhpcyBhZGRyZXNzIChtYW5hZ2VkIG9yIG93bmVkKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyByZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnJlc29sdmVJZGVudGl0eUJ5QWRkcmVzcyhuZXR3b3JrSWQsIGFkZHJlc3NJZCwgcm9sZXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ09uY2hhaW5JZGVudGl0eUFwaS5yZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGcCA9IE9uY2hhaW5JZGVudGl0eUFwaUZwO1xuLyoqXG4gKiBPbmNoYWluSWRlbnRpdHlBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBPbmNoYWluSWRlbnRpdHlBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5PbmNoYWluSWRlbnRpdHlBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgICAgICogQHN1bW1hcnkgT2J0YWlucyBvbmNoYWluIGlkZW50aXR5IGZvciBhbiBhZGRyZXNzIG9uIGEgc3BlY2lmaWMgbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBpZGVudGl0eSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtBcnJheTxSZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3NSb2xlc0VudW0+fSBbcm9sZXNdIEEgZmlsdGVyIGJ5IHJvbGUgb2YgdGhlIG5hbWVzIHJlbGF0ZWQgdG8gdGhpcyBhZGRyZXNzIChtYW5hZ2VkIG9yIG93bmVkKVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICByZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAucmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLk9uY2hhaW5JZGVudGl0eUFwaUZhY3RvcnkgPSBPbmNoYWluSWRlbnRpdHlBcGlGYWN0b3J5O1xuLyoqXG4gKiBPbmNoYWluSWRlbnRpdHlBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgT25jaGFpbklkZW50aXR5QXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgT25jaGFpbklkZW50aXR5QXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIE9idGFpbnMgb25jaGFpbiBpZGVudGl0eSBmb3IgYW4gYWRkcmVzcyBvbiBhIHNwZWNpZmljIG5ldHdvcmtcbiAgICAgKiBAc3VtbWFyeSBPYnRhaW5zIG9uY2hhaW4gaWRlbnRpdHkgZm9yIGFuIGFkZHJlc3Mgb24gYSBzcGVjaWZpYyBuZXR3b3JrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBpZGVudGl0eSBmb3JcbiAgICAgKiBAcGFyYW0ge0FycmF5PFJlc29sdmVJZGVudGl0eUJ5QWRkcmVzc1JvbGVzRW51bT59IFtyb2xlc10gQSBmaWx0ZXIgYnkgcm9sZSBvZiB0aGUgbmFtZXMgcmVsYXRlZCB0byB0aGlzIGFkZHJlc3MgKG1hbmFnZWQgb3Igb3duZWQpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBPbmNoYWluSWRlbnRpdHlBcGlcbiAgICAgKi9cbiAgICByZXNvbHZlSWRlbnRpdHlCeUFkZHJlc3MobmV0d29ya0lkLCBhZGRyZXNzSWQsIHJvbGVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCByb2xlcywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuT25jaGFpbklkZW50aXR5QXBpID0gT25jaGFpbklkZW50aXR5QXBpO1xuLyoqXG4gKiBAZXhwb3J0XG4gKi9cbmV4cG9ydHMuUmVzb2x2ZUlkZW50aXR5QnlBZGRyZXNzUm9sZXNFbnVtID0ge1xuICAgIE1hbmFnZWQ6ICdtYW5hZ2VkJyxcbiAgICBPd25lZDogJ293bmVkJ1xufTtcbi8qKlxuICogU2VydmVyU2lnbmVyc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNlcnZlclNpZ25lcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdH0gW2NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVTZXJ2ZXJTaWduZXI6IGFzeW5jIChjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcnZlclNpZ25lcjogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3NlcnZlclNpZ25lcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNlcnZlclNpZ25lcicsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNlcnZlcl9zaWduZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzZXJ2ZXJTaWduZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lckV2ZW50czogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0U2VydmVyU2lnbmVyRXZlbnRzJywgJ3NlcnZlclNpZ25lcklkJywgc2VydmVyU2lnbmVySWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zZXJ2ZXJfc2lnbmVycy97c2VydmVyX3NpZ25lcl9pZH0vZXZlbnRzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNlcnZlcl9zaWduZXJfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzZXJ2ZXJTaWduZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lcnM6IGFzeW5jIChsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3NlcnZlcl9zaWduZXJzYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7U2VlZENyZWF0aW9uRXZlbnRSZXN1bHR9IFtzZWVkQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdDogYXN5bmMgKHNlcnZlclNpZ25lcklkLCBzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQnLCAnc2VydmVyU2lnbmVySWQnLCBzZXJ2ZXJTaWduZXJJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3NlcnZlcl9zaWduZXJzL3tzZXJ2ZXJfc2lnbmVyX2lkfS9zZWVkX2V2ZW50X3Jlc3VsdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzZXJ2ZXJfc2lnbmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc2VydmVyU2lnbmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShzZWVkQ3JlYXRpb25FdmVudFJlc3VsdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQ6IGFzeW5jIChzZXJ2ZXJTaWduZXJJZCwgc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzZXJ2ZXJTaWduZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdzdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdCcsICdzZXJ2ZXJTaWduZXJJZCcsIHNlcnZlclNpZ25lcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc2VydmVyX3NpZ25lcnMve3NlcnZlcl9zaWduZXJfaWR9L3NpZ25hdHVyZV9ldmVudF9yZXN1bHRgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wic2VydmVyX3NpZ25lcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHNlcnZlclNpZ25lcklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBTZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFNlcnZlclNpZ25lcnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTZXJ2ZXJTaWduZXJzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVTZXJ2ZXJTaWduZXIoY3JlYXRlU2VydmVyU2lnbmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLmNyZWF0ZVNlcnZlclNpZ25lciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHNlcnZlciBzaWduZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkuZ2V0U2VydmVyU2lnbmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgZXZlbnRzIGZvciBhIHNlcnZlciBzaWduZXJcbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIGZldGNoIGV2ZW50cyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTZXJ2ZXJTaWduZXJzQXBpLmxpc3RTZXJ2ZXJTaWduZXJFdmVudHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBzZXJ2ZXIgc2lnbmVycyBmb3IgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5saXN0U2VydmVyU2lnbmVycyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7U2VlZENyZWF0aW9uRXZlbnRSZXN1bHR9IFtzZWVkQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2VlZENyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NlcnZlclNpZ25lcnNBcGkuc3VibWl0U2VydmVyU2lnbmVyU2VlZEV2ZW50UmVzdWx0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAc3VtbWFyeSBTdWJtaXQgdGhlIHJlc3VsdCBvZiBhIHNlcnZlciBzaWduZXIgZXZlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgICAgICogQHBhcmFtIHtTaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2lnbmF0dXJlQ3JlYXRpb25FdmVudFJlc3VsdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3Iuc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU2VydmVyU2lnbmVyc0FwaS5zdWJtaXRTZXJ2ZXJTaWduZXJTaWduYXR1cmVFdmVudFJlc3VsdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCA9IFNlcnZlclNpZ25lcnNBcGlGcDtcbi8qKlxuICogU2VydmVyU2lnbmVyc0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNlcnZlclNpZ25lcnNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgU2VydmVyLVNpZ25lclxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNlcnZlclNpZ25lcihzZXJ2ZXJTaWduZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0U2VydmVyU2lnbmVyKHNlcnZlclNpZ25lcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2ggZXZlbnRzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RTZXJ2ZXJTaWduZXJzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0fSBbc2VlZENyZWF0aW9uRXZlbnRSZXN1bHRdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBzdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VydmVyU2lnbmVySWQgVGhlIElEIG9mIHRoZSBzZXJ2ZXIgc2lnbmVyIHRvIHN1Ym1pdCB0aGUgZXZlbnQgcmVzdWx0IGZvclxuICAgICAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLnN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRmFjdG9yeSA9IFNlcnZlclNpZ25lcnNBcGlGYWN0b3J5O1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXJzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFNlcnZlclNpZ25lcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTZXJ2ZXJTaWduZXJzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTZXJ2ZXItU2lnbmVyXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IFNlcnZlci1TaWduZXJcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3R9IFtjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVNlcnZlclNpZ25lcihjcmVhdGVTZXJ2ZXJTaWduZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlU2VydmVyU2lnbmVyKGNyZWF0ZVNlcnZlclNpZ25lclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzZXJ2ZXIgc2lnbmVyIGJ5IElEXG4gICAgICogQHN1bW1hcnkgR2V0IGEgc2VydmVyIHNpZ25lciBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNlcnZlclNpZ25lcnNBcGlcbiAgICAgKi9cbiAgICBnZXRTZXJ2ZXJTaWduZXIoc2VydmVyU2lnbmVySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRTZXJ2ZXJTaWduZXIoc2VydmVyU2lnbmVySWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGV2ZW50cyBmb3IgYSBzZXJ2ZXIgc2lnbmVyXG4gICAgICogQHN1bW1hcnkgTGlzdCBldmVudHMgZm9yIGEgc2VydmVyIHNpZ25lclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gZmV0Y2ggZXZlbnRzIGZvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJTaWduZXJzQXBpXG4gICAgICovXG4gICAgbGlzdFNlcnZlclNpZ25lckV2ZW50cyhzZXJ2ZXJTaWduZXJJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U2VydmVyU2lnbmVyRXZlbnRzKHNlcnZlclNpZ25lcklkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgc2VydmVyIHNpZ25lcnMgZm9yIHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgKiBAc3VtbWFyeSBMaXN0IHNlcnZlciBzaWduZXJzIGZvciB0aGUgY3VycmVudCBwcm9qZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTZXJ2ZXJTaWduZXJzQXBpXG4gICAgICovXG4gICAgbGlzdFNlcnZlclNpZ25lcnMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U2VydmVyU2lnbmVycyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBzdW1tYXJ5IFN1Ym1pdCB0aGUgcmVzdWx0IG9mIGEgc2VydmVyIHNpZ25lciBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZXJ2ZXJTaWduZXJJZCBUaGUgSUQgb2YgdGhlIHNlcnZlciBzaWduZXIgdG8gc3VibWl0IHRoZSBldmVudCByZXN1bHQgZm9yXG4gICAgICogQHBhcmFtIHtTZWVkQ3JlYXRpb25FdmVudFJlc3VsdH0gW3NlZWRDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIHN1Ym1pdFNlcnZlclNpZ25lclNlZWRFdmVudFJlc3VsdChzZXJ2ZXJTaWduZXJJZCwgc2VlZENyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNlcnZlclNpZ25lcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5zdWJtaXRTZXJ2ZXJTaWduZXJTZWVkRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNlZWRDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICogQHN1bW1hcnkgU3VibWl0IHRoZSByZXN1bHQgb2YgYSBzZXJ2ZXIgc2lnbmVyIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlcnZlclNpZ25lcklkIFRoZSBJRCBvZiB0aGUgc2VydmVyIHNpZ25lciB0byBzdWJtaXQgdGhlIGV2ZW50IHJlc3VsdCBmb3JcbiAgICAgKiBAcGFyYW0ge1NpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHR9IFtzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU2VydmVyU2lnbmVyc0FwaVxuICAgICAqL1xuICAgIHN1Ym1pdFNlcnZlclNpZ25lclNpZ25hdHVyZUV2ZW50UmVzdWx0KHNlcnZlclNpZ25lcklkLCBzaWduYXR1cmVDcmVhdGlvbkV2ZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TZXJ2ZXJTaWduZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuc3VibWl0U2VydmVyU2lnbmVyU2lnbmF0dXJlRXZlbnRSZXN1bHQoc2VydmVyU2lnbmVySWQsIHNpZ25hdHVyZUNyZWF0aW9uRXZlbnRSZXN1bHQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyU2lnbmVyc0FwaSA9IFNlcnZlclNpZ25lcnNBcGk7XG4vKipcbiAqIFNtYXJ0Q29udHJhY3RzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNtYXJ0Q29udHJhY3Q6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTbWFydENvbnRyYWN0JywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVNtYXJ0Q29udHJhY3QnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVNtYXJ0Q29udHJhY3QnLCAnY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QnLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zbWFydF9jb250cmFjdHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcGxveXMgYSBzbWFydCBjb250cmFjdCwgYnkgYnJvYWRjYXN0aW5nIHRoZSB0cmFuc2FjdGlvbiB0byB0aGUgbmV0d29yay5cbiAgICAgICAgICogQHN1bW1hcnkgRGVwbG95IGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiB0by5cbiAgICAgICAgICogQHBhcmFtIHtEZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdH0gZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlcGxveVNtYXJ0Q29udHJhY3Q6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlcGxveVNtYXJ0Q29udHJhY3QnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZGVwbG95U21hcnRDb250cmFjdCcsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc21hcnRDb250cmFjdElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlcGxveVNtYXJ0Q29udHJhY3QnLCAnc21hcnRDb250cmFjdElkJywgc21hcnRDb250cmFjdElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2RlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlcGxveVNtYXJ0Q29udHJhY3QnLCAnZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QnLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zbWFydF9jb250cmFjdHMve3NtYXJ0X2NvbnRyYWN0X2lkfS9kZXBsb3lgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wic21hcnRfY29udHJhY3RfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhzbWFydENvbnRyYWN0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHNtYXJ0IGNvbnRyYWN0IGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTbWFydENvbnRyYWN0OiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNtYXJ0Q29udHJhY3QnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U21hcnRDb250cmFjdCcsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnc21hcnRDb250cmFjdElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFNtYXJ0Q29udHJhY3QnLCAnc21hcnRDb250cmFjdElkJywgc21hcnRDb250cmFjdElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3NtYXJ0X2NvbnRyYWN0cy97c21hcnRfY29udHJhY3RfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInNtYXJ0X2NvbnRyYWN0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc21hcnRDb250cmFjdElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdHMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNtYXJ0Q29udHJhY3RzOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0U21hcnRDb250cmFjdHMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFNtYXJ0Q29udHJhY3RzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zbWFydF9jb250cmFjdHNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIHJlYWQgb3BlcmF0aW9uIG9uIGEgc21hcnQgY29udHJhY3Qgd2l0aG91dCBjcmVhdGluZyBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvbnRyYWN0OiBhc3luYyAobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnbmV0d29ya0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlYWRDb250cmFjdCcsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY29udHJhY3RBZGRyZXNzJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ3JlYWRDb250cmFjdCcsICdjb250cmFjdEFkZHJlc3MnLCBjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAncmVhZENvbnRyYWN0UmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdyZWFkQ29udHJhY3QnLCAncmVhZENvbnRyYWN0UmVxdWVzdCcsIHJlYWRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9uZXR3b3Jrcy97bmV0d29ya19pZH0vc21hcnRfY29udHJhY3RzL3tjb250cmFjdF9hZGRyZXNzfS9yZWFkYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJjb250cmFjdF9hZGRyZXNzXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoY29udHJhY3RBZGRyZXNzKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkocmVhZENvbnRyYWN0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogU21hcnRDb250cmFjdHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBTbWFydENvbnRyYWN0c0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmNyZWF0ZVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVwbG95cyBhIHNtYXJ0IGNvbnRyYWN0LCBieSBicm9hZGNhc3RpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxuICAgICAgICAgKiBAc3VtbWFyeSBEZXBsb3kgYSBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc21hcnRDb250cmFjdElkIFRoZSBVVUlEIG9mIHRoZSBzbWFydCBjb250cmFjdCB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge0RlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0fSBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmRlcGxveVNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHNtYXJ0IGNvbnRyYWN0IGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLmdldFNtYXJ0Q29udHJhY3QnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdHMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFNtYXJ0Q29udHJhY3RzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0U21hcnRDb250cmFjdHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTbWFydENvbnRyYWN0c0FwaS5saXN0U21hcnRDb250cmFjdHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIHJlYWQgb3BlcmF0aW9uIG9uIGEgc21hcnQgY29udHJhY3Qgd2l0aG91dCBjcmVhdGluZyBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgcmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IucmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1NtYXJ0Q29udHJhY3RzQXBpLnJlYWRDb250cmFjdCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnAgPSBTbWFydENvbnRyYWN0c0FwaUZwO1xuLyoqXG4gKiBTbWFydENvbnRyYWN0c0FwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzbWFydCBjb250cmFjdFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGRlcGxveSB0aGUgc21hcnQgY29udHJhY3QgZnJvbS5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXBsb3lzIGEgc21hcnQgY29udHJhY3QsIGJ5IGJyb2FkY2FzdGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmsuXG4gICAgICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBicm9hZGNhc3QgdGhlIHRyYW5zYWN0aW9uIGZyb20uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICAgICAqIEBwYXJhbSB7RGVwbG95U21hcnRDb250cmFjdFJlcXVlc3R9IGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZXBsb3lTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIHNtYXJ0Q29udHJhY3RJZCwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdCBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGZldGNoLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdHMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFNtYXJ0Q29udHJhY3RzKHdhbGxldElkLCBhZGRyZXNzSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RTbWFydENvbnRyYWN0cyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybSBhIHJlYWQgb3BlcmF0aW9uIG9uIGEgc21hcnQgY29udHJhY3Qgd2l0aG91dCBjcmVhdGluZyBhIHRyYW5zYWN0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29udHJhY3RBZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5yZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeSA9IFNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeTtcbi8qKlxuICogU21hcnRDb250cmFjdHNBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU21hcnRDb250cmFjdHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTbWFydENvbnRyYWN0c0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBkZXBsb3kgdGhlIHNtYXJ0IGNvbnRyYWN0IGZyb20uXG4gICAgICogQHBhcmFtIHtDcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdH0gY3JlYXRlU21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgY3JlYXRlU21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVTbWFydENvbnRyYWN0KHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhIHNtYXJ0IGNvbnRyYWN0LCBieSBicm9hZGNhc3RpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrLlxuICAgICAqIEBzdW1tYXJ5IERlcGxveSBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gYnJvYWRjYXN0IHRoZSB0cmFuc2FjdGlvbiBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbWFydENvbnRyYWN0SWQgVGhlIFVVSUQgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHRvIGJyb2FkY2FzdCB0aGUgdHJhbnNhY3Rpb24gdG8uXG4gICAgICogQHBhcmFtIHtEZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdH0gZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFNtYXJ0Q29udHJhY3RzQXBpXG4gICAgICovXG4gICAgZGVwbG95U21hcnRDb250cmFjdCh3YWxsZXRJZCwgYWRkcmVzc0lkLCBzbWFydENvbnRyYWN0SWQsIGRlcGxveVNtYXJ0Q29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlcGxveVNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIHNtYXJ0IGNvbnRyYWN0IGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgR2V0IGEgc3BlY2lmaWMgc21hcnQgY29udHJhY3QgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdCBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNtYXJ0Q29udHJhY3RJZCBUaGUgVVVJRCBvZiB0aGUgc21hcnQgY29udHJhY3QgdG8gZmV0Y2guXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTbWFydENvbnRyYWN0c0FwaVxuICAgICAqL1xuICAgIGdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TbWFydENvbnRyYWN0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFNtYXJ0Q29udHJhY3Qod2FsbGV0SWQsIGFkZHJlc3NJZCwgc21hcnRDb250cmFjdElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgc21hcnQgY29udHJhY3RzIGRlcGxveWVkIGJ5IGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCBzbWFydCBjb250cmFjdHMgZGVwbG95ZWQgYnkgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzbWFydCBjb250cmFjdHMgZm9yLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICBsaXN0U21hcnRDb250cmFjdHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU21hcnRDb250cmFjdHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0U21hcnRDb250cmFjdHMod2FsbGV0SWQsIGFkZHJlc3NJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSByZWFkIG9wZXJhdGlvbiBvbiBhIHNtYXJ0IGNvbnRyYWN0IHdpdGhvdXQgY3JlYXRpbmcgYSB0cmFuc2FjdGlvblxuICAgICAqIEBzdW1tYXJ5IFJlYWQgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRyYWN0QWRkcmVzc1xuICAgICAqIEBwYXJhbSB7UmVhZENvbnRyYWN0UmVxdWVzdH0gcmVhZENvbnRyYWN0UmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU21hcnRDb250cmFjdHNBcGlcbiAgICAgKi9cbiAgICByZWFkQ29udHJhY3QobmV0d29ya0lkLCBjb250cmFjdEFkZHJlc3MsIHJlYWRDb250cmFjdFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikucmVhZENvbnRyYWN0KG5ldHdvcmtJZCwgY29udHJhY3RBZGRyZXNzLCByZWFkQ29udHJhY3RSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlNtYXJ0Q29udHJhY3RzQXBpID0gU21hcnRDb250cmFjdHNBcGk7XG4vKipcbiAqIFN0YWtlQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBzdW1tYXJ5IEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7QnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYnVpbGRTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAoYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2J1aWxkU3Rha2luZ09wZXJhdGlvbicsICdidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JywgYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3N0YWtlL2J1aWxkYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXM6IGFzeW5jIChuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcycsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdzdGFydFRpbWUnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJywgJ3N0YXJ0VGltZScsIHN0YXJ0VGltZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdlbmRUaW1lJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2ZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcycsICdlbmRUaW1lJywgZW5kVGltZSk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3N0YWtlL2JhbGFuY2VzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3NldElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydhc3NldF9pZCddID0gYXNzZXRJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3N0YXJ0X3RpbWUnXSA9IChzdGFydFRpbWUgaW5zdGFuY2VvZiBEYXRlKSA/XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0VGltZS50b0lTT1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZFRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2VuZF90aW1lJ10gPSAoZW5kVGltZSBpbnN0YW5jZW9mIERhdGUpID9cbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZS50b0lTT1N0cmluZygpIDpcbiAgICAgICAgICAgICAgICAgICAgZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hTdGFraW5nUmV3YXJkczogYXN5bmMgKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdmZXRjaFN0YWtpbmdSZXdhcmRzJywgJ2ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0JywgZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS9zdGFrZS9yZXdhcmRzL3NlYXJjaGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydsaW1pdCddID0gbGltaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsncGFnZSddID0gcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb246IGFzeW5jIChuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnbmV0d29ya0lkJywgbmV0d29ya0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24nLCAnc3Rha2luZ09wZXJhdGlvbklkJywgc3Rha2luZ09wZXJhdGlvbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvbmV0d29ya3Mve25ldHdvcmtfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2luZ19vcGVyYXRpb25zL3tzdGFraW5nX29wZXJhdGlvbl9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wibmV0d29ya19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKG5ldHdvcmtJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzdGFraW5nX29wZXJhdGlvbl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHN0YWtpbmdPcGVyYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBzdGFraW5nIGNvbnRleHQgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHN0YWtpbmcgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge0dldFN0YWtpbmdDb250ZXh0UmVxdWVzdH0gZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRTdGFraW5nQ29udGV4dDogYXN5bmMgKGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0U3Rha2luZ0NvbnRleHQnLCAnZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0JywgZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvc3Rha2UvY29udGV4dGA7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFN0YWtlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Rha2VBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAc3VtbWFyeSBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge0J1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuYnVpbGRTdGFraW5nT3BlcmF0aW9uJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBmb3IgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBJRCBvZiB0aGUgYXNzZXQgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIG9uY2hhaW4gYWRkcmVzcyBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZFRpbWUgVGhlIGVuZCB0aW1lIG9mIHRoaXMgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2UgcGVyaW9kLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBmZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnU3Rha2VBcGkuZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZldGNoIHN0YWtpbmcgcmV3YXJkcyBmb3IgYSBsaXN0IG9mIGFkZHJlc3Nlc1xuICAgICAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgICAgICogQHBhcmFtIHtGZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdH0gZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZmV0Y2hTdGFraW5nUmV3YXJkcyhmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5mZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydTdGFrZUFwaS5mZXRjaFN0YWtpbmdSZXdhcmRzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbihuZXR3b3JrSWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmdldEV4dGVybmFsU3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3Rha2luZyBjb250ZXh0IGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBzdGFraW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHtHZXRTdGFraW5nQ29udGV4dFJlcXVlc3R9IGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1N0YWtlQXBpLmdldFN0YWtpbmdDb250ZXh0J10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuU3Rha2VBcGlGcCA9IFN0YWtlQXBpRnA7XG4vKipcbiAqIFN0YWtlQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgU3Rha2VBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgQnVpbGQgYSBuZXcgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtCdWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBidWlsZFN0YWtpbmdPcGVyYXRpb24oYnVpbGRTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGJ1aWxkU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgZm9yIGdpdmVuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgSUQgb2YgdGhlIGFzc2V0IGZvciB3aGljaCB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGFyZSBiZWluZyBmZXRjaGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydFRpbWUgVGhlIHN0YXJ0IHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbmRUaW1lIFRoZSBlbmQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2hIaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZXRjaCBzdGFraW5nIHJld2FyZHMgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXNcbiAgICAgICAgICogQHN1bW1hcnkgRmV0Y2ggc3Rha2luZyByZXdhcmRzXG4gICAgICAgICAqIEBwYXJhbSB7RmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3R9IGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGZldGNoU3Rha2luZ1Jld2FyZHMoZmV0Y2hTdGFraW5nUmV3YXJkc1JlcXVlc3QsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5mZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3Rha2luZyBjb250ZXh0IGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBzdGFraW5nIGNvbnRleHRcbiAgICAgICAgICogQHBhcmFtIHtHZXRTdGFraW5nQ29udGV4dFJlcXVlc3R9IGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRTdGFraW5nQ29udGV4dChnZXRTdGFraW5nQ29udGV4dFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlN0YWtlQXBpRmFjdG9yeSA9IFN0YWtlQXBpRmFjdG9yeTtcbi8qKlxuICogU3Rha2VBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgU3Rha2VBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBTdGFrZUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIG5ldyBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBzdW1tYXJ5IEJ1aWxkIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtCdWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihidWlsZFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IEZldGNoIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIElEIG9mIHRoZSBhc3NldCBmb3Igd2hpY2ggdGhlIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlcyBhcmUgYmVpbmcgZmV0Y2hlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBvbmNoYWluIGFkZHJlc3MgZm9yIHdoaWNoIHRoZSBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZXMgYXJlIGJlaW5nIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0VGltZSBUaGUgc3RhcnQgdGltZSBvZiB0aGlzIGhpc3RvcmljYWwgc3Rha2luZyBiYWxhbmNlIHBlcmlvZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kVGltZSBUaGUgZW5kIHRpbWUgb2YgdGhpcyBoaXN0b3JpY2FsIHN0YWtpbmcgYmFsYW5jZSBwZXJpb2QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDUwLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBTdGFrZUFwaVxuICAgICAqL1xuICAgIGZldGNoSGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhuZXR3b3JrSWQsIGFzc2V0SWQsIGFkZHJlc3NJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaCBzdGFraW5nIHJld2FyZHMgZm9yIGEgbGlzdCBvZiBhZGRyZXNzZXNcbiAgICAgKiBAc3VtbWFyeSBGZXRjaCBzdGFraW5nIHJld2FyZHNcbiAgICAgKiBAcGFyYW0ge0ZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0fSBmZXRjaFN0YWtpbmdSZXdhcmRzUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgU3Rha2VBcGlcbiAgICAgKi9cbiAgICBmZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuU3Rha2VBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5mZXRjaFN0YWtpbmdSZXdhcmRzKGZldGNoU3Rha2luZ1Jld2FyZHNSZXF1ZXN0LCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuZ2V0RXh0ZXJuYWxTdGFraW5nT3BlcmF0aW9uKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc3Rha2luZyBjb250ZXh0IGZvciBhbiBhZGRyZXNzXG4gICAgICogQHN1bW1hcnkgR2V0IHN0YWtpbmcgY29udGV4dFxuICAgICAqIEBwYXJhbSB7R2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0fSBnZXRTdGFraW5nQ29udGV4dFJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFN0YWtlQXBpXG4gICAgICovXG4gICAgZ2V0U3Rha2luZ0NvbnRleHQoZ2V0U3Rha2luZ0NvbnRleHRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5TdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFN0YWtpbmdDb250ZXh0KGdldFN0YWtpbmdDb250ZXh0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFrZUFwaSA9IFN0YWtlQXBpO1xuLyoqXG4gKiBUcmFkZXNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFkZXNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhZGVSZXF1ZXN0fSBicm9hZGNhc3RUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFRyYWRlOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFkZUlkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFRyYWRlJywgJ3RyYWRlSWQnLCB0cmFkZUlkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Jyb2FkY2FzdFRyYWRlUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFkZScsICdicm9hZGNhc3RUcmFkZVJlcXVlc3QnLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhZGVzL3t0cmFkZV9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYWRlX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhZGVJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFkZSBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY29uZHVjdCB0aGUgdHJhZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYWRlUmVxdWVzdH0gY3JlYXRlVHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVUcmFkZTogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFkZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFkZScsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnY3JlYXRlVHJhZGVSZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVRyYWRlJywgJ2NyZWF0ZVRyYWRlUmVxdWVzdCcsIGNyZWF0ZVRyYWRlUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS90cmFkZXNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlVHJhZGVSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFkZTogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VHJhZGUnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VHJhZGUnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3RyYWRlSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VHJhZGUnLCAndHJhZGVJZCcsIHRyYWRlSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhZGVzL3t0cmFkZV9pZH1gXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1widHJhZGVfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh0cmFkZUlkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYWRlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFRyYWRlczogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RUcmFkZXMnLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnbGlzdFRyYWRlcycsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhZGVzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYWRlc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gVHJhZGVzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFRyYWRlc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYWRlc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuVHJhZGVzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYWRlUmVxdWVzdH0gYnJvYWRjYXN0VHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBicm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5icm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhZGVzQXBpLmJyb2FkY2FzdFRyYWRlJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFkZVxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhZGUgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNvbmR1Y3QgdGhlIHRyYWRlIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFkZVJlcXVlc3R9IGNyZWF0ZVRyYWRlUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYWRlc0FwaS5jcmVhdGVUcmFkZSddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhZGVJZCBUaGUgSUQgb2YgdGhlIHRyYWRlIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFkZXNBcGkuZ2V0VHJhZGUnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhZGVzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYWRlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RUcmFkZXMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhZGVzQXBpLmxpc3RUcmFkZXMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFkZXNBcGlGcCA9IFRyYWRlc0FwaUZwO1xuLyoqXG4gKiBUcmFkZXNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFkZXNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5UcmFkZXNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gYnJvYWRjYXN0XG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhZGVSZXF1ZXN0fSBicm9hZGNhc3RUcmFkZVJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGJyb2FkY2FzdFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIGJyb2FkY2FzdFRyYWRlUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHRyYWRlXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB0cmFkZSBmb3IgYW4gYWRkcmVzc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gY29uZHVjdCB0aGUgdHJhZGUgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVRyYWRlUmVxdWVzdH0gY3JlYXRlVHJhZGVSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYWRlUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSB0cmFkZSBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFkZXMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhZGVzIGZvclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0VHJhZGVzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFkZXNBcGlGYWN0b3J5ID0gVHJhZGVzQXBpRmFjdG9yeTtcbi8qKlxuICogVHJhZGVzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFRyYWRlc0FwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFRyYWRlc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3QgYSB0cmFkZVxuICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHRyYWRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gYnJvYWRjYXN0XG4gICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFkZVJlcXVlc3R9IGJyb2FkY2FzdFRyYWRlUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhZGVzQXBpXG4gICAgICovXG4gICAgYnJvYWRjYXN0VHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhZGVJZCwgYnJvYWRjYXN0VHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFkZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5icm9hZGNhc3RUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFkZUlkLCBicm9hZGNhc3RUcmFkZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgdHJhZGVcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhZGUgZm9yIGFuIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIHNvdXJjZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjb25kdWN0IHRoZSB0cmFkZSBmcm9tXG4gICAgICogQHBhcmFtIHtDcmVhdGVUcmFkZVJlcXVlc3R9IGNyZWF0ZVRyYWRlUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhZGVzQXBpXG4gICAgICovXG4gICAgY3JlYXRlVHJhZGUod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhZGVSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFkZXNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVUcmFkZSh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFkZVJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSB0cmFkZSBieSBJRFxuICAgICAqIEBzdW1tYXJ5IEdldCBhIHRyYWRlIGJ5IElEXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhZGUgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFkZUlkIFRoZSBJRCBvZiB0aGUgdHJhZGUgdG8gZmV0Y2hcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYWRlc0FwaVxuICAgICAqL1xuICAgIGdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYWRlc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFRyYWRlKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYWRlSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYWRlcyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGxpc3QgdHJhZGVzIGZvclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgVHJhZGVzQXBpXG4gICAgICovXG4gICAgbGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhZGVzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFRyYWRlcyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFkZXNBcGkgPSBUcmFkZXNBcGk7XG4vKipcbiAqIFRyYW5zYWN0aW9uSGlzdG9yeUFwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgdHJhbnNhY3Rpb25zIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2FjdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zOiBhc3luYyAobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0QWRkcmVzc1RyYW5zYWN0aW9ucycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RBZGRyZXNzVHJhbnNhY3Rpb25zJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zYWN0aW9uc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJuZXR3b3JrX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcobmV0d29ya0lkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUF4aW9zUGFyYW1DcmVhdG9yID0gVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFRyYW5zYWN0aW9uSGlzdG9yeUFwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zYWN0aW9ucyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29ya1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgdHJhbnNhY3Rpb25zIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zYWN0aW9uSGlzdG9yeUFwaS5saXN0QWRkcmVzc1RyYW5zYWN0aW9ucyddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwID0gVHJhbnNhY3Rpb25IaXN0b3J5QXBpRnA7XG4vKipcbiAqIFRyYW5zYWN0aW9uSGlzdG9yeUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uSGlzdG9yeUFwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBhbGwgdHJhbnNhY3Rpb25zIHRoYXQgaW50ZXJhY3Qgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2FjdGlvbnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFuc2FjdGlvbkhpc3RvcnlBcGlGYWN0b3J5ID0gVHJhbnNhY3Rpb25IaXN0b3J5QXBpRmFjdG9yeTtcbi8qKlxuICogVHJhbnNhY3Rpb25IaXN0b3J5QXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFRyYW5zYWN0aW9uSGlzdG9yeUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uSGlzdG9yeUFwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCB0cmFuc2FjdGlvbnMgdGhhdCBpbnRlcmFjdCB3aXRoIHRoZSBhZGRyZXNzLlxuICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNhY3Rpb25zIGZvciBhbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmtcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBmZXRjaCB0aGUgdHJhbnNhY3Rpb25zIGZvci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zYWN0aW9uSGlzdG9yeUFwaVxuICAgICAqL1xuICAgIGxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNhY3Rpb25IaXN0b3J5QXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdEFkZHJlc3NUcmFuc2FjdGlvbnMobmV0d29ya0lkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zYWN0aW9uSGlzdG9yeUFwaSA9IFRyYW5zYWN0aW9uSGlzdG9yeUFwaTtcbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNmZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RUcmFuc2ZlcjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFuc2ZlcicsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2FkZHJlc3NJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFuc2ZlcicsICdhZGRyZXNzSWQnLCBhZGRyZXNzSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAndHJhbnNmZXJJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RUcmFuc2ZlcicsICd0cmFuc2ZlcklkJywgdHJhbnNmZXJJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnYnJvYWRjYXN0VHJhbnNmZXInLCAnYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0JywgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0KTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVycy97dHJhbnNmZXJfaWR9L2Jyb2FkY2FzdGBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ0cmFuc2Zlcl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHRyYW5zZmVySWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZVRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhbnNmZXI6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhbnNmZXInLCAnd2FsbGV0SWQnLCB3YWxsZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhZGRyZXNzSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlVHJhbnNmZXInLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVRyYW5zZmVyUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVUcmFuc2ZlcicsICdjcmVhdGVUcmFuc2ZlclJlcXVlc3QnLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vdHJhbnNmZXJzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VHJhbnNmZXI6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ2FkZHJlc3NJZCcsIGFkZHJlc3NJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd0cmFuc2ZlcklkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFRyYW5zZmVyJywgJ3RyYW5zZmVySWQnLCB0cmFuc2ZlcklkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVycy97dHJhbnNmZXJfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInRyYW5zZmVyX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodHJhbnNmZXJJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RUcmFuc2ZlcnM6IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VHJhbnNmZXJzJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RUcmFuc2ZlcnMnLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9hZGRyZXNzZXMve2FkZHJlc3NfaWR9L3RyYW5zZmVyc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5UcmFuc2ZlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yO1xuLyoqXG4gKiBUcmFuc2ZlcnNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBUcmFuc2ZlcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUF4aW9zUGFyYW1DcmVhdG9yKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBicm9hZGNhc3RcbiAgICAgICAgICogQHBhcmFtIHtCcm9hZGNhc3RUcmFuc2ZlclJlcXVlc3R9IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zZmVyc0FwaS5icm9hZGNhc3RUcmFuc2ZlciddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgdHJhbnNmZXJcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgc291cmNlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byB0cmFuc2ZlciBmcm9tXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVUcmFuc2ZlclJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydUcmFuc2ZlcnNBcGkuY3JlYXRlVHJhbnNmZXInXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZmVySWQgVGhlIElEIG9mIHRoZSB0cmFuc2ZlciB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgZ2V0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnVHJhbnNmZXJzQXBpLmdldFRyYW5zZmVyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHRyYW5zZmVycyBmb3IgYW4gYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gbGlzdCB0cmFuc2ZlcnMgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5saXN0VHJhbnNmZXJzKHdhbGxldElkLCBhZGRyZXNzSWQsIGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1RyYW5zZmVyc0FwaS5saXN0VHJhbnNmZXJzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNmZXJzQXBpRnAgPSBUcmFuc2ZlcnNBcGlGcDtcbi8qKlxuICogVHJhbnNmZXJzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVHJhbnNmZXJzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdH0gYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB0cmFuc2ZlclxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgdHJhbnNmZXIgZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIHRyYW5zZmVyIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVUcmFuc2ZlclJlcXVlc3R9IGNyZWF0ZVRyYW5zZmVyUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlVHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0aGUgdHJhbnNmZXIgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdHJhbnNmZXJzIGZvciBhbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0b1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYW5zZmVycyBmb3JcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFRyYW5zZmVycyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAubGlzdFRyYW5zZmVycyh3YWxsZXRJZCwgYWRkcmVzc0lkLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVHJhbnNmZXJzQXBpRmFjdG9yeSA9IFRyYW5zZmVyc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFRyYW5zZmVyc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBUcmFuc2ZlcnNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBUcmFuc2ZlcnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0IGEgdHJhbnNmZXJcbiAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSB0cmFuc2ZlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGJyb2FkY2FzdFxuICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0fSBicm9hZGNhc3RUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGJyb2FkY2FzdFRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIHRyYW5zZmVySWQsIGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0VHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgdHJhbnNmZXJJZCwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHRyYW5zZmVyXG4gICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHRyYW5zZmVyIGZvciBhbiBhZGRyZXNzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBzb3VyY2UgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gdHJhbnNmZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlVHJhbnNmZXJSZXF1ZXN0fSBjcmVhdGVUcmFuc2ZlclJlcXVlc3RcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVRyYW5zZmVyKHdhbGxldElkLCBhZGRyZXNzSWQsIGNyZWF0ZVRyYW5zZmVyUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVHJhbnNmZXJzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlVHJhbnNmZXIod2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgdHJhbnNmZXIgYnkgSURcbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB0cmFuc2ZlciBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHRyYW5zZmVyIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmZXJJZCBUaGUgSUQgb2YgdGhlIHRyYW5zZmVyIHRvIGZldGNoXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBUcmFuc2ZlcnNBcGlcbiAgICAgKi9cbiAgICBnZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5UcmFuc2ZlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRUcmFuc2Zlcih3YWxsZXRJZCwgYWRkcmVzc0lkLCB0cmFuc2ZlcklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHN1bW1hcnkgTGlzdCB0cmFuc2ZlcnMgZm9yIGFuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBsaXN0IHRyYW5zZmVycyBmb3JcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFRyYW5zZmVyc0FwaVxuICAgICAqL1xuICAgIGxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlRyYW5zZmVyc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RUcmFuc2ZlcnMod2FsbGV0SWQsIGFkZHJlc3NJZCwgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNmZXJzQXBpID0gVHJhbnNmZXJzQXBpO1xuLyoqXG4gKiBVc2Vyc0FwaSAtIGF4aW9zIHBhcmFtZXRlciBjcmVhdG9yXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldEN1cnJlbnRVc2VyOiBhc3luYyAob3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3VzZXJzL21lYDtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFVzZXJzQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlVzZXJzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldEN1cnJlbnRVc2VyKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRDdXJyZW50VXNlcihvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1VzZXJzQXBpLmdldEN1cnJlbnRVc2VyJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVXNlcnNBcGlGcCA9IFVzZXJzQXBpRnA7XG4vKipcbiAqIFVzZXJzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVXNlcnNBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5Vc2Vyc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgY3VycmVudCB1c2VyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRDdXJyZW50VXNlcihvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRDdXJyZW50VXNlcihvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5Vc2Vyc0FwaUZhY3RvcnkgPSBVc2Vyc0FwaUZhY3Rvcnk7XG4vKipcbiAqIFVzZXJzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFVzZXJzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVXNlcnNBcGkgZXh0ZW5kcyBiYXNlXzEuQmFzZUFQSSB7XG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgdXNlclxuICAgICAqIEBzdW1tYXJ5IEdldCBjdXJyZW50IHVzZXJcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFVzZXJzQXBpXG4gICAgICovXG4gICAgZ2V0Q3VycmVudFVzZXIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuVXNlcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRDdXJyZW50VXNlcihvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLlVzZXJzQXBpID0gVXNlcnNBcGk7XG4vKipcbiAqIFZhbGlkYXRvcnNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBWYWxpZGF0b3JzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmssIGFzc2V0IGFuZCBpZC5cbiAgICAgICAgICogQHN1bW1hcnkgR2V0IGEgdmFsaWRhdG9yIGJlbG9uZ2luZyB0byB0aGUgQ0RQIHByb2plY3RcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmtJZCBUaGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZ2V0IHRoZSB2YWxpZGF0b3IgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsaWRhdG9ySWQgVGhlIHVuaXF1ZSBpZCBvZiB0aGUgdmFsaWRhdG9yIHRvIGZldGNoIGRldGFpbHMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VmFsaWRhdG9yOiBhc3luYyAobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICduZXR3b3JrSWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0VmFsaWRhdG9yJywgJ25ldHdvcmtJZCcsIG5ldHdvcmtJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdhc3NldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFZhbGlkYXRvcicsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd2YWxpZGF0b3JJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRWYWxpZGF0b3InLCAndmFsaWRhdG9ySWQnLCB2YWxpZGF0b3JJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hc3NldHMve2Fzc2V0X2lkfS92YWxpZGF0b3JzL3t2YWxpZGF0b3JfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ2YWxpZGF0b3JfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh2YWxpZGF0b3JJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yU3RhdHVzfSBbc3RhdHVzXSBBIGZpbHRlciB0byBsaXN0IHZhbGlkYXRvcnMgYmFzZWQgb24gYSBzdGF0dXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RWYWxpZGF0b3JzOiBhc3luYyAobmV0d29ya0lkLCBhc3NldElkLCBzdGF0dXMsIGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ25ldHdvcmtJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VmFsaWRhdG9ycycsICduZXR3b3JrSWQnLCBuZXR3b3JrSWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYXNzZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdsaXN0VmFsaWRhdG9ycycsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL25ldHdvcmtzL3tuZXR3b3JrX2lkfS9hc3NldHMve2Fzc2V0X2lkfS92YWxpZGF0b3JzYFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIm5ldHdvcmtfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhuZXR3b3JrSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhc3NldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFzc2V0SWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAoc3RhdHVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydzdGF0dXMnXSA9IHN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxWYXJRdWVyeVBhcmFtZXRlclsnbGltaXQnXSA9IGxpbWl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ3BhZ2UnXSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLlZhbGlkYXRvcnNBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFZhbGlkYXRvcnNBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogVmFsaWRhdG9yc0FwaSAtIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFZhbGlkYXRvcnNBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLlZhbGlkYXRvcnNBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yaywgYXNzZXQgYW5kIGlkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvciBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmdldFZhbGlkYXRvcihuZXR3b3JrSWQsIGFzc2V0SWQsIHZhbGlkYXRvcklkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1ZhbGlkYXRvcnNBcGkuZ2V0VmFsaWRhdG9yJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIENEUCBwcm9qZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7VmFsaWRhdG9yU3RhdHVzfSBbc3RhdHVzXSBBIGZpbHRlciB0byBsaXN0IHZhbGlkYXRvcnMgYmFzZWQgb24gYSBzdGF0dXMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyA1MC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydWYWxpZGF0b3JzQXBpLmxpc3RWYWxpZGF0b3JzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVmFsaWRhdG9yc0FwaUZwID0gVmFsaWRhdG9yc0FwaUZwO1xuLyoqXG4gKiBWYWxpZGF0b3JzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgVmFsaWRhdG9yc0FwaUZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbiwgYmFzZVBhdGgsIGF4aW9zKSB7XG4gICAgY29uc3QgbG9jYWxWYXJGcCA9ICgwLCBleHBvcnRzLlZhbGlkYXRvcnNBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIHZhbGlkYXRvciBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yaywgYXNzZXQgYW5kIGlkLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvciBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgdmFsaWRhdG9ySWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmsgYW5kIGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHZhbGlkYXRvcnMgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCBUaGUgc3ltYm9sIG9mIHRoZSBhc3NldCB0byBnZXQgdGhlIHZhbGlkYXRvcnMgZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge1ZhbGlkYXRvclN0YXR1c30gW3N0YXR1c10gQSBmaWx0ZXIgdG8gbGlzdCB2YWxpZGF0b3JzIGJhc2VkIG9uIGEgc3RhdHVzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RWYWxpZGF0b3JzKG5ldHdvcmtJZCwgYXNzZXRJZCwgc3RhdHVzLCBsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuVmFsaWRhdG9yc0FwaUZhY3RvcnkgPSBWYWxpZGF0b3JzQXBpRmFjdG9yeTtcbi8qKlxuICogVmFsaWRhdG9yc0FwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBWYWxpZGF0b3JzQXBpXG4gKiBAZXh0ZW5kcyB7QmFzZUFQSX1cbiAqL1xuY2xhc3MgVmFsaWRhdG9yc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSB1c2VyIGZvciBhIGdpdmVuIG5ldHdvcmssIGFzc2V0IGFuZCBpZC5cbiAgICAgKiBAc3VtbWFyeSBHZXQgYSB2YWxpZGF0b3IgYmVsb25naW5nIHRvIHRoZSBDRFAgcHJvamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrSWQgVGhlIElEIG9mIHRoZSBibG9ja2NoYWluIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZ2V0IHRoZSB2YWxpZGF0b3IgZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWxpZGF0b3JJZCBUaGUgdW5pcXVlIGlkIG9mIHRoZSB2YWxpZGF0b3IgdG8gZmV0Y2ggZGV0YWlscyBmb3IuXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBWYWxpZGF0b3JzQXBpXG4gICAgICovXG4gICAgZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgdmFsaWRhdG9ySWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlZhbGlkYXRvcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRWYWxpZGF0b3IobmV0d29ya0lkLCBhc3NldElkLCB2YWxpZGF0b3JJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdmFsaWRhdG9ycyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIgZm9yIGEgZ2l2ZW4gbmV0d29yayBhbmQgYXNzZXQuXG4gICAgICogQHN1bW1hcnkgTGlzdCB2YWxpZGF0b3JzIGJlbG9uZ2luZyB0byB0aGUgQ0RQIHByb2plY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29ya0lkIFRoZSBJRCBvZiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGdldCB0aGUgdmFsaWRhdG9ycyBmb3IuXG4gICAgICogQHBhcmFtIHtWYWxpZGF0b3JTdGF0dXN9IFtzdGF0dXNdIEEgZmlsdGVyIHRvIGxpc3QgdmFsaWRhdG9ycyBiYXNlZCBvbiBhIHN0YXR1cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgNTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFZhbGlkYXRvcnNBcGlcbiAgICAgKi9cbiAgICBsaXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLlZhbGlkYXRvcnNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cywgbGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuVmFsaWRhdG9yc0FwaSA9IFZhbGlkYXRvcnNBcGk7XG4vKipcbiAqIFdhbGxldFN0YWtlQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uOiBhc3luYyAod2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ3N0YWtpbmdPcGVyYXRpb25JZCcsIHN0YWtpbmdPcGVyYXRpb25JZCk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uJywgJ2Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JywgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9L2FkZHJlc3Nlcy97YWRkcmVzc19pZH0vc3Rha2luZ19vcGVyYXRpb25zL3tzdGFraW5nX29wZXJhdGlvbl9pZH0vYnJvYWRjYXN0YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wiYWRkcmVzc19pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGFkZHJlc3NJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcInN0YWtpbmdfb3BlcmF0aW9uX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoc3Rha2luZ09wZXJhdGlvbklkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjcmVhdGUgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb246IGFzeW5jICh3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdjcmVhdGVTdGFraW5nT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0JyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2NyZWF0ZVN0YWtpbmdPcGVyYXRpb24nLCAnY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QnLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zdGFraW5nX29wZXJhdGlvbnNgXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYHske1wid2FsbGV0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2FsbGV0SWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJhZGRyZXNzX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYWRkcmVzc0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0U3Rha2luZ09wZXJhdGlvbjogYXN5bmMgKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVxdWlyZWQgcGFyYW1ldGVyICd3YWxsZXRJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTdGFraW5nT3BlcmF0aW9uJywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnYWRkcmVzc0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2dldFN0YWtpbmdPcGVyYXRpb24nLCAnYWRkcmVzc0lkJywgYWRkcmVzc0lkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3N0YWtpbmdPcGVyYXRpb25JZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCdnZXRTdGFraW5nT3BlcmF0aW9uJywgJ3N0YWtpbmdPcGVyYXRpb25JZCcsIHN0YWtpbmdPcGVyYXRpb25JZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYWRkcmVzc2VzL3thZGRyZXNzX2lkfS9zdGFraW5nX29wZXJhdGlvbnMve3N0YWtpbmdfb3BlcmF0aW9uX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFkZHJlc3NfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhhZGRyZXNzSWQpKSlcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJzdGFraW5nX29wZXJhdGlvbl9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHN0YWtpbmdPcGVyYXRpb25JZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2FsbGV0U3Rha2VBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IFdhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFdhbGxldFN0YWtlQXBpIC0gZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2FsbGV0U3Rha2VBcGlGcCA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgY29uc3QgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvciA9ICgwLCBleHBvcnRzLldhbGxldFN0YWtlQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQnJvYWRjYXN0IGEgc3Rha2luZyBvcGVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24gdG8gYnJvYWRjYXN0LlxuICAgICAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldFN0YWtlQXBpLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24nXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgc3Rha2luZyBvcGVyYXRpb24gZm9yIGFuIGFkZHJlc3NcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0U3Rha2VBcGkuY3JlYXRlU3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0U3Rha2VBcGkuZ2V0U3Rha2luZ09wZXJhdGlvbiddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldhbGxldFN0YWtlQXBpRnAgPSBXYWxsZXRTdGFrZUFwaUZwO1xuLyoqXG4gKiBXYWxsZXRTdGFrZUFwaSAtIGZhY3RvcnkgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IFdhbGxldFN0YWtlQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuV2FsbGV0U3Rha2VBcGlGcCkoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBCcm9hZGNhc3QgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdGhlIGFkZHJlc3MgYmVsb25ncyB0by5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbiB0byBicm9hZGNhc3QuXG4gICAgICAgICAqIEBwYXJhbSB7QnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uIGZvciBhbiBhZGRyZXNzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzc0lkIFRoZSBJRCBvZiB0aGUgYWRkcmVzcyB0byBjcmVhdGUgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdH0gY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3RcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgdGhlIGxhdGVzdCBzdGF0ZSBvZiBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGZldGNoIHRoZSBzdGFraW5nIG9wZXJhdGlvbiBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGFraW5nT3BlcmF0aW9uSWQgVGhlIElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2FsbGV0U3Rha2VBcGlGYWN0b3J5ID0gV2FsbGV0U3Rha2VBcGlGYWN0b3J5O1xuLyoqXG4gKiBXYWxsZXRTdGFrZUFwaSAtIG9iamVjdC1vcmllbnRlZCBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqIEBjbGFzcyBXYWxsZXRTdGFrZUFwaVxuICogQGV4dGVuZHMge0Jhc2VBUEl9XG4gKi9cbmNsYXNzIFdhbGxldFN0YWtlQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IEJyb2FkY2FzdCBhIHN0YWtpbmcgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRoZSBhZGRyZXNzIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJlbG9uZ3MgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YWtpbmdPcGVyYXRpb25JZCBUaGUgSUQgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIHRvIGJyb2FkY2FzdC5cbiAgICAgKiBAcGFyYW0ge0Jyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0fSBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0U3Rha2VBcGlcbiAgICAgKi9cbiAgICBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIHN0YWtpbmdPcGVyYXRpb25JZCwgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldFN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBzdGFraW5nT3BlcmF0aW9uSWQsIGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyBzdGFraW5nIG9wZXJhdGlvbiBmb3IgYW4gYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzSWQgVGhlIElEIG9mIHRoZSBhZGRyZXNzIHRvIGNyZWF0ZSB0aGUgc3Rha2luZyBvcGVyYXRpb24gZm9yLlxuICAgICAqIEBwYXJhbSB7Q3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3R9IGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0XG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRTdGFrZUFwaVxuICAgICAqL1xuICAgIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldFN0YWtlQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih3YWxsZXRJZCwgYWRkcmVzc0lkLCBjcmVhdGVTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF0ZXN0IHN0YXRlIG9mIGEgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2YgYSBzdGFraW5nIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0aGUgYWRkcmVzcyBiZWxvbmdzIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3NJZCBUaGUgSUQgb2YgdGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3Rha2luZ09wZXJhdGlvbklkIFRoZSBJRCBvZiB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXYWxsZXRTdGFrZUFwaVxuICAgICAqL1xuICAgIGdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRTdGFrZUFwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFN0YWtpbmdPcGVyYXRpb24od2FsbGV0SWQsIGFkZHJlc3NJZCwgc3Rha2luZ09wZXJhdGlvbklkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG59XG5leHBvcnRzLldhbGxldFN0YWtlQXBpID0gV2FsbGV0U3Rha2VBcGk7XG4vKipcbiAqIFdhbGxldHNBcGkgLSBheGlvcyBwYXJhbWV0ZXIgY3JlYXRvclxuICogQGV4cG9ydFxuICovXG5jb25zdCBXYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IHNjb3BlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFJlcXVlc3R9IFtjcmVhdGVXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2FsbGV0OiBhc3luYyAoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHNgO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BPU1QnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5kYXRhID0gKDAsIGNvbW1vbl8xLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCkoY3JlYXRlV2FsbGV0UmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBHZXQgd2FsbGV0IGJ5IElEXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaFxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2FsbGV0OiBhc3luYyAod2FsbGV0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0V2FsbGV0JywgJ3dhbGxldElkJywgd2FsbGV0SWQpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93YWxsZXRzL3t3YWxsZXRfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndhbGxldF9pZFwifX1gLCBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHdhbGxldElkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ0dFVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhZ2dyZWdhdGVkIGJhbGFuY2Ugb2YgYW4gYXNzZXQgYWNyb3NzIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiB0aGUgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXYWxsZXRCYWxhbmNlOiBhc3luYyAod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0V2FsbGV0QmFsYW5jZScsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ2Fzc2V0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnZ2V0V2FsbGV0QmFsYW5jZScsICdhc3NldElkJywgYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dhbGxldHMve3dhbGxldF9pZH0vYmFsYW5jZXMve2Fzc2V0X2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcImFzc2V0X2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcoYXNzZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3QgdGhlIGJhbGFuY2VzIG9mIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQgYWdncmVnYXRlZCBieSBhc3NldC5cbiAgICAgICAgICogQHN1bW1hcnkgTGlzdCB3YWxsZXQgYmFsYW5jZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGxpc3RXYWxsZXRCYWxhbmNlczogYXN5bmMgKHdhbGxldElkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dhbGxldElkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2xpc3RXYWxsZXRCYWxhbmNlcycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS9iYWxhbmNlc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdHRVQnLCAuLi5iYXNlT3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIgPSB7fTtcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5zZXRTZWFyY2hQYXJhbXMpKGxvY2FsVmFyVXJsT2JqLCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyKTtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzRnJvbUJhc2VPcHRpb25zID0gYmFzZU9wdGlvbnMgJiYgYmFzZU9wdGlvbnMuaGVhZGVycyA/IGJhc2VPcHRpb25zLmhlYWRlcnMgOiB7fTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuaGVhZGVycyA9IHsgLi4ubG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXIsIC4uLmhlYWRlcnNGcm9tQmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMuaGVhZGVycyB9O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cmw6ICgwLCBjb21tb25fMS50b1BhdGhTdHJpbmcpKGxvY2FsVmFyVXJsT2JqKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBsb2NhbFZhclJlcXVlc3RPcHRpb25zLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2FsbGV0cyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBsaXN0V2FsbGV0czogYXN5bmMgKGxpbWl0LCBwYWdlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0c2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IgPSBXYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3I7XG4vKipcbiAqIFdhbGxldHNBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBXYWxsZXRzQXBpRnAgPSBmdW5jdGlvbiAoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IgPSAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpQXhpb3NQYXJhbUNyZWF0b3IpKGNvbmZpZ3VyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2FsbGV0IHNjb3BlZCB0byB0aGUgdXNlci5cbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFJlcXVlc3R9IFtjcmVhdGVXYWxsZXRSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5jcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXYWxsZXRzQXBpLmNyZWF0ZVdhbGxldCddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB3YWxsZXQgYnkgSURcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyQXhpb3NBcmdzID0gYXdhaXQgbG9jYWxWYXJBeGlvc1BhcmFtQ3JlYXRvci5nZXRXYWxsZXQod2FsbGV0SWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2FsbGV0c0FwaS5nZXRXYWxsZXQnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhZ2dyZWdhdGVkIGJhbGFuY2Ugb2YgYW4gYXNzZXQgYWNyb3NzIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiB0aGUgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuZ2V0V2FsbGV0QmFsYW5jZSh3YWxsZXRJZCwgYXNzZXRJZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXYWxsZXRzQXBpLmdldFdhbGxldEJhbGFuY2UnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0aGUgYmFsYW5jZXMgb2YgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldCBhZ2dyZWdhdGVkIGJ5IGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldCBiYWxhbmNlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgYXN5bmMgbGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IubGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldHNBcGkubGlzdFdhbGxldEJhbGFuY2VzJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgd2FsbGV0cyBiZWxvbmdpbmcgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0c1xuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcGFnZV0gQSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIHJlc3VsdHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dF9wYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBsaXN0V2FsbGV0cyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dhbGxldHNBcGkubGlzdFdhbGxldHMnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XYWxsZXRzQXBpRnAgPSBXYWxsZXRzQXBpRnA7XG4vKipcbiAqIFdhbGxldHNBcGkgLSBmYWN0b3J5IGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBXYWxsZXRzQXBpRmFjdG9yeSA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uLCBiYXNlUGF0aCwgYXhpb3MpIHtcbiAgICBjb25zdCBsb2NhbFZhckZwID0gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdhbGxldCBzY29wZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0UmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5jcmVhdGVXYWxsZXQoY3JlYXRlV2FsbGV0UmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB3YWxsZXRcbiAgICAgICAgICogQHN1bW1hcnkgR2V0IHdhbGxldCBieSBJRFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2hcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZ2V0V2FsbGV0KHdhbGxldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBhZ2dyZWdhdGVkIGJhbGFuY2Ugb2YgYW4gYXNzZXQgYWNyb3NzIGFsbCBvZiB0aGUgYWRkcmVzc2VzIGluIHRoZSB3YWxsZXQuXG4gICAgICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiB0aGUgd2FsbGV0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaCB0aGUgYmFsYW5jZSBmb3JcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgVGhlIHN5bWJvbCBvZiB0aGUgYXNzZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2UgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5nZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB0aGUgYmFsYW5jZXMgb2YgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldCBhZ2dyZWdhdGVkIGJ5IGFzc2V0LlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldCBiYWxhbmNlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gZmV0Y2ggdGhlIGJhbGFuY2VzIGZvclxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdhbGxldEJhbGFuY2VzKHdhbGxldElkLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdhbGxldHMgYmVsb25naW5nIHRvIHRoZSB1c2VyLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdhbGxldHNcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XYWxsZXRzQXBpRmFjdG9yeSA9IFdhbGxldHNBcGlGYWN0b3J5O1xuLyoqXG4gKiBXYWxsZXRzQXBpIC0gb2JqZWN0LW9yaWVudGVkIGludGVyZmFjZVxuICogQGV4cG9ydFxuICogQGNsYXNzIFdhbGxldHNBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBXYWxsZXRzQXBpIGV4dGVuZHMgYmFzZV8xLkJhc2VBUEkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyB3YWxsZXQgc2NvcGVkIHRvIHRoZSB1c2VyLlxuICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3YWxsZXRcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFJlcXVlc3R9IFtjcmVhdGVXYWxsZXRSZXF1ZXN0XVxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVdhbGxldChjcmVhdGVXYWxsZXRSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikuY3JlYXRlV2FsbGV0KGNyZWF0ZVdhbGxldFJlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgd2FsbGV0XG4gICAgICogQHN1bW1hcnkgR2V0IHdhbGxldCBieSBJRFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3YWxsZXRJZCBUaGUgSUQgb2YgdGhlIHdhbGxldCB0byBmZXRjaFxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2FsbGV0c0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmdldFdhbGxldCh3YWxsZXRJZCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYWdncmVnYXRlZCBiYWxhbmNlIG9mIGFuIGFzc2V0IGFjcm9zcyBhbGwgb2YgdGhlIGFkZHJlc3NlcyBpbiB0aGUgd2FsbGV0LlxuICAgICAqIEBzdW1tYXJ5IEdldCB0aGUgYmFsYW5jZSBvZiBhbiBhc3NldCBpbiB0aGUgd2FsbGV0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhc3NldElkIFRoZSBzeW1ib2wgb2YgdGhlIGFzc2V0IHRvIGZldGNoIHRoZSBiYWxhbmNlIGZvclxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGdldFdhbGxldEJhbGFuY2Uod2FsbGV0SWQsIGFzc2V0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5nZXRXYWxsZXRCYWxhbmNlKHdhbGxldElkLCBhc3NldElkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgYmFsYW5jZXMgb2YgYWxsIG9mIHRoZSBhZGRyZXNzZXMgaW4gdGhlIHdhbGxldCBhZ2dyZWdhdGVkIGJ5IGFzc2V0LlxuICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0IGJhbGFuY2VzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGZldGNoIHRoZSBiYWxhbmNlcyBmb3JcbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdhbGxldHNBcGlcbiAgICAgKi9cbiAgICBsaXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICgwLCBleHBvcnRzLldhbGxldHNBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5saXN0V2FsbGV0QmFsYW5jZXMod2FsbGV0SWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHdhbGxldHMgYmVsb25naW5nIHRvIHRoZSB1c2VyLlxuICAgICAqIEBzdW1tYXJ5IExpc3Qgd2FsbGV0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgKiBAbWVtYmVyb2YgV2FsbGV0c0FwaVxuICAgICAqL1xuICAgIGxpc3RXYWxsZXRzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XYWxsZXRzQXBpRnApKHRoaXMuY29uZmlndXJhdGlvbikubGlzdFdhbGxldHMobGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0c0FwaSA9IFdhbGxldHNBcGk7XG4vKipcbiAqIFdlYmhvb2tzQXBpIC0gYXhpb3MgcGFyYW1ldGVyIGNyZWF0b3JcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2ViaG9va3NBcGlBeGlvc1BhcmFtQ3JlYXRvciA9IGZ1bmN0aW9uIChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgd2ViaG9vayBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZVdhbGxldFdlYmhvb2s6IGFzeW5jICh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2FsbGV0SWQnIGlzIG5vdCBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLmFzc2VydFBhcmFtRXhpc3RzKSgnY3JlYXRlV2FsbGV0V2ViaG9vaycsICd3YWxsZXRJZCcsIHdhbGxldElkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2FsbGV0cy97d2FsbGV0X2lkfS93ZWJob29rc2BcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3YWxsZXRfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3YWxsZXRJZCkpKTtcbiAgICAgICAgICAgIC8vIHVzZSBkdW1teSBiYXNlIFVSTCBzdHJpbmcgYmVjYXVzZSB0aGUgVVJMIGNvbnN0cnVjdG9yIG9ubHkgYWNjZXB0cyBhYnNvbHV0ZSBVUkxzLlxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJVcmxPYmogPSBuZXcgVVJMKGxvY2FsVmFyUGF0aCwgY29tbW9uXzEuRFVNTVlfQkFTRV9VUkwpO1xuICAgICAgICAgICAgbGV0IGJhc2VPcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBiYXNlT3B0aW9ucyA9IGNvbmZpZ3VyYXRpb24uYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclJlcXVlc3RPcHRpb25zID0geyBtZXRob2Q6ICdQT1NUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBsb2NhbFZhckhlYWRlclBhcmFtZXRlclsnQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMuZGF0YSA9ICgwLCBjb21tb25fMS5zZXJpYWxpemVEYXRhSWZOZWVkZWQpKGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBsb2NhbFZhclJlcXVlc3RPcHRpb25zLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVXZWJob29rOiBhc3luYyAoY3JlYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93ZWJob29rc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnUE9TVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKShjcmVhdGVXZWJob29rUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBEZWxldGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgdXVpZCB0aGF0IG5lZWRzIHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZVdlYmhvb2s6IGFzeW5jICh3ZWJob29rSWQsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgLy8gdmVyaWZ5IHJlcXVpcmVkIHBhcmFtZXRlciAnd2ViaG9va0lkJyBpcyBub3QgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgICgwLCBjb21tb25fMS5hc3NlcnRQYXJhbUV4aXN0cykoJ2RlbGV0ZVdlYmhvb2snLCAnd2ViaG9va0lkJywgd2ViaG9va0lkKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUGF0aCA9IGAvdjEvd2ViaG9va3Mve3dlYmhvb2tfaWR9YFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKGB7JHtcIndlYmhvb2tfaWRcIn19YCwgZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyh3ZWJob29rSWQpKSk7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnREVMRVRFJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuc2V0U2VhcmNoUGFyYW1zKShsb2NhbFZhclVybE9iaiwgbG9jYWxWYXJRdWVyeVBhcmFtZXRlcik7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc0Zyb21CYXNlT3B0aW9ucyA9IGJhc2VPcHRpb25zICYmIGJhc2VPcHRpb25zLmhlYWRlcnMgPyBiYXNlT3B0aW9ucy5oZWFkZXJzIDoge307XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSB7IC4uLmxvY2FsVmFySGVhZGVyUGFyYW1ldGVyLCAuLi5oZWFkZXJzRnJvbUJhc2VPcHRpb25zLCAuLi5vcHRpb25zLmhlYWRlcnMgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdXJsOiAoMCwgY29tbW9uXzEudG9QYXRoU3RyaW5nKShsb2NhbFZhclVybE9iaiksXG4gICAgICAgICAgICAgICAgb3B0aW9uczogbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdlYmhvb2tzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGV2ZW50IHR5cGUuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2ViaG9va3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdlYmhvb2tzOiBhc3luYyAobGltaXQsIHBhZ2UsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJQYXRoID0gYC92MS93ZWJob29rc2A7XG4gICAgICAgICAgICAvLyB1c2UgZHVtbXkgYmFzZSBVUkwgc3RyaW5nIGJlY2F1c2UgdGhlIFVSTCBjb25zdHJ1Y3RvciBvbmx5IGFjY2VwdHMgYWJzb2x1dGUgVVJMcy5cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyVXJsT2JqID0gbmV3IFVSTChsb2NhbFZhclBhdGgsIGNvbW1vbl8xLkRVTU1ZX0JBU0VfVVJMKTtcbiAgICAgICAgICAgIGxldCBiYXNlT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYmFzZU9wdGlvbnMgPSBjb25maWd1cmF0aW9uLmJhc2VPcHRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucyA9IHsgbWV0aG9kOiAnR0VUJywgLi4uYmFzZU9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFySGVhZGVyUGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyID0ge307XG4gICAgICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXJbJ2xpbWl0J10gPSBsaW1pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFZhclF1ZXJ5UGFyYW1ldGVyWydwYWdlJ10gPSBwYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgaWQgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7VXBkYXRlV2ViaG9va1JlcXVlc3R9IFt1cGRhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVdlYmhvb2s6IGFzeW5jICh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXF1aXJlZCBwYXJhbWV0ZXIgJ3dlYmhvb2tJZCcgaXMgbm90IG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAoMCwgY29tbW9uXzEuYXNzZXJ0UGFyYW1FeGlzdHMpKCd1cGRhdGVXZWJob29rJywgJ3dlYmhvb2tJZCcsIHdlYmhvb2tJZCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclBhdGggPSBgL3YxL3dlYmhvb2tzL3t3ZWJob29rX2lkfWBcbiAgICAgICAgICAgICAgICAucmVwbGFjZShgeyR7XCJ3ZWJob29rX2lkXCJ9fWAsIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcod2ViaG9va0lkKSkpO1xuICAgICAgICAgICAgLy8gdXNlIGR1bW15IGJhc2UgVVJMIHN0cmluZyBiZWNhdXNlIHRoZSBVUkwgY29uc3RydWN0b3Igb25seSBhY2NlcHRzIGFic29sdXRlIFVSTHMuXG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhclVybE9iaiA9IG5ldyBVUkwobG9jYWxWYXJQYXRoLCBjb21tb25fMS5EVU1NWV9CQVNFX1VSTCk7XG4gICAgICAgICAgICBsZXQgYmFzZU9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGJhc2VPcHRpb25zID0gY29uZmlndXJhdGlvbi5iYXNlT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMgPSB7IG1ldGhvZDogJ1BVVCcsIC4uLmJhc2VPcHRpb25zLCAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckhlYWRlclBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJRdWVyeVBhcmFtZXRlciA9IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJIZWFkZXJQYXJhbWV0ZXJbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgKDAsIGNvbW1vbl8xLnNldFNlYXJjaFBhcmFtcykobG9jYWxWYXJVcmxPYmosIGxvY2FsVmFyUXVlcnlQYXJhbWV0ZXIpO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnNGcm9tQmFzZU9wdGlvbnMgPSBiYXNlT3B0aW9ucyAmJiBiYXNlT3B0aW9ucy5oZWFkZXJzID8gYmFzZU9wdGlvbnMuaGVhZGVycyA6IHt9O1xuICAgICAgICAgICAgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0geyAuLi5sb2NhbFZhckhlYWRlclBhcmFtZXRlciwgLi4uaGVhZGVyc0Zyb21CYXNlT3B0aW9ucywgLi4ub3B0aW9ucy5oZWFkZXJzIH07XG4gICAgICAgICAgICBsb2NhbFZhclJlcXVlc3RPcHRpb25zLmRhdGEgPSAoMCwgY29tbW9uXzEuc2VyaWFsaXplRGF0YUlmTmVlZGVkKSh1cGRhdGVXZWJob29rUmVxdWVzdCwgbG9jYWxWYXJSZXF1ZXN0T3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogKDAsIGNvbW1vbl8xLnRvUGF0aFN0cmluZykobG9jYWxWYXJVcmxPYmopLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGxvY2FsVmFyUmVxdWVzdE9wdGlvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59O1xuZXhwb3J0cy5XZWJob29rc0FwaUF4aW9zUGFyYW1DcmVhdG9yID0gV2ViaG9va3NBcGlBeGlvc1BhcmFtQ3JlYXRvcjtcbi8qKlxuICogV2ViaG9va3NBcGkgLSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIGludGVyZmFjZVxuICogQGV4cG9ydFxuICovXG5jb25zdCBXZWJob29rc0FwaUZwID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yID0gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlBeGlvc1BhcmFtQ3JlYXRvcikoY29uZmlndXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdhbGxldElkIFRoZSBJRCBvZiB0aGUgd2FsbGV0IHRvIGNyZWF0ZSB0aGUgd2ViaG9vayBmb3IuXG4gICAgICAgICAqIEBwYXJhbSB7Q3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleCA9IGNvbmZpZ3VyYXRpb24/LnNlcnZlckluZGV4ID8/IDA7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoID0gYmFzZV8xLm9wZXJhdGlvblNlcnZlck1hcFsnV2ViaG9va3NBcGkuY3JlYXRlV2FsbGV0V2ViaG9vayddPy5bbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJJbmRleF0/LnVybDtcbiAgICAgICAgICAgIHJldHVybiAoYXhpb3MsIGJhc2VQYXRoKSA9PiAoMCwgY29tbW9uXzEuY3JlYXRlUmVxdWVzdEZ1bmN0aW9uKShsb2NhbFZhckF4aW9zQXJncywgYXhpb3NfMS5kZWZhdWx0LCBiYXNlXzEuQkFTRV9QQVRILCBjb25maWd1cmF0aW9uKShheGlvcywgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCB8fCBiYXNlUGF0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge0NyZWF0ZVdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBjcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhckF4aW9zQXJncyA9IGF3YWl0IGxvY2FsVmFyQXhpb3NQYXJhbUNyZWF0b3IuY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rc0FwaS5jcmVhdGVXZWJob29rJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIHV1aWQgdGhhdCBuZWVkcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBhc3luYyBkZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXggPSBjb25maWd1cmF0aW9uPy5zZXJ2ZXJJbmRleCA/PyAwO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJPcGVyYXRpb25TZXJ2ZXJCYXNlUGF0aCA9IGJhc2VfMS5vcGVyYXRpb25TZXJ2ZXJNYXBbJ1dlYmhvb2tzQXBpLmRlbGV0ZVdlYmhvb2snXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCB3ZWJob29rcywgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBldmVudCB0eXBlLlxuICAgICAgICAgKiBAc3VtbWFyeSBMaXN0IHdlYmhvb2tzXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIEEgbGltaXQgb24gdGhlIG51bWJlciBvZiBvYmplY3RzIHRvIGJlIHJldHVybmVkLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAsIGFuZCB0aGUgZGVmYXVsdCBpcyAxMC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIGxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLmxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rc0FwaS5saXN0V2ViaG9va3MnXT8uW2xvY2FsVmFyT3BlcmF0aW9uU2VydmVySW5kZXhdPy51cmw7XG4gICAgICAgICAgICByZXR1cm4gKGF4aW9zLCBiYXNlUGF0aCkgPT4gKDAsIGNvbW1vbl8xLmNyZWF0ZVJlcXVlc3RGdW5jdGlvbikobG9jYWxWYXJBeGlvc0FyZ3MsIGF4aW9zXzEuZGVmYXVsdCwgYmFzZV8xLkJBU0VfUEFUSCwgY29uZmlndXJhdGlvbikoYXhpb3MsIGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggfHwgYmFzZVBhdGgpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3ZWJob29rSWQgVGhlIFdlYmhvb2sgaWQgdGhhdCBuZWVkcyB0byBiZSB1cGRhdGVkXG4gICAgICAgICAqIEBwYXJhbSB7VXBkYXRlV2ViaG9va1JlcXVlc3R9IFt1cGRhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgICAgICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxWYXJBeGlvc0FyZ3MgPSBhd2FpdCBsb2NhbFZhckF4aW9zUGFyYW1DcmVhdG9yLnVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4ID0gY29uZmlndXJhdGlvbj8uc2VydmVySW5kZXggPz8gMDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsVmFyT3BlcmF0aW9uU2VydmVyQmFzZVBhdGggPSBiYXNlXzEub3BlcmF0aW9uU2VydmVyTWFwWydXZWJob29rc0FwaS51cGRhdGVXZWJob29rJ10/Lltsb2NhbFZhck9wZXJhdGlvblNlcnZlckluZGV4XT8udXJsO1xuICAgICAgICAgICAgcmV0dXJuIChheGlvcywgYmFzZVBhdGgpID0+ICgwLCBjb21tb25fMS5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24pKGxvY2FsVmFyQXhpb3NBcmdzLCBheGlvc18xLmRlZmF1bHQsIGJhc2VfMS5CQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pKGF4aW9zLCBsb2NhbFZhck9wZXJhdGlvblNlcnZlckJhc2VQYXRoIHx8IGJhc2VQYXRoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuV2ViaG9va3NBcGlGcCA9IFdlYmhvb2tzQXBpRnA7XG4vKipcbiAqIFdlYmhvb2tzQXBpIC0gZmFjdG9yeSBpbnRlcmZhY2VcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgV2ViaG9va3NBcGlGYWN0b3J5ID0gZnVuY3Rpb24gKGNvbmZpZ3VyYXRpb24sIGJhc2VQYXRoLCBheGlvcykge1xuICAgIGNvbnN0IGxvY2FsVmFyRnAgPSAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKShjb25maWd1cmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2sgc2NvcGVkIHRvIGEgd2FsbGV0XG4gICAgICAgICAqIEBzdW1tYXJ5IENyZWF0ZSBhIG5ldyB3ZWJob29rIHNjb3BlZCB0byBhIHdhbGxldFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSB3ZWJob29rIGZvci5cbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXYWxsZXRXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2FsbGV0V2ViaG9vayh3YWxsZXRJZCwgY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbFZhckZwLmNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KGF4aW9zLCBiYXNlUGF0aCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtDcmVhdGVXZWJob29rUmVxdWVzdH0gW2NyZWF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdChheGlvcywgYmFzZVBhdGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHN1bW1hcnkgRGVsZXRlIGEgd2ViaG9va1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIHV1aWQgdGhhdCBuZWVkcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW29wdGlvbnNdIE92ZXJyaWRlIGh0dHAgcmVxdWVzdCBvcHRpb24uXG4gICAgICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVXZWJob29rKHdlYmhvb2tJZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsVmFyRnAuZGVsZXRlV2ViaG9vayh3ZWJob29rSWQsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IHdlYmhvb2tzLCBvcHRpb25hbGx5IGZpbHRlcmVkIGJ5IGV2ZW50IHR5cGUuXG4gICAgICAgICAqIEBzdW1tYXJ5IExpc3Qgd2ViaG9va3NcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtsaW1pdF0gQSBsaW1pdCBvbiB0aGUgbnVtYmVyIG9mIG9iamVjdHMgdG8gYmUgcmV0dXJuZWQuIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMCwgYW5kIHRoZSBkZWZhdWx0IGlzIDEwLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3BhZ2VdIEEgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiByZXN1bHRzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHRfcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgbGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC5saXN0V2ViaG9va3MobGltaXQsIHBhZ2UsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYSB3ZWJob29rXG4gICAgICAgICAqIEBzdW1tYXJ5IFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayBpZCB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICogQHBhcmFtIHtVcGRhdGVXZWJob29rUmVxdWVzdH0gW3VwZGF0ZVdlYmhvb2tSZXF1ZXN0XVxuICAgICAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlV2ViaG9vayh3ZWJob29rSWQsIHVwZGF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxWYXJGcC51cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QoYXhpb3MsIGJhc2VQYXRoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5leHBvcnRzLldlYmhvb2tzQXBpRmFjdG9yeSA9IFdlYmhvb2tzQXBpRmFjdG9yeTtcbi8qKlxuICogV2ViaG9va3NBcGkgLSBvYmplY3Qtb3JpZW50ZWQgaW50ZXJmYWNlXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgV2ViaG9va3NBcGlcbiAqIEBleHRlbmRzIHtCYXNlQVBJfVxuICovXG5jbGFzcyBXZWJob29rc0FwaSBleHRlbmRzIGJhc2VfMS5CYXNlQVBJIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9vayBzY29wZWQgdG8gYSB3YWxsZXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2FsbGV0SWQgVGhlIElEIG9mIHRoZSB3YWxsZXQgdG8gY3JlYXRlIHRoZSB3ZWJob29rIGZvci5cbiAgICAgKiBAcGFyYW0ge0NyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0fSBbY3JlYXRlV2FsbGV0V2ViaG9va1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rc0FwaVxuICAgICAqL1xuICAgIGNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmNyZWF0ZVdhbGxldFdlYmhvb2sod2FsbGV0SWQsIGNyZWF0ZVdhbGxldFdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHdlYmhvb2tcbiAgICAgKiBAc3VtbWFyeSBDcmVhdGUgYSBuZXcgd2ViaG9va1xuICAgICAqIEBwYXJhbSB7Q3JlYXRlV2ViaG9va1JlcXVlc3R9IFtjcmVhdGVXZWJob29rUmVxdWVzdF1cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tzQXBpXG4gICAgICovXG4gICAgY3JlYXRlV2ViaG9vayhjcmVhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS5jcmVhdGVXZWJob29rKGNyZWF0ZVdlYmhvb2tSZXF1ZXN0LCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgd2ViaG9va1xuICAgICAqIEBzdW1tYXJ5IERlbGV0ZSBhIHdlYmhvb2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gd2ViaG9va0lkIFRoZSBXZWJob29rIHV1aWQgdGhhdCBuZWVkcyB0byBiZSBkZWxldGVkXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rc0FwaVxuICAgICAqL1xuICAgIGRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmRlbGV0ZVdlYmhvb2sod2ViaG9va0lkLCBvcHRpb25zKS50aGVuKChyZXF1ZXN0KSA9PiByZXF1ZXN0KHRoaXMuYXhpb3MsIHRoaXMuYmFzZVBhdGgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB3ZWJob29rcywgb3B0aW9uYWxseSBmaWx0ZXJlZCBieSBldmVudCB0eXBlLlxuICAgICAqIEBzdW1tYXJ5IExpc3Qgd2ViaG9va3NcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XSBBIGxpbWl0IG9uIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0byBiZSByZXR1cm5lZC4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLCBhbmQgdGhlIGRlZmF1bHQgaXMgMTAuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwYWdlXSBBIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgcmVzdWx0cy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0X3BhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKiBAcGFyYW0geyp9IFtvcHRpb25zXSBPdmVycmlkZSBodHRwIHJlcXVlc3Qgb3B0aW9uLlxuICAgICAqIEB0aHJvd3Mge1JlcXVpcmVkRXJyb3J9XG4gICAgICogQG1lbWJlcm9mIFdlYmhvb2tzQXBpXG4gICAgICovXG4gICAgbGlzdFdlYmhvb2tzKGxpbWl0LCBwYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5XZWJob29rc0FwaUZwKSh0aGlzLmNvbmZpZ3VyYXRpb24pLmxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSwgb3B0aW9ucykudGhlbigocmVxdWVzdCkgPT4gcmVxdWVzdCh0aGlzLmF4aW9zLCB0aGlzLmJhc2VQYXRoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIHdlYmhvb2tcbiAgICAgKiBAc3VtbWFyeSBVcGRhdGUgYSB3ZWJob29rXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHdlYmhvb2tJZCBUaGUgV2ViaG9vayBpZCB0aGF0IG5lZWRzIHRvIGJlIHVwZGF0ZWRcbiAgICAgKiBAcGFyYW0ge1VwZGF0ZVdlYmhvb2tSZXF1ZXN0fSBbdXBkYXRlV2ViaG9va1JlcXVlc3RdXG4gICAgICogQHBhcmFtIHsqfSBbb3B0aW9uc10gT3ZlcnJpZGUgaHR0cCByZXF1ZXN0IG9wdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtSZXF1aXJlZEVycm9yfVxuICAgICAqIEBtZW1iZXJvZiBXZWJob29rc0FwaVxuICAgICAqL1xuICAgIHVwZGF0ZVdlYmhvb2sod2ViaG9va0lkLCB1cGRhdGVXZWJob29rUmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKDAsIGV4cG9ydHMuV2ViaG9va3NBcGlGcCkodGhpcy5jb25maWd1cmF0aW9uKS51cGRhdGVXZWJob29rKHdlYmhvb2tJZCwgdXBkYXRlV2ViaG9va1JlcXVlc3QsIG9wdGlvbnMpLnRoZW4oKHJlcXVlc3QpID0+IHJlcXVlc3QodGhpcy5heGlvcywgdGhpcy5iYXNlUGF0aCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViaG9va3NBcGkgPSBXZWJob29rc0FwaTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/base.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.operationServerMap = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = exports.BASE_PATH = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\nexports.BASE_PATH = \"https://api.cdp.coinbase.com/platform\".replace(/\\/+$/, \"\");\n/**\n *\n * @export\n */\nexports.COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n/**\n *\n * @export\n * @class BaseAPI\n */\nclass BaseAPI {\n    constructor(configuration, basePath = exports.BASE_PATH, axios = axios_1.default) {\n        this.basePath = basePath;\n        this.axios = axios;\n        if (configuration) {\n            this.configuration = configuration;\n            this.basePath = configuration.basePath ?? basePath;\n        }\n    }\n}\nexports.BaseAPI = BaseAPI;\n;\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nclass RequiredError extends Error {\n    constructor(field, msg) {\n        super(msg);\n        this.field = field;\n        this.name = \"RequiredError\";\n    }\n}\nexports.RequiredError = RequiredError;\n/**\n *\n * @export\n */\nexports.operationServerMap = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxlQUFlLEdBQUcsMEJBQTBCLEdBQUcsaUJBQWlCO0FBQ3JILGdDQUFnQyxtQkFBTyxDQUFDLDZEQUFPO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY2xpZW50L2Jhc2UuanM/MzcwMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcGVyYXRpb25TZXJ2ZXJNYXAgPSBleHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBleHBvcnRzLkJhc2VBUEkgPSBleHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IGV4cG9ydHMuQkFTRV9QQVRIID0gdm9pZCAwO1xuY29uc3QgYXhpb3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYXhpb3NcIikpO1xuZXhwb3J0cy5CQVNFX1BBVEggPSBcImh0dHBzOi8vYXBpLmNkcC5jb2luYmFzZS5jb20vcGxhdGZvcm1cIi5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkNPTExFQ1RJT05fRk9STUFUUyA9IHtcbiAgICBjc3Y6IFwiLFwiLFxuICAgIHNzdjogXCIgXCIsXG4gICAgdHN2OiBcIlxcdFwiLFxuICAgIHBpcGVzOiBcInxcIixcbn07XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgQmFzZUFQSVxuICovXG5jbGFzcyBCYXNlQVBJIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uLCBiYXNlUGF0aCA9IGV4cG9ydHMuQkFTRV9QQVRILCBheGlvcyA9IGF4aW9zXzEuZGVmYXVsdCkge1xuICAgICAgICB0aGlzLmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgICAgIHRoaXMuYXhpb3MgPSBheGlvcztcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgICAgICAgICB0aGlzLmJhc2VQYXRoID0gY29uZmlndXJhdGlvbi5iYXNlUGF0aCA/PyBiYXNlUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUFQSSA9IEJhc2VBUEk7XG47XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKiBAY2xhc3MgUmVxdWlyZWRFcnJvclxuICogQGV4dGVuZHMge0Vycm9yfVxuICovXG5jbGFzcyBSZXF1aXJlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkLCBtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlcXVpcmVkRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVpcmVkRXJyb3IgPSBSZXF1aXJlZEVycm9yO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLm9wZXJhdGlvblNlcnZlck1hcCA9IHt9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/common.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createRequestFunction = exports.toPathString = exports.serializeDataIfNeeded = exports.setSearchParams = exports.setOAuthToObject = exports.setBearerAuthToObject = exports.setBasicAuthToObject = exports.setApiKeyToObject = exports.assertParamExists = exports.DUMMY_BASE_URL = void 0;\nconst base_1 = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\n/**\n *\n * @export\n */\nexports.DUMMY_BASE_URL = 'https://example.com';\n/**\n *\n * @throws {RequiredError}\n * @export\n */\nconst assertParamExists = function (functionName, paramName, paramValue) {\n    if (paramValue === null || paramValue === undefined) {\n        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);\n    }\n};\nexports.assertParamExists = assertParamExists;\n/**\n *\n * @export\n */\nconst setApiKeyToObject = async function (object, keyParamName, configuration) {\n    if (configuration && configuration.apiKey) {\n        const localVarApiKeyValue = typeof configuration.apiKey === 'function'\n            ? await configuration.apiKey(keyParamName)\n            : await configuration.apiKey;\n        object[keyParamName] = localVarApiKeyValue;\n    }\n};\nexports.setApiKeyToObject = setApiKeyToObject;\n/**\n *\n * @export\n */\nconst setBasicAuthToObject = function (object, configuration) {\n    if (configuration && (configuration.username || configuration.password)) {\n        object[\"auth\"] = { username: configuration.username, password: configuration.password };\n    }\n};\nexports.setBasicAuthToObject = setBasicAuthToObject;\n/**\n *\n * @export\n */\nconst setBearerAuthToObject = async function (object, configuration) {\n    if (configuration && configuration.accessToken) {\n        const accessToken = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken()\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + accessToken;\n    }\n};\nexports.setBearerAuthToObject = setBearerAuthToObject;\n/**\n *\n * @export\n */\nconst setOAuthToObject = async function (object, name, scopes, configuration) {\n    if (configuration && configuration.accessToken) {\n        const localVarAccessTokenValue = typeof configuration.accessToken === 'function'\n            ? await configuration.accessToken(name, scopes)\n            : await configuration.accessToken;\n        object[\"Authorization\"] = \"Bearer \" + localVarAccessTokenValue;\n    }\n};\nexports.setOAuthToObject = setOAuthToObject;\nfunction setFlattenedQueryParams(urlSearchParams, parameter, key = \"\") {\n    if (parameter == null)\n        return;\n    if (typeof parameter === \"object\") {\n        if (Array.isArray(parameter)) {\n            parameter.forEach(item => setFlattenedQueryParams(urlSearchParams, item, key));\n        }\n        else {\n            Object.keys(parameter).forEach(currentKey => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== '' ? '.' : ''}${currentKey}`));\n        }\n    }\n    else {\n        if (urlSearchParams.has(key)) {\n            urlSearchParams.append(key, parameter);\n        }\n        else {\n            urlSearchParams.set(key, parameter);\n        }\n    }\n}\n/**\n *\n * @export\n */\nconst setSearchParams = function (url, ...objects) {\n    const searchParams = new URLSearchParams(url.search);\n    setFlattenedQueryParams(searchParams, objects);\n    url.search = searchParams.toString();\n};\nexports.setSearchParams = setSearchParams;\n/**\n *\n * @export\n */\nconst serializeDataIfNeeded = function (value, requestOptions, configuration) {\n    const nonString = typeof value !== 'string';\n    const needsSerialization = nonString && configuration && configuration.isJsonMime\n        ? configuration.isJsonMime(requestOptions.headers['Content-Type'])\n        : nonString;\n    return needsSerialization\n        ? JSON.stringify(value !== undefined ? value : {})\n        : (value || \"\");\n};\nexports.serializeDataIfNeeded = serializeDataIfNeeded;\n/**\n *\n * @export\n */\nconst toPathString = function (url) {\n    return url.pathname + url.search + url.hash;\n};\nexports.toPathString = toPathString;\n/**\n *\n * @export\n */\nconst createRequestFunction = function (axiosArgs, globalAxios, BASE_PATH, configuration) {\n    return (axios = globalAxios, basePath = BASE_PATH) => {\n        const axiosRequestArgs = { ...axiosArgs.options, url: (axios.defaults.baseURL ? '' : configuration?.basePath ?? basePath) + axiosArgs.url };\n        return axios.request(axiosRequestArgs);\n    };\n};\nexports.createRequestFunction = createRequestFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRyw2QkFBNkIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx5QkFBeUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDelIsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsV0FBVyxxQ0FBcUMsYUFBYTtBQUNySTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsSUFBSSxFQUFFLHNCQUFzQixFQUFFLFdBQVc7QUFDcks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb21tb24uanM/ZjY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBleHBvcnRzLnRvUGF0aFN0cmluZyA9IGV4cG9ydHMuc2VyaWFsaXplRGF0YUlmTmVlZGVkID0gZXhwb3J0cy5zZXRTZWFyY2hQYXJhbXMgPSBleHBvcnRzLnNldE9BdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEJlYXJlckF1dGhUb09iamVjdCA9IGV4cG9ydHMuc2V0QmFzaWNBdXRoVG9PYmplY3QgPSBleHBvcnRzLnNldEFwaUtleVRvT2JqZWN0ID0gZXhwb3J0cy5hc3NlcnRQYXJhbUV4aXN0cyA9IGV4cG9ydHMuRFVNTVlfQkFTRV9VUkwgPSB2b2lkIDA7XG5jb25zdCBiYXNlXzEgPSByZXF1aXJlKFwiLi9iYXNlXCIpO1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5leHBvcnRzLkRVTU1ZX0JBU0VfVVJMID0gJ2h0dHBzOi8vZXhhbXBsZS5jb20nO1xuLyoqXG4gKlxuICogQHRocm93cyB7UmVxdWlyZWRFcnJvcn1cbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgYXNzZXJ0UGFyYW1FeGlzdHMgPSBmdW5jdGlvbiAoZnVuY3Rpb25OYW1lLCBwYXJhbU5hbWUsIHBhcmFtVmFsdWUpIHtcbiAgICBpZiAocGFyYW1WYWx1ZSA9PT0gbnVsbCB8fCBwYXJhbVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGJhc2VfMS5SZXF1aXJlZEVycm9yKHBhcmFtTmFtZSwgYFJlcXVpcmVkIHBhcmFtZXRlciAke3BhcmFtTmFtZX0gd2FzIG51bGwgb3IgdW5kZWZpbmVkIHdoZW4gY2FsbGluZyAke2Z1bmN0aW9uTmFtZX0uYCk7XG4gICAgfVxufTtcbmV4cG9ydHMuYXNzZXJ0UGFyYW1FeGlzdHMgPSBhc3NlcnRQYXJhbUV4aXN0cztcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0QXBpS2V5VG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBrZXlQYXJhbU5hbWUsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFwaUtleSkge1xuICAgICAgICBjb25zdCBsb2NhbFZhckFwaUtleVZhbHVlID0gdHlwZW9mIGNvbmZpZ3VyYXRpb24uYXBpS2V5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYXBpS2V5KGtleVBhcmFtTmFtZSlcbiAgICAgICAgICAgIDogYXdhaXQgY29uZmlndXJhdGlvbi5hcGlLZXk7XG4gICAgICAgIG9iamVjdFtrZXlQYXJhbU5hbWVdID0gbG9jYWxWYXJBcGlLZXlWYWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRBcGlLZXlUb09iamVjdCA9IHNldEFwaUtleVRvT2JqZWN0O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRCYXNpY0F1dGhUb09iamVjdCA9IGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiAoY29uZmlndXJhdGlvbi51c2VybmFtZSB8fCBjb25maWd1cmF0aW9uLnBhc3N3b3JkKSkge1xuICAgICAgICBvYmplY3RbXCJhdXRoXCJdID0geyB1c2VybmFtZTogY29uZmlndXJhdGlvbi51c2VybmFtZSwgcGFzc3dvcmQ6IGNvbmZpZ3VyYXRpb24ucGFzc3dvcmQgfTtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRCYXNpY0F1dGhUb09iamVjdCA9IHNldEJhc2ljQXV0aFRvT2JqZWN0O1xuLyoqXG4gKlxuICogQGV4cG9ydFxuICovXG5jb25zdCBzZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBjb25maWd1cmF0aW9uKSB7XG4gICAgaWYgKGNvbmZpZ3VyYXRpb24gJiYgY29uZmlndXJhdGlvbi5hY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4oKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBhY2Nlc3NUb2tlbjtcbiAgICB9XG59O1xuZXhwb3J0cy5zZXRCZWFyZXJBdXRoVG9PYmplY3QgPSBzZXRCZWFyZXJBdXRoVG9PYmplY3Q7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNldE9BdXRoVG9PYmplY3QgPSBhc3luYyBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBzY29wZXMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBpZiAoY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsVmFyQWNjZXNzVG9rZW5WYWx1ZSA9IHR5cGVvZiBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGF3YWl0IGNvbmZpZ3VyYXRpb24uYWNjZXNzVG9rZW4obmFtZSwgc2NvcGVzKVxuICAgICAgICAgICAgOiBhd2FpdCBjb25maWd1cmF0aW9uLmFjY2Vzc1Rva2VuO1xuICAgICAgICBvYmplY3RbXCJBdXRob3JpemF0aW9uXCJdID0gXCJCZWFyZXIgXCIgKyBsb2NhbFZhckFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgfVxufTtcbmV4cG9ydHMuc2V0T0F1dGhUb09iamVjdCA9IHNldE9BdXRoVG9PYmplY3Q7XG5mdW5jdGlvbiBzZXRGbGF0dGVuZWRRdWVyeVBhcmFtcyh1cmxTZWFyY2hQYXJhbXMsIHBhcmFtZXRlciwga2V5ID0gXCJcIikge1xuICAgIGlmIChwYXJhbWV0ZXIgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHBhcmFtZXRlci5mb3JFYWNoKGl0ZW0gPT4gc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXModXJsU2VhcmNoUGFyYW1zLCBpdGVtLCBrZXkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtZXRlcikuZm9yRWFjaChjdXJyZW50S2V5ID0+IHNldEZsYXR0ZW5lZFF1ZXJ5UGFyYW1zKHVybFNlYXJjaFBhcmFtcywgcGFyYW1ldGVyW2N1cnJlbnRLZXldLCBgJHtrZXl9JHtrZXkgIT09ICcnID8gJy4nIDogJyd9JHtjdXJyZW50S2V5fWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHVybFNlYXJjaFBhcmFtcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdXJsU2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHBhcmFtZXRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cmxTZWFyY2hQYXJhbXMuc2V0KGtleSwgcGFyYW1ldGVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3Qgc2V0U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHVybCwgLi4ub2JqZWN0cykge1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsLnNlYXJjaCk7XG4gICAgc2V0RmxhdHRlbmVkUXVlcnlQYXJhbXMoc2VhcmNoUGFyYW1zLCBvYmplY3RzKTtcbiAgICB1cmwuc2VhcmNoID0gc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCk7XG59O1xuZXhwb3J0cy5zZXRTZWFyY2hQYXJhbXMgPSBzZXRTZWFyY2hQYXJhbXM7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IHNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVxdWVzdE9wdGlvbnMsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICBjb25zdCBub25TdHJpbmcgPSB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnO1xuICAgIGNvbnN0IG5lZWRzU2VyaWFsaXphdGlvbiA9IG5vblN0cmluZyAmJiBjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uaXNKc29uTWltZVxuICAgICAgICA/IGNvbmZpZ3VyYXRpb24uaXNKc29uTWltZShyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzWydDb250ZW50LVR5cGUnXSlcbiAgICAgICAgOiBub25TdHJpbmc7XG4gICAgcmV0dXJuIG5lZWRzU2VyaWFsaXphdGlvblxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KVxuICAgICAgICA6ICh2YWx1ZSB8fCBcIlwiKTtcbn07XG5leHBvcnRzLnNlcmlhbGl6ZURhdGFJZk5lZWRlZCA9IHNlcmlhbGl6ZURhdGFJZk5lZWRlZDtcbi8qKlxuICpcbiAqIEBleHBvcnRcbiAqL1xuY29uc3QgdG9QYXRoU3RyaW5nID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoICsgdXJsLmhhc2g7XG59O1xuZXhwb3J0cy50b1BhdGhTdHJpbmcgPSB0b1BhdGhTdHJpbmc7XG4vKipcbiAqXG4gKiBAZXhwb3J0XG4gKi9cbmNvbnN0IGNyZWF0ZVJlcXVlc3RGdW5jdGlvbiA9IGZ1bmN0aW9uIChheGlvc0FyZ3MsIGdsb2JhbEF4aW9zLCBCQVNFX1BBVEgsIGNvbmZpZ3VyYXRpb24pIHtcbiAgICByZXR1cm4gKGF4aW9zID0gZ2xvYmFsQXhpb3MsIGJhc2VQYXRoID0gQkFTRV9QQVRIKSA9PiB7XG4gICAgICAgIGNvbnN0IGF4aW9zUmVxdWVzdEFyZ3MgPSB7IC4uLmF4aW9zQXJncy5vcHRpb25zLCB1cmw6IChheGlvcy5kZWZhdWx0cy5iYXNlVVJMID8gJycgOiBjb25maWd1cmF0aW9uPy5iYXNlUGF0aCA/PyBiYXNlUGF0aCkgKyBheGlvc0FyZ3MudXJsIH07XG4gICAgICAgIHJldHVybiBheGlvcy5yZXF1ZXN0KGF4aW9zUmVxdWVzdEFyZ3MpO1xuICAgIH07XG59O1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RnVuY3Rpb24gPSBjcmVhdGVSZXF1ZXN0RnVuY3Rpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Configuration = void 0;\nclass Configuration {\n    constructor(param = {}) {\n        this.apiKey = param.apiKey;\n        this.username = param.username;\n        this.password = param.password;\n        this.accessToken = param.accessToken;\n        this.basePath = param.basePath;\n        this.serverIndex = param.serverIndex;\n        this.baseOptions = param.baseOptions;\n        this.formDataCtor = param.formDataCtor;\n    }\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    isJsonMime(mime) {\n        const jsonMime = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n}\nexports.Configuration = Configuration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb25maWd1cmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXLHNCQUFzQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9jb25maWd1cmF0aW9uLmpzPzk5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogQ29pbmJhc2UgUGxhdGZvcm0gQVBJXG4gKiBUaGlzIGlzIHRoZSBPcGVuQVBJIDMuMCBzcGVjaWZpY2F0aW9uIGZvciB0aGUgQ29pbmJhc2UgUGxhdGZvcm0gQVBJcywgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBTREtzLlxuICpcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBPcGVuQVBJIGRvY3VtZW50OiAwLjAuMS1hbHBoYVxuICpcbiAqXG4gKiBOT1RFOiBUaGlzIGNsYXNzIGlzIGF1dG8gZ2VuZXJhdGVkIGJ5IE9wZW5BUEkgR2VuZXJhdG9yIChodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2gpLlxuICogaHR0cHM6Ly9vcGVuYXBpLWdlbmVyYXRvci50ZWNoXG4gKiBEbyBub3QgZWRpdCB0aGUgY2xhc3MgbWFudWFsbHkuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IHZvaWQgMDtcbmNsYXNzIENvbmZpZ3VyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtID0ge30pIHtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBwYXJhbS5hcGlLZXk7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSBwYXJhbS51c2VybmFtZTtcbiAgICAgICAgdGhpcy5wYXNzd29yZCA9IHBhcmFtLnBhc3N3b3JkO1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcGFyYW0uYWNjZXNzVG9rZW47XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwYXJhbS5iYXNlUGF0aDtcbiAgICAgICAgdGhpcy5zZXJ2ZXJJbmRleCA9IHBhcmFtLnNlcnZlckluZGV4O1xuICAgICAgICB0aGlzLmJhc2VPcHRpb25zID0gcGFyYW0uYmFzZU9wdGlvbnM7XG4gICAgICAgIHRoaXMuZm9ybURhdGFDdG9yID0gcGFyYW0uZm9ybURhdGFDdG9yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gTUlNRSBpcyBhIEpTT04gTUlNRS5cbiAgICAgKiBKU09OIE1JTUUgZXhhbXBsZXM6XG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uXG4gICAgICogICBhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PVVURjhcbiAgICAgKiAgIEFQUExJQ0FUSU9OL0pTT05cbiAgICAgKiAgIGFwcGxpY2F0aW9uL3ZuZC5jb21wYW55K2pzb25cbiAgICAgKiBAcGFyYW0gbWltZSAtIE1JTUUgKE11bHRpcHVycG9zZSBJbnRlcm5ldCBNYWlsIEV4dGVuc2lvbnMpXG4gICAgICogQHJldHVybiBUcnVlIGlmIHRoZSBnaXZlbiBNSU1FIGlzIEpTT04sIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc0pzb25NaW1lKG1pbWUpIHtcbiAgICAgICAgY29uc3QganNvbk1pbWUgPSBuZXcgUmVnRXhwKCdeKGFwcGxpY2F0aW9uXFwvanNvbnxbXjsvIFxcdF0rXFwvW147LyBcXHRdK1srXWpzb24pWyBcXHRdKig7LiopPyQnLCAnaScpO1xuICAgICAgICByZXR1cm4gbWltZSAhPT0gbnVsbCAmJiAoanNvbk1pbWUudGVzdChtaW1lKSB8fCBtaW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhcHBsaWNhdGlvbi9qc29uLXBhdGNoK2pzb24nKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbmZpZ3VyYXRpb24gPSBDb25maWd1cmF0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/client/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/* tslint:disable */\n/* eslint-disable */\n/**\n * Coinbase Platform API\n * This is the OpenAPI 3.0 specification for the Coinbase Platform APIs, used in conjunction with the Coinbase Platform SDKs.\n *\n * The version of the OpenAPI document: 0.0.1-alpha\n *\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\"), exports);\n__exportStar(__webpack_require__(/*! ./configuration */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw2RUFBTztBQUM1QixhQUFhLG1CQUFPLENBQUMsaUdBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jbGllbnQvaW5kZXguanM/YmFmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qIHRzbGludDpkaXNhYmxlICovXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBDb2luYmFzZSBQbGF0Zm9ybSBBUElcbiAqIFRoaXMgaXMgdGhlIE9wZW5BUEkgMy4wIHNwZWNpZmljYXRpb24gZm9yIHRoZSBDb2luYmFzZSBQbGF0Zm9ybSBBUElzLCB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIFNES3MuXG4gKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIE9wZW5BUEkgZG9jdW1lbnQ6IDAuMC4xLWFscGhhXG4gKlxuICpcbiAqIE5PVEU6IFRoaXMgY2xhc3MgaXMgYXV0byBnZW5lcmF0ZWQgYnkgT3BlbkFQSSBHZW5lcmF0b3IgKGh0dHBzOi8vb3BlbmFwaS1nZW5lcmF0b3IudGVjaCkuXG4gKiBodHRwczovL29wZW5hcGktZ2VuZXJhdG9yLnRlY2hcbiAqIERvIG5vdCBlZGl0IHRoZSBjbGFzcyBtYW51YWxseS5cbiAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uXCIpLCBleHBvcnRzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst faucet_transaction_1 = __webpack_require__(/*! ./faucet_transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\");\nconst historical_balance_1 = __webpack_require__(/*! ./historical_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst staking_reward_1 = __webpack_require__(/*! ./staking_reward */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\");\nconst staking_balance_1 = __webpack_require__(/*! ./staking_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\n/**\n * A representation of a blockchain address, which is a user-controlled account on a network.\n */\nclass Address {\n    /**\n     * Initializes a new Address instance.\n     *\n     * @param networkId - The network id.\n     * @param id - The onchain address id.\n     */\n    constructor(networkId, id) {\n        this.networkId = networkId;\n        this.id = id;\n    }\n    /**\n     * Returns the network ID.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.networkId;\n    }\n    /**\n     * Returns the address ID.\n     *\n     * @returns The address ID.\n     */\n    getId() {\n        return this.id;\n    }\n    /**\n     * Returns the list of balances for the address.\n     *\n     * @returns The map from asset ID to balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.listExternalAddressBalances(this.getNetworkId(), this.getId());\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @returns The balance of the asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.getExternalAddressBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data) {\n            return new decimal_js_1.default(0);\n        }\n        return balance_1.Balance.fromModelAndAssetId(response.data, assetId).amount;\n    }\n    /**\n     * Returns the historical balances of the provided asset.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.balanceHistory.listAddressHistoricalBalance(this.getNetworkId(), this.getId(), asset_1.Asset.primaryDenomination(assetId), limit, page);\n        response.data.data.forEach(historicalBalanceModel => {\n            const historicalBalance = historical_balance_1.HistoricalBalance.fromModel(historicalBalanceModel);\n            data.push(historicalBalance);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the transactions of the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transactions to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transactions. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Transactions.\n     */\n    async listTransactions({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transactionHistory.listAddressTransactions(this.getNetworkId(), this.getId(), limit, page);\n        response.data.data.forEach(transactionModel => {\n            const transaction = new transaction_1.Transaction(transactionModel);\n            data.push(transaction);\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return staking_reward_1.StakingReward.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, [this.getId()], startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return staking_balance_1.StakingBalance.list(coinbase_1.Coinbase.normalizeNetwork(this.getNetworkId()), assetId, this.getId(), startTime, endTime);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.stakeableBalance;\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * A. Dedicated ETH Staking\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to retrieve unstakeable balance for. Defaults to all validators.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.unstakeableBalance;\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const balances = await this.getStakingBalances(asset_id, mode, options);\n        return balances.claimableBalance;\n    }\n    /**\n     * Requests faucet funds for the address.\n     * Only supported on testnet networks.\n     *\n     * @param assetId - The ID of the asset to transfer from the faucet.\n     * @returns The faucet transaction object.\n     * @throws {Error} If the request does not return a transaction hash.\n     * @throws {Error} If the request fails.\n     */\n    async faucet(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.externalAddress.requestExternalFaucetFunds(this.getNetworkId(), this.getId(), assetId, true);\n        return new faucet_transaction_1.FaucetTransaction(response.data);\n    }\n    /**\n     * Returns a string representation of the address.\n     *\n     * @returns A string representing the address.\n     */\n    toString() {\n        return `Address { addressId: '${this.getId()}', networkId: '${this.getNetworkId()}' }`;\n    }\n    /**\n     * Validate if the operation is able to stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a stake operation.\n     */\n    async validateCanStake(amount, assetId, mode, options) {\n        const stakeableBalance = await this.stakeableBalance(assetId, mode, options);\n        if (new decimal_js_1.default(stakeableBalance).lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to stake, only ${stakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to unstake with the supplied input.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create an unstake operation.\n     */\n    async validateCanUnstake(amount, assetId, mode, options) {\n        const unstakeableBalance = new decimal_js_1.default(await this.unstakeableBalance(assetId, mode, options));\n        if (unstakeableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to unstake, only ${unstakeableBalance} available.`);\n        }\n    }\n    /**\n     * Validate if the operation is able to claim stake with the supplied input.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     * @private\n     * @throws {Error} If the supplied input is not able to create a claim stake operation.\n     */\n    async validateCanClaimStake(amount, assetId, mode, options) {\n        if (assetId === \"eth\" && mode === types_1.StakeOptionsMode.NATIVE) {\n            throw new Error(`Claiming stake for ETH is not supported in native mode.`);\n        }\n        const claimableBalance = new decimal_js_1.default(await this.claimableBalance(assetId, mode, options));\n        if (claimableBalance.lessThan(amount.toString())) {\n            throw new Error(`Insufficient funds ${amount} requested to claim stake, only ${claimableBalance} available.`);\n        }\n    }\n    /**\n     * Create a shallow copy of given options.\n     *\n     * @param options - The supplied options to be copied\n     * @private\n     * @returns A copy of the options.\n     */\n    copyOptions(options) {\n        return { ...options };\n    }\n    /**\n     * Get the different staking balance types for the supplied asset.\n     *\n     * @param assetId - The asset to lookup balances for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the balance lookup.\n     * @private\n     * @returns The different balance types.\n     */\n    async getStakingBalances(assetId, mode, options) {\n        const newOptions = this.copyOptions(options);\n        if (mode) {\n            newOptions.mode = mode;\n        }\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.getStakingContext(request);\n        return {\n            stakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.stakeable_balance, assetId).amount,\n            unstakeableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.unstakeable_balance, assetId).amount,\n            claimableBalance: balance_1.Balance.fromModelAndAssetId(response.data.context.claimable_balance, assetId).amount,\n        };\n    }\n}\nexports.Address = Address;\nAddress.MAX_HISTORICAL_BALANCE = 1000;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsNkJBQTZCLG1CQUFPLENBQUMsNkdBQXNCO0FBQzNELDZCQUE2QixtQkFBTyxDQUFDLDZHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsMEJBQTBCLG1CQUFPLENBQUMsdUdBQW1CO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxpRUFBaUUsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0VBQWtFLElBQUk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjLGFBQWEsaUJBQWlCLG9CQUFvQixHQUFHO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsMkJBQTJCLGtCQUFrQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsNkJBQTZCLG9CQUFvQjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVEsaUNBQWlDLGtCQUFrQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hZGRyZXNzLmpzPzI4YWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuY29uc3QgYmFsYW5jZV8xID0gcmVxdWlyZShcIi4vYmFsYW5jZVwiKTtcbmNvbnN0IGJhbGFuY2VfbWFwXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlX21hcFwiKTtcbmNvbnN0IGZhdWNldF90cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vZmF1Y2V0X3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgaGlzdG9yaWNhbF9iYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9oaXN0b3JpY2FsX2JhbGFuY2VcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBzdGFraW5nX3Jld2FyZF8xID0gcmVxdWlyZShcIi4vc3Rha2luZ19yZXdhcmRcIik7XG5jb25zdCBzdGFraW5nX2JhbGFuY2VfMSA9IHJlcXVpcmUoXCIuL3N0YWtpbmdfYmFsYW5jZVwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gYWRkcmVzcywgd2hpY2ggaXMgYSB1c2VyLWNvbnRyb2xsZWQgYWNjb3VudCBvbiBhIG5ldHdvcmsuXG4gKi9cbmNsYXNzIEFkZHJlc3Mge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFkZHJlc3MgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgaWQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIG9uY2hhaW4gYWRkcmVzcyBpZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrSWQsIGlkKSB7XG4gICAgICAgIHRoaXMubmV0d29ya0lkID0gbmV0d29ya0lkO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYWRkcmVzcyBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBiYWxhbmNlcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbWFwIGZyb20gYXNzZXQgSUQgdG8gYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QmFsYW5jZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5saXN0RXh0ZXJuYWxBZGRyZXNzQmFsYW5jZXModGhpcy5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VfbWFwXzEuQmFsYW5jZU1hcC5mcm9tQmFsYW5jZXMocmVzcG9uc2UuZGF0YS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmFsYW5jZSBvZiB0aGUgcHJvdmlkZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYmFsYW5jZSBvZiB0aGUgYXNzZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5nZXRFeHRlcm5hbEFkZHJlc3NCYWxhbmNlKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwgYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5kYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWxBbmRBc3NldElkKHJlc3BvbnNlLmRhdGEsIGFzc2V0SWQpLmFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGlzdG9yaWNhbCBiYWxhbmNlcyBvZiB0aGUgcHJvdmlkZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgSGlzdG9yaWNhbCBCYWxhbmNlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBIaXN0b3JpY2FsIEJhbGFuY2VzIGZvciB0aGUgZ2l2ZW4gQXNzZXQgSUQuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEhpc3RvcmljYWxCYWxhbmNlcyhhc3NldElkLCB7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYmFsYW5jZUhpc3RvcnkubGlzdEFkZHJlc3NIaXN0b3JpY2FsQmFsYW5jZSh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaChoaXN0b3JpY2FsQmFsYW5jZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcmljYWxCYWxhbmNlID0gaGlzdG9yaWNhbF9iYWxhbmNlXzEuSGlzdG9yaWNhbEJhbGFuY2UuZnJvbU1vZGVsKGhpc3RvcmljYWxCYWxhbmNlTW9kZWwpO1xuICAgICAgICAgICAgZGF0YS5wdXNoKGhpc3RvcmljYWxCYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhc01vcmUgPSByZXNwb25zZS5kYXRhLmhhc19tb3JlO1xuICAgICAgICBpZiAoaGFzTW9yZSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBhZ2UgPSByZXNwb25zZS5kYXRhLm5leHRfcGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIGhhc01vcmUsXG4gICAgICAgICAgICBuZXh0UGFnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNhY3Rpb25zIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIFRyYW5zYWN0aW9ucyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgVHJhbnNhY3Rpb25zLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIFRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0VHJhbnNhY3Rpb25zKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNhY3Rpb25IaXN0b3J5Lmxpc3RBZGRyZXNzVHJhbnNhY3Rpb25zKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRoaXMuZ2V0SWQoKSwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh0cmFuc2FjdGlvbk1vZGVsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25Nb2RlbCk7XG4gICAgICAgICAgICBkYXRhLnB1c2godHJhbnNhY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgc3Rha2luZyByZXdhcmRzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIHJld2FyZHMgaW4uICh1c2QsIG5hdGl2ZSkuIERlZmF1bHRzIHRvIHVzZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyByZXdhcmRzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YWtpbmdSZXdhcmRzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSwgZm9ybWF0ID0gdHlwZXNfMS5TdGFraW5nUmV3YXJkRm9ybWF0LlVTRCkge1xuICAgICAgICByZXR1cm4gc3Rha2luZ19yZXdhcmRfMS5TdGFraW5nUmV3YXJkLmxpc3QoY29pbmJhc2VfMS5Db2luYmFzZS5ub3JtYWxpemVOZXR3b3JrKHRoaXMuZ2V0TmV0d29ya0lkKCkpLCBhc3NldElkLCBbdGhpcy5nZXRJZCgpXSwgc3RhcnRUaW1lLCBlbmRUaW1lLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBiYWxhbmNlcy5cbiAgICAgKi9cbiAgICBhc3luYyBoaXN0b3JpY2FsU3Rha2luZ0JhbGFuY2VzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSkge1xuICAgICAgICByZXR1cm4gc3Rha2luZ19iYWxhbmNlXzEuU3Rha2luZ0JhbGFuY2UubGlzdChjb2luYmFzZV8xLkNvaW5iYXNlLm5vcm1hbGl6ZU5ldHdvcmsodGhpcy5nZXROZXR3b3JrSWQoKSksIGFzc2V0SWQsIHRoaXMuZ2V0SWQoKSwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIHRoZSBzdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSBzdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgYmFsYW5jZXMgPSBhd2FpdCB0aGlzLmdldFN0YWtpbmdCYWxhbmNlcyhhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlcy5zdGFrZWFibGVCYWxhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqIEEuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGB2YWxpZGF0b3JfcHViX2tleXNgIChvcHRpb25hbCk6IExpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbGlkYXRvciBwdWJsaWMga2V5cyB0byByZXRyaWV2ZSB1bnN0YWtlYWJsZSBiYWxhbmNlIGZvci4gRGVmYXVsdHMgdG8gYWxsIHZhbGlkYXRvcnMuXG4gICAgICogQHJldHVybnMgVGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgdW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rha2luZ0JhbGFuY2VzKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VzLnVuc3Rha2VhYmxlQmFsYW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjbGFpbWFibGUgYmFsYW5jZSBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0X2lkIC0gVGhlIGFzc2V0IHRvIGNoZWNrIGNsYWltYWJsZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIGNsYWltYWJsZSBiYWxhbmNlLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBjbGFpbWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBiYWxhbmNlcyA9IGF3YWl0IHRoaXMuZ2V0U3Rha2luZ0JhbGFuY2VzKGFzc2V0X2lkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGJhbGFuY2VzLmNsYWltYWJsZUJhbGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGZhdWNldCBmdW5kcyBmb3IgdGhlIGFkZHJlc3MuXG4gICAgICogT25seSBzdXBwb3J0ZWQgb24gdGVzdG5ldCBuZXR3b3Jrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIElEIG9mIHRoZSBhc3NldCB0byB0cmFuc2ZlciBmcm9tIHRoZSBmYXVjZXQuXG4gICAgICogQHJldHVybnMgVGhlIGZhdWNldCB0cmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByZXF1ZXN0IGRvZXMgbm90IHJldHVybiBhIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGZhdWNldChhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmV4dGVybmFsQWRkcmVzcy5yZXF1ZXN0RXh0ZXJuYWxGYXVjZXRGdW5kcyh0aGlzLmdldE5ldHdvcmtJZCgpLCB0aGlzLmdldElkKCksIGFzc2V0SWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gbmV3IGZhdWNldF90cmFuc2FjdGlvbl8xLkZhdWNldFRyYW5zYWN0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEFkZHJlc3MgeyBhZGRyZXNzSWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JyB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgaWYgdGhlIG9wZXJhdGlvbiBpcyBhYmxlIHRvIHN0YWtlIHdpdGggdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgaXMgbm90IGFibGUgdG8gY3JlYXRlIGEgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlQ2FuU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0YWtlYWJsZUJhbGFuY2UgPSBhd2FpdCB0aGlzLnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoc3Rha2VhYmxlQmFsYW5jZSkubGVzc1RoYW4oYW1vdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBmdW5kcyAke2Ftb3VudH0gcmVxdWVzdGVkIHRvIHN0YWtlLCBvbmx5ICR7c3Rha2VhYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGlmIHRoZSBvcGVyYXRpb24gaXMgYWJsZSB0byB1bnN0YWtlIHdpdGggdGhlIHN1cHBsaWVkIGlucHV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHVuc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB1bnN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgc3VwcGxpZWQgaW5wdXQgaXMgbm90IGFibGUgdG8gY3JlYXRlIGFuIHVuc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIHZhbGlkYXRlQ2FuVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdW5zdGFrZWFibGVCYWxhbmNlID0gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGF3YWl0IHRoaXMudW5zdGFrZWFibGVCYWxhbmNlKGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHVuc3Rha2VhYmxlQmFsYW5jZS5sZXNzVGhhbihhbW91bnQudG9TdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzICR7YW1vdW50fSByZXF1ZXN0ZWQgdG8gdW5zdGFrZSwgb25seSAke3Vuc3Rha2VhYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIGlmIHRoZSBvcGVyYXRpb24gaXMgYWJsZSB0byBjbGFpbSBzdGFrZSB3aXRoIHRoZSBzdXBwbGllZCBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN1cHBsaWVkIGlucHV0IGlzIG5vdCBhYmxlIHRvIGNyZWF0ZSBhIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZUNhbkNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc3NldElkID09PSBcImV0aFwiICYmIG1vZGUgPT09IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5OQVRJVkUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2xhaW1pbmcgc3Rha2UgZm9yIEVUSCBpcyBub3Qgc3VwcG9ydGVkIGluIG5hdGl2ZSBtb2RlLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsYWltYWJsZUJhbGFuY2UgPSBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoYXdhaXQgdGhpcy5jbGFpbWFibGVCYWxhbmNlKGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKGNsYWltYWJsZUJhbGFuY2UubGVzc1RoYW4oYW1vdW50LnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCBmdW5kcyAke2Ftb3VudH0gcmVxdWVzdGVkIHRvIGNsYWltIHN0YWtlLCBvbmx5ICR7Y2xhaW1hYmxlQmFsYW5jZX0gYXZhaWxhYmxlLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNoYWxsb3cgY29weSBvZiBnaXZlbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc3VwcGxpZWQgb3B0aW9ucyB0byBiZSBjb3BpZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIEEgY29weSBvZiB0aGUgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb3B5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaWZmZXJlbnQgc3Rha2luZyBiYWxhbmNlIHR5cGVzIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBsb29rdXAgYmFsYW5jZXMgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGJhbGFuY2UgbG9va3VwLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMgVGhlIGRpZmZlcmVudCBiYWxhbmNlIHR5cGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YWtpbmdCYWxhbmNlcyhhc3NldElkLCBtb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG5ld09wdGlvbnMgPSB0aGlzLmNvcHlPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5tb2RlID0gbW9kZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbmV0d29ya19pZDogdGhpcy5nZXROZXR3b3JrSWQoKSxcbiAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldF8xLkFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCksXG4gICAgICAgICAgICBhZGRyZXNzX2lkOiB0aGlzLmdldElkKCksXG4gICAgICAgICAgICBvcHRpb25zOiBuZXdPcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRTdGFraW5nQ29udGV4dChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YWtlYWJsZUJhbGFuY2U6IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YS5jb250ZXh0LnN0YWtlYWJsZV9iYWxhbmNlLCBhc3NldElkKS5hbW91bnQsXG4gICAgICAgICAgICB1bnN0YWtlYWJsZUJhbGFuY2U6IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YS5jb250ZXh0LnVuc3Rha2VhYmxlX2JhbGFuY2UsIGFzc2V0SWQpLmFtb3VudCxcbiAgICAgICAgICAgIGNsYWltYWJsZUJhbGFuY2U6IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YS5jb250ZXh0LmNsYWltYWJsZV9iYWxhbmNlLCBhc3NldElkKS5hbW91bnQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzID0gQWRkcmVzcztcbkFkZHJlc3MuTUFYX0hJU1RPUklDQUxfQkFMQU5DRSA9IDEwMDA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ExternalAddress = void 0;\nconst address_1 = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\n/**\n * A representation of a blockchain Address, which is a user-controlled account on a Network. Addresses are used to\n * send and receive Assets. An ExternalAddress is an Address that is not controlled by the developer, but is instead\n * controlled by the user.\n */\nclass ExternalAddress extends address_1.Address {\n    /**\n     * Builds a stake operation for the supplied asset. The stake operation\n     * may take a few minutes to complete in the case when infrastructure is spun up.\n     *\n     * @param amount - The amount of the asset to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @returns The stake operation.\n     */\n    async buildStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"stake\", mode, options);\n    }\n    /**\n     * Builds an unstake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @returns The unstake operation.\n     */\n    async buildUnstakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"unstake\", mode, options);\n    }\n    /**\n     * Builds a claim stake operation for the supplied asset.\n     *\n     * @param amount - The amount of the asset to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @returns The claim stake operation.\n     */\n    async buildClaimStakeOperation(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.buildStakingOperation(amount, assetId, \"claim_stake\", mode, options);\n    }\n    /**\n     * Builds the staking operation based on the supplied input.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The specific action for the staking operation. e.g. stake, unstake, claim_stake\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options to build a stake operation.\n     * @private\n     * @returns The staking operation.\n     * @throws {Error} If the supplied input cannot build a valid staking operation.\n     */\n    async buildStakingOperation(amount, assetId, action, mode, options) {\n        const stakingAmount = new decimal_js_1.default(amount.toString());\n        if (stakingAmount.lessThanOrEqualTo(0)) {\n            throw new Error(`Amount required greater than zero.`);\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const newOptions = this.copyOptions(options);\n        newOptions.mode = mode;\n        newOptions.amount = asset.toAtomicAmount(new decimal_js_1.default(amount.toString())).toString();\n        const request = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            address_id: this.getId(),\n            action: action,\n            options: newOptions,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.stake.buildStakingOperation(request);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n}\nexports.ExternalAddress = ExternalAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3MvZXh0ZXJuYWxfYWRkcmVzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBWTtBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBYTtBQUN4QyxxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvYWRkcmVzcy9leHRlcm5hbF9hZGRyZXNzLmpzPzRmNDQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkV4dGVybmFsQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGFkZHJlc3NfMSA9IHJlcXVpcmUoXCIuLi9hZGRyZXNzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi4vY29pbmJhc2VcIik7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuLi9hc3NldFwiKTtcbmNvbnN0IHN0YWtpbmdfb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc3Rha2luZ19vcGVyYXRpb25cIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBibG9ja2NoYWluIEFkZHJlc3MsIHdoaWNoIGlzIGEgdXNlci1jb250cm9sbGVkIGFjY291bnQgb24gYSBOZXR3b3JrLiBBZGRyZXNzZXMgYXJlIHVzZWQgdG9cbiAqIHNlbmQgYW5kIHJlY2VpdmUgQXNzZXRzLiBBbiBFeHRlcm5hbEFkZHJlc3MgaXMgYW4gQWRkcmVzcyB0aGF0IGlzIG5vdCBjb250cm9sbGVkIGJ5IHRoZSBkZXZlbG9wZXIsIGJ1dCBpcyBpbnN0ZWFkXG4gKiBjb250cm9sbGVkIGJ5IHRoZSB1c2VyLlxuICovXG5jbGFzcyBFeHRlcm5hbEFkZHJlc3MgZXh0ZW5kcyBhZGRyZXNzXzEuQWRkcmVzcyB7XG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgc3Rha2Ugb3BlcmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuIFRoZSBzdGFrZSBvcGVyYXRpb25cbiAgICAgKiBtYXkgdGFrZSBhIGZldyBtaW51dGVzIHRvIGNvbXBsZXRlIGluIHRoZSBjYXNlIHdoZW4gaW5mcmFzdHJ1Y3R1cmUgaXMgc3B1biB1cC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBzdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBzdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBzdGFrZSBvcGVyYXRpb246XG4gICAgICpcbiAgICAgKiBBLiBTaGFyZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgaW50ZWdyYXRvcl9jb250cmFjdF9hZGRyZXNzYCAob3B0aW9uYWwpOiBUaGUgY29udHJhY3QgYWRkcmVzcyB0byB3aGljaCB0aGUgc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQi4gRGVkaWNhdGVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGZ1bmRpbmdfYWRkcmVzc2AgKG9wdGlvbmFsKTogRXRoZXJldW0gYWRkcmVzcyBmb3IgZnVuZGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogIC0gYHdpdGhkcmF3YWxfYWRkcmVzc2AgKG9wdGlvbmFsKTogRXRoZXJldW0gYWRkcmVzcyBmb3IgcmVjZWl2aW5nIHJld2FyZHMgYW5kIHdpdGhkcmF3YWwgZnVuZHMuIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiAgLSBgZmVlX3JlY2lwaWVudF9hZGRyZXNzYCAob3B0aW9uYWwpOiBFdGhlcmV1bSBhZGRyZXNzIGZvciByZWNlaXZpbmcgdHJhbnNhY3Rpb24gZmVlcy4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZFN0YWtlT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhblN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwic3Rha2VcIiwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbiB1bnN0YWtlIG9wZXJhdGlvbiBmb3IgdGhlIHN1cHBsaWVkIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGFzc2V0IHRvIHVuc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB1bnN0YWtlIG9wZXJhdGlvbjpcbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSB1bnN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEIuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbW1lZGlhdGVgIChvcHRpb25hbCk6IFNldCB0aGlzIHRvIFwidHJ1ZVwiIHRvIHVuc3Rha2UgaW1tZWRpYXRlbHkgaS5lLiBsZXZlcmFnZSBcIkNvaW5iYXNlIG1hbmFnZWQgdW5zdGFrZVwiIHByb2Nlc3MgLiBEZWZhdWx0cyB0byBcImZhbHNlXCIgaS5lLiBcIlVzZXIgbWFuYWdlZCB1bnN0YWtlXCIgcHJvY2Vzcy5cbiAgICAgKiAgLSBgdmFsaWRhdG9yX3B1Yl9rZXlzYCAob3B0aW9uYWwpOiBMaXN0IG9mIGNvbW1hIHNlcGFyYXRlZCB2YWxpZGF0b3IgcHVibGljIGtleXMgdG8gdW5zdGFrZS4gRGVmYXVsdHMgdG8gdmFsaWRhdG9ycyBiZWluZyBwaWNrZWQgdXAgb24geW91ciBiZWhhbGYgY29ycmVzcG9uZGluZyB0byB0aGUgdW5zdGFrZSBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdW5zdGFrZSBvcGVyYXRpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGRVbnN0YWtlT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUNhblVuc3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJ1bnN0YWtlXCIsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgYSBjbGFpbSBzdGFrZSBvcGVyYXRpb24gZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byBjbGFpbSBzdGFrZS5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBBLiBTaGFyZWQgRVRIIFN0YWtpbmdcbiAgICAgKiAgLSBgaW50ZWdyYXRvcl9jb250cmFjdF9hZGRyZXNzYCAob3B0aW9uYWwpOiBUaGUgY29udHJhY3QgYWRkcmVzcyB0byB3aGljaCB0aGUgY2xhaW0gc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZENsYWltU3Rha2VPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZFN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcImNsYWltX3N0YWtlXCIsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGJhc2VkIG9uIHRoZSBzdXBwbGllZCBpbnB1dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIC0gVGhlIHNwZWNpZmljIGFjdGlvbiBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLiBlLmcuIHN0YWtlLCB1bnN0YWtlLCBjbGFpbV9zdGFrZVxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBidWlsZCBhIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHN1cHBsaWVkIGlucHV0IGNhbm5vdCBidWlsZCBhIHZhbGlkIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGJ1aWxkU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIGFjdGlvbiwgbW9kZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzdGFraW5nQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0YWtpbmdBbW91bnQubGVzc1RoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQW1vdW50IHJlcXVpcmVkIGdyZWF0ZXIgdGhhbiB6ZXJvLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaCh0aGlzLmdldE5ldHdvcmtJZCgpLCBhc3NldElkKTtcbiAgICAgICAgY29uc3QgbmV3T3B0aW9ucyA9IHRoaXMuY29weU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG5ld09wdGlvbnMubW9kZSA9IG1vZGU7XG4gICAgICAgIG5ld09wdGlvbnMuYW1vdW50ID0gYXNzZXQudG9BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KGFtb3VudC50b1N0cmluZygpKSkudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG5ldHdvcmtfaWQ6IHRoaXMuZ2V0TmV0d29ya0lkKCksXG4gICAgICAgICAgICBhc3NldF9pZDogYXNzZXRfMS5Bc3NldC5wcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpLFxuICAgICAgICAgICAgYWRkcmVzc19pZDogdGhpcy5nZXRJZCgpLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBvcHRpb25zOiBuZXdPcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5idWlsZFN0YWtpbmdPcGVyYXRpb24ocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBuZXcgc3Rha2luZ19vcGVyYXRpb25fMS5TdGFraW5nT3BlcmF0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxBZGRyZXNzID0gRXh0ZXJuYWxBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletAddress = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst client_1 = __webpack_require__(/*! ../../client */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst address_1 = __webpack_require__(/*! ../address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\");\nconst asset_1 = __webpack_require__(/*! ../asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst coinbase_1 = __webpack_require__(/*! ../coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst trade_1 = __webpack_require__(/*! ../trade */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\");\nconst transfer_1 = __webpack_require__(/*! ../transfer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\");\nconst contract_invocation_1 = __webpack_require__(/*! ../contract_invocation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\");\nconst types_1 = __webpack_require__(/*! ../types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst wallet_1 = __webpack_require__(/*! ../wallet */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\");\nconst staking_operation_1 = __webpack_require__(/*! ../staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\");\nconst payload_signature_1 = __webpack_require__(/*! ../payload_signature */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\");\nconst smart_contract_1 = __webpack_require__(/*! ../smart_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\");\n/**\n * A representation of a blockchain address, which is a wallet-controlled account on a network.\n */\nclass WalletAddress extends address_1.Address {\n    /**\n     * Initializes a new Wallet Address instance.\n     *\n     * @param model - The address model data.\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the address model is empty.\n     */\n    constructor(model, key) {\n        if (!model) {\n            throw new Error(\"Address model cannot be empty\");\n        }\n        super(model.network_id, model.address_id);\n        this.model = model;\n        this.key = key;\n    }\n    /**\n     * Returns a string representation of the wallet address.\n     *\n     * @returns A string representing the wallet address.\n     */\n    toString() {\n        return `WalletAddress{ addressId: '${this.getId()}', networkId: '${this.getNetworkId()}', walletId: '${this.getWalletId()}' }`;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Sets the private key.\n     *\n     * @param key - The ethers.js SigningKey the Address uses to sign data.\n     * @throws {Error} If the private key is already set.\n     */\n    setKey(key) {\n        if (this.key !== undefined) {\n            throw new Error(\"Private key is already set\");\n        }\n        this.key = key;\n    }\n    /**\n     * Exports the Address's private key to a hex string.\n     *\n     * @returns The Address's private key as a hex string.\n     */\n    export() {\n        if (this.key === undefined) {\n            throw new Error(\"Private key is not set\");\n        }\n        return this.key.privateKey;\n    }\n    /**\n     * Returns whether the Address has a private key backing it to sign transactions.\n     *\n     * @returns Whether the Address has a private key backing it to sign transactions.\n     */\n    canSign() {\n        return !!this.key;\n    }\n    /**\n     * Returns all the trades associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Trades to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Trades. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of trades.\n     */\n    async listTrades({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.trade.listTrades(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(tradeModel => {\n            data.push(new trade_1.Trade(tradeModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns all the transfers associated with the address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Transfers to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Transfers. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of transfers.\n     */\n    async listTransfers({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.transfer.listTransfers(this.model.wallet_id, this.model.address_id, limit, page);\n        response.data.data.forEach(transferModel => {\n            data.push(transfer_1.Transfer.fromModel(transferModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address.\n     * Only same-Network Transfers are supported.\n     * This returns a `Transfer` object that has been signed and broadcasted, you\n     * can wait for this to land on-chain (or fail) by calling `transfer.wait()`.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send. For Ether, Coinbase.assets.Eth, Coinbase.assets.Gwei, and Coinbase.assets.Wei supported.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @returns The transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer({ amount, assetId, destination, gasless = false, }) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot transfer from address without private key loaded\");\n        }\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        const [destinationAddress, destinationNetworkId] = await this.getDestinationAddressAndNetwork(destination);\n        const normalizedAmount = new decimal_js_1.Decimal(amount.toString());\n        const currentBalance = await this.getBalance(assetId);\n        if (currentBalance.lessThan(normalizedAmount)) {\n            throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n        }\n        const createTransferRequest = {\n            amount: asset.toAtomicAmount(normalizedAmount).toString(),\n            network_id: destinationNetworkId,\n            asset_id: asset.primaryDenomination(),\n            destination: destinationAddress,\n            gasless: gasless,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.createTransfer(this.getWalletId(), this.getId(), createTransferRequest);\n        const transfer = transfer_1.Transfer.fromModel(response.data);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return transfer;\n        }\n        await transfer.sign(this.getSigner());\n        await transfer.broadcast();\n        return transfer;\n    }\n    /**\n     * Gets a signer for the private key.\n     *\n     * @returns The signer for the private key.\n     * @throws {Error} If the private key is not loaded.\n     */\n    getSigner() {\n        if (!this.key) {\n            throw new Error(\"Cannot sign without a private key\");\n        }\n        return new ethers_1.ethers.Wallet(this.key.privateKey);\n    }\n    /**\n     * Trades the given amount of the given Asset for another Asset. Only same-network Trades are supported.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the From Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @returns The Trade object.\n     * @throws {APIError} if the API request to create or broadcast a Trade fails.\n     * @throws {Error} if the Trade times out.\n     */\n    async createTrade({ amount, fromAssetId, toAssetId }) {\n        const fromAsset = await asset_1.Asset.fetch(this.getNetworkId(), fromAssetId);\n        const toAsset = await asset_1.Asset.fetch(this.getNetworkId(), toAssetId);\n        await this.validateCanTrade(amount, fromAssetId);\n        const trade = await this.createTradeRequest(amount, fromAsset, toAsset);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return trade;\n        }\n        await trade.sign(this.getSigner());\n        await trade.broadcast();\n        return trade;\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     * @throws {Error} if the address cannot sign.\n     * @throws {ArgumentError} if the address does not have sufficient balance.\n     */\n    async invokeContract(options) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot invoke contract from address without private key loaded\");\n        }\n        let atomicAmount;\n        if (options.assetId && options.amount) {\n            const asset = await asset_1.Asset.fetch(this.getNetworkId(), options.assetId);\n            const normalizedAmount = new decimal_js_1.Decimal(options.amount.toString());\n            const currentBalance = await this.getBalance(options.assetId);\n            if (currentBalance.lessThan(normalizedAmount)) {\n                throw new errors_1.ArgumentError(`Insufficient funds: ${normalizedAmount} requested, but only ${currentBalance} available`);\n            }\n            atomicAmount = asset.toAtomicAmount(normalizedAmount).toString();\n        }\n        const contractInvocation = await this.createContractInvocation(options.contractAddress, options.method, options.abi, options.args, atomicAmount);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return contractInvocation;\n        }\n        await contractInvocation.sign(this.getSigner());\n        await contractInvocation.broadcast();\n        return contractInvocation;\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployToken(options) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC20 without private key loaded\");\n        }\n        const smartContract = await this.createERC20(options);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployNFT(options) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC721 without private key loaded\");\n        }\n        const smartContract = await this.createERC721(options);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Deploys an ERC1155 multi-token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.uri - The URI for all token metadata.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async deployMultiToken(options) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot deploy ERC1155 without private key loaded\");\n        }\n        const smartContract = await this.createERC1155(options);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return smartContract;\n        }\n        await smartContract.sign(this.getSigner());\n        await smartContract.broadcast();\n        return smartContract;\n    }\n    /**\n     * Creates an ERC20 token contract.\n     *\n     * @private\n     * @param {CreateERC20Options} options - The options for creating the ERC20 token.\n     * @param {string} options.name - The name of the ERC20 token.\n     * @param {string} options.symbol - The symbol of the ERC20 token.\n     * @param {BigNumber} options.totalSupply - The total supply of the ERC20 token.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC20(options) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc20,\n            options: {\n                name: options.name,\n                symbol: options.symbol,\n                total_supply: options.totalSupply.toString(),\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {APIError} If the private key is not loaded when not using server signer.\n     */\n    async createERC721(options) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc721,\n            options: {\n                name: options.name,\n                symbol: options.symbol,\n                base_uri: options.baseURI,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates an ERC1155 multi-token contract.\n     *\n     * @private\n     * @param {CreateERC1155Options} options - The options for creating the ERC1155 token.\n     * @param {string} options.uri - The URI for all token metadata.\n     * @returns {Promise<SmartContract>} A Promise that resolves to the created SmartContract.\n     * @throws {APIError} If the API request to create a smart contract fails.\n     */\n    async createERC1155(options) {\n        const resp = await coinbase_1.Coinbase.apiClients.smartContract.createSmartContract(this.getWalletId(), this.getId(), {\n            type: client_1.SmartContractType.Erc1155,\n            options: {\n                uri: options.uri,\n            },\n        });\n        return smart_contract_1.SmartContract.fromModel(resp?.data);\n    }\n    /**\n     * Creates a contract invocation with the given data.\n     *\n     * @param contractAddress - The address of the contract the method will be invoked on.\n     * @param method - The method to invoke on the contract.\n     * @param abi - The ABI of the contract.\n     * @param args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param atomicAmount - The atomic amount of the native asset to send to a payable contract method.\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async createContractInvocation(contractAddress, method, abi, args, atomicAmount) {\n        const resp = await coinbase_1.Coinbase.apiClients.contractInvocation.createContractInvocation(this.getWalletId(), this.getId(), {\n            method: method,\n            abi: JSON.stringify(abi),\n            contract_address: contractAddress,\n            args: JSON.stringify(args),\n            amount: atomicAmount,\n        });\n        return contract_invocation_1.ContractInvocation.fromModel(resp?.data);\n    }\n    /**\n     * Creates a staking operation to stake.\n     *\n     * @param amount - The amount to stake.\n     * @param assetId - The asset to stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the stake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `funding_address` (optional): Ethereum address for funding the stake operation. Defaults to the address initiating the stake operation.\n     *  - `withdrawal_address` (optional): Ethereum address for receiving rewards and withdrawal funds. Defaults to the address initiating the stake operation.\n     *  - `fee_recipient_address` (optional): Ethereum address for receiving transaction fees. Defaults to the address initiating the stake operation.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake.\n     *\n     * @param amount - The amount to unstake.\n     * @param assetId - The asset to unstake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the unstake operation:\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the unstake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * B. Dedicated ETH Staking\n     *  - `immediate` (optional): Set this to \"true\" to unstake immediately i.e. leverage \"Coinbase managed unstake\" process . Defaults to \"false\" i.e. \"User managed unstake\" process.\n     *  - `validator_pub_keys` (optional): List of comma separated validator public keys to unstake. Defaults to validators being picked up on your behalf corresponding to the unstake amount.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanUnstake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"unstake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake.\n     *\n     * @param amount - The amount to claim stake.\n     * @param assetId - The asset to claim stake.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for the claim stake operation.\n     *\n     * A. Shared ETH Staking\n     *  - `integrator_contract_address` (optional): The contract address to which the claim stake operation is directed to. Defaults to the integrator contract address associated with CDP account (if available) or else defaults to a shared integrator contract address for that network.\n     *\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 600, intervalSeconds = 0.2) {\n        await this.validateCanClaimStake(amount, assetId, mode, options);\n        return this.createStakingOperation(amount, assetId, \"claim_stake\", mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the address does not have a private key loaded or an associated Server-Signer.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot sign payload with address without private key loaded\");\n        }\n        let signature = undefined;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            signature = this.key.signingKey.sign(unsignedPayload).serialized;\n        }\n        const createPayloadSignatureRequest = {\n            unsigned_payload: unsignedPayload,\n            signature,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.address.createPayloadSignature(this.getWalletId(), this.getId(), createPayloadSignatureRequest);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Gets a Payload Signature.\n     *\n     * @param payloadSignatureId - The ID of the Payload Signature to fetch.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to get the Payload Signature fails.\n     */\n    async getPayloadSignature(payloadSignatureId) {\n        const response = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getId(), payloadSignatureId);\n        const payloadSignature = new payload_signature_1.PayloadSignature(response.data);\n        return payloadSignature;\n    }\n    /**\n     * Lists all the Payload Signatures associated with the Address.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Payload Signatures to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Payload Signatures. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns A promise that resolves to the paginated list response of Payload Signatures.\n     * @throws {APIError} if the API request to list the Payload Signatures fails.\n     */\n    async listPayloadSignatures({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.address.listPayloadSignatures(this.model.wallet_id, this.model.address_id, 100, page?.length ? page : undefined);\n        response.data.data.forEach(payloadSignatureModel => {\n            data.push(new payload_signature_1.PayloadSignature(payloadSignatureModel));\n        });\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the address and network ID of the given destination.\n     *\n     * @param destination - The destination to get the address and network ID of.\n     * @returns The address and network ID of the destination.\n     */\n    async getDestinationAddressAndNetwork(destination) {\n        if (typeof destination !== \"string\" && destination.getNetworkId() !== this.getNetworkId()) {\n            throw new errors_1.ArgumentError(\"Transfer must be on the same Network\");\n        }\n        if (destination instanceof wallet_1.Wallet) {\n            return [(await destination.getDefaultAddress()).getId(), destination.getNetworkId()];\n        }\n        if (destination instanceof address_1.Address) {\n            return [destination.getId(), destination.getNetworkId()];\n        }\n        return [destination, this.getNetworkId()];\n    }\n    /**\n     * Creates a trade model for the specified amount and assets.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAsset - The Asset to trade from.\n     * @param toAsset - The Asset to trade to.\n     * @returns A promise that resolves to a Trade object representing the new trade.\n     */\n    async createTradeRequest(amount, fromAsset, toAsset) {\n        const tradeRequestPayload = {\n            amount: fromAsset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString(),\n            from_asset_id: fromAsset.primaryDenomination(),\n            to_asset_id: toAsset.primaryDenomination(),\n        };\n        const tradeModel = await coinbase_1.Coinbase.apiClients.trade.createTrade(this.getWalletId(), this.getId(), tradeRequestPayload);\n        return new trade_1.Trade(tradeModel?.data);\n    }\n    /**\n     * Checks if trading is possible and raises an error if not.\n     *\n     * @param amount - The amount of the Asset to send.\n     * @param fromAssetId - The ID of the Asset to trade from. For Ether, eth, gwei, and wei are supported.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     */\n    async validateCanTrade(amount, fromAssetId) {\n        if (!coinbase_1.Coinbase.useServerSigner && !this.key) {\n            throw new Error(\"Cannot trade from address without private key loaded\");\n        }\n        const currentBalance = await this.getBalance(fromAssetId);\n        amount = new decimal_js_1.Decimal(amount.toString());\n        if (currentBalance.lessThan(amount)) {\n            throw new Error(`Insufficient funds: ${amount} requested, but only ${currentBalance} available`);\n        }\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset to the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {APIError} if the API request to create or broadcast staking operation fails.\n     * @throws {Error} if the amount is less than zero.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStakingOperation(amount, assetId, action, mode, options, timeoutSeconds, intervalSeconds) {\n        if (new decimal_js_1.Decimal(amount.toString()).lessThanOrEqualTo(0)) {\n            throw new Error(\"Amount required greater than zero.\");\n        }\n        let stakingOperation = await this.createStakingOperationRequest(amount, assetId, action, mode, options);\n        const startTime = Date.now();\n        // Loop until the timeout is reached.\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            // Loop through any unsigned transactions that are available, sign and broadcast them.\n            for (let i = 0; i < stakingOperation.getTransactions().length; i++) {\n                const transaction = stakingOperation.getTransactions()[i];\n                if (!transaction.isSigned()) {\n                    await transaction.sign(this.key);\n                    stakingOperation = await this.broadcastStakingOperationRequest(stakingOperation.getID(), transaction.getSignedPayload().slice(2), i);\n                }\n            }\n            await stakingOperation.reload();\n            if (stakingOperation.isTerminalState()) {\n                return stakingOperation;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking Operation timed out\");\n    }\n    /**\n     * A helper function that creates the staking operation.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param action - The type of staking action to perform.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @private\n     * @throws {APIError} if the API request to create staking operation fails.\n     * @returns The created staking operation.\n     */\n    async createStakingOperationRequest(amount, assetId, action, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        const asset = await asset_1.Asset.fetch(this.getNetworkId(), assetId);\n        options.amount = asset.toAtomicAmount(new decimal_js_1.Decimal(amount.toString())).toString();\n        options.mode = mode ? mode : types_1.StakeOptionsMode.DEFAULT;\n        const stakingOperationRequest = {\n            network_id: this.getNetworkId(),\n            asset_id: asset_1.Asset.primaryDenomination(assetId),\n            action: action,\n            options: options,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.createStakingOperation(this.getWalletId(), this.getId(), stakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n    /**\n     * A helper function that broadcasts the signed payload.\n     *\n     * @param stakingOperationID - The staking operation id related to the signed payload.\n     * @param signedPayload - The payload that's being broadcasted.\n     * @param transactionIndex - The index of the transaction in the array from the staking operation.\n     * @private\n     * @returns An updated staking operation with the broadcasted transaction.\n     */\n    async broadcastStakingOperationRequest(stakingOperationID, signedPayload, transactionIndex) {\n        const broadcastStakingOperationRequest = {\n            signed_payload: signedPayload,\n            transaction_index: transactionIndex,\n        };\n        const response = await coinbase_1.Coinbase.apiClients.walletStake.broadcastStakingOperation(this.getWalletId(), this.getId(), stakingOperationID, broadcastStakingOperationRequest);\n        return new staking_operation_1.StakingOperation(response.data);\n    }\n}\nexports.WalletAddress = WalletAddress;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFjO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLHdGQUFZO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLHNGQUFXO0FBQ3BDLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFVO0FBQ2xDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUFhO0FBQ3hDLDhCQUE4QixtQkFBTyxDQUFDLGdIQUF3QjtBQUM5RCxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxvRkFBVTtBQUNsQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRkFBVztBQUNwQyw0QkFBNEIsbUJBQU8sQ0FBQyw0R0FBc0I7QUFDMUQsNEJBQTRCLG1CQUFPLENBQUMsNEdBQXNCO0FBQzFELHlCQUF5QixtQkFBTyxDQUFDLHNHQUFtQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYyxhQUFhLGlCQUFpQixvQkFBb0IsZ0JBQWdCLG1CQUFtQixHQUFHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FkZHJlc3Mvd2FsbGV0X2FkZHJlc3MuanM/NjJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2FsbGV0QWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vY2xpZW50XCIpO1xuY29uc3QgYWRkcmVzc18xID0gcmVxdWlyZShcIi4uL2FkZHJlc3NcIik7XG5jb25zdCBhc3NldF8xID0gcmVxdWlyZShcIi4uL2Fzc2V0XCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuLi9jb2luYmFzZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHRyYWRlXzEgPSByZXF1aXJlKFwiLi4vdHJhZGVcIik7XG5jb25zdCB0cmFuc2Zlcl8xID0gcmVxdWlyZShcIi4uL3RyYW5zZmVyXCIpO1xuY29uc3QgY29udHJhY3RfaW52b2NhdGlvbl8xID0gcmVxdWlyZShcIi4uL2NvbnRyYWN0X2ludm9jYXRpb25cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHdhbGxldF8xID0gcmVxdWlyZShcIi4uL3dhbGxldFwiKTtcbmNvbnN0IHN0YWtpbmdfb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vc3Rha2luZ19vcGVyYXRpb25cIik7XG5jb25zdCBwYXlsb2FkX3NpZ25hdHVyZV8xID0gcmVxdWlyZShcIi4uL3BheWxvYWRfc2lnbmF0dXJlXCIpO1xuY29uc3Qgc21hcnRfY29udHJhY3RfMSA9IHJlcXVpcmUoXCIuLi9zbWFydF9jb250cmFjdFwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIGJsb2NrY2hhaW4gYWRkcmVzcywgd2hpY2ggaXMgYSB3YWxsZXQtY29udHJvbGxlZCBhY2NvdW50IG9uIGEgbmV0d29yay5cbiAqL1xuY2xhc3MgV2FsbGV0QWRkcmVzcyBleHRlbmRzIGFkZHJlc3NfMS5BZGRyZXNzIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBXYWxsZXQgQWRkcmVzcyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSBhZGRyZXNzIG1vZGVsIGRhdGEuXG4gICAgICogQHBhcmFtIGtleSAtIFRoZSBldGhlcnMuanMgU2lnbmluZ0tleSB0aGUgQWRkcmVzcyB1c2VzIHRvIHNpZ24gZGF0YS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGFkZHJlc3MgbW9kZWwgaXMgZW1wdHkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwsIGtleSkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBZGRyZXNzIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihtb2RlbC5uZXR3b3JrX2lkLCBtb2RlbC5hZGRyZXNzX2lkKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgd2FsbGV0IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHdhbGxldCBhZGRyZXNzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFdhbGxldEFkZHJlc3N7IGFkZHJlc3NJZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCB3YWxsZXRJZDogJyR7dGhpcy5nZXRXYWxsZXRJZCgpfScgfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHdhbGxldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB3YWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGV0aGVycy5qcyBTaWduaW5nS2V5IHRoZSBBZGRyZXNzIHVzZXMgdG8gc2lnbiBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgYWxyZWFkeSBzZXQuXG4gICAgICovXG4gICAgc2V0S2V5KGtleSkge1xuICAgICAgICBpZiAodGhpcy5rZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJpdmF0ZSBrZXkgaXMgYWxyZWFkeSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIEFkZHJlc3MncyBwcml2YXRlIGtleSB0byBhIGhleCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQWRkcmVzcydzIHByaXZhdGUga2V5IGFzIGEgaGV4IHN0cmluZy5cbiAgICAgKi9cbiAgICBleHBvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcml2YXRlIGtleSBpcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleS5wcml2YXRlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIEFkZHJlc3MgaGFzIGEgcHJpdmF0ZSBrZXkgYmFja2luZyBpdCB0byBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIEFkZHJlc3MgaGFzIGEgcHJpdmF0ZSBrZXkgYmFja2luZyBpdCB0byBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBjYW5TaWduKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgdGhlIHRyYWRlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYWdpbmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgVHJhZGVzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBUcmFkZXMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgdHJhZGVzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RUcmFkZXMoeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQYWdlO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5saXN0VHJhZGVzKHRoaXMubW9kZWwud2FsbGV0X2lkLCB0aGlzLm1vZGVsLmFkZHJlc3NfaWQsIGxpbWl0LCBwYWdlKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2godHJhZGVNb2RlbCA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2gobmV3IHRyYWRlXzEuVHJhZGUodHJhZGVNb2RlbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0aGUgdHJhbnNmZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBUcmFuc2ZlcnMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFRyYW5zZmVycy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiB0cmFuc2ZlcnMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFRyYW5zZmVycyh7IGxpbWl0ID0gY29pbmJhc2VfMS5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0LCBwYWdlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICBsZXQgbmV4dFBhZ2U7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmxpc3RUcmFuc2ZlcnModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwgbGltaXQsIHBhZ2UpO1xuICAgICAgICByZXNwb25zZS5kYXRhLmRhdGEuZm9yRWFjaCh0cmFuc2Zlck1vZGVsID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaCh0cmFuc2Zlcl8xLlRyYW5zZmVyLmZyb21Nb2RlbCh0cmFuc2Zlck1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNNb3JlID0gcmVzcG9uc2UuZGF0YS5oYXNfbW9yZTtcbiAgICAgICAgaWYgKGhhc01vcmUpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgIG5leHRQYWdlID0gcmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgbmV4dFBhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVycyB0aGUgZ2l2ZW4gYW1vdW50IG9mIHRoZSBnaXZlbiBBc3NldCB0byB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBPbmx5IHNhbWUtTmV0d29yayBUcmFuc2ZlcnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBUaGlzIHJldHVybnMgYSBgVHJhbnNmZXJgIG9iamVjdCB0aGF0IGhhcyBiZWVuIHNpZ25lZCBhbmQgYnJvYWRjYXN0ZWQsIHlvdVxuICAgICAqIGNhbiB3YWl0IGZvciB0aGlzIHRvIGxhbmQgb24tY2hhaW4gKG9yIGZhaWwpIGJ5IGNhbGxpbmcgYHRyYW5zZmVyLndhaXQoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNyZWF0ZSB0aGUgVHJhbnNmZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byBzZW5kLiBGb3IgRXRoZXIsIENvaW5iYXNlLmFzc2V0cy5FdGgsIENvaW5iYXNlLmFzc2V0cy5Hd2VpLCBhbmQgQ29pbmJhc2UuYXNzZXRzLldlaSBzdXBwb3J0ZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gb2YgdGhlIHRyYW5zZmVyLiBJZiBhIFdhbGxldCwgc2VuZHMgdG8gdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcy4gSWYgYSBTdHJpbmcsIGludGVycHJldHMgaXQgYXMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2FzbGVzcyAtIFdoZXRoZXIgdGhlIFRyYW5zZmVyIHNob3VsZCBiZSBnYXNsZXNzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNmZXIgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBicm9hZGNhc3QgYSBUcmFuc2ZlciBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVUcmFuc2Zlcih7IGFtb3VudCwgYXNzZXRJZCwgZGVzdGluYXRpb24sIGdhc2xlc3MgPSBmYWxzZSwgfSkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHRyYW5zZmVyIGZyb20gYWRkcmVzcyB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgYXNzZXRJZCk7XG4gICAgICAgIGNvbnN0IFtkZXN0aW5hdGlvbkFkZHJlc3MsIGRlc3RpbmF0aW9uTmV0d29ya0lkXSA9IGF3YWl0IHRoaXMuZ2V0RGVzdGluYXRpb25BZGRyZXNzQW5kTmV0d29yayhkZXN0aW5hdGlvbik7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBjb25zdCBjdXJyZW50QmFsYW5jZSA9IGF3YWl0IHRoaXMuZ2V0QmFsYW5jZShhc3NldElkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRCYWxhbmNlLmxlc3NUaGFuKG5vcm1hbGl6ZWRBbW91bnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgSW5zdWZmaWNpZW50IGZ1bmRzOiAke25vcm1hbGl6ZWRBbW91bnR9IHJlcXVlc3RlZCwgYnV0IG9ubHkgJHtjdXJyZW50QmFsYW5jZX0gYXZhaWxhYmxlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3JlYXRlVHJhbnNmZXJSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYW1vdW50OiBhc3NldC50b0F0b21pY0Ftb3VudChub3JtYWxpemVkQW1vdW50KS50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV0d29ya19pZDogZGVzdGluYXRpb25OZXR3b3JrSWQsXG4gICAgICAgICAgICBhc3NldF9pZDogYXNzZXQucHJpbWFyeURlbm9taW5hdGlvbigpLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uQWRkcmVzcyxcbiAgICAgICAgICAgIGdhc2xlc3M6IGdhc2xlc3MsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmNyZWF0ZVRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBjcmVhdGVUcmFuc2ZlclJlcXVlc3QpO1xuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IHRyYW5zZmVyXzEuVHJhbnNmZXIuZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlcjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0cmFuc2Zlci5zaWduKHRoaXMuZ2V0U2lnbmVyKCkpO1xuICAgICAgICBhd2FpdCB0cmFuc2Zlci5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgc2lnbmVyIGZvciB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVyIGZvciB0aGUgcHJpdmF0ZSBrZXkuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldFNpZ25lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gd2l0aG91dCBhIHByaXZhdGUga2V5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJzXzEuZXRoZXJzLldhbGxldCh0aGlzLmtleS5wcml2YXRlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhZGVzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IGZvciBhbm90aGVyIEFzc2V0LiBPbmx5IHNhbWUtbmV0d29yayBUcmFkZXMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFkZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBGcm9tIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZnJvbUFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudG9Bc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byB0cmFkZSB0by5cbiAgICAgKiBAcmV0dXJucyBUaGUgVHJhZGUgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIG9yIGJyb2FkY2FzdCBhIFRyYWRlIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgVHJhZGUgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYWRlKHsgYW1vdW50LCBmcm9tQXNzZXRJZCwgdG9Bc3NldElkIH0pIHtcbiAgICAgICAgY29uc3QgZnJvbUFzc2V0ID0gYXdhaXQgYXNzZXRfMS5Bc3NldC5mZXRjaCh0aGlzLmdldE5ldHdvcmtJZCgpLCBmcm9tQXNzZXRJZCk7XG4gICAgICAgIGNvbnN0IHRvQXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIHRvQXNzZXRJZCk7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5UcmFkZShhbW91bnQsIGZyb21Bc3NldElkKTtcbiAgICAgICAgY29uc3QgdHJhZGUgPSBhd2FpdCB0aGlzLmNyZWF0ZVRyYWRlUmVxdWVzdChhbW91bnQsIGZyb21Bc3NldCwgdG9Bc3NldCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWRlO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRyYWRlLnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHRyYWRlLmJyb2FkY2FzdCgpO1xuICAgICAgICByZXR1cm4gdHJhZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBjb250cmFjdCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBpbnZva2UgdGhlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoZSBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIG9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZCAtIFRoZSBtZXRob2QgdG8gaW52b2tlIG9uIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjb250cmFjdCBtZXRob2QgaW52b2NhdGlvbi5cbiAgICAgKiAgIFRoZSBrZXlzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gc2VuZCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiAgIFRoZSBhc3NldCBtdXN0IGJlIGEgZGVub21pbmF0aW9uIG9mIHRoZSBuYXRpdmUgYXNzZXQuIChFeC4gXCJ3ZWlcIiwgXCJnd2VpXCIsIG9yIFwiZXRoXCIpLlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgY29udHJhY3QgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGFkZHJlc3MgY2Fubm90IHNpZ24uXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gaWYgdGhlIGFkZHJlc3MgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgaW52b2tlQ29udHJhY3Qob3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGludm9rZSBjb250cmFjdCBmcm9tIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGF0b21pY0Ftb3VudDtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXNzZXRJZCAmJiBvcHRpb25zLmFtb3VudCkge1xuICAgICAgICAgICAgY29uc3QgYXNzZXQgPSBhd2FpdCBhc3NldF8xLkFzc2V0LmZldGNoKHRoaXMuZ2V0TmV0d29ya0lkKCksIG9wdGlvbnMuYXNzZXRJZCk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKG9wdGlvbnMuYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2Uob3B0aW9ucy5hc3NldElkKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50QmFsYW5jZS5sZXNzVGhhbihub3JtYWxpemVkQW1vdW50KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKGBJbnN1ZmZpY2llbnQgZnVuZHM6ICR7bm9ybWFsaXplZEFtb3VudH0gcmVxdWVzdGVkLCBidXQgb25seSAke2N1cnJlbnRCYWxhbmNlfSBhdmFpbGFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0b21pY0Ftb3VudCA9IGFzc2V0LnRvQXRvbWljQW1vdW50KG5vcm1hbGl6ZWRBbW91bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udHJhY3RJbnZvY2F0aW9uID0gYXdhaXQgdGhpcy5jcmVhdGVDb250cmFjdEludm9jYXRpb24ob3B0aW9ucy5jb250cmFjdEFkZHJlc3MsIG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLmFiaSwgb3B0aW9ucy5hcmdzLCBhdG9taWNBbW91bnQpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdEludm9jYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgY29udHJhY3RJbnZvY2F0aW9uLnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IGNvbnRyYWN0SW52b2NhdGlvbi5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW52b2NhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkMyMCB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRvdGFsU3VwcGx5IC0gVGhlIHRvdGFsIHN1cHBseSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgc21hcnQgY29udHJhY3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95VG9rZW4ob3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlcGxveSBFUkMyMCB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0ID0gYXdhaXQgdGhpcy5jcmVhdGVFUkMyMChvcHRpb25zKTtcbiAgICAgICAgaWYgKGNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc21hcnRDb250cmFjdDtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzbWFydENvbnRyYWN0LnNpZ24odGhpcy5nZXRTaWduZXIoKSk7XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3QuYnJvYWRjYXN0KCk7XG4gICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzcyMSB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lORlQob3B0aW9ucykge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRlcGxveSBFUkM3MjEgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdCA9IGF3YWl0IHRoaXMuY3JlYXRlRVJDNzIxKG9wdGlvbnMpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3Quc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcGxveXMgYW4gRVJDMTE1NSBtdWx0aS10b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVyaSAtIFRoZSBVUkkgZm9yIGFsbCB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBkZXBsb3lNdWx0aVRva2VuKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZXBsb3kgRVJDMTE1NSB3aXRob3V0IHByaXZhdGUga2V5IGxvYWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0ID0gYXdhaXQgdGhpcy5jcmVhdGVFUkMxMTU1KG9wdGlvbnMpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzbWFydENvbnRyYWN0O1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHNtYXJ0Q29udHJhY3Quc2lnbih0aGlzLmdldFNpZ25lcigpKTtcbiAgICAgICAgYXdhaXQgc21hcnRDb250cmFjdC5icm9hZGNhc3QoKTtcbiAgICAgICAgcmV0dXJuIHNtYXJ0Q29udHJhY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gRVJDMjAgdG9rZW4gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Q3JlYXRlRVJDMjBPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSB7QmlnTnVtYmVyfSBvcHRpb25zLnRvdGFsU3VwcGx5IC0gVGhlIHRvdGFsIHN1cHBseSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U21hcnRDb250cmFjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjcmVhdGVkIFNtYXJ0Q29udHJhY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBzbWFydCBjb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVFUkMyMChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5jcmVhdGVTbWFydENvbnRyYWN0KHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICB0eXBlOiBjbGllbnRfMS5TbWFydENvbnRyYWN0VHlwZS5FcmMyMCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiBvcHRpb25zLnN5bWJvbCxcbiAgICAgICAgICAgICAgICB0b3RhbF9zdXBwbHk6IG9wdGlvbnMudG90YWxTdXBwbHkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc21hcnRfY29udHJhY3RfMS5TbWFydENvbnRyYWN0LmZyb21Nb2RlbChyZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFUkM3MjEgdG9rZW4gY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlVVJJIC0gVGhlIGJhc2UgVVJJIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVSQzcyMShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3AgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5jcmVhdGVTbWFydENvbnRyYWN0KHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICB0eXBlOiBjbGllbnRfMS5TbWFydENvbnRyYWN0VHlwZS5FcmM3MjEsXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogb3B0aW9ucy5uYW1lLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogb3B0aW9ucy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgYmFzZV91cmk6IG9wdGlvbnMuYmFzZVVSSSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc21hcnRfY29udHJhY3RfMS5TbWFydENvbnRyYWN0LmZyb21Nb2RlbChyZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBFUkMxMTU1IG11bHRpLXRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0NyZWF0ZUVSQzExNTVPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnVyaSAtIFRoZSBVUkkgZm9yIGFsbCB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTbWFydENvbnRyYWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNyZWF0ZWQgU21hcnRDb250cmFjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIHNtYXJ0IGNvbnRyYWN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUVSQzExNTUob3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuY3JlYXRlU21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwge1xuICAgICAgICAgICAgdHlwZTogY2xpZW50XzEuU21hcnRDb250cmFjdFR5cGUuRXJjMTE1NSxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICB1cmk6IG9wdGlvbnMudXJpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzbWFydF9jb250cmFjdF8xLlNtYXJ0Q29udHJhY3QuZnJvbU1vZGVsKHJlc3A/LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29udHJhY3QgaW52b2NhdGlvbiB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB0aGUgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBvbi5cbiAgICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCB0byBpbnZva2Ugb24gdGhlIGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBhYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgY29udHJhY3QgbWV0aG9kIGludm9jYXRpb24uXG4gICAgICogICBUaGUga2V5cyBzaG91bGQgYmUgdGhlIGFyZ3VtZW50IG5hbWVzIGFuZCB0aGUgdmFsdWVzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgdmFsdWVzLlxuICAgICAqIEBwYXJhbSBhdG9taWNBbW91bnQgLSBUaGUgYXRvbWljIGFtb3VudCBvZiB0aGUgbmF0aXZlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIGNvbnRyYWN0IGludm9jYXRpb24gZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ29udHJhY3RJbnZvY2F0aW9uKGNvbnRyYWN0QWRkcmVzcywgbWV0aG9kLCBhYmksIGFyZ3MsIGF0b21pY0Ftb3VudCkge1xuICAgICAgICBjb25zdCByZXNwID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbi5jcmVhdGVDb250cmFjdEludm9jYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgYWJpOiBKU09OLnN0cmluZ2lmeShhYmkpLFxuICAgICAgICAgICAgY29udHJhY3RfYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgYXJnczogSlNPTi5zdHJpbmdpZnkoYXJncyksXG4gICAgICAgICAgICBhbW91bnQ6IGF0b21pY0Ftb3VudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250cmFjdF9pbnZvY2F0aW9uXzEuQ29udHJhY3RJbnZvY2F0aW9uLmZyb21Nb2RlbChyZXNwPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWtpbmcgb3BlcmF0aW9uIHRvIHN0YWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgdG8gc3Rha2UuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHN0YWtlIG9wZXJhdGlvbiBpcyBkaXJlY3RlZCB0by4gRGVmYXVsdHMgdG8gdGhlIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggQ0RQIGFjY291bnQgKGlmIGF2YWlsYWJsZSkgb3IgZWxzZSBkZWZhdWx0cyB0byBhIHNoYXJlZCBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgZm9yIHRoYXQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEIuIERlZGljYXRlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBmdW5kaW5nX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIGZ1bmRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi4gRGVmYXVsdHMgdG8gdGhlIGFkZHJlc3MgaW5pdGlhdGluZyB0aGUgc3Rha2Ugb3BlcmF0aW9uLlxuICAgICAqICAtIGB3aXRoZHJhd2FsX2FkZHJlc3NgIChvcHRpb25hbCk6IEV0aGVyZXVtIGFkZHJlc3MgZm9yIHJlY2VpdmluZyByZXdhcmRzIGFuZCB3aXRoZHJhd2FsIGZ1bmRzLiBEZWZhdWx0cyB0byB0aGUgYWRkcmVzcyBpbml0aWF0aW5nIHRoZSBzdGFrZSBvcGVyYXRpb24uXG4gICAgICogIC0gYGZlZV9yZWNpcGllbnRfYWRkcmVzc2AgKG9wdGlvbmFsKTogRXRoZXJldW0gYWRkcmVzcyBmb3IgcmVjZWl2aW5nIHRyYW5zYWN0aW9uIGZlZXMuIERlZmF1bHRzIHRvIHRoZSBhZGRyZXNzIGluaXRpYXRpbmcgdGhlIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MDAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIFwic3Rha2VcIiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byB1bnN0YWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgdG8gdW5zdGFrZS5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB1bnN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIHVuc3Rha2Ugb3BlcmF0aW9uOlxuICAgICAqXG4gICAgICogQS4gU2hhcmVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGludGVncmF0b3JfY29udHJhY3RfYWRkcmVzc2AgKG9wdGlvbmFsKTogVGhlIGNvbnRyYWN0IGFkZHJlc3MgdG8gd2hpY2ggdGhlIHVuc3Rha2Ugb3BlcmF0aW9uIGlzIGRpcmVjdGVkIHRvLiBEZWZhdWx0cyB0byB0aGUgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCBDRFAgYWNjb3VudCAoaWYgYXZhaWxhYmxlKSBvciBlbHNlIGRlZmF1bHRzIHRvIGEgc2hhcmVkIGludGVncmF0b3IgY29udHJhY3QgYWRkcmVzcyBmb3IgdGhhdCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQi4gRGVkaWNhdGVkIEVUSCBTdGFraW5nXG4gICAgICogIC0gYGltbWVkaWF0ZWAgKG9wdGlvbmFsKTogU2V0IHRoaXMgdG8gXCJ0cnVlXCIgdG8gdW5zdGFrZSBpbW1lZGlhdGVseSBpLmUuIGxldmVyYWdlIFwiQ29pbmJhc2UgbWFuYWdlZCB1bnN0YWtlXCIgcHJvY2VzcyAuIERlZmF1bHRzIHRvIFwiZmFsc2VcIiBpLmUuIFwiVXNlciBtYW5hZ2VkIHVuc3Rha2VcIiBwcm9jZXNzLlxuICAgICAqICAtIGB2YWxpZGF0b3JfcHViX2tleXNgIChvcHRpb25hbCk6IExpc3Qgb2YgY29tbWEgc2VwYXJhdGVkIHZhbGlkYXRvciBwdWJsaWMga2V5cyB0byB1bnN0YWtlLiBEZWZhdWx0cyB0byB2YWxpZGF0b3JzIGJlaW5nIHBpY2tlZCB1cCBvbiB5b3VyIGJlaGFsZiBjb3JyZXNwb25kaW5nIHRvIHRoZSB1bnN0YWtlIGFtb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9LCB0aW1lb3V0U2Vjb25kcyA9IDYwMCwgaW50ZXJ2YWxTZWNvbmRzID0gMC4yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVDYW5VbnN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVN0YWtpbmdPcGVyYXRpb24oYW1vdW50LCBhc3NldElkLCBcInVuc3Rha2VcIiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBjbGFpbSBzdGFrZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IHRvIGNsYWltIHN0YWtlLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGNsYWltIHN0YWtlIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEEuIFNoYXJlZCBFVEggU3Rha2luZ1xuICAgICAqICAtIGBpbnRlZ3JhdG9yX2NvbnRyYWN0X2FkZHJlc3NgIChvcHRpb25hbCk6IFRoZSBjb250cmFjdCBhZGRyZXNzIHRvIHdoaWNoIHRoZSBjbGFpbSBzdGFrZSBvcGVyYXRpb24gaXMgZGlyZWN0ZWQgdG8uIERlZmF1bHRzIHRvIHRoZSBpbnRlZ3JhdG9yIGNvbnRyYWN0IGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIENEUCBhY2NvdW50IChpZiBhdmFpbGFibGUpIG9yIGVsc2UgZGVmYXVsdHMgdG8gYSBzaGFyZWQgaW50ZWdyYXRvciBjb250cmFjdCBhZGRyZXNzIGZvciB0aGF0IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSwgdGltZW91dFNlY29uZHMgPSA2MDAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQ2FuQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdGFraW5nT3BlcmF0aW9uKGFtb3VudCwgYXNzZXRJZCwgXCJjbGFpbV9zdGFrZVwiLCBtb2RlLCBvcHRpb25zLCB0aW1lb3V0U2Vjb25kcywgaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuc2lnbmVkUGF5bG9hZCAtIFRoZSBVbnNpZ25lZCBQYXlsb2FkIHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGNyZWF0ZSBhIFBheWxvYWQgU2lnbmF0dXJlIGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgYWRkcmVzcyBkb2VzIG5vdCBoYXZlIGEgcHJpdmF0ZSBrZXkgbG9hZGVkIG9yIGFuIGFzc29jaWF0ZWQgU2VydmVyLVNpZ25lci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHVuc2lnbmVkUGF5bG9hZCkge1xuICAgICAgICBpZiAoIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyICYmICF0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNpZ24gcGF5bG9hZCB3aXRoIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gdGhpcy5rZXkuc2lnbmluZ0tleS5zaWduKHVuc2lnbmVkUGF5bG9hZCkuc2VyaWFsaXplZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHVuc2lnbmVkX3BheWxvYWQ6IHVuc2lnbmVkUGF5bG9hZCxcbiAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBjcmVhdGVQYXlsb2FkU2lnbmF0dXJlUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWRTaWduYXR1cmUgPSBuZXcgcGF5bG9hZF9zaWduYXR1cmVfMS5QYXlsb2FkU2lnbmF0dXJlKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZFNpZ25hdHVyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBheWxvYWRTaWduYXR1cmVJZCAtIFRoZSBJRCBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUgdG8gZmV0Y2guXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFBheWxvYWQgU2lnbmF0dXJlIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCB0aGUgUGF5bG9hZCBTaWduYXR1cmUgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UGF5bG9hZFNpZ25hdHVyZShwYXlsb2FkU2lnbmF0dXJlSWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5nZXRQYXlsb2FkU2lnbmF0dXJlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRJZCgpLCBwYXlsb2FkU2lnbmF0dXJlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkU2lnbmF0dXJlID0gbmV3IHBheWxvYWRfc2lnbmF0dXJlXzEuUGF5bG9hZFNpZ25hdHVyZShyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWRTaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCB0aGUgUGF5bG9hZCBTaWduYXR1cmVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgQWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBQYXlsb2FkIFNpZ25hdHVyZXMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFBheWxvYWQgU2lnbmF0dXJlcy4gRG9uXFwmIzM5O3QgaW5jbHVkZSB0aGlzIHBhcmFtZXRlciBvbiB0aGUgZmlyc3QgY2FsbC4gVXNlIHRoZSBuZXh0IHBhZ2UgdmFsdWUgcmV0dXJuZWQgaW4gYSBwcmV2aW91cyByZXNwb25zZSB0byByZXF1ZXN0IHN1YnNlcXVlbnQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYWdpbmF0ZWQgbGlzdCByZXNwb25zZSBvZiBQYXlsb2FkIFNpZ25hdHVyZXMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBsaXN0IHRoZSBQYXlsb2FkIFNpZ25hdHVyZXMgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdFBheWxvYWRTaWduYXR1cmVzKHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGxldCBuZXh0UGFnZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5saXN0UGF5bG9hZFNpZ25hdHVyZXModGhpcy5tb2RlbC53YWxsZXRfaWQsIHRoaXMubW9kZWwuYWRkcmVzc19pZCwgMTAwLCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmVzcG9uc2UuZGF0YS5kYXRhLmZvckVhY2gocGF5bG9hZFNpZ25hdHVyZU1vZGVsID0+IHtcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgcGF5bG9hZF9zaWduYXR1cmVfMS5QYXlsb2FkU2lnbmF0dXJlKHBheWxvYWRTaWduYXR1cmVNb2RlbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIGFuZCBuZXR3b3JrIElEIG9mIHRoZSBnaXZlbiBkZXN0aW5hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXN0aW5hdGlvbiAtIFRoZSBkZXN0aW5hdGlvbiB0byBnZXQgdGhlIGFkZHJlc3MgYW5kIG5ldHdvcmsgSUQgb2YuXG4gICAgICogQHJldHVybnMgVGhlIGFkZHJlc3MgYW5kIG5ldHdvcmsgSUQgb2YgdGhlIGRlc3RpbmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGdldERlc3RpbmF0aW9uQWRkcmVzc0FuZE5ldHdvcmsoZGVzdGluYXRpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiAhPT0gXCJzdHJpbmdcIiAmJiBkZXN0aW5hdGlvbi5nZXROZXR3b3JrSWQoKSAhPT0gdGhpcy5nZXROZXR3b3JrSWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFyZ3VtZW50RXJyb3IoXCJUcmFuc2ZlciBtdXN0IGJlIG9uIHRoZSBzYW1lIE5ldHdvcmtcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2Ygd2FsbGV0XzEuV2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gWyhhd2FpdCBkZXN0aW5hdGlvbi5nZXREZWZhdWx0QWRkcmVzcygpKS5nZXRJZCgpLCBkZXN0aW5hdGlvbi5nZXROZXR3b3JrSWQoKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uIGluc3RhbmNlb2YgYWRkcmVzc18xLkFkZHJlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbZGVzdGluYXRpb24uZ2V0SWQoKSwgZGVzdGluYXRpb24uZ2V0TmV0d29ya0lkKCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZGVzdGluYXRpb24sIHRoaXMuZ2V0TmV0d29ya0lkKCldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdHJhZGUgbW9kZWwgZm9yIHRoZSBzcGVjaWZpZWQgYW1vdW50IGFuZCBhc3NldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gZnJvbUFzc2V0IC0gVGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uXG4gICAgICogQHBhcmFtIHRvQXNzZXQgLSBUaGUgQXNzZXQgdG8gdHJhZGUgdG8uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBUcmFkZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXcgdHJhZGUuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVHJhZGVSZXF1ZXN0KGFtb3VudCwgZnJvbUFzc2V0LCB0b0Fzc2V0KSB7XG4gICAgICAgIGNvbnN0IHRyYWRlUmVxdWVzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICBhbW91bnQ6IGZyb21Bc3NldC50b0F0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpKS50b1N0cmluZygpLFxuICAgICAgICAgICAgZnJvbV9hc3NldF9pZDogZnJvbUFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oKSxcbiAgICAgICAgICAgIHRvX2Fzc2V0X2lkOiB0b0Fzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdHJhZGVNb2RlbCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5jcmVhdGVUcmFkZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgdHJhZGVSZXF1ZXN0UGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBuZXcgdHJhZGVfMS5UcmFkZSh0cmFkZU1vZGVsPy5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRyYWRpbmcgaXMgcG9zc2libGUgYW5kIHJhaXNlcyBhbiBlcnJvciBpZiBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0gZnJvbUFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHRyYWRlIGZyb20uIEZvciBFdGhlciwgZXRoLCBnd2VpLCBhbmQgd2VpIGFyZSBzdXBwb3J0ZWQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkLCBvciBpZiB0aGUgYXNzZXQgSURzIGFyZSB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlcmUgYXJlIGluc3VmZmljaWVudCBmdW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyB2YWxpZGF0ZUNhblRyYWRlKGFtb3VudCwgZnJvbUFzc2V0SWQpIHtcbiAgICAgICAgaWYgKCFjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lciAmJiAhdGhpcy5rZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFkZSBmcm9tIGFkZHJlc3Mgd2l0aG91dCBwcml2YXRlIGtleSBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoZnJvbUFzc2V0SWQpO1xuICAgICAgICBhbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoY3VycmVudEJhbGFuY2UubGVzc1RoYW4oYW1vdW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgZnVuZHM6ICR7YW1vdW50fSByZXF1ZXN0ZWQsIGJ1dCBvbmx5ICR7Y3VycmVudEJhbGFuY2V9IGF2YWlsYWJsZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBzdGFrZSwgc2lnbnMgaXQsIGFuZCBicm9hZGNhc3RzIGl0IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCB0byB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSB0eXBlIG9mIHN0YWtpbmcgYWN0aW9uIHRvIHBlcmZvcm0uXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHN1Y2ggYXMgc2V0dGluZyB0aGUgbW9kZSBmb3IgdGhlIHN0YWtpbmcgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIG9yIGJyb2FkY2FzdCBzdGFraW5nIG9wZXJhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGFtb3VudCBpcyBsZXNzIHRoYW4gemVyby5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU3Rha2luZ09wZXJhdGlvbihhbW91bnQsIGFzc2V0SWQsIGFjdGlvbiwgbW9kZSwgb3B0aW9ucywgdGltZW91dFNlY29uZHMsIGludGVydmFsU2Vjb25kcykge1xuICAgICAgICBpZiAobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKS5sZXNzVGhhbk9yRXF1YWxUbygwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW1vdW50IHJlcXVpcmVkIGdyZWF0ZXIgdGhhbiB6ZXJvLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3Rha2luZ09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuY3JlYXRlU3Rha2luZ09wZXJhdGlvblJlcXVlc3QoYW1vdW50LCBhc3NldElkLCBhY3Rpb24sIG1vZGUsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAvLyBMb29wIHVudGlsIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICAvLyBMb29wIHRocm91Z2ggYW55IHVuc2lnbmVkIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBhdmFpbGFibGUsIHNpZ24gYW5kIGJyb2FkY2FzdCB0aGVtLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFraW5nT3BlcmF0aW9uLmdldFRyYW5zYWN0aW9ucygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzdGFraW5nT3BlcmF0aW9uLmdldFRyYW5zYWN0aW9ucygpW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb24uaXNTaWduZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0cmFuc2FjdGlvbi5zaWduKHRoaXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgc3Rha2luZ09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3Qoc3Rha2luZ09wZXJhdGlvbi5nZXRJRCgpLCB0cmFuc2FjdGlvbi5nZXRTaWduZWRQYXlsb2FkKCkuc2xpY2UoMiksIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHN0YWtpbmdPcGVyYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAoc3Rha2luZ09wZXJhdGlvbi5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFraW5nT3BlcmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3Rha2luZyBPcGVyYXRpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgdHlwZSBvZiBzdGFraW5nIGFjdGlvbiB0byBwZXJmb3JtLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIHN0YWtpbmcgb3BlcmF0aW9uIGZhaWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0KGFtb3VudCwgYXNzZXRJZCwgYWN0aW9uLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2godGhpcy5nZXROZXR3b3JrSWQoKSwgYXNzZXRJZCk7XG4gICAgICAgIG9wdGlvbnMuYW1vdW50ID0gYXNzZXQudG9BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKGFtb3VudC50b1N0cmluZygpKSkudG9TdHJpbmcoKTtcbiAgICAgICAgb3B0aW9ucy5tb2RlID0gbW9kZSA/IG1vZGUgOiB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVDtcbiAgICAgICAgY29uc3Qgc3Rha2luZ09wZXJhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICBuZXR3b3JrX2lkOiB0aGlzLmdldE5ldHdvcmtJZCgpLFxuICAgICAgICAgICAgYXNzZXRfaWQ6IGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSxcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuY3JlYXRlU3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgc3Rha2luZ09wZXJhdGlvblJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gbmV3IHN0YWtpbmdfb3BlcmF0aW9uXzEuU3Rha2luZ09wZXJhdGlvbihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBicm9hZGNhc3RzIHRoZSBzaWduZWQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFraW5nT3BlcmF0aW9uSUQgLSBUaGUgc3Rha2luZyBvcGVyYXRpb24gaWQgcmVsYXRlZCB0byB0aGUgc2lnbmVkIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHNpZ25lZFBheWxvYWQgLSBUaGUgcGF5bG9hZCB0aGF0J3MgYmVpbmcgYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBhcnJheSBmcm9tIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIEFuIHVwZGF0ZWQgc3Rha2luZyBvcGVyYXRpb24gd2l0aCB0aGUgYnJvYWRjYXN0ZWQgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvblJlcXVlc3Qoc3Rha2luZ09wZXJhdGlvbklELCBzaWduZWRQYXlsb2FkLCB0cmFuc2FjdGlvbkluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFN0YWtpbmdPcGVyYXRpb25SZXF1ZXN0ID0ge1xuICAgICAgICAgICAgc2lnbmVkX3BheWxvYWQ6IHNpZ25lZFBheWxvYWQsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbl9pbmRleDogdHJhbnNhY3Rpb25JbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuYnJvYWRjYXN0U3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0SWQoKSwgc3Rha2luZ09wZXJhdGlvbklELCBicm9hZGNhc3RTdGFraW5nT3BlcmF0aW9uUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBuZXcgc3Rha2luZ19vcGVyYXRpb25fMS5TdGFraW5nT3BlcmF0aW9uKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2FsbGV0QWRkcmVzcyA9IFdhbGxldEFkZHJlc3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NetworkFeatureUnsupportedError = exports.InvalidTransferStatusError = exports.InvalidSignedPayloadError = exports.FaucetLimitReachedError = exports.ResourceExhaustedError = exports.InvalidNetworkIDError = exports.InvalidDestinationError = exports.InvalidAssetIDError = exports.UnsupportedAssetError = exports.MalformedRequestError = exports.AlreadyExistsError = exports.InvalidLimitError = exports.InvalidPageError = exports.InvalidTransferIDError = exports.InvalidAmountError = exports.InvalidAddressError = exports.InvalidWalletError = exports.InvalidAddressIDError = exports.InvalidWalletIDError = exports.NotFoundError = exports.UnauthorizedError = exports.UnimplementedError = exports.InternalError = exports.APIError = void 0;\n/* eslint-disable jsdoc/require-jsdoc */\nconst axios_1 = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\");\n/**\n * A wrapper for API errors to provide more context.\n */\nclass APIError extends axios_1.AxiosError {\n    /**\n     * Initializes a new APIError object.\n     *\n     * @class\n     * @param {AxiosError} error - The Axios error.\n     */\n    constructor(error) {\n        super();\n        this.name = this.constructor.name;\n        this.httpCode = error.response ? error.response.status : null;\n        this.apiCode = null;\n        this.apiMessage = null;\n        this.correlationId = null;\n        if (error.response && error.response.data) {\n            const body = error.response.data;\n            this.apiCode = body.code;\n            this.apiMessage = body.message;\n            this.correlationId = body.correlation_id;\n        }\n    }\n    /**\n     * Creates a specific APIError based on the API error code.\n     *\n     * @param {AxiosError} error - The underlying error object.\n     * @returns {APIError} A specific APIError instance.\n     */\n    static fromError(error) {\n        const apiError = new APIError(error);\n        if (!error.response || !error.response.data) {\n            return apiError;\n        }\n        const body = error?.response?.data;\n        switch (body?.code) {\n            case \"unimplemented\":\n                return new UnimplementedError(error);\n            case \"unauthorized\":\n                return new UnauthorizedError(error);\n            case \"internal\":\n                return new InternalError(error);\n            case \"not_found\":\n                return new NotFoundError(error);\n            case \"invalid_wallet_id\":\n                return new InvalidWalletIDError(error);\n            case \"invalid_address_id\":\n                return new InvalidAddressIDError(error);\n            case \"invalid_wallet\":\n                return new InvalidWalletError(error);\n            case \"invalid_address\":\n                return new InvalidAddressError(error);\n            case \"invalid_amount\":\n                return new InvalidAmountError(error);\n            case \"invalid_transfer_id\":\n                return new InvalidTransferIDError(error);\n            case \"invalid_page_token\":\n                return new InvalidPageError(error);\n            case \"invalid_page_limit\":\n                return new InvalidLimitError(error);\n            case \"already_exists\":\n                return new AlreadyExistsError(error);\n            case \"malformed_request\":\n                return new MalformedRequestError(error);\n            case \"unsupported_asset\":\n                return new UnsupportedAssetError(error);\n            case \"invalid_asset_id\":\n                return new InvalidAssetIDError(error);\n            case \"invalid_destination\":\n                return new InvalidDestinationError(error);\n            case \"invalid_network_id\":\n                return new InvalidNetworkIDError(error);\n            case \"resource_exhausted\":\n                return new ResourceExhaustedError(error);\n            case \"faucet_limit_reached\":\n                return new FaucetLimitReachedError(error);\n            case \"invalid_signed_payload\":\n                return new InvalidSignedPayloadError(error);\n            case \"invalid_transfer_status\":\n                return new InvalidTransferStatusError(error);\n            case \"network_feature_unsupported\":\n                return new NetworkFeatureUnsupportedError(error);\n            default:\n                return apiError;\n        }\n    }\n    /**\n     * Returns a String representation of the APIError.\n     *\n     * @returns {string} a String representation of the APIError\n     */\n    toString() {\n        const payload = {};\n        if (this.httpCode)\n            payload.httpCode = this.httpCode;\n        if (this.apiCode)\n            payload.apiCode = this.apiCode;\n        if (this.apiMessage)\n            payload.apiMessage = this.apiMessage;\n        if (this.correlationId)\n            payload.correlationId = this.correlationId;\n        return `${this.name}{${Object.entries(payload)\n            .map(([key, value]) => `${key}: ${value}`)\n            .join(\", \")}}`;\n    }\n}\nexports.APIError = APIError;\nclass InternalError extends APIError {\n}\nexports.InternalError = InternalError;\nclass UnimplementedError extends APIError {\n}\nexports.UnimplementedError = UnimplementedError;\nclass UnauthorizedError extends APIError {\n}\nexports.UnauthorizedError = UnauthorizedError;\nclass NotFoundError extends APIError {\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidWalletIDError extends APIError {\n}\nexports.InvalidWalletIDError = InvalidWalletIDError;\nclass InvalidAddressIDError extends APIError {\n}\nexports.InvalidAddressIDError = InvalidAddressIDError;\nclass InvalidWalletError extends APIError {\n}\nexports.InvalidWalletError = InvalidWalletError;\nclass InvalidAddressError extends APIError {\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidAmountError extends APIError {\n}\nexports.InvalidAmountError = InvalidAmountError;\nclass InvalidTransferIDError extends APIError {\n}\nexports.InvalidTransferIDError = InvalidTransferIDError;\nclass InvalidPageError extends APIError {\n}\nexports.InvalidPageError = InvalidPageError;\nclass InvalidLimitError extends APIError {\n}\nexports.InvalidLimitError = InvalidLimitError;\nclass AlreadyExistsError extends APIError {\n}\nexports.AlreadyExistsError = AlreadyExistsError;\nclass MalformedRequestError extends APIError {\n}\nexports.MalformedRequestError = MalformedRequestError;\nclass UnsupportedAssetError extends APIError {\n}\nexports.UnsupportedAssetError = UnsupportedAssetError;\nclass InvalidAssetIDError extends APIError {\n}\nexports.InvalidAssetIDError = InvalidAssetIDError;\nclass InvalidDestinationError extends APIError {\n}\nexports.InvalidDestinationError = InvalidDestinationError;\nclass InvalidNetworkIDError extends APIError {\n}\nexports.InvalidNetworkIDError = InvalidNetworkIDError;\nclass ResourceExhaustedError extends APIError {\n}\nexports.ResourceExhaustedError = ResourceExhaustedError;\nclass FaucetLimitReachedError extends APIError {\n}\nexports.FaucetLimitReachedError = FaucetLimitReachedError;\nclass InvalidSignedPayloadError extends APIError {\n}\nexports.InvalidSignedPayloadError = InvalidSignedPayloadError;\nclass InvalidTransferStatusError extends APIError {\n}\nexports.InvalidTransferStatusError = InvalidTransferStatusError;\nclass NetworkFeatureUnsupportedError extends APIError {\n}\nexports.NetworkFeatureUnsupportedError = NetworkFeatureUnsupportedError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2FwaV9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0MsR0FBRyxrQ0FBa0MsR0FBRyxpQ0FBaUMsR0FBRywrQkFBK0IsR0FBRyw4QkFBOEIsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyw4QkFBOEIsR0FBRywwQkFBMEIsR0FBRywyQkFBMkIsR0FBRywwQkFBMEIsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyxxQkFBcUIsR0FBRyx5QkFBeUIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDMXRCO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRTtBQUMvQixzQ0FBc0MsSUFBSSxJQUFJLE1BQU07QUFDcEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hcGlfZXJyb3IuanM/MTU2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJTdGF0dXNFcnJvciA9IGV4cG9ydHMuSW52YWxpZFNpZ25lZFBheWxvYWRFcnJvciA9IGV4cG9ydHMuRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IgPSBleHBvcnRzLlJlc291cmNlRXhoYXVzdGVkRXJyb3IgPSBleHBvcnRzLkludmFsaWROZXR3b3JrSURFcnJvciA9IGV4cG9ydHMuSW52YWxpZERlc3RpbmF0aW9uRXJyb3IgPSBleHBvcnRzLkludmFsaWRBc3NldElERXJyb3IgPSBleHBvcnRzLlVuc3VwcG9ydGVkQXNzZXRFcnJvciA9IGV4cG9ydHMuTWFsZm9ybWVkUmVxdWVzdEVycm9yID0gZXhwb3J0cy5BbHJlYWR5RXhpc3RzRXJyb3IgPSBleHBvcnRzLkludmFsaWRMaW1pdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkUGFnZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJJREVycm9yID0gZXhwb3J0cy5JbnZhbGlkQW1vdW50RXJyb3IgPSBleHBvcnRzLkludmFsaWRBZGRyZXNzRXJyb3IgPSBleHBvcnRzLkludmFsaWRXYWxsZXRFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFkZHJlc3NJREVycm9yID0gZXhwb3J0cy5JbnZhbGlkV2FsbGV0SURFcnJvciA9IGV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGV4cG9ydHMuVW5hdXRob3JpemVkRXJyb3IgPSBleHBvcnRzLlVuaW1wbGVtZW50ZWRFcnJvciA9IGV4cG9ydHMuSW50ZXJuYWxFcnJvciA9IGV4cG9ydHMuQVBJRXJyb3IgPSB2b2lkIDA7XG4vKiBlc2xpbnQtZGlzYWJsZSBqc2RvYy9yZXF1aXJlLWpzZG9jICovXG5jb25zdCBheGlvc18xID0gcmVxdWlyZShcImF4aW9zXCIpO1xuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEFQSSBlcnJvcnMgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQuXG4gKi9cbmNsYXNzIEFQSUVycm9yIGV4dGVuZHMgYXhpb3NfMS5BeGlvc0Vycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBUElFcnJvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0ge0F4aW9zRXJyb3J9IGVycm9yIC0gVGhlIEF4aW9zIGVycm9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVycm9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5odHRwQ29kZSA9IGVycm9yLnJlc3BvbnNlID8gZXJyb3IucmVzcG9uc2Uuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgdGhpcy5hcGlDb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gbnVsbDtcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlICYmIGVycm9yLnJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlcnJvci5yZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgdGhpcy5hcGlDb2RlID0gYm9keS5jb2RlO1xuICAgICAgICAgICAgdGhpcy5hcGlNZXNzYWdlID0gYm9keS5tZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5jb3JyZWxhdGlvbklkID0gYm9keS5jb3JyZWxhdGlvbl9pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3BlY2lmaWMgQVBJRXJyb3IgYmFzZWQgb24gdGhlIEFQSSBlcnJvciBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBeGlvc0Vycm9yfSBlcnJvciAtIFRoZSB1bmRlcmx5aW5nIGVycm9yIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7QVBJRXJyb3J9IEEgc3BlY2lmaWMgQVBJRXJyb3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21FcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBUElFcnJvcihlcnJvcik7XG4gICAgICAgIGlmICghZXJyb3IucmVzcG9uc2UgfHwgIWVycm9yLnJlc3BvbnNlLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gZXJyb3I/LnJlc3BvbnNlPy5kYXRhO1xuICAgICAgICBzd2l0Y2ggKGJvZHk/LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1bmltcGxlbWVudGVkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVbmltcGxlbWVudGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcInVuYXV0aG9yaXplZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5hdXRob3JpemVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludGVybmFsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJub3RfZm91bmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfd2FsbGV0X2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkV2FsbGV0SURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9hZGRyZXNzX2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQWRkcmVzc0lERXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfd2FsbGV0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkV2FsbGV0RXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9hbW91bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRBbW91bnRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF90cmFuc2Zlcl9pZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZFRyYW5zZmVySURFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9wYWdlX3Rva2VuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkUGFnZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3BhZ2VfbGltaXRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludmFsaWRMaW1pdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJhbHJlYWR5X2V4aXN0c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWxyZWFkeUV4aXN0c0Vycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJtYWxmb3JtZWRfcmVxdWVzdFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFsZm9ybWVkUmVxdWVzdEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1bnN1cHBvcnRlZF9hc3NldFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVW5zdXBwb3J0ZWRBc3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Fzc2V0X2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkQXNzZXRJREVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Rlc3RpbmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkRGVzdGluYXRpb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9uZXR3b3JrX2lkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkTmV0d29ya0lERXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcInJlc291cmNlX2V4aGF1c3RlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VFeGhhdXN0ZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBjYXNlIFwiZmF1Y2V0X2xpbWl0X3JlYWNoZWRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZhdWNldExpbWl0UmVhY2hlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3NpZ25lZF9wYXlsb2FkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3RyYW5zZmVyX3N0YXR1c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW52YWxpZFRyYW5zZmVyU3RhdHVzRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSBcIm5ldHdvcmtfZmVhdHVyZV91bnN1cHBvcnRlZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFQSUVycm9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIEFQSUVycm9yXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuaHR0cENvZGUpXG4gICAgICAgICAgICBwYXlsb2FkLmh0dHBDb2RlID0gdGhpcy5odHRwQ29kZTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ29kZSlcbiAgICAgICAgICAgIHBheWxvYWQuYXBpQ29kZSA9IHRoaXMuYXBpQ29kZTtcbiAgICAgICAgaWYgKHRoaXMuYXBpTWVzc2FnZSlcbiAgICAgICAgICAgIHBheWxvYWQuYXBpTWVzc2FnZSA9IHRoaXMuYXBpTWVzc2FnZTtcbiAgICAgICAgaWYgKHRoaXMuY29ycmVsYXRpb25JZClcbiAgICAgICAgICAgIHBheWxvYWQuY29ycmVsYXRpb25JZCA9IHRoaXMuY29ycmVsYXRpb25JZDtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX17JHtPYmplY3QuZW50cmllcyhwYXlsb2FkKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgJHtrZXl9OiAke3ZhbHVlfWApXG4gICAgICAgICAgICAuam9pbihcIiwgXCIpfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuQVBJRXJyb3IgPSBBUElFcnJvcjtcbmNsYXNzIEludGVybmFsRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludGVybmFsRXJyb3IgPSBJbnRlcm5hbEVycm9yO1xuY2xhc3MgVW5pbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5VbmltcGxlbWVudGVkRXJyb3IgPSBVbmltcGxlbWVudGVkRXJyb3I7XG5jbGFzcyBVbmF1dGhvcml6ZWRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuVW5hdXRob3JpemVkRXJyb3IgPSBVbmF1dGhvcml6ZWRFcnJvcjtcbmNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yO1xuY2xhc3MgSW52YWxpZFdhbGxldElERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRXYWxsZXRJREVycm9yID0gSW52YWxpZFdhbGxldElERXJyb3I7XG5jbGFzcyBJbnZhbGlkQWRkcmVzc0lERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBZGRyZXNzSURFcnJvciA9IEludmFsaWRBZGRyZXNzSURFcnJvcjtcbmNsYXNzIEludmFsaWRXYWxsZXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFdhbGxldEVycm9yID0gSW52YWxpZFdhbGxldEVycm9yO1xuY2xhc3MgSW52YWxpZEFkZHJlc3NFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZEFkZHJlc3NFcnJvciA9IEludmFsaWRBZGRyZXNzRXJyb3I7XG5jbGFzcyBJbnZhbGlkQW1vdW50RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBbW91bnRFcnJvciA9IEludmFsaWRBbW91bnRFcnJvcjtcbmNsYXNzIEludmFsaWRUcmFuc2ZlcklERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRUcmFuc2ZlcklERXJyb3IgPSBJbnZhbGlkVHJhbnNmZXJJREVycm9yO1xuY2xhc3MgSW52YWxpZFBhZ2VFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZFBhZ2VFcnJvciA9IEludmFsaWRQYWdlRXJyb3I7XG5jbGFzcyBJbnZhbGlkTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuSW52YWxpZExpbWl0RXJyb3IgPSBJbnZhbGlkTGltaXRFcnJvcjtcbmNsYXNzIEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbn1cbmV4cG9ydHMuQWxyZWFkeUV4aXN0c0Vycm9yID0gQWxyZWFkeUV4aXN0c0Vycm9yO1xuY2xhc3MgTWFsZm9ybWVkUmVxdWVzdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5NYWxmb3JtZWRSZXF1ZXN0RXJyb3IgPSBNYWxmb3JtZWRSZXF1ZXN0RXJyb3I7XG5jbGFzcyBVbnN1cHBvcnRlZEFzc2V0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkQXNzZXRFcnJvciA9IFVuc3VwcG9ydGVkQXNzZXRFcnJvcjtcbmNsYXNzIEludmFsaWRBc3NldElERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWRBc3NldElERXJyb3IgPSBJbnZhbGlkQXNzZXRJREVycm9yO1xuY2xhc3MgSW52YWxpZERlc3RpbmF0aW9uRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWREZXN0aW5hdGlvbkVycm9yID0gSW52YWxpZERlc3RpbmF0aW9uRXJyb3I7XG5jbGFzcyBJbnZhbGlkTmV0d29ya0lERXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkludmFsaWROZXR3b3JrSURFcnJvciA9IEludmFsaWROZXR3b3JrSURFcnJvcjtcbmNsYXNzIFJlc291cmNlRXhoYXVzdGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLlJlc291cmNlRXhoYXVzdGVkRXJyb3IgPSBSZXNvdXJjZUV4aGF1c3RlZEVycm9yO1xuY2xhc3MgRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG59XG5leHBvcnRzLkZhdWNldExpbWl0UmVhY2hlZEVycm9yID0gRmF1Y2V0TGltaXRSZWFjaGVkRXJyb3I7XG5jbGFzcyBJbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkU2lnbmVkUGF5bG9hZEVycm9yID0gSW52YWxpZFNpZ25lZFBheWxvYWRFcnJvcjtcbmNsYXNzIEludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5JbnZhbGlkVHJhbnNmZXJTdGF0dXNFcnJvciA9IEludmFsaWRUcmFuc2ZlclN0YXR1c0Vycm9yO1xuY2xhc3MgTmV0d29ya0ZlYXR1cmVVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xufVxuZXhwb3J0cy5OZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3IgPSBOZXR3b3JrRmVhdHVyZVVuc3VwcG9ydGVkRXJyb3I7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Asset = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/** A representation of an Asset. */\nclass Asset {\n    /**\n     * Private constructor for the Asset class.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param contractAddress - The address ID.\n     * @param decimals - The number of decimals.\n     */\n    constructor(networkId, assetId, contractAddress, decimals) {\n        this.networkId = networkId;\n        this.assetId = assetId;\n        this.contractAddress = contractAddress;\n        this.decimals = decimals;\n    }\n    /**\n     * Creates an Asset from an Asset Model.\n     *\n     * @param model - The Asset Model.\n     * @param assetId - The Asset ID.\n     * @throws If the Asset Model is invalid.\n     * @returns The Asset Class.\n     */\n    static fromModel(model, assetId) {\n        if (!model) {\n            throw new Error(\"Invalid asset model\");\n        }\n        let decimals = model.decimals;\n        // TODO: Push this logic down to the backend.\n        if (assetId &&\n            model.asset_id &&\n            coinbase_1.Coinbase.toAssetId(model.asset_id) !== coinbase_1.Coinbase.toAssetId(assetId)) {\n            switch (assetId) {\n                case \"gwei\":\n                    decimals = constants_1.GWEI_DECIMALS;\n                    break;\n                case \"wei\":\n                    decimals = 0;\n                    break;\n                case \"eth\":\n                    break;\n                default:\n                    throw new errors_1.ArgumentError(`Invalid asset ID: ${assetId}`);\n            }\n        }\n        return new Asset(model.network_id, model.asset_id, model.contract_address, decimals);\n    }\n    /**\n     * Fetches the Asset with the provided Asset ID.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @throws If the Asset cannot be fetched.\n     * @returns The Asset Class.\n     */\n    static async fetch(networkId, assetId) {\n        const asset = await coinbase_1.Coinbase.apiClients.asset.getAsset(coinbase_1.Coinbase.normalizeNetwork(networkId), Asset.primaryDenomination(assetId));\n        return Asset.fromModel(asset?.data, assetId);\n    }\n    /**\n     * Returns the primary denomination for the provided Asset ID.\n     * For `gwei` and `wei` the primary denomination is `eth`.\n     * For all other assets, the primary denomination is the same asset ID.\n     *\n     * @param assetId - The Asset ID.\n     * @returns The primary denomination for the Asset ID.\n     */\n    static primaryDenomination(assetId) {\n        return [coinbase_1.Coinbase.assets.Gwei, coinbase_1.Coinbase.assets.Wei].includes(assetId)\n            ? coinbase_1.Coinbase.assets.Eth\n            : assetId;\n    }\n    /**\n     * Returns the primary denomination for the Asset.\n     *\n     * @returns The primary denomination for the Asset.\n     */\n    primaryDenomination() {\n        return Asset.primaryDenomination(this.assetId);\n    }\n    /**\n     * Converts the amount of the Asset from whole to atomic units.\n     *\n     * @param wholeAmount - The whole amount to convert to atomic units.\n     * @returns The amount in atomic units\n     */\n    toAtomicAmount(wholeAmount) {\n        const atomicAmount = wholeAmount.times(new decimal_js_1.default(10).pow(this.decimals));\n        return BigInt(atomicAmount.toFixed());\n    }\n    /**\n     * Converts the amount of the Asset from atomic to whole units.\n     *\n     * @param atomicAmount - The atomic amount to convert to whole units.\n     * @returns The amount in atomic units\n     */\n    fromAtomicAmount(atomicAmount) {\n        return atomicAmount.dividedBy(new decimal_js_1.default(10).pow(this.decimals));\n    }\n    /**\n     * Returns a string representation of the Asset.\n     *\n     * @returns a string representation of the Asset\n     */\n    toString() {\n        return `Asset{ networkId: ${this.networkId}, assetId: ${this.assetId}, contractAddress: ${this.contractAddress}, decimals: ${this.decimals} }`;\n    }\n    /**\n     * Returns the Asset ID.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.assetId;\n    }\n}\nexports.Asset = Asset;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Fzc2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDJGQUFhO0FBQ3pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFFBQVE7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLGVBQWUsYUFBYSxhQUFhLHFCQUFxQixxQkFBcUIsY0FBYyxnQkFBZ0I7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hc3NldC5qcz9kNGE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NldCA9IHZvaWQgMDtcbmNvbnN0IGRlY2ltYWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVjaW1hbC5qc1wiKSk7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgYW4gQXNzZXQuICovXG5jbGFzcyBBc3NldCB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciBmb3IgdGhlIEFzc2V0IGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBUaGUgbnVtYmVyIG9mIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgY29udHJhY3RBZGRyZXNzLCBkZWNpbWFscykge1xuICAgICAgICB0aGlzLm5ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICAgICAgdGhpcy5hc3NldElkID0gYXNzZXRJZDtcbiAgICAgICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3M7XG4gICAgICAgIHRoaXMuZGVjaW1hbHMgPSBkZWNpbWFscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBc3NldCBmcm9tIGFuIEFzc2V0IE1vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIEFzc2V0IE1vZGVsLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIEFzc2V0IElELlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIEFzc2V0IE1vZGVsIGlzIGludmFsaWQuXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IENsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwobW9kZWwsIGFzc2V0SWQpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhc3NldCBtb2RlbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjaW1hbHMgPSBtb2RlbC5kZWNpbWFscztcbiAgICAgICAgLy8gVE9ETzogUHVzaCB0aGlzIGxvZ2ljIGRvd24gdG8gdGhlIGJhY2tlbmQuXG4gICAgICAgIGlmIChhc3NldElkICYmXG4gICAgICAgICAgICBtb2RlbC5hc3NldF9pZCAmJlxuICAgICAgICAgICAgY29pbmJhc2VfMS5Db2luYmFzZS50b0Fzc2V0SWQobW9kZWwuYXNzZXRfaWQpICE9PSBjb2luYmFzZV8xLkNvaW5iYXNlLnRvQXNzZXRJZChhc3NldElkKSkge1xuICAgICAgICAgICAgc3dpdGNoIChhc3NldElkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImd3ZWlcIjpcbiAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBjb25zdGFudHNfMS5HV0VJX0RFQ0lNQUxTO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwid2VpXCI6XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImV0aFwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgSW52YWxpZCBhc3NldCBJRDogJHthc3NldElkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXNzZXQobW9kZWwubmV0d29ya19pZCwgbW9kZWwuYXNzZXRfaWQsIG1vZGVsLmNvbnRyYWN0X2FkZHJlc3MsIGRlY2ltYWxzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyB0aGUgQXNzZXQgd2l0aCB0aGUgcHJvdmlkZWQgQXNzZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHRocm93cyBJZiB0aGUgQXNzZXQgY2Fubm90IGJlIGZldGNoZWQuXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IENsYXNzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmZXRjaChuZXR3b3JrSWQsIGFzc2V0SWQpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYXNzZXQuZ2V0QXNzZXQoY29pbmJhc2VfMS5Db2luYmFzZS5ub3JtYWxpemVOZXR3b3JrKG5ldHdvcmtJZCksIEFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24oYXNzZXRJZCkpO1xuICAgICAgICByZXR1cm4gQXNzZXQuZnJvbU1vZGVsKGFzc2V0Py5kYXRhLCBhc3NldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJpbWFyeSBkZW5vbWluYXRpb24gZm9yIHRoZSBwcm92aWRlZCBBc3NldCBJRC5cbiAgICAgKiBGb3IgYGd3ZWlgIGFuZCBgd2VpYCB0aGUgcHJpbWFyeSBkZW5vbWluYXRpb24gaXMgYGV0aGAuXG4gICAgICogRm9yIGFsbCBvdGhlciBhc3NldHMsIHRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBpcyB0aGUgc2FtZSBhc3NldCBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIEFzc2V0IElELlxuICAgICAqIEByZXR1cm5zIFRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBmb3IgdGhlIEFzc2V0IElELlxuICAgICAqL1xuICAgIHN0YXRpYyBwcmltYXJ5RGVub21pbmF0aW9uKGFzc2V0SWQpIHtcbiAgICAgICAgcmV0dXJuIFtjb2luYmFzZV8xLkNvaW5iYXNlLmFzc2V0cy5Hd2VpLCBjb2luYmFzZV8xLkNvaW5iYXNlLmFzc2V0cy5XZWldLmluY2x1ZGVzKGFzc2V0SWQpXG4gICAgICAgICAgICA/IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXNzZXRzLkV0aFxuICAgICAgICAgICAgOiBhc3NldElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGRlbm9taW5hdGlvbiBmb3IgdGhlIEFzc2V0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHByaW1hcnkgZGVub21pbmF0aW9uIGZvciB0aGUgQXNzZXQuXG4gICAgICovXG4gICAgcHJpbWFyeURlbm9taW5hdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFzc2V0LnByaW1hcnlEZW5vbWluYXRpb24odGhpcy5hc3NldElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGFtb3VudCBvZiB0aGUgQXNzZXQgZnJvbSB3aG9sZSB0byBhdG9taWMgdW5pdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2hvbGVBbW91bnQgLSBUaGUgd2hvbGUgYW1vdW50IHRvIGNvbnZlcnQgdG8gYXRvbWljIHVuaXRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gYXRvbWljIHVuaXRzXG4gICAgICovXG4gICAgdG9BdG9taWNBbW91bnQod2hvbGVBbW91bnQpIHtcbiAgICAgICAgY29uc3QgYXRvbWljQW1vdW50ID0gd2hvbGVBbW91bnQudGltZXMobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KDEwKS5wb3codGhpcy5kZWNpbWFscykpO1xuICAgICAgICByZXR1cm4gQmlnSW50KGF0b21pY0Ftb3VudC50b0ZpeGVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgYW1vdW50IG9mIHRoZSBBc3NldCBmcm9tIGF0b21pYyB0byB3aG9sZSB1bml0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdG9taWNBbW91bnQgLSBUaGUgYXRvbWljIGFtb3VudCB0byBjb252ZXJ0IHRvIHdob2xlIHVuaXRzLlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gYXRvbWljIHVuaXRzXG4gICAgICovXG4gICAgZnJvbUF0b21pY0Ftb3VudChhdG9taWNBbW91bnQpIHtcbiAgICAgICAgcmV0dXJuIGF0b21pY0Ftb3VudC5kaXZpZGVkQnkobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KDEwKS5wb3codGhpcy5kZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBBc3NldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBBc3NldFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEFzc2V0eyBuZXR3b3JrSWQ6ICR7dGhpcy5uZXR3b3JrSWR9LCBhc3NldElkOiAke3RoaXMuYXNzZXRJZH0sIGNvbnRyYWN0QWRkcmVzczogJHt0aGlzLmNvbnRyYWN0QWRkcmVzc30sIGRlY2ltYWxzOiAke3RoaXMuZGVjaW1hbHN9IH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBc3NldCBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBc3NldCBJRC5cbiAgICAgKi9cbiAgICBnZXRBc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NldElkO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXQgPSBBc3NldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CoinbaseAuthenticator = void 0;\nconst node_jose_1 = __webpack_require__(/*! node-jose */ \"(ssr)/./node_modules/node-jose/lib/index.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst package_json_1 = __webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/package.json\");\nconst pemHeader = \"-----BEGIN EC PRIVATE KEY-----\";\nconst pemFooter = \"-----END EC PRIVATE KEY-----\";\n/**\n * A class that builds JWTs for authenticating with the Coinbase Platform APIs.\n */\nclass CoinbaseAuthenticator {\n    /**\n     * Initializes the Authenticator.\n     *\n     * @param {string} apiKey - The API key name.\n     * @param {string} privateKey - The private key associated with the API key.\n     */\n    constructor(apiKey, privateKey) {\n        this.apiKey = apiKey;\n        this.privateKey = privateKey;\n    }\n    /**\n     * Middleware to intercept requests and add JWT to Authorization header.\n     *\n     * @param {InternalAxiosRequestConfig} config - The request configuration.\n     * @param {boolean} debugging - Flag to enable debugging.\n     * @returns {Promise<InternalAxiosRequestConfig>} The request configuration with the Authorization header added.\n     * @throws {InvalidAPIKeyFormat} If JWT could not be built.\n     */\n    async authenticateRequest(config, debugging = false) {\n        const method = config.method?.toString().toUpperCase();\n        const token = await this.buildJWT(config.url || \"\", method);\n        if (debugging) {\n            console.log(`API REQUEST: ${method} ${config.url}`);\n        }\n        config.headers[\"Authorization\"] = `Bearer ${token}`;\n        config.headers[\"Content-Type\"] = \"application/json\";\n        config.headers[\"Correlation-Context\"] = this.getCorrelationData();\n        return config;\n    }\n    /**\n     * Builds the JWT for the given API endpoint URL.\n     *\n     * @param {string} url - URL of the API endpoint.\n     * @param {string} method - HTTP method of the request.\n     * @returns {Promise<string>} JWT token.\n     * @throws {InvalidAPIKeyFormat} If the private key is not in the correct format.\n     */\n    async buildJWT(url, method = \"GET\") {\n        const pemPrivateKey = this.extractPemKey(this.privateKey);\n        let privateKey;\n        try {\n            privateKey = await node_jose_1.JWK.asKey(pemPrivateKey, \"pem\");\n            if (privateKey.kty !== \"EC\") {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Invalid key type\");\n            }\n        }\n        catch (error) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not parse the private key\");\n        }\n        const header = {\n            alg: \"ES256\",\n            kid: this.apiKey,\n            typ: \"JWT\",\n            nonce: this.nonce(),\n        };\n        const urlObject = new URL(url);\n        const uri = `${method} ${urlObject.host}${urlObject.pathname}`;\n        const claims = {\n            sub: this.apiKey,\n            iss: \"cdp\",\n            aud: [\"cdp_service\"],\n            nbf: Math.floor(Date.now() / 1000),\n            exp: Math.floor(Date.now() / 1000) + 60, // +1 minute\n            uris: [uri],\n        };\n        const payload = Buffer.from(JSON.stringify(claims)).toString(\"utf8\");\n        try {\n            const result = await node_jose_1.JWS.createSign({ format: \"compact\", fields: header }, privateKey)\n                .update(payload)\n                .final();\n            return result;\n        }\n        catch (err) {\n            throw new errors_1.InvalidAPIKeyFormatError(\"Could not sign the JWT\");\n        }\n    }\n    /**\n     * Extracts the PEM key from the given private key string.\n     *\n     * @param {string} privateKeyString - The private key string.\n     * @returns {string} The PEM key.\n     * @throws {InvalidAPIKeyFormat} If the private key string is not in the correct format.\n     */\n    extractPemKey(privateKeyString) {\n        privateKeyString = privateKeyString.replace(/\\n/g, \"\");\n        if (privateKeyString.startsWith(pemHeader) && privateKeyString.endsWith(pemFooter)) {\n            return privateKeyString;\n        }\n        throw new errors_1.InvalidAPIKeyFormatError(\"Invalid private key format\");\n    }\n    /**\n     * Generates a random nonce for the JWT.\n     *\n     * @returns {string} The generated nonce.\n     */\n    nonce() {\n        const range = \"0123456789\";\n        let result = \"\";\n        for (let i = 0; i < 16; i++) {\n            result += range.charAt(Math.floor(Math.random() * range.length));\n        }\n        return result;\n    }\n    /**\n     * Returns encoded correlation data including the SDK version and language.\n     *\n     * @returns {string} Encoded correlation data.\n     */\n    getCorrelationData() {\n        const data = {\n            sdk_version: package_json_1.version,\n            sdk_language: \"typescript\",\n        };\n        return Object.keys(data)\n            .map(key => `${key}=${encodeURIComponent(data[key])}`)\n            .join(\",\");\n    }\n}\nexports.CoinbaseAuthenticator = CoinbaseAuthenticator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2F1dGhlbnRpY2F0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLG9CQUFvQixtQkFBTyxDQUFDLDhEQUFXO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DLHVCQUF1QixtQkFBTyxDQUFDLG9GQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQyxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLHFDQUFxQztBQUN0RCxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxFQUFFLFdBQVc7QUFDN0Q7QUFDQSxvREFBb0QsTUFBTTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLGlCQUFpQjtBQUNsQyxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUSxFQUFFLGVBQWUsRUFBRSxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUNBQW1DO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekIsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUksR0FBRyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9hdXRoZW50aWNhdG9yLmpzP2M3NTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvaW5iYXNlQXV0aGVudGljYXRvciA9IHZvaWQgMDtcbmNvbnN0IG5vZGVfam9zZV8xID0gcmVxdWlyZShcIm5vZGUtam9zZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgcGFja2FnZV9qc29uXzEgPSByZXF1aXJlKFwiLi4vLi4vcGFja2FnZS5qc29uXCIpO1xuY29uc3QgcGVtSGVhZGVyID0gXCItLS0tLUJFR0lOIEVDIFBSSVZBVEUgS0VZLS0tLS1cIjtcbmNvbnN0IHBlbUZvb3RlciA9IFwiLS0tLS1FTkQgRUMgUFJJVkFURSBLRVktLS0tLVwiO1xuLyoqXG4gKiBBIGNsYXNzIHRoYXQgYnVpbGRzIEpXVHMgZm9yIGF1dGhlbnRpY2F0aW5nIHdpdGggdGhlIENvaW5iYXNlIFBsYXRmb3JtIEFQSXMuXG4gKi9cbmNsYXNzIENvaW5iYXNlQXV0aGVudGljYXRvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEF1dGhlbnRpY2F0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBpS2V5IC0gVGhlIEFQSSBrZXkgbmFtZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIEFQSSBrZXkuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXBpS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgICAgICB0aGlzLnByaXZhdGVLZXkgPSBwcml2YXRlS2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaWRkbGV3YXJlIHRvIGludGVyY2VwdCByZXF1ZXN0cyBhbmQgYWRkIEpXVCB0byBBdXRob3JpemF0aW9uIGhlYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWd9IGNvbmZpZyAtIFRoZSByZXF1ZXN0IGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkZWJ1Z2dpbmcgLSBGbGFnIHRvIGVuYWJsZSBkZWJ1Z2dpbmcuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZXJuYWxBeGlvc1JlcXVlc3RDb25maWc+fSBUaGUgcmVxdWVzdCBjb25maWd1cmF0aW9uIHdpdGggdGhlIEF1dGhvcml6YXRpb24gaGVhZGVyIGFkZGVkLlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXR9IElmIEpXVCBjb3VsZCBub3QgYmUgYnVpbHQuXG4gICAgICovXG4gICAgYXN5bmMgYXV0aGVudGljYXRlUmVxdWVzdChjb25maWcsIGRlYnVnZ2luZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGNvbmZpZy5tZXRob2Q/LnRvU3RyaW5nKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBhd2FpdCB0aGlzLmJ1aWxkSldUKGNvbmZpZy51cmwgfHwgXCJcIiwgbWV0aG9kKTtcbiAgICAgICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEFQSSBSRVFVRVNUOiAke21ldGhvZH0gJHtjb25maWcudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzW1wiQXV0aG9yaXphdGlvblwiXSA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgICBjb25maWcuaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuICAgICAgICBjb25maWcuaGVhZGVyc1tcIkNvcnJlbGF0aW9uLUNvbnRleHRcIl0gPSB0aGlzLmdldENvcnJlbGF0aW9uRGF0YSgpO1xuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIEpXVCBmb3IgdGhlIGdpdmVuIEFQSSBlbmRwb2ludCBVUkwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIG9mIHRoZSBBUEkgZW5kcG9pbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCAtIEhUVFAgbWV0aG9kIG9mIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEpXVCB0b2tlbi5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0fSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdC5cbiAgICAgKi9cbiAgICBhc3luYyBidWlsZEpXVCh1cmwsIG1ldGhvZCA9IFwiR0VUXCIpIHtcbiAgICAgICAgY29uc3QgcGVtUHJpdmF0ZUtleSA9IHRoaXMuZXh0cmFjdFBlbUtleSh0aGlzLnByaXZhdGVLZXkpO1xuICAgICAgICBsZXQgcHJpdmF0ZUtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByaXZhdGVLZXkgPSBhd2FpdCBub2RlX2pvc2VfMS5KV0suYXNLZXkocGVtUHJpdmF0ZUtleSwgXCJwZW1cIik7XG4gICAgICAgICAgICBpZiAocHJpdmF0ZUtleS5rdHkgIT09IFwiRUNcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoXCJJbnZhbGlkIGtleSB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSB0aGUgcHJpdmF0ZSBrZXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgICAgICAgYWxnOiBcIkVTMjU2XCIsXG4gICAgICAgICAgICBraWQ6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgdHlwOiBcIkpXVFwiLFxuICAgICAgICAgICAgbm9uY2U6IHRoaXMubm9uY2UoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCB1cmkgPSBgJHttZXRob2R9ICR7dXJsT2JqZWN0Lmhvc3R9JHt1cmxPYmplY3QucGF0aG5hbWV9YDtcbiAgICAgICAgY29uc3QgY2xhaW1zID0ge1xuICAgICAgICAgICAgc3ViOiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIGlzczogXCJjZHBcIixcbiAgICAgICAgICAgIGF1ZDogW1wiY2RwX3NlcnZpY2VcIl0sXG4gICAgICAgICAgICBuYmY6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApLFxuICAgICAgICAgICAgZXhwOiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIDYwLCAvLyArMSBtaW51dGVcbiAgICAgICAgICAgIHVyaXM6IFt1cmldLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoY2xhaW1zKSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbm9kZV9qb3NlXzEuSldTLmNyZWF0ZVNpZ24oeyBmb3JtYXQ6IFwiY29tcGFjdFwiLCBmaWVsZHM6IGhlYWRlciB9LCBwcml2YXRlS2V5KVxuICAgICAgICAgICAgICAgIC51cGRhdGUocGF5bG9hZClcbiAgICAgICAgICAgICAgICAuZmluYWwoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBUElLZXlGb3JtYXRFcnJvcihcIkNvdWxkIG5vdCBzaWduIHRoZSBKV1RcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIFBFTSBrZXkgZnJvbSB0aGUgZ2l2ZW4gcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByaXZhdGVLZXlTdHJpbmcgLSBUaGUgcHJpdmF0ZSBrZXkgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBQRU0ga2V5LlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRBUElLZXlGb3JtYXR9IElmIHRoZSBwcml2YXRlIGtleSBzdHJpbmcgaXMgbm90IGluIHRoZSBjb3JyZWN0IGZvcm1hdC5cbiAgICAgKi9cbiAgICBleHRyYWN0UGVtS2V5KHByaXZhdGVLZXlTdHJpbmcpIHtcbiAgICAgICAgcHJpdmF0ZUtleVN0cmluZyA9IHByaXZhdGVLZXlTdHJpbmcucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgICAgICBpZiAocHJpdmF0ZUtleVN0cmluZy5zdGFydHNXaXRoKHBlbUhlYWRlcikgJiYgcHJpdmF0ZUtleVN0cmluZy5lbmRzV2l0aChwZW1Gb290ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpdmF0ZUtleVN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleSBmb3JtYXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHJhbmRvbSBub25jZSBmb3IgdGhlIEpXVC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBnZW5lcmF0ZWQgbm9uY2UuXG4gICAgICovXG4gICAgbm9uY2UoKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gXCIwMTIzNDU2Nzg5XCI7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSByYW5nZS5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZ2UubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlbmNvZGVkIGNvcnJlbGF0aW9uIGRhdGEgaW5jbHVkaW5nIHRoZSBTREsgdmVyc2lvbiBhbmQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBFbmNvZGVkIGNvcnJlbGF0aW9uIGRhdGEuXG4gICAgICovXG4gICAgZ2V0Q29ycmVsYXRpb25EYXRhKCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgc2RrX3ZlcnNpb246IHBhY2thZ2VfanNvbl8xLnZlcnNpb24sXG4gICAgICAgICAgICBzZGtfbGFuZ3VhZ2U6IFwidHlwZXNjcmlwdFwiLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQoZGF0YVtrZXldKX1gKVxuICAgICAgICAgICAgLmpvaW4oXCIsXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29pbmJhc2VBdXRoZW50aWNhdG9yID0gQ29pbmJhc2VBdXRoZW50aWNhdG9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Balance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of a balance. */\nclass Balance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {string} assetId - The asset ID.\n     * @hideconstructor\n     */\n    constructor(amount, assetId, asset) {\n        this.amount = amount;\n        this.assetId = assetId;\n        this.asset = asset;\n    }\n    /**\n     * Converts a BalanceModel into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n    /**\n     * Converts a BalanceModel and asset ID into a Balance object.\n     *\n     * @param {BalanceModel} model - The balance model object.\n     * @param {string} assetId - The asset ID.\n     * @returns {Balance} The Balance object.\n     */\n    static fromModelAndAssetId(model, assetId) {\n        const asset = asset_1.Asset.fromModel(model.asset, assetId);\n        return new Balance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), asset.getAssetId(), asset);\n    }\n}\nexports.Balance = Balance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9iYWxhbmNlLmpzPzBiNDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBiYWxhbmNlLiAqL1xuY2xhc3MgQmFsYW5jZSB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge0RlY2ltYWx9IGFtb3VudCAtIFRoZSBhbW91bnQgb2YgdGhlIGJhbGFuY2UuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgYXNzZXRJZCwgYXNzZXQpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuYXNzZXRJZCA9IGFzc2V0SWQ7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBhc3NldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCYWxhbmNlTW9kZWwgaW50byBhIEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlTW9kZWx9IG1vZGVsIC0gVGhlIGJhbGFuY2UgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtCYWxhbmNlfSBUaGUgQmFsYW5jZSBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbChtb2RlbCkge1xuICAgICAgICBjb25zdCBhc3NldCA9IGFzc2V0XzEuQXNzZXQuZnJvbU1vZGVsKG1vZGVsLmFzc2V0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCYWxhbmNlKGFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KG1vZGVsLmFtb3VudCkpLCBhc3NldC5nZXRBc3NldElkKCksIGFzc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBCYWxhbmNlTW9kZWwgYW5kIGFzc2V0IElEIGludG8gYSBCYWxhbmNlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QmFsYW5jZU1vZGVsfSBtb2RlbCAtIFRoZSBiYWxhbmNlIG1vZGVsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcmV0dXJucyB7QmFsYW5jZX0gVGhlIEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWxBbmRBc3NldElkKG1vZGVsLCBhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IGFzc2V0ID0gYXNzZXRfMS5Bc3NldC5mcm9tTW9kZWwobW9kZWwuYXNzZXQsIGFzc2V0SWQpO1xuICAgICAgICByZXR1cm4gbmV3IEJhbGFuY2UoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQobW9kZWwuYW1vdW50KSksIGFzc2V0LmdldEFzc2V0SWQoKSwgYXNzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZSA9IEJhbGFuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BalanceMap = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\n/**\n * A convenience class for storing and manipulating Asset balances in a human-readable format.\n */\nclass BalanceMap extends Map {\n    /**\n     * Converts a list of Balance models to a BalanceMap.\n     *\n     * @param {BalanceModel[]} balances - The list of balances fetched from the API.\n     * @returns {BalanceMap} The converted BalanceMap object.\n     */\n    static fromBalances(balances) {\n        const balanceMap = new BalanceMap();\n        balances.forEach(balanceModel => {\n            const balance = balance_1.Balance.fromModel(balanceModel);\n            balanceMap.add(balance);\n        });\n        return balanceMap;\n    }\n    /**\n     * Adds a balance to the map.\n     *\n     * @param {Balance} balance - The balance to add to the map.\n     */\n    add(balance) {\n        if (!(balance instanceof balance_1.Balance)) {\n            throw new Error(\"balance must be a Balance\");\n        }\n        this.set(balance.assetId, balance.amount);\n    }\n    /**\n     * Returns a string representation of the balance map.\n     *\n     * @returns The string representation of the balance map.\n     */\n    toString() {\n        const result = {};\n        this.forEach((value, key) => {\n            let str = value.toString();\n            if (value.isInteger()) {\n                str = value.toNumber().toString();\n            }\n            result[key] = str;\n        });\n        return `BalanceMap${JSON.stringify(result)}`;\n    }\n}\nexports.BalanceMap = BalanceMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2JhbGFuY2VfbWFwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixrQkFBa0IsbUJBQU8sQ0FBQyx1RkFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9iYWxhbmNlX21hcC5qcz84NWQ2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWxhbmNlTWFwID0gdm9pZCAwO1xuY29uc3QgYmFsYW5jZV8xID0gcmVxdWlyZShcIi4vYmFsYW5jZVwiKTtcbi8qKlxuICogQSBjb252ZW5pZW5jZSBjbGFzcyBmb3Igc3RvcmluZyBhbmQgbWFuaXB1bGF0aW5nIEFzc2V0IGJhbGFuY2VzIGluIGEgaHVtYW4tcmVhZGFibGUgZm9ybWF0LlxuICovXG5jbGFzcyBCYWxhbmNlTWFwIGV4dGVuZHMgTWFwIHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIGxpc3Qgb2YgQmFsYW5jZSBtb2RlbHMgdG8gYSBCYWxhbmNlTWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlTW9kZWxbXX0gYmFsYW5jZXMgLSBUaGUgbGlzdCBvZiBiYWxhbmNlcyBmZXRjaGVkIGZyb20gdGhlIEFQSS5cbiAgICAgKiBAcmV0dXJucyB7QmFsYW5jZU1hcH0gVGhlIGNvbnZlcnRlZCBCYWxhbmNlTWFwIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJhbGFuY2VzKGJhbGFuY2VzKSB7XG4gICAgICAgIGNvbnN0IGJhbGFuY2VNYXAgPSBuZXcgQmFsYW5jZU1hcCgpO1xuICAgICAgICBiYWxhbmNlcy5mb3JFYWNoKGJhbGFuY2VNb2RlbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsKGJhbGFuY2VNb2RlbCk7XG4gICAgICAgICAgICBiYWxhbmNlTWFwLmFkZChiYWxhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgYmFsYW5jZSB0byB0aGUgbWFwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCYWxhbmNlfSBiYWxhbmNlIC0gVGhlIGJhbGFuY2UgdG8gYWRkIHRvIHRoZSBtYXAuXG4gICAgICovXG4gICAgYWRkKGJhbGFuY2UpIHtcbiAgICAgICAgaWYgKCEoYmFsYW5jZSBpbnN0YW5jZW9mIGJhbGFuY2VfMS5CYWxhbmNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFsYW5jZSBtdXN0IGJlIGEgQmFsYW5jZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldChiYWxhbmNlLmFzc2V0SWQsIGJhbGFuY2UuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmFsYW5jZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBiYWxhbmNlIG1hcC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuaXNJbnRlZ2VyKCkpIHtcbiAgICAgICAgICAgICAgICBzdHIgPSB2YWx1ZS50b051bWJlcigpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHN0cjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBgQmFsYW5jZU1hcCR7SlNPTi5zdHJpbmdpZnkocmVzdWx0KX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFsYW5jZU1hcCA9IEJhbGFuY2VNYXA7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Coinbase = void 0;\nconst axios_1 = __importDefault(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\nconst axios_retry_1 = __importDefault(__webpack_require__(/*! axios-retry */ \"(ssr)/./node_modules/axios-retry/dist/cjs/index.js\"));\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst client_1 = __webpack_require__(/*! ../client */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/index.js\");\nconst base_1 = __webpack_require__(/*! ./../client/base */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/base.js\");\nconst configuration_1 = __webpack_require__(/*! ./../client/configuration */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/configuration.js\");\nconst authenticator_1 = __webpack_require__(/*! ./authenticator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst os = __importStar(__webpack_require__(/*! os */ \"os\"));\n/**\n * The Coinbase SDK.\n */\nclass Coinbase {\n    /**\n     * Initializes the Coinbase SDK.\n     *\n     * @deprecated as of v0.5.0, use `configure` or `configureFromJson` instead.\n     *\n     * @class\n     * @param options - The constructor options.\n     * @param options.apiKeyName - The API key name.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @param options.maxNetworkRetries - The maximum number of network retries for the API GET requests.\n     * @throws {InvalidConfigurationError} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormatError} If not able to create JWT token.\n     */\n    constructor({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, maxNetworkRetries = 3, }) {\n        if (apiKeyName === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: apiKeyName is empty\");\n        }\n        if (privateKey === \"\") {\n            throw new errors_1.InvalidConfigurationError(\"Invalid configuration: privateKey is empty\");\n        }\n        const coinbaseAuthenticator = new authenticator_1.CoinbaseAuthenticator(apiKeyName, privateKey);\n        const config = new configuration_1.Configuration({\n            basePath: basePath,\n        });\n        const axiosInstance = axios_1.default.create();\n        (0, axios_retry_1.default)(axiosInstance, {\n            retries: maxNetworkRetries,\n            retryCondition: (error) => {\n                return (error.config?.method?.toUpperCase() === \"GET\" &&\n                    (error.response?.status || 0) in [500, 502, 503, 504]);\n            },\n        });\n        (0, utils_1.registerAxiosInterceptors)(axiosInstance, config => coinbaseAuthenticator.authenticateRequest(config, debugging), \n        /* istanbul ignore file */\n        response => (0, utils_1.logApiResponse)(response, debugging));\n        Coinbase.apiClients.wallet = (0, client_1.WalletsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.address = (0, client_1.AddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transfer = (0, client_1.TransfersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.trade = (0, client_1.TradesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.serverSigner = (0, client_1.ServerSignersApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.stake = (0, client_1.StakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.walletStake = (0, client_1.WalletStakeApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.validator = (0, client_1.ValidatorsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.asset = (0, client_1.AssetsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.webhook = (0, client_1.WebhooksApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractInvocation = (0, client_1.ContractInvocationsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.externalAddress = (0, client_1.ExternalAddressesApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.balanceHistory = (0, client_1.BalanceHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.contractEvent = (0, client_1.ContractEventsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.smartContract = (0, client_1.SmartContractsApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiClients.transactionHistory = (0, client_1.TransactionHistoryApiFactory)(config, basePath, axiosInstance);\n        Coinbase.apiKeyPrivateKey = privateKey;\n        Coinbase.useServerSigner = useServerSigner;\n    }\n    /**\n     * Configures the Coinbase SDK with the provided options.\n     *\n     * @param options - The configuration options.\n     * @param options.apiKeyName - The name of the API key.\n     * @param options.privateKey - The private key associated with the API key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not. Defaults to false.\n     * @param options.debugging - If true, logs API requests and responses to the console. Defaults to false.\n     * @param options.basePath - The base path for the API. Defaults to BASE_PATH.\n     * @returns A new instance of the Coinbase SDK.\n     */\n    static configure({ apiKeyName, privateKey, useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, }) {\n        return new Coinbase({\n            apiKeyName,\n            privateKey,\n            useServerSigner,\n            debugging,\n            basePath,\n        });\n    }\n    /**\n     * Reads the API key and private key from a JSON file and initializes the Coinbase SDK.\n     *\n     * @param options - The configuration options.\n     * @param options.filePath - The path to the JSON file containing the API key and private key.\n     * @param options.useServerSigner - Whether to use a Server-Signer or not.\n     * @param options.debugging - If true, logs API requests and responses to the console.\n     * @param options.basePath - The base path for the API.\n     * @returns A new instance of the Coinbase SDK.\n     * @throws {InvalidAPIKeyFormat} If the file does not exist or the configuration values are missing/invalid.\n     * @throws {InvalidConfiguration} If the configuration is invalid.\n     * @throws {InvalidAPIKeyFormat} If not able to create JWT token.\n     */\n    static configureFromJson({ filePath = \"coinbase_cloud_api_key.json\", useServerSigner = false, debugging = false, basePath = base_1.BASE_PATH, } = {}) {\n        filePath = filePath.startsWith(\"~\") ? filePath.replace(\"~\", os.homedir()) : filePath;\n        if (!fs.existsSync(filePath)) {\n            throw new errors_1.InvalidConfigurationError(`Invalid configuration: file not found at ${filePath}`);\n        }\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            const config = JSON.parse(data);\n            if (!config.name || !config.privateKey) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Invalid configuration: missing configuration values\");\n            }\n            return new Coinbase({\n                apiKeyName: config.name,\n                privateKey: config.privateKey,\n                useServerSigner: useServerSigner,\n                debugging: debugging,\n                basePath: basePath,\n            });\n        }\n        catch (e) {\n            if (e instanceof SyntaxError) {\n                throw new errors_1.InvalidAPIKeyFormatError(\"Not able to parse the configuration file\");\n            }\n            else {\n                throw new errors_1.InvalidAPIKeyFormatError(`An error occurred while reading the configuration file: ${e.message}`);\n            }\n        }\n    }\n    /**\n     * Converts a network symbol to a string, replacing underscores with hyphens.\n     *\n     * @param network - The network symbol to convert\n     * @returns the converted string\n     */\n    static normalizeNetwork(network) {\n        return network.replace(/_/g, \"-\");\n    }\n    /**\n     * Converts a string to a symbol, replacing hyphens with underscores.\n     *\n     * @param asset - The string to convert\n     * @returns the converted symbol\n     */\n    static toAssetId(asset) {\n        return asset.replace(/-/g, \"_\");\n    }\n}\nexports.Coinbase = Coinbase;\n/**\n * The map of supported networks to network ID. Generated from the OpenAPI spec.\n *\n * @constant\n *\n * @example\n * ```typescript\n * Coinbase.networks.BaseMainnet\n * ```\n */\nCoinbase.networks = client_1.NetworkIdentifier;\n/**\n * The list of supported assets.\n *\n * @constant\n */\nCoinbase.assets = {\n    Eth: \"eth\",\n    Wei: \"wei\",\n    Gwei: \"gwei\",\n    Usdc: \"usdc\",\n    Weth: \"weth\",\n    Sol: \"sol\",\n    Lamport: \"lamport\",\n};\nCoinbase.apiClients = {};\n/**\n * The default page limit for list methods.\n *\n * @constant\n */\nCoinbase.defaultPageLimit = 100;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvaW5iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixnQ0FBZ0MsbUJBQU8sQ0FBQyw2REFBTztBQUMvQyxzQ0FBc0MsbUJBQU8sQ0FBQyx1RUFBYTtBQUMzRCx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDLGlCQUFpQixtQkFBTyxDQUFDLG1GQUFXO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyx5RkFBa0I7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsMkdBQTJCO0FBQzNELHdCQUF3QixtQkFBTyxDQUFDLG1HQUFpQjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyx3QkFBd0IsbUJBQU8sQ0FBQyxjQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDLGdCQUFnQiwwQkFBMEI7QUFDMUM7QUFDQSxrQkFBa0IseUhBQXlIO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrR0FBa0c7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQSwrQkFBK0IscUhBQXFILElBQUk7QUFDeEo7QUFDQTtBQUNBLHFHQUFxRyxTQUFTO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxVQUFVO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvaW5iYXNlLmpzP2E5NTMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29pbmJhc2UgPSB2b2lkIDA7XG5jb25zdCBheGlvc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5jb25zdCBheGlvc19yZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJheGlvcy1yZXRyeVwiKSk7XG5jb25zdCBmcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiZnNcIikpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi4vY2xpZW50XCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIi4vLi4vY2xpZW50L2Jhc2VcIik7XG5jb25zdCBjb25maWd1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi8uLi9jbGllbnQvY29uZmlndXJhdGlvblwiKTtcbmNvbnN0IGF1dGhlbnRpY2F0b3JfMSA9IHJlcXVpcmUoXCIuL2F1dGhlbnRpY2F0b3JcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IG9zID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJvc1wiKSk7XG4vKipcbiAqIFRoZSBDb2luYmFzZSBTREsuXG4gKi9cbmNsYXNzIENvaW5iYXNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgQ29pbmJhc2UgU0RLLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgYXMgb2YgdjAuNS4wLCB1c2UgYGNvbmZpZ3VyZWAgb3IgYGNvbmZpZ3VyZUZyb21Kc29uYCBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcGlLZXlOYW1lIC0gVGhlIEFQSSBrZXkgbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IGFzc29jaWF0ZWQgd2l0aCB0aGUgQVBJIGtleS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy51c2VTZXJ2ZXJTaWduZXIgLSBXaGV0aGVyIHRvIHVzZSBhIFNlcnZlci1TaWduZXIgb3Igbm90LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlYnVnZ2luZyAtIElmIHRydWUsIGxvZ3MgQVBJIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgdG8gdGhlIGNvbnNvbGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVBhdGggLSBUaGUgYmFzZSBwYXRoIGZvciB0aGUgQVBJLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1heE5ldHdvcmtSZXRyaWVzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIG5ldHdvcmsgcmV0cmllcyBmb3IgdGhlIEFQSSBHRVQgcmVxdWVzdHMuXG4gICAgICogQHRocm93cyB7SW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcn0gSWYgdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3J9IElmIG5vdCBhYmxlIHRvIGNyZWF0ZSBKV1QgdG9rZW4uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBhcGlLZXlOYW1lLCBwcml2YXRlS2V5LCB1c2VTZXJ2ZXJTaWduZXIgPSBmYWxzZSwgZGVidWdnaW5nID0gZmFsc2UsIGJhc2VQYXRoID0gYmFzZV8xLkJBU0VfUEFUSCwgbWF4TmV0d29ya1JldHJpZXMgPSAzLCB9KSB7XG4gICAgICAgIGlmIChhcGlLZXlOYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbjogYXBpS2V5TmFtZSBpcyBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpdmF0ZUtleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IoXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb246IHByaXZhdGVLZXkgaXMgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29pbmJhc2VBdXRoZW50aWNhdG9yID0gbmV3IGF1dGhlbnRpY2F0b3JfMS5Db2luYmFzZUF1dGhlbnRpY2F0b3IoYXBpS2V5TmFtZSwgcHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uXzEuQ29uZmlndXJhdGlvbih7XG4gICAgICAgICAgICBiYXNlUGF0aDogYmFzZVBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBheGlvc0luc3RhbmNlID0gYXhpb3NfMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICAoMCwgYXhpb3NfcmV0cnlfMS5kZWZhdWx0KShheGlvc0luc3RhbmNlLCB7XG4gICAgICAgICAgICByZXRyaWVzOiBtYXhOZXR3b3JrUmV0cmllcyxcbiAgICAgICAgICAgIHJldHJ5Q29uZGl0aW9uOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVycm9yLmNvbmZpZz8ubWV0aG9kPy50b1VwcGVyQ2FzZSgpID09PSBcIkdFVFwiICYmXG4gICAgICAgICAgICAgICAgICAgIChlcnJvci5yZXNwb25zZT8uc3RhdHVzIHx8IDApIGluIFs1MDAsIDUwMiwgNTAzLCA1MDRdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAoMCwgdXRpbHNfMS5yZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzKShheGlvc0luc3RhbmNlLCBjb25maWcgPT4gY29pbmJhc2VBdXRoZW50aWNhdG9yLmF1dGhlbnRpY2F0ZVJlcXVlc3QoY29uZmlnLCBkZWJ1Z2dpbmcpLCBcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGZpbGUgKi9cbiAgICAgICAgcmVzcG9uc2UgPT4gKDAsIHV0aWxzXzEubG9nQXBpUmVzcG9uc2UpKHJlc3BvbnNlLCBkZWJ1Z2dpbmcpKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQgPSAoMCwgY2xpZW50XzEuV2FsbGV0c0FwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MgPSAoMCwgY2xpZW50XzEuQWRkcmVzc2VzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNmZXIgPSAoMCwgY2xpZW50XzEuVHJhbnNmZXJzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudHJhZGUgPSAoMCwgY2xpZW50XzEuVHJhZGVzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuc2VydmVyU2lnbmVyID0gKDAsIGNsaWVudF8xLlNlcnZlclNpZ25lcnNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZSA9ICgwLCBjbGllbnRfMS5TdGFrZUFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLndhbGxldFN0YWtlID0gKDAsIGNsaWVudF8xLldhbGxldFN0YWtlQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudmFsaWRhdG9yID0gKDAsIGNsaWVudF8xLlZhbGlkYXRvcnNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5hc3NldCA9ICgwLCBjbGllbnRfMS5Bc3NldHNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rID0gKDAsIGNsaWVudF8xLldlYmhvb2tzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMuY29udHJhY3RJbnZvY2F0aW9uID0gKDAsIGNsaWVudF8xLkNvbnRyYWN0SW52b2NhdGlvbnNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MgPSAoMCwgY2xpZW50XzEuRXh0ZXJuYWxBZGRyZXNzZXNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5iYWxhbmNlSGlzdG9yeSA9ICgwLCBjbGllbnRfMS5CYWxhbmNlSGlzdG9yeUFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0RXZlbnQgPSAoMCwgY2xpZW50XzEuQ29udHJhY3RFdmVudHNBcGlGYWN0b3J5KShjb25maWcsIGJhc2VQYXRoLCBheGlvc0luc3RhbmNlKTtcbiAgICAgICAgQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0ID0gKDAsIGNsaWVudF8xLlNtYXJ0Q29udHJhY3RzQXBpRmFjdG9yeSkoY29uZmlnLCBiYXNlUGF0aCwgYXhpb3NJbnN0YW5jZSk7XG4gICAgICAgIENvaW5iYXNlLmFwaUNsaWVudHMudHJhbnNhY3Rpb25IaXN0b3J5ID0gKDAsIGNsaWVudF8xLlRyYW5zYWN0aW9uSGlzdG9yeUFwaUZhY3RvcnkpKGNvbmZpZywgYmFzZVBhdGgsIGF4aW9zSW5zdGFuY2UpO1xuICAgICAgICBDb2luYmFzZS5hcGlLZXlQcml2YXRlS2V5ID0gcHJpdmF0ZUtleTtcbiAgICAgICAgQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyID0gdXNlU2VydmVyU2lnbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoZSBDb2luYmFzZSBTREsgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcGlLZXlOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEFQSSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSBhc3NvY2lhdGVkIHdpdGggdGhlIEFQSSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXNlU2VydmVyU2lnbmVyIC0gV2hldGhlciB0byB1c2UgYSBTZXJ2ZXItU2lnbmVyIG9yIG5vdC4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVidWdnaW5nIC0gSWYgdHJ1ZSwgbG9ncyBBUEkgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byB0aGUgY29uc29sZS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVBhdGggLSBUaGUgYmFzZSBwYXRoIGZvciB0aGUgQVBJLiBEZWZhdWx0cyB0byBCQVNFX1BBVEguXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvaW5iYXNlIFNESy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29uZmlndXJlKHsgYXBpS2V5TmFtZSwgcHJpdmF0ZUtleSwgdXNlU2VydmVyU2lnbmVyID0gZmFsc2UsIGRlYnVnZ2luZyA9IGZhbHNlLCBiYXNlUGF0aCA9IGJhc2VfMS5CQVNFX1BBVEgsIH0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2luYmFzZSh7XG4gICAgICAgICAgICBhcGlLZXlOYW1lLFxuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIHVzZVNlcnZlclNpZ25lcixcbiAgICAgICAgICAgIGRlYnVnZ2luZyxcbiAgICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIEFQSSBrZXkgYW5kIHByaXZhdGUga2V5IGZyb20gYSBKU09OIGZpbGUgYW5kIGluaXRpYWxpemVzIHRoZSBDb2luYmFzZSBTREsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsZVBhdGggLSBUaGUgcGF0aCB0byB0aGUgSlNPTiBmaWxlIGNvbnRhaW5pbmcgdGhlIEFQSSBrZXkgYW5kIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVzZVNlcnZlclNpZ25lciAtIFdoZXRoZXIgdG8gdXNlIGEgU2VydmVyLVNpZ25lciBvciBub3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVidWdnaW5nIC0gSWYgdHJ1ZSwgbG9ncyBBUEkgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byB0aGUgY29uc29sZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5iYXNlUGF0aCAtIFRoZSBiYXNlIHBhdGggZm9yIHRoZSBBUEkuXG4gICAgICogQHJldHVybnMgQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvaW5iYXNlIFNESy5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0fSBJZiB0aGUgZmlsZSBkb2VzIG5vdCBleGlzdCBvciB0aGUgY29uZmlndXJhdGlvbiB2YWx1ZXMgYXJlIG1pc3NpbmcvaW52YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQ29uZmlndXJhdGlvbn0gSWYgdGhlIGNvbmZpZ3VyYXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkQVBJS2V5Rm9ybWF0fSBJZiBub3QgYWJsZSB0byBjcmVhdGUgSldUIHRva2VuLlxuICAgICAqL1xuICAgIHN0YXRpYyBjb25maWd1cmVGcm9tSnNvbih7IGZpbGVQYXRoID0gXCJjb2luYmFzZV9jbG91ZF9hcGlfa2V5Lmpzb25cIiwgdXNlU2VydmVyU2lnbmVyID0gZmFsc2UsIGRlYnVnZ2luZyA9IGZhbHNlLCBiYXNlUGF0aCA9IGJhc2VfMS5CQVNFX1BBVEgsIH0gPSB7fSkge1xuICAgICAgICBmaWxlUGF0aCA9IGZpbGVQYXRoLnN0YXJ0c1dpdGgoXCJ+XCIpID8gZmlsZVBhdGgucmVwbGFjZShcIn5cIiwgb3MuaG9tZWRpcigpKSA6IGZpbGVQYXRoO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcihgSW52YWxpZCBjb25maWd1cmF0aW9uOiBmaWxlIG5vdCBmb3VuZCBhdCAke2ZpbGVQYXRofWApO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBcInV0ZjhcIik7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKCFjb25maWcubmFtZSB8fCAhY29uZmlnLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uOiBtaXNzaW5nIGNvbmZpZ3VyYXRpb24gdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2luYmFzZSh7XG4gICAgICAgICAgICAgICAgYXBpS2V5TmFtZTogY29uZmlnLm5hbWUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogY29uZmlnLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgdXNlU2VydmVyU2lnbmVyOiB1c2VTZXJ2ZXJTaWduZXIsXG4gICAgICAgICAgICAgICAgZGVidWdnaW5nOiBkZWJ1Z2dpbmcsXG4gICAgICAgICAgICAgICAgYmFzZVBhdGg6IGJhc2VQYXRoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKFwiTm90IGFibGUgdG8gcGFyc2UgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlYWRpbmcgdGhlIGNvbmZpZ3VyYXRpb24gZmlsZTogJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBuZXR3b3JrIHN5bWJvbCB0byBhIHN0cmluZywgcmVwbGFjaW5nIHVuZGVyc2NvcmVzIHdpdGggaHlwaGVucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrIC0gVGhlIG5ldHdvcmsgc3ltYm9sIHRvIGNvbnZlcnRcbiAgICAgKiBAcmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBub3JtYWxpemVOZXR3b3JrKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldHdvcmsucmVwbGFjZSgvXy9nLCBcIi1cIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgc3ltYm9sLCByZXBsYWNpbmcgaHlwaGVucyB3aXRoIHVuZGVyc2NvcmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0IC0gVGhlIHN0cmluZyB0byBjb252ZXJ0XG4gICAgICogQHJldHVybnMgdGhlIGNvbnZlcnRlZCBzeW1ib2xcbiAgICAgKi9cbiAgICBzdGF0aWMgdG9Bc3NldElkKGFzc2V0KSB7XG4gICAgICAgIHJldHVybiBhc3NldC5yZXBsYWNlKC8tL2csIFwiX1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkNvaW5iYXNlID0gQ29pbmJhc2U7XG4vKipcbiAqIFRoZSBtYXAgb2Ygc3VwcG9ydGVkIG5ldHdvcmtzIHRvIG5ldHdvcmsgSUQuIEdlbmVyYXRlZCBmcm9tIHRoZSBPcGVuQVBJIHNwZWMuXG4gKlxuICogQGNvbnN0YW50XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIENvaW5iYXNlLm5ldHdvcmtzLkJhc2VNYWlubmV0XG4gKiBgYGBcbiAqL1xuQ29pbmJhc2UubmV0d29ya3MgPSBjbGllbnRfMS5OZXR3b3JrSWRlbnRpZmllcjtcbi8qKlxuICogVGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIGFzc2V0cy5cbiAqXG4gKiBAY29uc3RhbnRcbiAqL1xuQ29pbmJhc2UuYXNzZXRzID0ge1xuICAgIEV0aDogXCJldGhcIixcbiAgICBXZWk6IFwid2VpXCIsXG4gICAgR3dlaTogXCJnd2VpXCIsXG4gICAgVXNkYzogXCJ1c2RjXCIsXG4gICAgV2V0aDogXCJ3ZXRoXCIsXG4gICAgU29sOiBcInNvbFwiLFxuICAgIExhbXBvcnQ6IFwibGFtcG9ydFwiLFxufTtcbkNvaW5iYXNlLmFwaUNsaWVudHMgPSB7fTtcbi8qKlxuICogVGhlIGRlZmF1bHQgcGFnZSBsaW1pdCBmb3IgbGlzdCBtZXRob2RzLlxuICpcbiAqIEBjb25zdGFudFxuICovXG5Db2luYmFzZS5kZWZhdWx0UGFnZUxpbWl0ID0gMTAwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.GWEI_DECIMALS = void 0;\nexports.GWEI_DECIMALS = 9;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9jb25zdGFudHMuanM/YWU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR1dFSV9ERUNJTUFMUyA9IHZvaWQgMDtcbmV4cG9ydHMuR1dFSV9ERUNJTUFMUyA9IDk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractEvent = void 0;\n/**\n * A representation of a single contract event.\n */\nclass ContractEvent {\n    /**\n     * Creates the ContractEvent object.\n     *\n     * @param model - The underlying contract event object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns the network ID of the ContractEvent.\n     *\n     * @returns The network ID.\n     */\n    networkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the protocol name of the ContractEvent.\n     *\n     * @returns The protocol name.\n     */\n    protocolName() {\n        return this.model.protocol_name;\n    }\n    /**\n     * Returns the contract name of the ContractEvent.\n     *\n     * @returns The contract name.\n     */\n    contractName() {\n        return this.model.contract_name;\n    }\n    /**\n     * Returns the event name of the ContractEvent.\n     *\n     * @returns The event name.\n     */\n    eventName() {\n        return this.model.event_name;\n    }\n    /**\n     * Returns the signature of the ContractEvent.\n     *\n     * @returns The event signature.\n     */\n    sig() {\n        return this.model.sig;\n    }\n    /**\n     * Returns the four bytes of the Keccak hash of the event signature.\n     *\n     * @returns The four bytes of the event signature hash.\n     */\n    fourBytes() {\n        return this.model.four_bytes;\n    }\n    /**\n     * Returns the contract address of the ContractEvent.\n     *\n     * @returns The contract address.\n     */\n    contractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the block time of the ContractEvent.\n     *\n     * @returns The block time.\n     */\n    blockTime() {\n        return new Date(this.model.block_time);\n    }\n    /**\n     * Returns the block height of the ContractEvent.\n     *\n     * @returns The block height.\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the transaction hash of the ContractEvent.\n     *\n     * @returns The transaction hash.\n     */\n    txHash() {\n        return this.model.tx_hash;\n    }\n    /**\n     * Returns the transaction index of the ContractEvent.\n     *\n     * @returns The transaction index.\n     */\n    txIndex() {\n        return this.model.tx_index;\n    }\n    /**\n     * Returns the event index of the ContractEvent.\n     *\n     * @returns The event index.\n     */\n    eventIndex() {\n        return this.model.event_index;\n    }\n    /**\n     * Returns the event data of the ContractEvent.\n     *\n     * @returns The event data.\n     */\n    data() {\n        return this.model.data;\n    }\n    /**\n     * Print the ContractEvent as a string.\n     *\n     * @returns The string representation of the ContractEvent.\n     */\n    toString() {\n        return `ContractEvent { networkId: '${this.networkId()}' protocolName: '${this.protocolName()}' contractName: '${this.contractName()}' eventName: '${this.eventName()}' contractAddress: '${this.contractAddress()}' blockHeight: ${this.blockHeight()} txHash: '${this.txHash()}' }`;\n    }\n}\nexports.ContractEvent = ContractEvent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGNBQWMsaUJBQWlCLG1CQUFtQixvQkFBb0IsbUJBQW1CLG9CQUFvQixnQkFBZ0IsaUJBQWlCLHNCQUFzQix1QkFBdUIsaUJBQWlCLG9CQUFvQixXQUFXLGNBQWMsR0FBRztBQUM1UjtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9jb250cmFjdF9ldmVudC5qcz9lYjUzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cmFjdEV2ZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGNvbnRyYWN0IGV2ZW50LlxuICovXG5jbGFzcyBDb250cmFjdEV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBDb250cmFjdEV2ZW50IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtb2RlbCAtIFRoZSB1bmRlcmx5aW5nIGNvbnRyYWN0IGV2ZW50IG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBuZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3RvY29sIG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvdG9jb2wgbmFtZS5cbiAgICAgKi9cbiAgICBwcm90b2NvbE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnByb3RvY29sX25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyYWN0IG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJhY3QgbmFtZS5cbiAgICAgKi9cbiAgICBjb250cmFjdE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRyYWN0X25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IG5hbWUgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBldmVudE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmV2ZW50X25hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNpZ25hdHVyZSBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICovXG4gICAgc2lnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZvdXIgYnl0ZXMgb2YgdGhlIEtlY2NhayBoYXNoIG9mIHRoZSBldmVudCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZm91ciBieXRlcyBvZiB0aGUgZXZlbnQgc2lnbmF0dXJlIGhhc2guXG4gICAgICovXG4gICAgZm91ckJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mb3VyX2J5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICovXG4gICAgY29udHJhY3RBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBibG9jayB0aW1lIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIHRpbWUuXG4gICAgICovXG4gICAgYmxvY2tUaW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy5tb2RlbC5ibG9ja190aW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmxvY2sgaGVpZ2h0IG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIGhlaWdodC5cbiAgICAgKi9cbiAgICBibG9ja0hlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYmxvY2tfaGVpZ2h0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBDb250cmFjdEV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgdHhIYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50eF9oYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBpbmRleCBvZiB0aGUgQ29udHJhY3RFdmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0cmFuc2FjdGlvbiBpbmRleC5cbiAgICAgKi9cbiAgICB0eEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50eF9pbmRleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgaW5kZXggb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgaW5kZXguXG4gICAgICovXG4gICAgZXZlbnRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZXZlbnRfaW5kZXg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGV2ZW50IGRhdGEgb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZXZlbnQgZGF0YS5cbiAgICAgKi9cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludCB0aGUgQ29udHJhY3RFdmVudCBhcyBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIENvbnRyYWN0RXZlbnQuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ29udHJhY3RFdmVudCB7IG5ldHdvcmtJZDogJyR7dGhpcy5uZXR3b3JrSWQoKX0nIHByb3RvY29sTmFtZTogJyR7dGhpcy5wcm90b2NvbE5hbWUoKX0nIGNvbnRyYWN0TmFtZTogJyR7dGhpcy5jb250cmFjdE5hbWUoKX0nIGV2ZW50TmFtZTogJyR7dGhpcy5ldmVudE5hbWUoKX0nIGNvbnRyYWN0QWRkcmVzczogJyR7dGhpcy5jb250cmFjdEFkZHJlc3MoKX0nIGJsb2NrSGVpZ2h0OiAke3RoaXMuYmxvY2tIZWlnaHQoKX0gdHhIYXNoOiAnJHt0aGlzLnR4SGFzaCgpfScgfWA7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFjdEV2ZW50ID0gQ29udHJhY3RFdmVudDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ContractInvocation = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a ContractInvocation, which calls a smart contract method\n * onchain. The fee is assumed to be paid in the native Asset of the Network.\n */\nclass ContractInvocation {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param contractInvocationModel - The ContractInvocation model.\n     * @hideconstructor\n     */\n    constructor(contractInvocationModel) {\n        if (!contractInvocationModel) {\n            throw new Error(\"ContractInvocation model cannot be empty\");\n        }\n        this.model = contractInvocationModel;\n    }\n    /**\n     * Converts a ContractInvocationModel into a ContractInvocation object.\n     *\n     * @param contractInvocationModel - The ContractInvocation model object.\n     * @returns The ContractInvocation object.\n     */\n    static fromModel(contractInvocationModel) {\n        return new ContractInvocation(contractInvocationModel);\n    }\n    /**\n     * Returns the ID of the ContractInvocation.\n     *\n     * @returns The ContractInvocation ID.\n     */\n    getId() {\n        return this.model.contract_invocation_id;\n    }\n    /**\n     * Returns the Network ID of the ContractInvocation.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the ContractInvocation.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the ContractInvocation.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the ContractInvocation.\n     *\n     * @returns The Destination Address ID.\n     */\n    getContractAddressId() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Method of the ContractInvocation.\n     *\n     * @returns The Method.\n     */\n    getMethod() {\n        return this.model.method;\n    }\n    /**\n     * Returns the Arguments of the ContractInvocation.\n     *\n     * @returns {object} The arguments object passed to the contract invocation.\n     * The key is the argument name and the value is the argument value.\n     */\n    getArgs() {\n        return JSON.parse(this.model.args);\n    }\n    /**\n     * Returns the ABI of the ContractInvocation, if specified.\n     *\n     * @returns The ABI as an object, or undefined if not available.\n     */\n    getAbi() {\n        if (!this.model.abi)\n            return undefined;\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the amount of the native asset sent to a payable contract method, if applicable.\n     *\n     * @returns The amount in atomic units of the native asset.\n     */\n    getAmount() {\n        return new decimal_js_1.Decimal(this.model.amount);\n    }\n    /**\n     * Returns the Transaction Hash of the ContractInvocation.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getTransaction().getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the ContractInvocation with the provided key and returns the hex signature\n     * required for broadcasting the ContractInvocation.\n     *\n     * @param key - The key to sign the ContractInvocation with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Returns the Status of the ContractInvocation.\n     *\n     * @returns The Status of the ContractInvocation.\n     */\n    getStatus() {\n        return this.getTransaction().getStatus();\n    }\n    /**\n     * Returns the Transaction of the ContractInvocation.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getTransaction().getTransactionLink();\n    }\n    /**\n     * Broadcasts the ContractInvocation to the Network.\n     *\n     * @returns The ContractInvocation object\n     * @throws {APIError} if the API request to broadcast a ContractInvocation fails.\n     */\n    async broadcast() {\n        if (!this.getTransaction()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned ContractInvocation\");\n        const broadcastContractInvocationRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.contractInvocation.broadcastContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastContractInvocationRequest);\n        return ContractInvocation.fromModel(response.data);\n    }\n    /**\n     * Waits for the ContractInvocation to be confirmed on the Network or fail on chain.\n     * Waits until the ContractInvocation is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the ContractInvocation takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the ContractInvocation.\n     * @param options.timeoutSeconds - The maximum time to wait for the ContractInvocation to be confirmed.\n     *\n     * @returns The ContractInvocation object in a terminal state.\n     * @throws {Error} if the ContractInvocation times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the ContractInvocation is in a terminal state, return the ContractInvocation.\n            const status = this.getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"ContractInvocation timed out\");\n    }\n    /**\n     * Reloads the ContractInvocation model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a ContractInvocation fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.contractInvocation.getContractInvocation(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the ContractInvocation.\n     *\n     * @returns The string representation of the ContractInvocation.\n     */\n    toString() {\n        return (`ContractInvocation{contractInvocationId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', contractAddressId: '${this.getContractAddressId()}', ` +\n            `method: '${this.getMethod()}', args: '${this.getArgs()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.ContractInvocation = ContractInvocation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFZO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLCtGQUFlO0FBQzdDLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHFGQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLGlCQUFpQiw4Q0FBOEMsSUFBSTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlCQUF5QixhQUFhLGlCQUFpQixvQkFBb0I7QUFDL0csK0JBQStCLHdCQUF3Qix5QkFBeUIsNEJBQTRCO0FBQzVHLHdCQUF3QixpQkFBaUIsWUFBWSxlQUFlLHVCQUF1QiwwQkFBMEI7QUFDckgsaUNBQWlDLDBCQUEwQixjQUFjLGlCQUFpQixFQUFFO0FBQzVGO0FBQ0E7QUFDQSwwQkFBMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb24uanM/Zjk5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29udHJhY3RJbnZvY2F0aW9uID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gcmVxdWlyZShcImRlY2ltYWwuanNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIENvbnRyYWN0SW52b2NhdGlvbiwgd2hpY2ggY2FsbHMgYSBzbWFydCBjb250cmFjdCBtZXRob2RcbiAqIG9uY2hhaW4uIFRoZSBmZWUgaXMgYXNzdW1lZCB0byBiZSBwYWlkIGluIHRoZSBuYXRpdmUgQXNzZXQgb2YgdGhlIE5ldHdvcmsuXG4gKi9cbmNsYXNzIENvbnRyYWN0SW52b2NhdGlvbiB7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciB0byBwcmV2ZW50IGRpcmVjdCBpbnN0YW50aWF0aW9uIG91dHNpZGUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0gY29udHJhY3RJbnZvY2F0aW9uTW9kZWwgLSBUaGUgQ29udHJhY3RJbnZvY2F0aW9uIG1vZGVsLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdEludm9jYXRpb25Nb2RlbCkge1xuICAgICAgICBpZiAoIWNvbnRyYWN0SW52b2NhdGlvbk1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cmFjdEludm9jYXRpb24gbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBjb250cmFjdEludm9jYXRpb25Nb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBDb250cmFjdEludm9jYXRpb25Nb2RlbCBpbnRvIGEgQ29udHJhY3RJbnZvY2F0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEludm9jYXRpb25Nb2RlbCAtIFRoZSBDb250cmFjdEludm9jYXRpb24gbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwoY29udHJhY3RJbnZvY2F0aW9uTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdEludm9jYXRpb24oY29udHJhY3RJbnZvY2F0aW9uTW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udHJhY3RfaW52b2NhdGlvbl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSUQuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRnJvbSBBZGRyZXNzIElEIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRnJvbSBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldEZyb21BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIERlc3RpbmF0aW9uIEFkZHJlc3MgSUQgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldENvbnRyYWN0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5jb250cmFjdF9hZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBNZXRob2Qgb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBNZXRob2QuXG4gICAgICovXG4gICAgZ2V0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5tZXRob2Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFyZ3VtZW50cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIGFyZ3VtZW50cyBvYmplY3QgcGFzc2VkIHRvIHRoZSBjb250cmFjdCBpbnZvY2F0aW9uLlxuICAgICAqIFRoZSBrZXkgaXMgdGhlIGFyZ3VtZW50IG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgYXJndW1lbnQgdmFsdWUuXG4gICAgICovXG4gICAgZ2V0QXJncygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5tb2RlbC5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQUJJIG9mIHRoZSBDb250cmFjdEludm9jYXRpb24sIGlmIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBQkkgYXMgYW4gb2JqZWN0LCBvciB1bmRlZmluZWQgaWYgbm90IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBnZXRBYmkoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5hYmkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh0aGlzLm1vZGVsLmFiaSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiB0aGUgbmF0aXZlIGFzc2V0IHNlbnQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZCwgaWYgYXBwbGljYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgaW4gYXRvbWljIHVuaXRzIG9mIHRoZSBuYXRpdmUgYXNzZXQuXG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwuYW1vdW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gSGFzaCBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2ggYXMgYSBIZXggc3RyaW5nLCBvciB1bmRlZmluZWQgaWYgbm90IHlldCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFRyYW5zYWN0aW9uSGFzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV0aGVycy5qcyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyAoSW52YWxpZFVuc2lnbmVkUGF5bG9hZCkgSWYgdGhlIFVuc2lnbmVkIFBheWxvYWQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBnZXRSYXdUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5yYXdUcmFuc2FjdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZVxuICAgICAqIHJlcXVpcmVkIGZvciBicm9hZGNhc3RpbmcgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIENvbnRyYWN0SW52b2NhdGlvbiB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25lZCBwYXlsb2FkXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIENvbnRyYWN0SW52b2NhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5nZXRUcmFuc2FjdGlvbkxpbmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvYWRjYXN0cyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIENvbnRyYWN0SW52b2NhdGlvbiBvYmplY3RcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGJyb2FkY2FzdCBhIENvbnRyYWN0SW52b2NhdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBicm9hZGNhc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRUcmFuc2FjdGlvbigpPy5pc1NpZ25lZCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGJyb2FkY2FzdCB1bnNpZ25lZCBDb250cmFjdEludm9jYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdENvbnRyYWN0SW52b2NhdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICBzaWduZWRfcGF5bG9hZDogdGhpcy5nZXRUcmFuc2FjdGlvbigpLmdldFNpZ25hdHVyZSgpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEludm9jYXRpb24uYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSwgYnJvYWRjYXN0Q29udHJhY3RJbnZvY2F0aW9uUmVxdWVzdCk7XG4gICAgICAgIHJldHVybiBDb250cmFjdEludm9jYXRpb24uZnJvbU1vZGVsKHJlc3BvbnNlLmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyBmb3IgdGhlIENvbnRyYWN0SW52b2NhdGlvbiB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgb24tY2hhaW4gYnkgcG9sbGluZyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBDb250cmFjdEludm9jYXRpb24gdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBDb250cmFjdEludm9jYXRpb24gdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB3aGlsZSAoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSA8IHRpbWVvdXRTZWNvbmRzICogMTAwMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWxvYWQoKTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBDb250cmFjdEludm9jYXRpb24gaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBDb250cmFjdEludm9jYXRpb24uXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURSB8fCBzdGF0dXMgPT09IHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiQ29udHJhY3RJbnZvY2F0aW9uIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgQ29udHJhY3RJbnZvY2F0aW9uIG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgQ29udHJhY3RJbnZvY2F0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmNvbnRyYWN0SW52b2NhdGlvbi5nZXRDb250cmFjdEludm9jYXRpb24odGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEZyb21BZGRyZXNzSWQoKSwgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHJlc3VsdD8uZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29udHJhY3RJbnZvY2F0aW9uLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKGBDb250cmFjdEludm9jYXRpb257Y29udHJhY3RJbnZvY2F0aW9uSWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JywgYCArXG4gICAgICAgICAgICBgZnJvbUFkZHJlc3NJZDogJyR7dGhpcy5nZXRGcm9tQWRkcmVzc0lkKCl9JywgY29udHJhY3RBZGRyZXNzSWQ6ICcke3RoaXMuZ2V0Q29udHJhY3RBZGRyZXNzSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBtZXRob2Q6ICcke3RoaXMuZ2V0TWV0aG9kKCl9JywgYXJnczogJyR7dGhpcy5nZXRBcmdzKCl9JywgdHJhbnNhY3Rpb25IYXNoOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpfScsIGAgK1xuICAgICAgICAgICAgYHRyYW5zYWN0aW9uTGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9J31gKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYWN0SW52b2NhdGlvbiA9IENvbnRyYWN0SW52b2NhdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AlreadySignedError = exports.NotSignedError = exports.InvalidUnsignedPayloadError = exports.InvalidConfigurationError = exports.ArgumentError = exports.TimeoutError = exports.InvalidAPIKeyFormatError = void 0;\n/**\n * InvalidAPIKeyFormatError error is thrown when the API key format is invalid.\n */\nclass InvalidAPIKeyFormatError extends Error {\n    /**\n     * Initializes a new InvalidAPIKeyFormat instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidAPIKeyFormatError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidAPIKeyFormatError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidAPIKeyFormatError);\n        }\n    }\n}\nexports.InvalidAPIKeyFormatError = InvalidAPIKeyFormatError;\nInvalidAPIKeyFormatError.DEFAULT_MESSAGE = \"Invalid API key format\";\n/**\n * TimeoutError is thrown when an operation times out.\n */\nclass TimeoutError extends Error {\n    /**\n     * Initializes a new TimeoutError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Timeout Error\") {\n        super(message);\n        this.name = \"TimeoutError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, TimeoutError);\n        }\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\n * ArgumentError is thrown when an argument is invalid.\n */\nclass ArgumentError extends Error {\n    /**\n     * Initializes a new ArgumentError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = ArgumentError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"ArgumentError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ArgumentError);\n        }\n    }\n}\nexports.ArgumentError = ArgumentError;\nArgumentError.DEFAULT_MESSAGE = \"Argument Error\";\n/**\n * InvalidConfigurationError error is thrown when apikey/privateKey configuration is invalid.\n */\nclass InvalidConfigurationError extends Error {\n    /**\n     * Initializes a new InvalidConfiguration instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidConfigurationError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidConfigurationError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidConfigurationError);\n        }\n    }\n}\nexports.InvalidConfigurationError = InvalidConfigurationError;\nInvalidConfigurationError.DEFAULT_MESSAGE = \"Invalid configuration\";\n/**\n * InvalidUnsignedPayload error is thrown when the unsigned payload is invalid.\n */\nclass InvalidUnsignedPayloadError extends Error {\n    /**\n     * Initializes a new InvalidUnsignedPayload instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = InvalidUnsignedPayloadError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"InvalidUnsignedPayloadError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, InvalidUnsignedPayloadError);\n        }\n    }\n}\nexports.InvalidUnsignedPayloadError = InvalidUnsignedPayloadError;\nInvalidUnsignedPayloadError.DEFAULT_MESSAGE = \"Invalid unsigned payload\";\n/**\n * NotSignedError is thrown when a resource is not signed.\n */\nclass NotSignedError extends Error {\n    /**\n     * Initializes a new NotSignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = \"Resource not signed\") {\n        super(message);\n        this.name = \"NotSignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, NotSignedError);\n        }\n    }\n}\nexports.NotSignedError = NotSignedError;\n/**\n * AlreadySignedError is thrown when a resource is already signed.\n */\nclass AlreadySignedError extends Error {\n    /**\n     * Initializes a new AlreadySignedError instance.\n     *\n     * @param message - The error message.\n     */\n    constructor(message = AlreadySignedError.DEFAULT_MESSAGE) {\n        super(message);\n        this.name = \"AlreadySignedError\";\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, AlreadySignedError);\n        }\n    }\n}\nexports.AlreadySignedError = AlreadySignedError;\nAlreadySignedError.DEFAULT_MESSAGE = \"Resource already signed\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxtQ0FBbUMsR0FBRyxpQ0FBaUMsR0FBRyxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRyxnQ0FBZ0M7QUFDL007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9lcnJvcnMuanM/NzYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWxyZWFkeVNpZ25lZEVycm9yID0gZXhwb3J0cy5Ob3RTaWduZWRFcnJvciA9IGV4cG9ydHMuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yID0gZXhwb3J0cy5Bcmd1bWVudEVycm9yID0gZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBleHBvcnRzLkludmFsaWRBUElLZXlGb3JtYXRFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogSW52YWxpZEFQSUtleUZvcm1hdEVycm9yIGVycm9yIGlzIHRocm93biB3aGVuIHRoZSBBUEkga2V5IGZvcm1hdCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkQVBJS2V5Rm9ybWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSW52YWxpZEFQSUtleUZvcm1hdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEludmFsaWRBUElLZXlGb3JtYXRFcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZEFQSUtleUZvcm1hdEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZEFQSUtleUZvcm1hdEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yID0gSW52YWxpZEFQSUtleUZvcm1hdEVycm9yO1xuSW52YWxpZEFQSUtleUZvcm1hdEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiSW52YWxpZCBBUEkga2V5IGZvcm1hdFwiO1xuLyoqXG4gKiBUaW1lb3V0RXJyb3IgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIHRpbWVzIG91dC5cbiAqL1xuY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IFRpbWVvdXRFcnJvciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IFwiVGltZW91dCBFcnJvclwiKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRpbWVvdXRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbi8qKlxuICogQXJndW1lbnRFcnJvciBpcyB0aHJvd24gd2hlbiBhbiBhcmd1bWVudCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBBcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEFyZ3VtZW50RXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBBcmd1bWVudEVycm9yLkRFRkFVTFRfTUVTU0FHRSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBcmd1bWVudEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXJndW1lbnRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFyZ3VtZW50RXJyb3IgPSBBcmd1bWVudEVycm9yO1xuQXJndW1lbnRFcnJvci5ERUZBVUxUX01FU1NBR0UgPSBcIkFyZ3VtZW50IEVycm9yXCI7XG4vKipcbiAqIEludmFsaWRDb25maWd1cmF0aW9uRXJyb3IgZXJyb3IgaXMgdGhyb3duIHdoZW4gYXBpa2V5L3ByaXZhdGVLZXkgY29uZmlndXJhdGlvbiBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGEgbmV3IEludmFsaWRDb25maWd1cmF0aW9uIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludmFsaWRDb25maWd1cmF0aW9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ29uZmlndXJhdGlvbkVycm9yID0gSW52YWxpZENvbmZpZ3VyYXRpb25FcnJvcjtcbkludmFsaWRDb25maWd1cmF0aW9uRXJyb3IuREVGQVVMVF9NRVNTQUdFID0gXCJJbnZhbGlkIGNvbmZpZ3VyYXRpb25cIjtcbi8qKlxuICogSW52YWxpZFVuc2lnbmVkUGF5bG9hZCBlcnJvciBpcyB0aHJvd24gd2hlbiB0aGUgdW5zaWduZWQgcGF5bG9hZCBpcyBpbnZhbGlkLlxuICovXG5jbGFzcyBJbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgSW52YWxpZFVuc2lnbmVkUGF5bG9hZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gVGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSA9IEludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvci5ERUZBVUxUX01FU1NBR0UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yXCI7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yID0gSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yO1xuSW52YWxpZFVuc2lnbmVkUGF5bG9hZEVycm9yLkRFRkFVTFRfTUVTU0FHRSA9IFwiSW52YWxpZCB1bnNpZ25lZCBwYXlsb2FkXCI7XG4vKipcbiAqIE5vdFNpZ25lZEVycm9yIGlzIHRocm93biB3aGVuIGEgcmVzb3VyY2UgaXMgbm90IHNpZ25lZC5cbiAqL1xuY2xhc3MgTm90U2lnbmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgTm90U2lnbmVkRXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBcIlJlc291cmNlIG5vdCBzaWduZWRcIikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb3RTaWduZWRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIE5vdFNpZ25lZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuTm90U2lnbmVkRXJyb3IgPSBOb3RTaWduZWRFcnJvcjtcbi8qKlxuICogQWxyZWFkeVNpZ25lZEVycm9yIGlzIHRocm93biB3aGVuIGEgcmVzb3VyY2UgaXMgYWxyZWFkeSBzaWduZWQuXG4gKi9cbmNsYXNzIEFscmVhZHlTaWduZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBBbHJlYWR5U2lnbmVkRXJyb3IgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSBBbHJlYWR5U2lnbmVkRXJyb3IuREVGQVVMVF9NRVNTQUdFKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkFscmVhZHlTaWduZWRFcnJvclwiO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEFscmVhZHlTaWduZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFscmVhZHlTaWduZWRFcnJvciA9IEFscmVhZHlTaWduZWRFcnJvcjtcbkFscmVhZHlTaWduZWRFcnJvci5ERUZBVUxUX01FU1NBR0UgPSBcIlJlc291cmNlIGFscmVhZHkgc2lnbmVkXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FaucetTransaction = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Represents a transaction from a faucet.\n */\nclass FaucetTransaction {\n    /**\n     * Creates a new FaucetTransaction instance.\n     * Do not use this method directly - instead, use Address.faucet().\n     *\n     * @class\n     * @param {FaucetTransactionModel} model - The FaucetTransaction model.\n     * @throws {Error} If the model does not exist.\n     */\n    constructor(model) {\n        if (!model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this.model = model;\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Transaction of the FaucetTransaction.\n     *\n     * @returns The Faucet Transaction\n     */\n    get transaction() {\n        return this._transaction;\n    }\n    /**\n     * Returns the transaction hash.\n     *\n     * @returns {string} The transaction hash.\n     */\n    getTransactionHash() {\n        return this.transaction.getTransactionHash();\n    }\n    /**\n     * Returns the link to the transaction on the blockchain explorer.\n     *\n     * @returns {string} The link to the transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.transaction.getTransactionLink();\n    }\n    /**\n     * Returns the Status of the FaucetTransaction.\n     *\n     * @returns The Status of the FaucetTransaction.\n     */\n    getStatus() {\n        return this.transaction.getStatus();\n    }\n    /**\n     * Returns the network ID of the FaucetTransaction.\n     *\n     * @returns {string} The network ID.\n     */\n    getNetworkId() {\n        return this.transaction.getNetworkId();\n    }\n    /**\n     * Returns the address that is being funded by the faucet.\n     *\n     * @returns {string} The address ID.\n     */\n    getAddressId() {\n        return this.transaction.toAddressId();\n    }\n    /**\n     * Waits for the FaucetTransaction to be confirmed on the Network or fail on chain.\n     * Waits until the FaucetTransaction is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the FaucetTransaction takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the FaucetTransaction.\n     * @param options.timeoutSeconds - The maximum time to wait for the FaucetTransaction to be confirmed.\n     *\n     * @returns The FaucetTransaction object in a terminal state.\n     * @throws {Error} if the FaucetTransaction times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the FaucetTransaction is in a terminal state, return the FaucetTransaction.\n            if (this.transaction.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"FaucetTransaction timed out\");\n    }\n    /**\n     * Reloads the FaucetTransaction model with the latest data from the server.\n     *\n     * @returns {FaucetTransaction} The reloaded FaucetTransaction object.\n     * @throws {APIError} if the API request to get a FaucetTransaction fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.externalAddress.getFaucetTransaction(this.transaction.getNetworkId(), this.getAddressId(), this.getTransactionHash());\n        this.model = result?.data;\n        if (!this.model?.transaction) {\n            throw new Error(\"FaucetTransaction model cannot be empty\");\n        }\n        this._transaction = new transaction_1.Transaction(this.model.transaction);\n        return this;\n    }\n    /**\n     * Returns a string representation of the FaucetTransaction.\n     *\n     * @returns {string} A string representation of the FaucetTransaction.\n     */\n    toString() {\n        return `Coinbase::FaucetTransaction{transaction_hash: '${this.getTransactionHash()}', transaction_link: '${this.getTransactionLink()}'}`;\n    }\n}\nexports.FaucetTransaction = FaucetTransaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2ZhdWNldF90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDhDQUE4QyxJQUFJO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUIsMEJBQTBCLHdCQUF3QiwwQkFBMEIsRUFBRTtBQUMvSTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9mYXVjZXRfdHJhbnNhY3Rpb24uanM/NWVhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmF1Y2V0VHJhbnNhY3Rpb24gPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zYWN0aW9uIGZyb20gYSBmYXVjZXQuXG4gKi9cbmNsYXNzIEZhdWNldFRyYW5zYWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZhdWNldFRyYW5zYWN0aW9uIGluc3RhbmNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBpbnN0ZWFkLCB1c2UgQWRkcmVzcy5mYXVjZXQoKS5cbiAgICAgKlxuICAgICAqIEBjbGFzc1xuICAgICAqIEBwYXJhbSB7RmF1Y2V0VHJhbnNhY3Rpb25Nb2RlbH0gbW9kZWwgLSBUaGUgRmF1Y2V0VHJhbnNhY3Rpb24gbW9kZWwuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBtb2RlbCBkb2VzIG5vdCBleGlzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsPy50cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmF1Y2V0VHJhbnNhY3Rpb24gbW9kZWwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZhdWNldCBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0cmFuc2FjdGlvbiBoYXNoLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5nZXRUcmFuc2FjdGlvbkhhc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGluayB0byB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbGluayB0byB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIGJsb2NrY2hhaW4gZXhwbG9yZXJcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldFRyYW5zYWN0aW9uTGluaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIEZhdWNldFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1cyBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbi5nZXRTdGF0dXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV0d29yayBJRCBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLmdldE5ldHdvcmtJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhZGRyZXNzIHRoYXQgaXMgYmVpbmcgZnVuZGVkIGJ5IHRoZSBmYXVjZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgYWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRBZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9uLnRvQWRkcmVzc0lkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkIG9uIHRoZSBOZXR3b3JrIG9yIGZhaWwgb24gY2hhaW4uXG4gICAgICogV2FpdHMgdW50aWwgdGhlIEZhdWNldFRyYW5zYWN0aW9uIGlzIGNvbXBsZXRlZCBvciBmYWlsZWQgb24tY2hhaW4gYnkgcG9sbGluZyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICogUmFpc2VzIGFuIGVycm9yIGlmIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0U2Vjb25kcyAtIFRoZSBtYXhpbXVtIHRpbWUgdG8gd2FpdCBmb3IgdGhlIEZhdWNldFRyYW5zYWN0aW9uIHRvIGJlIGNvbmZpcm1lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGYXVjZXRUcmFuc2FjdGlvbiBvYmplY3QgaW4gYSB0ZXJtaW5hbCBzdGF0ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIEZhdWNldFRyYW5zYWN0aW9uIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gMC4yLCB0aW1lb3V0U2Vjb25kcyA9IDEwLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24gaXMgaW4gYSB0ZXJtaW5hbCBzdGF0ZSwgcmV0dXJuIHRoZSBGYXVjZXRUcmFuc2FjdGlvbi5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiRmF1Y2V0VHJhbnNhY3Rpb24gdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBGYXVjZXRUcmFuc2FjdGlvbiBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmF1Y2V0VHJhbnNhY3Rpb259IFRoZSByZWxvYWRlZCBGYXVjZXRUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBGYXVjZXRUcmFuc2FjdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5leHRlcm5hbEFkZHJlc3MuZ2V0RmF1Y2V0VHJhbnNhY3Rpb24odGhpcy50cmFuc2FjdGlvbi5nZXROZXR3b3JrSWQoKSwgdGhpcy5nZXRBZGRyZXNzSWQoKSwgdGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbD8udHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhdWNldFRyYW5zYWN0aW9uIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRmF1Y2V0VHJhbnNhY3Rpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgQ29pbmJhc2U6OkZhdWNldFRyYW5zYWN0aW9ue3RyYW5zYWN0aW9uX2hhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9JywgdHJhbnNhY3Rpb25fbGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nfWA7XG4gICAgfVxufVxuZXhwb3J0cy5GYXVjZXRUcmFuc2FjdGlvbiA9IEZhdWNldFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashTypedDataMessage = exports.hashMessage = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\n/**\n * Computes the EIP-191 personal-sign message digest to sign.\n *\n * @returns The EIP-191 hash of the message as a string.\n * @throws {Error} if the message cannot be hashed.\n * @param message - The message to hash.\n */\nconst hashMessage = (message) => {\n    return ethers_1.ethers.hashMessage(message);\n};\nexports.hashMessage = hashMessage;\n/**\n * Computes the hash of the EIP-712 compliant typed data message.\n *\n * @param domain - The domain parameters for the EIP-712 message, including the name, version, chainId, and verifying contract.\n * @param types - The types definitions for the EIP-712 message, represented as a record of type names to their fields.\n * @param value - The actual data object to hash, conforming to the types defined.\n *\n * @returns The EIP-712 hash of the typed data as a hex-encoded string.\n * @throws {Error} if the typed data cannot be hashed.\n */\nconst hashTypedDataMessage = (domain, types, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvalue) => {\n    return ethers_1.ethers.TypedDataEncoder.hash(domain, types, value);\n};\nexports.hashTypedDataMessage = hashTypedDataMessage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hhc2guanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xELGlCQUFpQixtQkFBTyxDQUFDLGlFQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hhc2guanM/YjJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFR5cGVkRGF0YU1lc3NhZ2UgPSBleHBvcnRzLmhhc2hNZXNzYWdlID0gdm9pZCAwO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgRUlQLTE5MSBwZXJzb25hbC1zaWduIG1lc3NhZ2UgZGlnZXN0IHRvIHNpZ24uXG4gKlxuICogQHJldHVybnMgVGhlIEVJUC0xOTEgaGFzaCBvZiB0aGUgbWVzc2FnZSBhcyBhIHN0cmluZy5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgbWVzc2FnZSBjYW5ub3QgYmUgaGFzaGVkLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICovXG5jb25zdCBoYXNoTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVyc18xLmV0aGVycy5oYXNoTWVzc2FnZShtZXNzYWdlKTtcbn07XG5leHBvcnRzLmhhc2hNZXNzYWdlID0gaGFzaE1lc3NhZ2U7XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIG9mIHRoZSBFSVAtNzEyIGNvbXBsaWFudCB0eXBlZCBkYXRhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGRvbWFpbiAtIFRoZSBkb21haW4gcGFyYW1ldGVycyBmb3IgdGhlIEVJUC03MTIgbWVzc2FnZSwgaW5jbHVkaW5nIHRoZSBuYW1lLCB2ZXJzaW9uLCBjaGFpbklkLCBhbmQgdmVyaWZ5aW5nIGNvbnRyYWN0LlxuICogQHBhcmFtIHR5cGVzIC0gVGhlIHR5cGVzIGRlZmluaXRpb25zIGZvciB0aGUgRUlQLTcxMiBtZXNzYWdlLCByZXByZXNlbnRlZCBhcyBhIHJlY29yZCBvZiB0eXBlIG5hbWVzIHRvIHRoZWlyIGZpZWxkcy5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhY3R1YWwgZGF0YSBvYmplY3QgdG8gaGFzaCwgY29uZm9ybWluZyB0byB0aGUgdHlwZXMgZGVmaW5lZC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgRUlQLTcxMiBoYXNoIG9mIHRoZSB0eXBlZCBkYXRhIGFzIGEgaGV4LWVuY29kZWQgc3RyaW5nLlxuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSB0eXBlZCBkYXRhIGNhbm5vdCBiZSBoYXNoZWQuXG4gKi9cbmNvbnN0IGhhc2hUeXBlZERhdGFNZXNzYWdlID0gKGRvbWFpbiwgdHlwZXMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIGV0aGVyc18xLmV0aGVycy5UeXBlZERhdGFFbmNvZGVyLmhhc2goZG9tYWluLCB0eXBlcywgdmFsdWUpO1xufTtcbmV4cG9ydHMuaGFzaFR5cGVkRGF0YU1lc3NhZ2UgPSBoYXNoVHlwZWREYXRhTWVzc2FnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HistoricalBalance = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\n/** A representation of historical balance. */\nclass HistoricalBalance {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param {Decimal} amount - The amount of the balance.\n     * @param {Decimal} blockHeight - The block height at which the balance was recorded.\n     * @param {string} blockHash - The block hash at which the balance was recorded\n     * @param {string} asset - The asset we want to fetch.\n     * @hideconstructor\n     */\n    constructor(amount, blockHeight, blockHash, asset) {\n        this.amount = amount;\n        this.blockHeight = blockHeight;\n        this.blockHash = blockHash;\n        this.asset = asset;\n    }\n    /**\n     * Converts a HistoricalBalanceModel into a HistoricalBalance object.\n     *\n     * @param {HistoricalBalanceModel} model - The historical balance model object.\n     * @returns {HistoricalBalance} The HistoricalBalance object.\n     */\n    static fromModel(model) {\n        const asset = asset_1.Asset.fromModel(model.asset);\n        return new HistoricalBalance(asset.fromAtomicAmount(new decimal_js_1.default(model.amount)), new decimal_js_1.default(model.block_height), model.block_hash, asset);\n    }\n}\nexports.HistoricalBalance = HistoricalBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL2hpc3RvcmljYWxfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QixxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBWTtBQUN6RCxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0JBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9oaXN0b3JpY2FsX2JhbGFuY2UuanM/MDYyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGlzdG9yaWNhbEJhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlY2ltYWwuanNcIikpO1xuY29uc3QgYXNzZXRfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0XCIpO1xuLyoqIEEgcmVwcmVzZW50YXRpb24gb2YgaGlzdG9yaWNhbCBiYWxhbmNlLiAqL1xuY2xhc3MgSGlzdG9yaWNhbEJhbGFuY2Uge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHtEZWNpbWFsfSBhbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBiYWxhbmNlLlxuICAgICAqIEBwYXJhbSB7RGVjaW1hbH0gYmxvY2tIZWlnaHQgLSBUaGUgYmxvY2sgaGVpZ2h0IGF0IHdoaWNoIHRoZSBiYWxhbmNlIHdhcyByZWNvcmRlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmxvY2tIYXNoIC0gVGhlIGJsb2NrIGhhc2ggYXQgd2hpY2ggdGhlIGJhbGFuY2Ugd2FzIHJlY29yZGVkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFzc2V0IC0gVGhlIGFzc2V0IHdlIHdhbnQgdG8gZmV0Y2guXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFtb3VudCwgYmxvY2tIZWlnaHQsIGJsb2NrSGFzaCwgYXNzZXQpIHtcbiAgICAgICAgdGhpcy5hbW91bnQgPSBhbW91bnQ7XG4gICAgICAgIHRoaXMuYmxvY2tIZWlnaHQgPSBibG9ja0hlaWdodDtcbiAgICAgICAgdGhpcy5ibG9ja0hhc2ggPSBibG9ja0hhc2g7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBhc3NldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBIaXN0b3JpY2FsQmFsYW5jZU1vZGVsIGludG8gYSBIaXN0b3JpY2FsQmFsYW5jZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hpc3RvcmljYWxCYWxhbmNlTW9kZWx9IG1vZGVsIC0gVGhlIGhpc3RvcmljYWwgYmFsYW5jZSBtb2RlbCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0hpc3RvcmljYWxCYWxhbmNlfSBUaGUgSGlzdG9yaWNhbEJhbGFuY2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tTW9kZWwobW9kZWwpIHtcbiAgICAgICAgY29uc3QgYXNzZXQgPSBhc3NldF8xLkFzc2V0LmZyb21Nb2RlbChtb2RlbC5hc3NldCk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yaWNhbEJhbGFuY2UoYXNzZXQuZnJvbUF0b21pY0Ftb3VudChuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQobW9kZWwuYW1vdW50KSksIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdChtb2RlbC5ibG9ja19oZWlnaHQpLCBtb2RlbC5ibG9ja19oYXNoLCBhc3NldCk7XG4gICAgfVxufVxuZXhwb3J0cy5IaXN0b3JpY2FsQmFsYW5jZSA9IEhpc3RvcmljYWxCYWxhbmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PayloadSignature = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Payload Signature.\n */\nclass PayloadSignature {\n    /**\n     * Constructs a Payload Signature.\n     *\n     * @class\n     * @param model - The underlying Payload Signature object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the ID of the Payload Signature.\n     *\n     * @returns The ID of the Payload Signature\n     */\n    getId() {\n        return this.model.payload_signature_id;\n    }\n    /**\n     * Returns the Wallet ID of the Payload Signature.\n     *\n     * @returns The Wallet ID\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Payload Signature.\n     *\n     * @returns The Address ID\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Unsigned Payload of the Payload Signature.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signature of the Payload Signature.\n     *\n     * @returns The Signature\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Returns the Status of the Payload Signature.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.PayloadSignatureStatus.PENDING:\n                return types_1.PayloadSignatureStatus.PENDING;\n            case types_1.PayloadSignatureStatus.SIGNED:\n                return types_1.PayloadSignatureStatus.SIGNED;\n            case types_1.PayloadSignatureStatus.FAILED:\n                return types_1.PayloadSignatureStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns whether the Payload Signature is in a terminal State.\n     *\n     * @returns Whether the Payload Signature is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.PayloadSignatureStatus.SIGNED, types_1.PayloadSignatureStatus.FAILED].includes(status);\n    }\n    /**\n     * Waits for the Payload Signature to be signed or for the signature operation to fail.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Payload Signature.\n     * @param options.timeoutSeconds - The maximum time to wait for the Payload Signature to be confirmed.\n     *\n     * @returns The Payload Signature object in a terminal state.\n     * @throws {Error} if the Payload Signature times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10, } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Payload Signature is in a terminal state, return the Payload Signature.\n            if (this.isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Payload Signature timed out\");\n    }\n    /**\n     * Reloads the Payload Signature model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Payload Signature fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.address.getPayloadSignature(this.getWalletId(), this.getAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Payload Signature.\n     *\n     * @returns A string representation of the Payload Signature.\n     */\n    toString() {\n        return `PayloadSignature { status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signature: ${this.getSignature()} }`;\n    }\n}\nexports.PayloadSignature = PayloadSignature;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVyxpQkFBaUIsdUJBQXVCLDBCQUEwQixnQkFBZ0Isc0JBQXNCO0FBQ3RKO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlLmpzP2QzNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBheWxvYWRTaWduYXR1cmUgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFBheWxvYWQgU2lnbmF0dXJlLlxuICovXG5jbGFzcyBQYXlsb2FkU2lnbmF0dXJlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBQYXlsb2FkIFNpZ25hdHVyZSBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgSUQgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5wYXlsb2FkX3NpZ25hdHVyZV9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2FsbGV0IElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSURcbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBZGRyZXNzIElEIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBZGRyZXNzIElEXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVbnNpZ25lZCBQYXlsb2FkIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBVbnNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0VW5zaWduZWRQYXlsb2FkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC51bnNpZ25lZF9wYXlsb2FkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTaWduYXR1cmUgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNpZ25hdHVyZVxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2lnbmF0dXJlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFBheWxvYWQgU2lnbmF0dXJlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFN0YXR1c1xuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlBheWxvYWRTaWduYXR1cmVTdGF0dXMuUEVORElORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5TSUdORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5TSUdORUQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgUGF5bG9hZCBTaWduYXR1cmUgaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZVxuICAgICAqL1xuICAgIGlzVGVybWluYWxTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5nZXRTdGF0dXMoKTtcbiAgICAgICAgaWYgKCFzdGF0dXMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBbdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLlNJR05FRCwgdHlwZXNfMS5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzLkZBSUxFRF0uaW5jbHVkZXMoc3RhdHVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0byBiZSBzaWduZWQgb3IgZm9yIHRoZSBzaWduYXR1cmUgb3BlcmF0aW9uIHRvIGZhaWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgdG8gY2hlY2sgdGhlIHN0YXR1cyBvZiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0byBiZSBjb25maXJtZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgUGF5bG9hZCBTaWduYXR1cmUgb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBQYXlsb2FkIFNpZ25hdHVyZSB0aW1lcyBvdXQuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFBheWxvYWQgU2lnbmF0dXJlIGlzIGluIGEgdGVybWluYWwgc3RhdGUsIHJldHVybiB0aGUgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKDAsIHV0aWxzXzEuZGVsYXkpKGludGVydmFsU2Vjb25kcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihcIlBheWxvYWQgU2lnbmF0dXJlIHRpbWVkIG91dFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgUGF5bG9hZCBTaWduYXR1cmUgbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBnZXQgYSBQYXlsb2FkIFNpZ25hdHVyZSBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5hZGRyZXNzLmdldFBheWxvYWRTaWduYXR1cmUodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldEFkZHJlc3NJZCgpLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBQYXlsb2FkIFNpZ25hdHVyZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBQYXlsb2FkU2lnbmF0dXJlIHsgc3RhdHVzOiAnJHt0aGlzLmdldFN0YXR1cygpfScsIHVuc2lnbmVkUGF5bG9hZDogJyR7dGhpcy5nZXRVbnNpZ25lZFBheWxvYWQoKX0nLCBzaWduYXR1cmU6ICR7dGhpcy5nZXRTaWduYXR1cmUoKX0gfWA7XG4gICAgfVxufVxuZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlID0gUGF5bG9hZFNpZ25hdHVyZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readContract = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * Converts a SolidityValue to its corresponding JavaScript type.\n *\n * @param {SolidityValue} solidityValue - The Solidity value to convert.\n * @returns {unknown} The converted JavaScript value.\n */\nfunction convertSolidityValue(solidityValue) {\n    const { type, value, values } = solidityValue;\n    switch (type) {\n        case \"uint8\":\n        case \"uint16\":\n        case \"uint32\":\n        case \"int8\":\n        case \"int16\":\n        case \"int32\":\n            return Number(value);\n        case \"uint64\":\n        case \"uint128\":\n        case \"uint256\":\n        case \"int64\":\n        case \"int128\":\n        case \"int256\":\n            return BigInt(value);\n        case \"address\":\n            return value;\n        case \"bool\":\n            return value === \"true\";\n        case \"string\":\n            return value;\n        case \"bytes\":\n        case \"bytes1\":\n        case \"bytes2\":\n        case \"bytes3\":\n        case \"bytes4\":\n        case \"bytes5\":\n        case \"bytes6\":\n        case \"bytes7\":\n        case \"bytes8\":\n        case \"bytes9\":\n        case \"bytes10\":\n        case \"bytes11\":\n        case \"bytes12\":\n        case \"bytes13\":\n        case \"bytes14\":\n        case \"bytes15\":\n        case \"bytes16\":\n        case \"bytes17\":\n        case \"bytes18\":\n        case \"bytes19\":\n        case \"bytes20\":\n        case \"bytes21\":\n        case \"bytes22\":\n        case \"bytes23\":\n        case \"bytes24\":\n        case \"bytes25\":\n        case \"bytes26\":\n        case \"bytes27\":\n        case \"bytes28\":\n        case \"bytes29\":\n        case \"bytes30\":\n        case \"bytes31\":\n        case \"bytes32\":\n            return value;\n        case \"array\":\n            return values.map(convertSolidityValue);\n        case \"tuple\":\n            return values.reduce((acc, val) => {\n                if (!val.name) {\n                    throw new Error(\"Tuple field missing name\");\n                }\n                acc[val.name] = convertSolidityValue(val);\n                return acc;\n            }, {});\n        default:\n            throw new Error(`Unsupported Solidity type: ${type}`);\n    }\n}\n/**\n * Parses a SolidityValue to a specific type T.\n *\n * @template T\n * @param {SolidityValue} solidityValue - The Solidity value to parse.\n * @returns {T} The parsed value of type T.\n */\nfunction parseSolidityValue(solidityValue) {\n    return convertSolidityValue(solidityValue);\n}\n/**\n * Reads data from a smart contract using the Coinbase API.\n *\n * @template TAbi - The ABI type.\n * @template TFunctionName - The contract function name type.\n * @template TArgs - The function arguments type.\n * @param {object} params - The parameters for reading the contract.\n * @param {string} params.networkId - The network ID.\n * @param {string} params.contractAddress - The contract address (as a hexadecimal string).\n * @param {TFunctionName} params.method - The contract method to call.\n * @param {TArgs} params.args - The arguments for the contract method.\n * @param {TAbi} [params.abi] - The contract ABI (optional).\n * @returns {Promise<any>} The result of the contract call.\n */\nasync function readContract(params) {\n    const response = await coinbase_1.Coinbase.apiClients.smartContract.readContract(params.networkId, params.contractAddress, {\n        method: params.method,\n        args: JSON.stringify(params.args || {}),\n        abi: params.abi ? JSON.stringify(params.abi) : undefined,\n    });\n    return parseSolidityValue(response.data);\n}\nexports.readContract = readContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3JlYWRfY29udHJhY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9yZWFkX2NvbnRyYWN0LmpzP2MwMDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlYWRDb250cmFjdCA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQ29udmVydHMgYSBTb2xpZGl0eVZhbHVlIHRvIGl0cyBjb3JyZXNwb25kaW5nIEphdmFTY3JpcHQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1NvbGlkaXR5VmFsdWV9IHNvbGlkaXR5VmFsdWUgLSBUaGUgU29saWRpdHkgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHt1bmtub3dufSBUaGUgY29udmVydGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRTb2xpZGl0eVZhbHVlKHNvbGlkaXR5VmFsdWUpIHtcbiAgICBjb25zdCB7IHR5cGUsIHZhbHVlLCB2YWx1ZXMgfSA9IHNvbGlkaXR5VmFsdWU7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJ1aW50OFwiOlxuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgY2FzZSBcImludDE2XCI6XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgY2FzZSBcInVpbnQxMjhcIjpcbiAgICAgICAgY2FzZSBcInVpbnQyNTZcIjpcbiAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIGNhc2UgXCJpbnQxMjhcIjpcbiAgICAgICAgY2FzZSBcImludDI1NlwiOlxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJib29sXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IFwidHJ1ZVwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxXCI6XG4gICAgICAgIGNhc2UgXCJieXRlczJcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM0XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczVcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXM3XCI6XG4gICAgICAgIGNhc2UgXCJieXRlczhcIjpcbiAgICAgICAgY2FzZSBcImJ5dGVzOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxMlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxN1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxOFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMxOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyMlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyM1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyNlwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyN1wiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyOFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMyOVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMFwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMVwiOlxuICAgICAgICBjYXNlIFwiYnl0ZXMzMlwiOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXMubWFwKGNvbnZlcnRTb2xpZGl0eVZhbHVlKTtcbiAgICAgICAgY2FzZSBcInR1cGxlXCI6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWwpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlR1cGxlIGZpZWxkIG1pc3NpbmcgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjW3ZhbC5uYW1lXSA9IGNvbnZlcnRTb2xpZGl0eVZhbHVlKHZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgU29saWRpdHkgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbn1cbi8qKlxuICogUGFyc2VzIGEgU29saWRpdHlWYWx1ZSB0byBhIHNwZWNpZmljIHR5cGUgVC5cbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTb2xpZGl0eVZhbHVlfSBzb2xpZGl0eVZhbHVlIC0gVGhlIFNvbGlkaXR5IHZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMge1R9IFRoZSBwYXJzZWQgdmFsdWUgb2YgdHlwZSBULlxuICovXG5mdW5jdGlvbiBwYXJzZVNvbGlkaXR5VmFsdWUoc29saWRpdHlWYWx1ZSkge1xuICAgIHJldHVybiBjb252ZXJ0U29saWRpdHlWYWx1ZShzb2xpZGl0eVZhbHVlKTtcbn1cbi8qKlxuICogUmVhZHMgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3QgdXNpbmcgdGhlIENvaW5iYXNlIEFQSS5cbiAqXG4gKiBAdGVtcGxhdGUgVEFiaSAtIFRoZSBBQkkgdHlwZS5cbiAqIEB0ZW1wbGF0ZSBURnVuY3Rpb25OYW1lIC0gVGhlIGNvbnRyYWN0IGZ1bmN0aW9uIG5hbWUgdHlwZS5cbiAqIEB0ZW1wbGF0ZSBUQXJncyAtIFRoZSBmdW5jdGlvbiBhcmd1bWVudHMgdHlwZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgcmVhZGluZyB0aGUgY29udHJhY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm5ldHdvcmtJZCAtIFRoZSBuZXR3b3JrIElELlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcyAoYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcpLlxuICogQHBhcmFtIHtURnVuY3Rpb25OYW1lfSBwYXJhbXMubWV0aG9kIC0gVGhlIGNvbnRyYWN0IG1ldGhvZCB0byBjYWxsLlxuICogQHBhcmFtIHtUQXJnc30gcGFyYW1zLmFyZ3MgLSBUaGUgYXJndW1lbnRzIGZvciB0aGUgY29udHJhY3QgbWV0aG9kLlxuICogQHBhcmFtIHtUQWJpfSBbcGFyYW1zLmFiaV0gLSBUaGUgY29udHJhY3QgQUJJIChvcHRpb25hbCkuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxhbnk+fSBUaGUgcmVzdWx0IG9mIHRoZSBjb250cmFjdCBjYWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkQ29udHJhY3QocGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc21hcnRDb250cmFjdC5yZWFkQ29udHJhY3QocGFyYW1zLm5ldHdvcmtJZCwgcGFyYW1zLmNvbnRyYWN0QWRkcmVzcywge1xuICAgICAgICBtZXRob2Q6IHBhcmFtcy5tZXRob2QsXG4gICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KHBhcmFtcy5hcmdzIHx8IHt9KSxcbiAgICAgICAgYWJpOiBwYXJhbXMuYWJpID8gSlNPTi5zdHJpbmdpZnkocGFyYW1zLmFiaSkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlU29saWRpdHlWYWx1ZShyZXNwb25zZS5kYXRhKTtcbn1cbmV4cG9ydHMucmVhZENvbnRyYWN0ID0gcmVhZENvbnRyYWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerSigner = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Server-Signer. Server-Signers are assigned to sign transactions for a Wallet.\n */\nclass ServerSigner {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method.\n     * Creates a new ServerSigner instance.\n     * Do not use this method directly. Instead, use ServerSigner.getDefault().\n     *\n     * @ignore\n     * @param serverSignerModel - The Server-Signer model.\n     * @hideconstructor\n     */\n    constructor(serverSignerModel) {\n        this.model = serverSignerModel;\n    }\n    /**\n     * Returns the default Server-Signer for the CDP Project.\n     *\n     * @returns The default Server-Signer.\n     * @throws {APIError} if the API request to list Server-Signers fails.\n     * @throws {Error} if there is no Server-Signer associated with the CDP Project.\n     */\n    static async getDefault() {\n        const response = await coinbase_1.Coinbase.apiClients.serverSigner.listServerSigners();\n        if (response.data.data.length === 0) {\n            throw new Error(\"No Server-Signer is associated with the project\");\n        }\n        return new ServerSigner(response.data.data[0]);\n    }\n    /**\n     * Returns the ID of the Server-Signer.\n     *\n     * @returns The Server-Signer ID.\n     */\n    getId() {\n        return this.model.server_signer_id;\n    }\n    /**\n     * Returns the IDs of the Wallet's the Server-Signer can sign for.\n     *\n     * @returns The Wallet IDs.\n     */\n    getWallets() {\n        return this.model.wallets;\n    }\n    /**\n     * Returns a String representation of the Server-Signer.\n     *\n     * @returns a String representation of the Server-Signer.\n     */\n    toString() {\n        return `ServerSigner{id: '${this.getId()}', wallets: '${this.getWallets()}'}`;\n    }\n}\nexports.ServerSigner = ServerSigner;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NlcnZlcl9zaWduZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsT0FBTyxhQUFhLGVBQWUsa0JBQWtCLEVBQUU7QUFDcEY7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc2VydmVyX3NpZ25lci5qcz82M2U2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXJTaWduZXIgPSB2b2lkIDA7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBTZXJ2ZXItU2lnbmVyLiBTZXJ2ZXItU2lnbmVycyBhcmUgYXNzaWduZWQgdG8gc2lnbiB0cmFuc2FjdGlvbnMgZm9yIGEgV2FsbGV0LlxuICovXG5jbGFzcyBTZXJ2ZXJTaWduZXIge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2VydmVyU2lnbmVyIGluc3RhbmNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQsIHVzZSBTZXJ2ZXJTaWduZXIuZ2V0RGVmYXVsdCgpLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSBzZXJ2ZXJTaWduZXJNb2RlbCAtIFRoZSBTZXJ2ZXItU2lnbmVyIG1vZGVsLlxuICAgICAqIEBoaWRlY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXJTaWduZXJNb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gc2VydmVyU2lnbmVyTW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmF1bHQgU2VydmVyLVNpZ25lciBmb3IgdGhlIENEUCBQcm9qZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGRlZmF1bHQgU2VydmVyLVNpZ25lci5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGxpc3QgU2VydmVyLVNpZ25lcnMgZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZXJlIGlzIG5vIFNlcnZlci1TaWduZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBDRFAgUHJvamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZ2V0RGVmYXVsdCgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuc2VydmVyU2lnbmVyLmxpc3RTZXJ2ZXJTaWduZXJzKCk7XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBTZXJ2ZXItU2lnbmVyIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcnZlclNpZ25lcihyZXNwb25zZS5kYXRhLmRhdGFbMF0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgU2VydmVyLVNpZ25lci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTZXJ2ZXItU2lnbmVyIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zZXJ2ZXJfc2lnbmVyX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRHMgb2YgdGhlIFdhbGxldCdzIHRoZSBTZXJ2ZXItU2lnbmVyIGNhbiBzaWduIGZvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQgSURzLlxuICAgICAqL1xuICAgIGdldFdhbGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLndhbGxldHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFNlcnZlci1TaWduZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU2VydmVyLVNpZ25lci5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTZXJ2ZXJTaWduZXJ7aWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCB3YWxsZXRzOiAnJHt0aGlzLmdldFdhbGxldHMoKX0nfWA7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJTaWduZXIgPSBTZXJ2ZXJTaWduZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContract = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst contract_event_1 = __webpack_require__(/*! ./contract_event */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\");\n/**\n * A representation of a SmartContract on the blockchain.\n */\nclass SmartContract {\n    /**\n     * Creates a new SmartContract instance.\n     *\n     * @param contractModel - The SmartContract model from the API.\n     */\n    constructor(contractModel) {\n        if (!contractModel) {\n            throw new Error(\"SmartContract model cannot be empty\");\n        }\n        this.model = contractModel;\n    }\n    /**\n     * Returns a list of ContractEvents for the provided network, contract, and event details.\n     *\n     * @param networkId - The network ID.\n     * @param protocolName - The protocol name.\n     * @param contractAddress - The contract address.\n     * @param contractName - The contract name.\n     * @param eventName - The event name.\n     * @param fromBlockHeight - The start block height.\n     * @param toBlockHeight - The end block height.\n     * @returns The contract events.\n     */\n    static async listEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight) {\n        const contractEvents = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.contractEvent.listContractEvents(networkId, protocolName, contractAddress, contractName, eventName, fromBlockHeight, toBlockHeight, page?.length ? page : undefined);\n            response.data.data.forEach(contractEvent => {\n                contractEvents.push(new contract_event_1.ContractEvent(contractEvent));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return contractEvents;\n    }\n    /**\n     * Converts a SmartContractModel into a SmartContract object.\n     *\n     * @param contractModel - The SmartContract model object.\n     * @returns The SmartContract object.\n     */\n    static fromModel(contractModel) {\n        return new SmartContract(contractModel);\n    }\n    /**\n     * Returns the ID of the SmartContract.\n     *\n     * @returns The SmartContract ID.\n     */\n    getId() {\n        return this.model.smart_contract_id;\n    }\n    /**\n     * Returns the Network ID of the SmartContract.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID that deployed the smart contract.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Contract Address of the smart contract.\n     *\n     * @returns The Contract Address.\n     */\n    getContractAddress() {\n        return this.model.contract_address;\n    }\n    /**\n     * Returns the Deployer Address of the smart contract.\n     *\n     * @returns The Deployer Address.\n     */\n    getDeployerAddress() {\n        return this.model.deployer_address;\n    }\n    /**\n     * Returns the Type of the smart contract.\n     *\n     * @returns The Smart Contract Type.\n     */\n    getType() {\n        switch (this.model.type) {\n            case api_1.SmartContractType.Erc20:\n                return types_1.SmartContractType.ERC20;\n            case api_1.SmartContractType.Erc721:\n                return types_1.SmartContractType.ERC721;\n            case api_1.SmartContractType.Erc1155:\n                return types_1.SmartContractType.ERC1155;\n            default:\n                throw new Error(`Unknown smart contract type: ${this.model.type}`);\n        }\n    }\n    /**\n     * Returns the Options of the smart contract.\n     *\n     * @returns The Smart Contract Options.\n     */\n    getOptions() {\n        if (this.isERC20(this.getType(), this.model.options)) {\n            return {\n                name: this.model.options.name,\n                symbol: this.model.options.symbol,\n                totalSupply: this.model.options.total_supply,\n            };\n        }\n        else if (this.isERC721(this.getType(), this.model.options)) {\n            return {\n                name: this.model.options.name,\n                symbol: this.model.options.symbol,\n                baseURI: this.model.options.base_uri,\n            };\n        }\n        else {\n            return {\n                uri: this.model.options.uri,\n            };\n        }\n    }\n    /**\n     * Returns the ABI of the smart contract.\n     *\n     * @returns The ABI as a JSON-encoded string.\n     */\n    getAbi() {\n        return JSON.parse(this.model.abi);\n    }\n    /**\n     * Returns the Transaction of the smart contract deployment.\n     *\n     * @returns The Transaction.\n     */\n    getTransaction() {\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Signs the SmartContract deployment with the provided key and returns the hex signature\n     * required for broadcasting the SmartContract deployment.\n     *\n     * @param key - The key to sign the SmartContract deployment with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getTransaction().sign(key);\n    }\n    /**\n     * Broadcasts the SmartContract deployment to the Network.\n     *\n     * @returns The SmartContract object\n     * @throws {APIError} if the API request to broadcast a SmartContract deployment fails.\n     */\n    async broadcast() {\n        if (!this.getTransaction().isSigned())\n            throw new Error(\"Cannot broadcast unsigned SmartContract deployment\");\n        const deploySmartContractRequest = {\n            signed_payload: this.getTransaction().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.smartContract.deploySmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId(), deploySmartContractRequest);\n        return SmartContract.fromModel(response.data);\n    }\n    /**\n     * Waits for the SmartContract deployment to be confirmed on the Network or fail on chain.\n     * Waits until the SmartContract deployment is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the SmartContract deployment takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the SmartContract deployment.\n     * @param options.timeoutSeconds - The maximum time to wait for the SmartContract deployment to be confirmed.\n     *\n     * @returns The SmartContract object in a terminal state.\n     * @throws {Error} if the SmartContract deployment times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the SmartContract deployment is in a terminal state, return the SmartContract.\n            const status = this.getTransaction().getStatus();\n            if (status === types_1.TransactionStatus.COMPLETE || status === types_1.TransactionStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"SmartContract deployment timed out\");\n    }\n    /**\n     * Reloads the SmartContract model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a SmartContract fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.smartContract.getSmartContract(this.getWalletId(), this.getDeployerAddress(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the SmartContract.\n     *\n     * @returns The string representation of the SmartContract.\n     */\n    toString() {\n        return (`SmartContract{id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `contractAddress: '${this.getContractAddress()}', deployerAddress: '${this.getDeployerAddress()}', ` +\n            `type: '${this.getType()}'}`);\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC20.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC20, false otherwise.\n     */\n    isERC20(type, options) {\n        return type === types_1.SmartContractType.ERC20;\n    }\n    /**\n     * Type guard for checking if the smart contract is an ERC721.\n     *\n     * @param type - The type of the smart contract.\n     * @param options - The options of the smart contract.\n     * @returns True if the smart contract is an ERC721, false otherwise.\n     */\n    isERC721(type, options) {\n        return type === types_1.SmartContractType.ERC721;\n    }\n}\nexports.SmartContract = SmartContract;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3NtYXJ0X2NvbnRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMseUJBQXlCLG1CQUFPLENBQUMscUdBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQkFBZ0I7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxpQkFBaUIsNkNBQTZDLElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLGFBQWEsaUJBQWlCLG9CQUFvQjtBQUN4RixpQ0FBaUMsMEJBQTBCLHVCQUF1QiwwQkFBMEI7QUFDNUcsc0JBQXNCLGVBQWUsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc21hcnRfY29udHJhY3QuanM/ZDQ4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU21hcnRDb250cmFjdCA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIi4uL2NsaWVudC9hcGlcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4vdHJhbnNhY3Rpb25cIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGNvbnRyYWN0X2V2ZW50XzEgPSByZXF1aXJlKFwiLi9jb250cmFjdF9ldmVudFwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFNtYXJ0Q29udHJhY3Qgb24gdGhlIGJsb2NrY2hhaW4uXG4gKi9cbmNsYXNzIFNtYXJ0Q29udHJhY3Qge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU21hcnRDb250cmFjdCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdE1vZGVsIC0gVGhlIFNtYXJ0Q29udHJhY3QgbW9kZWwgZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0TW9kZWwpIHtcbiAgICAgICAgaWYgKCFjb250cmFjdE1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbWFydENvbnRyYWN0IG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gY29udHJhY3RNb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgQ29udHJhY3RFdmVudHMgZm9yIHRoZSBwcm92aWRlZCBuZXR3b3JrLCBjb250cmFjdCwgYW5kIGV2ZW50IGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIHByb3RvY29sTmFtZSAtIFRoZSBwcm90b2NvbCBuYW1lLlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBUaGUgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29udHJhY3ROYW1lIC0gVGhlIGNvbnRyYWN0IG5hbWUuXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBldmVudCBuYW1lLlxuICAgICAqIEBwYXJhbSBmcm9tQmxvY2tIZWlnaHQgLSBUaGUgc3RhcnQgYmxvY2sgaGVpZ2h0LlxuICAgICAqIEBwYXJhbSB0b0Jsb2NrSGVpZ2h0IC0gVGhlIGVuZCBibG9jayBoZWlnaHQuXG4gICAgICogQHJldHVybnMgVGhlIGNvbnRyYWN0IGV2ZW50cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbGlzdEV2ZW50cyhuZXR3b3JrSWQsIHByb3RvY29sTmFtZSwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0RXZlbnRzID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW1wiXCJdO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5jb250cmFjdEV2ZW50Lmxpc3RDb250cmFjdEV2ZW50cyhuZXR3b3JrSWQsIHByb3RvY29sTmFtZSwgY29udHJhY3RBZGRyZXNzLCBjb250cmFjdE5hbWUsIGV2ZW50TmFtZSwgZnJvbUJsb2NrSGVpZ2h0LCB0b0Jsb2NrSGVpZ2h0LCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKGNvbnRyYWN0RXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0RXZlbnRzLnB1c2gobmV3IGNvbnRyYWN0X2V2ZW50XzEuQ29udHJhY3RFdmVudChjb250cmFjdEV2ZW50KSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmhhc19tb3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJhY3RFdmVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgU21hcnRDb250cmFjdE1vZGVsIGludG8gYSBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdE1vZGVsIC0gVGhlIFNtYXJ0Q29udHJhY3QgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbU1vZGVsKGNvbnRyYWN0TW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbWFydENvbnRyYWN0KGNvbnRyYWN0TW9kZWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zbWFydF9jb250cmFjdF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBOZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgV2FsbGV0IElEIHRoYXQgZGVwbG95ZWQgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBDb250cmFjdCBBZGRyZXNzIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdCBBZGRyZXNzLlxuICAgICAqL1xuICAgIGdldENvbnRyYWN0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuY29udHJhY3RfYWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgRGVwbG95ZXIgQWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgRGVwbG95ZXIgQWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXREZXBsb3llckFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmRlcGxveWVyX2FkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFR5cGUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNtYXJ0IENvbnRyYWN0IFR5cGUuXG4gICAgICovXG4gICAgZ2V0VHlwZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGVsLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuU21hcnRDb250cmFjdFR5cGUuRXJjMjA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuRVJDMjA7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlNtYXJ0Q29udHJhY3RUeXBlLkVyYzcyMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5FUkM3MjE7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlNtYXJ0Q29udHJhY3RUeXBlLkVyYzExNTU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRDb250cmFjdFR5cGUuRVJDMTE1NTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHNtYXJ0IGNvbnRyYWN0IHR5cGU6ICR7dGhpcy5tb2RlbC50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9wdGlvbnMgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNtYXJ0IENvbnRyYWN0IE9wdGlvbnMuXG4gICAgICovXG4gICAgZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFUkMyMCh0aGlzLmdldFR5cGUoKSwgdGhpcy5tb2RlbC5vcHRpb25zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm1vZGVsLm9wdGlvbnMubmFtZSxcbiAgICAgICAgICAgICAgICBzeW1ib2w6IHRoaXMubW9kZWwub3B0aW9ucy5zeW1ib2wsXG4gICAgICAgICAgICAgICAgdG90YWxTdXBwbHk6IHRoaXMubW9kZWwub3B0aW9ucy50b3RhbF9zdXBwbHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNFUkM3MjEodGhpcy5nZXRUeXBlKCksIHRoaXMubW9kZWwub3B0aW9ucykpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhpcy5tb2RlbC5vcHRpb25zLm5hbWUsXG4gICAgICAgICAgICAgICAgc3ltYm9sOiB0aGlzLm1vZGVsLm9wdGlvbnMuc3ltYm9sLFxuICAgICAgICAgICAgICAgIGJhc2VVUkk6IHRoaXMubW9kZWwub3B0aW9ucy5iYXNlX3VyaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVyaTogdGhpcy5tb2RlbC5vcHRpb25zLnVyaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQUJJIG9mIHRoZSBzbWFydCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBBQkkgYXMgYSBKU09OLWVuY29kZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIGdldEFiaSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGhpcy5tb2RlbC5hYmkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFuc2FjdGlvbiBvZiB0aGUgc21hcnQgY29udHJhY3QgZGVwbG95bWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25hdHVyZVxuICAgICAqIHJlcXVpcmVkIGZvciBicm9hZGNhc3RpbmcgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25lZCBwYXlsb2FkXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0byB0aGUgTmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTbWFydENvbnRyYWN0IG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGJyb2FkY2FzdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFRyYW5zYWN0aW9uKCkuaXNTaWduZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgdW5zaWduZWQgU21hcnRDb250cmFjdCBkZXBsb3ltZW50XCIpO1xuICAgICAgICBjb25zdCBkZXBsb3lTbWFydENvbnRyYWN0UmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0U2lnbmF0dXJlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnNtYXJ0Q29udHJhY3QuZGVwbG95U21hcnRDb250cmFjdCh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0RGVwbG95ZXJBZGRyZXNzKCksIHRoaXMuZ2V0SWQoKSwgZGVwbG95U21hcnRDb250cmFjdFJlcXVlc3QpO1xuICAgICAgICByZXR1cm4gU21hcnRDb250cmFjdC5mcm9tTW9kZWwocmVzcG9uc2UuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIGZvciB0aGUgU21hcnRDb250cmFjdCBkZXBsb3ltZW50IHRvIGJlIGNvbmZpcm1lZCBvbiB0aGUgTmV0d29yayBvciBmYWlsIG9uIGNoYWluLlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSB3YWl0IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmludGVydmFsU2Vjb25kcyAtIFRoZSBpbnRlcnZhbCB0byBjaGVjayB0aGUgc3RhdHVzIG9mIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSB0aW1lIHRvIHdhaXQgZm9yIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNtYXJ0Q29udHJhY3Qgb2JqZWN0IGluIGEgdGVybWluYWwgc3RhdGUuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFNtYXJ0Q29udHJhY3QgZGVwbG95bWVudCBpcyBpbiBhIHRlcm1pbmFsIHN0YXRlLCByZXR1cm4gdGhlIFNtYXJ0Q29udHJhY3QuXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFRyYW5zYWN0aW9uKCkuZ2V0U3RhdHVzKCk7XG4gICAgICAgICAgICBpZiAoc3RhdHVzID09PSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkNPTVBMRVRFIHx8IHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgwLCB1dGlsc18xLmRlbGF5KShpbnRlcnZhbFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5UaW1lb3V0RXJyb3IoXCJTbWFydENvbnRyYWN0IGRlcGxveW1lbnQgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBTbWFydENvbnRyYWN0IG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgU21hcnRDb250cmFjdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zbWFydENvbnRyYWN0LmdldFNtYXJ0Q29udHJhY3QodGhpcy5nZXRXYWxsZXRJZCgpLCB0aGlzLmdldERlcGxveWVyQWRkcmVzcygpLCB0aGlzLmdldElkKCkpO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0Py5kYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTbWFydENvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU21hcnRDb250cmFjdC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChgU21hcnRDb250cmFjdHtpZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBjb250cmFjdEFkZHJlc3M6ICcke3RoaXMuZ2V0Q29udHJhY3RBZGRyZXNzKCl9JywgZGVwbG95ZXJBZGRyZXNzOiAnJHt0aGlzLmdldERlcGxveWVyQWRkcmVzcygpfScsIGAgK1xuICAgICAgICAgICAgYHR5cGU6ICcke3RoaXMuZ2V0VHlwZSgpfSd9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHRoZSBzbWFydCBjb250cmFjdCBpcyBhbiBFUkMyMC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHNtYXJ0IGNvbnRyYWN0IGlzIGFuIEVSQzIwLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFUkMyMCh0eXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSB0eXBlc18xLlNtYXJ0Q29udHJhY3RUeXBlLkVSQzIwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDNzIxLlxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvZiB0aGUgc21hcnQgY29udHJhY3QuXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc21hcnQgY29udHJhY3QgaXMgYW4gRVJDNzIxLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaXNFUkM3MjEodHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gdHlwZXNfMS5TbWFydENvbnRyYWN0VHlwZS5FUkM3MjE7XG4gICAgfVxufVxuZXhwb3J0cy5TbWFydENvbnRyYWN0ID0gU21hcnRDb250cmFjdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SponsoredSend = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of an onchain Sponsored Send.\n */\nclass SponsoredSend {\n    /**\n     * Sponsored Sends should be constructed via higher level abstractions like Transfer.\n     *\n     * @class\n     * @param model - The underlying Sponsored Send object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Keccak256 hash of the typed data. This payload must be signed\n     * by the sender to be used as an approval in the EIP-3009 transaction.\n     *\n     * @returns The Keccak256 hash of the typed data.\n     */\n    getTypedDataHash() {\n        return this.model.typed_data_hash;\n    }\n    /**\n     * Returns the signature of the typed data.\n     *\n     * @returns The hash of the typed data signature.\n     */\n    getSignature() {\n        return this.model.signature;\n    }\n    /**\n     * Signs the Sponsored Send with the provided key and returns the hex signature.\n     *\n     * @param key - The key to sign the Sponsored Send with\n     * @returns The hex-encoded signature\n     */\n    async sign(key) {\n        ethers_1.ethers.toBeArray;\n        const signature = key.signingKey.sign(ethers_1.ethers.getBytes(this.getTypedDataHash())).serialized;\n        this.model.signature = signature;\n        return signature;\n    }\n    /**\n     * Returns whether the Sponsored Send has been signed.\n     *\n     * @returns if the Sponsored Send has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns the Status of the Sponsored Send.\n     *\n     * @returns the Status of the Sponsored Send\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.SponsoredSendStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.SponsoredSendStatus.SIGNED;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.SponsoredSendStatus.SUBMITTED;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.SponsoredSendStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.SponsoredSendStatus.FAILED;\n            default:\n                undefined;\n        }\n    }\n    /**\n     * Returns whether the Sponsored Send is in a terminal State.\n     *\n     * @returns Whether the Sponsored Send is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        if (!status)\n            return false;\n        return [types_1.SponsoredSendStatus.COMPLETE, types_1.SponsoredSendStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the Transaction Hash of the Sponsored Send.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the link to the Sponsored Send on the blockchain explorer.\n     *\n     * @returns The link to the Sponsored Send on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns a string representation of the Sponsored Send.\n     *\n     * @returns A string representation of the Sponsored Send\n     */\n    toString() {\n        return `SponsoredSend { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', typedDataHash: '${this.getTypedDataHash()}', signature: ${this.getSignature()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.SponsoredSend = SponsoredSend;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3Nwb25zb3JlZF9zZW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQiwwQkFBMEIsY0FBYyxpQkFBaUIscUJBQXFCLHdCQUF3QixnQkFBZ0Isb0JBQW9CLHFCQUFxQiw0QkFBNEI7QUFDL087QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2Uvc3BvbnNvcmVkX3NlbmQuanM/NzkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3BvbnNvcmVkU2VuZCA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbiBvbmNoYWluIFNwb25zb3JlZCBTZW5kLlxuICovXG5jbGFzcyBTcG9uc29yZWRTZW5kIHtcbiAgICAvKipcbiAgICAgKiBTcG9uc29yZWQgU2VuZHMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHZpYSBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zIGxpa2UgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBTcG9uc29yZWQgU2VuZCBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgS2VjY2FrMjU2IGhhc2ggb2YgdGhlIHR5cGVkIGRhdGEuIFRoaXMgcGF5bG9hZCBtdXN0IGJlIHNpZ25lZFxuICAgICAqIGJ5IHRoZSBzZW5kZXIgdG8gYmUgdXNlZCBhcyBhbiBhcHByb3ZhbCBpbiB0aGUgRUlQLTMwMDkgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgS2VjY2FrMjU2IGhhc2ggb2YgdGhlIHR5cGVkIGRhdGEuXG4gICAgICovXG4gICAgZ2V0VHlwZWREYXRhSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHlwZWRfZGF0YV9oYXNoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduYXR1cmUgb2YgdGhlIHR5cGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHlwZWQgZGF0YSBzaWduYXR1cmUuXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5zaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBTcG9uc29yZWQgU2VuZCB3aXRoIHRoZSBwcm92aWRlZCBrZXkgYW5kIHJldHVybnMgdGhlIGhleCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBzaWduIHRoZSBTcG9uc29yZWQgU2VuZCB3aXRoXG4gICAgICogQHJldHVybnMgVGhlIGhleC1lbmNvZGVkIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGFzeW5jIHNpZ24oa2V5KSB7XG4gICAgICAgIGV0aGVyc18xLmV0aGVycy50b0JlQXJyYXk7XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGtleS5zaWduaW5nS2V5LnNpZ24oZXRoZXJzXzEuZXRoZXJzLmdldEJ5dGVzKHRoaXMuZ2V0VHlwZWREYXRhSGFzaCgpKSkuc2VyaWFsaXplZDtcbiAgICAgICAgdGhpcy5tb2RlbC5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgICAgIHJldHVybiBzaWduYXR1cmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3BvbnNvcmVkIFNlbmQgaGFzIGJlZW4gc2lnbmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgaWYgdGhlIFNwb25zb3JlZCBTZW5kIGhhcyBiZWVuIHNpZ25lZC5cbiAgICAgKi9cbiAgICBpc1NpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRTaWduYXR1cmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBTcG9uc29yZWQgU2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBTdGF0dXMgb2YgdGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNJR05FRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNJR05FRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNVQk1JVFRFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLlNVQk1JVFRFRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNwb25zb3JlZCBTZW5kIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTcG9uc29yZWQgU2VuZCBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICBpZiAoIXN0YXR1cylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFt0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuQ09NUExFVEUsIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRURdLmluY2x1ZGVzKHN0YXR1cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFNwb25zb3JlZCBTZW5kLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2hcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFNwb25zb3JlZCBTZW5kIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFNwb25zb3JlZCBTZW5kIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFuc2FjdGlvbl9saW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTcG9uc29yZWQgU2VuZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTcG9uc29yZWQgU2VuZFxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFNwb25zb3JlZFNlbmQgeyB0cmFuc2FjdGlvbkhhc2g6ICcke3RoaXMuZ2V0VHJhbnNhY3Rpb25IYXNoKCl9Jywgc3RhdHVzOiAnJHt0aGlzLmdldFN0YXR1cygpfScsIHR5cGVkRGF0YUhhc2g6ICcke3RoaXMuZ2V0VHlwZWREYXRhSGFzaCgpfScsIHNpZ25hdHVyZTogJHt0aGlzLmdldFNpZ25hdHVyZSgpfSwgdHJhbnNhY3Rpb25MaW5rOiAke3RoaXMuZ2V0VHJhbnNhY3Rpb25MaW5rKCl9IH1gO1xuICAgIH1cbn1cbmV4cG9ydHMuU3BvbnNvcmVkU2VuZCA9IFNwb25zb3JlZFNlbmQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingBalance = void 0;\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of the staking balance for a given asset on a specific date.\n */\nclass StakingBalance {\n    /**\n     * Creates the StakingBalance object.\n     *\n     * @param model - The underlying staking balance object.\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Returns a list of StakingBalances for the provided network, asset, and address.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressId - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @returns The staking balances.\n     */\n    static async list(networkId, assetId, addressId, startTime, endTime) {\n        const stakingBalances = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchHistoricalStakingBalances(networkId, assetId, addressId, startTime, endTime, 100, page?.length ? page : undefined);\n            response.data.data.forEach(stakingBalance => {\n                stakingBalances.push(new StakingBalance(stakingBalance));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingBalances;\n    }\n    /**\n     * Returns the bonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    bondedStake() {\n        return balance_1.Balance.fromModel(this.model.bonded_stake);\n    }\n    /**\n     * Returns the unbonded stake amount of the StakingBalance.\n     *\n     * @returns The Balance.\n     */\n    unbondedBalance() {\n        return balance_1.Balance.fromModel(this.model.unbonded_balance);\n    }\n    /**\n     * Returns the participant type of the address.\n     *\n     * @returns The participant type.\n     */\n    participantType() {\n        return this.model.participant_type;\n    }\n    /**\n     * Returns the date of the StakingBalance.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingBalance.\n     *\n     * @returns The onchain address.\n     */\n    address() {\n        return this.model.address;\n    }\n    /**\n     * Print the Staking Balance as a string.\n     *\n     * @returns The string representation of the Staking Balance.\n     */\n    toString() {\n        return `StakingBalance { date: '${this.date().toISOString()}' address: '${this.address()}' bondedStake: '${this.bondedStake().amount} ${this.bondedStake().asset?.assetId?.toUpperCase()}' unbondedBalance: '${this.unbondedBalance().amount} ${this.unbondedBalance().asset?.assetId?.toUpperCase()}' participantType: '${this.participantType()}' }`;\n    }\n}\nexports.StakingBalance = StakingBalance;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfYmFsYW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxTQUFTLDBCQUEwQixjQUFjLGVBQWUsa0JBQWtCLDJCQUEyQixFQUFFLGlEQUFpRCxzQkFBc0IsK0JBQStCLEVBQUUscURBQXFELHNCQUFzQix1QkFBdUIsR0FBRztBQUM3VjtBQUNBO0FBQ0Esc0JBQXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zdGFraW5nX2JhbGFuY2UuanM/ZTIxNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Rha2luZ0JhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBiYWxhbmNlXzEgPSByZXF1aXJlKFwiLi9iYWxhbmNlXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdGFraW5nIGJhbGFuY2UgZm9yIGEgZ2l2ZW4gYXNzZXQgb24gYSBzcGVjaWZpYyBkYXRlLlxuICovXG5jbGFzcyBTdGFraW5nQmFsYW5jZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgU3Rha2luZ0JhbGFuY2Ugb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgc3Rha2luZyBiYWxhbmNlIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIFN0YWtpbmdCYWxhbmNlcyBmb3IgdGhlIHByb3ZpZGVkIG5ldHdvcmssIGFzc2V0LCBhbmQgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkIC0gVGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIC0gVGhlIGVuZCB0aW1lLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIGJhbGFuY2VzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkLCBzdGFydFRpbWUsIGVuZFRpbWUpIHtcbiAgICAgICAgY29uc3Qgc3Rha2luZ0JhbGFuY2VzID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW1wiXCJdO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5mZXRjaEhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMobmV0d29ya0lkLCBhc3NldElkLCBhZGRyZXNzSWQsIHN0YXJ0VGltZSwgZW5kVGltZSwgMTAwLCBwYWdlPy5sZW5ndGggPyBwYWdlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHN0YWtpbmdCYWxhbmNlID0+IHtcbiAgICAgICAgICAgICAgICBzdGFraW5nQmFsYW5jZXMucHVzaChuZXcgU3Rha2luZ0JhbGFuY2Uoc3Rha2luZ0JhbGFuY2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuaGFzX21vcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFraW5nQmFsYW5jZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJvbmRlZCBzdGFrZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhbGFuY2UuXG4gICAgICovXG4gICAgYm9uZGVkU3Rha2UoKSB7XG4gICAgICAgIHJldHVybiBiYWxhbmNlXzEuQmFsYW5jZS5mcm9tTW9kZWwodGhpcy5tb2RlbC5ib25kZWRfc3Rha2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmJvbmRlZCBzdGFrZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEJhbGFuY2UuXG4gICAgICovXG4gICAgdW5ib25kZWRCYWxhbmNlKCkge1xuICAgICAgICByZXR1cm4gYmFsYW5jZV8xLkJhbGFuY2UuZnJvbU1vZGVsKHRoaXMubW9kZWwudW5ib25kZWRfYmFsYW5jZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcnRpY2lwYW50IHR5cGUgb2YgdGhlIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFydGljaXBhbnQgdHlwZS5cbiAgICAgKi9cbiAgICBwYXJ0aWNpcGFudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnBhcnRpY2lwYW50X3R5cGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGUgb2YgdGhlIFN0YWtpbmdCYWxhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGRhdGUuXG4gICAgICovXG4gICAgZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMubW9kZWwuZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9uY2hhaW4gYWRkcmVzcyBvZiB0aGUgU3Rha2luZ0JhbGFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb25jaGFpbiBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW50IHRoZSBTdGFraW5nIEJhbGFuY2UgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdGFraW5nIEJhbGFuY2UuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3Rha2luZ0JhbGFuY2UgeyBkYXRlOiAnJHt0aGlzLmRhdGUoKS50b0lTT1N0cmluZygpfScgYWRkcmVzczogJyR7dGhpcy5hZGRyZXNzKCl9JyBib25kZWRTdGFrZTogJyR7dGhpcy5ib25kZWRTdGFrZSgpLmFtb3VudH0gJHt0aGlzLmJvbmRlZFN0YWtlKCkuYXNzZXQ/LmFzc2V0SWQ/LnRvVXBwZXJDYXNlKCl9JyB1bmJvbmRlZEJhbGFuY2U6ICcke3RoaXMudW5ib25kZWRCYWxhbmNlKCkuYW1vdW50fSAke3RoaXMudW5ib25kZWRCYWxhbmNlKCkuYXNzZXQ/LmFzc2V0SWQ/LnRvVXBwZXJDYXNlKCl9JyBwYXJ0aWNpcGFudFR5cGU6ICcke3RoaXMucGFydGljaXBhbnRUeXBlKCl9JyB9YDtcbiAgICB9XG59XG5leHBvcnRzLlN0YWtpbmdCYWxhbmNlID0gU3Rha2luZ0JhbGFuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingOperation = void 0;\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a staking operation (stake, unstake, claim stake, etc.). It\n * may have multiple steps with some being transactions to sign, and others to wait.\n */\nclass StakingOperation {\n    /**\n     * Creates a StakingOperation object.\n     *\n     * @class\n     * @param model - The staking operation response from the API call.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n        this.transactions = [];\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Get the staking operation for the given ID.\n     *\n     * @param networkId - The network ID.\n     * @param addressId - The address ID.\n     * @param id - The staking operation ID.\n     * @param walletId - The wallet ID of the staking operation.\n     * @throws {Error} If the wallet id is defined but empty.\n     *\n     * @returns The staking operation object.\n     */\n    static async fetch(networkId, addressId, id, walletId) {\n        if (walletId === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(networkId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else if (walletId != undefined && walletId != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(walletId, addressId, id);\n            return new StakingOperation(result.data);\n        }\n        else {\n            throw new Error(\"Invalid wallet ID\");\n        }\n    }\n    /**\n     * Returns the Staking Operation ID.\n     *\n     * @returns The Staking Operation ID.\n     */\n    getID() {\n        return this.model.id;\n    }\n    /**\n     * Get the status of the staking operation.\n     *\n     * @returns The status of the staking operation.\n     */\n    getStatus() {\n        return this.model.status;\n    }\n    /**\n     * Returns the Wallet ID if it exists.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletID() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID.\n     *\n     * @returns The Address ID.\n     */\n    getAddressID() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Network ID.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkID() {\n        return this.model.network_id;\n    }\n    /**\n     * Return a human-readable string representation of the StakingOperation object.\n     *\n     * @returns The string representation of the StakingOperation object.\n     */\n    toString() {\n        return `StakingOperation { id: ${this.getID()} status: ${this.getStatus()} network_id: ${this.getNetworkID()} address_id: ${this.getAddressID()} }`;\n    }\n    /**\n     * Returns whether the Staking operation is in a terminal State.\n     *\n     * @returns Whether the Staking operation is in a terminal State\n     */\n    isTerminalState() {\n        return this.isCompleteState() || this.isFailedState();\n    }\n    /**\n     * Returns whether the Staking operation is in a failed state.\n     *\n     * @returns Whether the Staking operation is in a failed state.\n     */\n    isFailedState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Failed;\n    }\n    /**\n     * Returns whether the Staking operation is in a complete state.\n     *\n     * @returns Whether the Staking operation is in a complete state.\n     */\n    isCompleteState() {\n        return this.getStatus() === api_1.StakingOperationStatusEnum.Complete;\n    }\n    /**\n     * Get the transactions associated with this staking operation.\n     *\n     * @returns The array of transactions.\n     */\n    getTransactions() {\n        return this.transactions;\n    }\n    /**\n     * Get signed voluntary exit messages for native eth unstaking\n     *\n     * @returns The signed voluntary exit messages for a native eth unstaking operation.\n     */\n    getSignedVoluntaryExitMessages() {\n        const signedVoluntaryExitMessages = [];\n        if (this.model.metadata) {\n            this.model.metadata.forEach(metadata => {\n                const decodedSignedVoluntaryExitMessage = atob(metadata.signed_voluntary_exit);\n                signedVoluntaryExitMessages.push(decodedSignedVoluntaryExitMessage);\n            });\n        }\n        return signedVoluntaryExitMessages;\n    }\n    /**\n     * Reloads the StakingOperation model with the latest data from the server.\n     * If the StakingOperation object was created by an ExternalAddress then it will\n     * not have a wallet ID.\n     *\n     * @throws {APIError} if the API request to get the StakingOperation fails.\n     * @throws {Error} if this function is called on a StakingOperation without a wallet ID.\n     */\n    async reload() {\n        if (this.getWalletID() === undefined) {\n            const result = await coinbase_1.Coinbase.apiClients.stake.getExternalStakingOperation(this.getNetworkID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        else if (this.getWalletID() != undefined && this.getWalletID() != \"\") {\n            const result = await coinbase_1.Coinbase.apiClients.walletStake.getStakingOperation(this.getWalletID(), this.getAddressID(), this.getID());\n            this.model = result.data;\n        }\n        this.loadTransactionsFromModel();\n    }\n    /**\n     * Waits until the Staking Operation is completed or failed by polling its status at the given interval.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the StakingOperation to complete, in seconds\n     * @throws {Error} If the StakingOperation takes longer than the given timeout.\n     * @returns The completed StakingOperation object.\n     */\n    async wait({ intervalSeconds = 5, timeoutSeconds = 3600, } = {}) {\n        if (this.getWalletID() != undefined) {\n            throw new Error(\"cannot wait on staking operation for wallet address.\");\n        }\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.isTerminalState()) {\n                return this.model;\n            }\n            if (Date.now() - startTime > timeoutSeconds * 1000) {\n                throw new Error(\"Staking operation timed out\");\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Staking operation timed out\");\n    }\n    /**\n     * Sign the transactions in the StakingOperation object.\n     *\n     * @param key - The key used to sign the transactions.\n     */\n    async sign(key) {\n        for (const tx of this.transactions) {\n            if (!tx.isSigned()) {\n                await tx.sign(key);\n            }\n        }\n    }\n    /**\n     * loadTransactionsFromModel loads new unsigned transactions from the model into the transactions array.\n     * Note: For External Address model since tx signing and broadcast status happens by the end user and not our backend\n     * we need to be careful to not overwrite the transactions array with the response from the API. Ex: End user could have used\n     * stakingOperation.sign() method to sign the transactions, and we should not overwrite them with the response from the API.\n     * This however is ok to do so for the Wallet Address model since the transactions states are maintained by our backend.\n     * This method attempts to be safe for both address models, and only adds newly created unsigned transactions that are not\n     *  already in the transactions array.\n     */\n    loadTransactionsFromModel() {\n        // Only overwrite the transactions if the response is populated.\n        if (this.model.transactions && this.model.transactions.length > 0) {\n            // Create a set of existing unsigned payloads to avoid duplicates.\n            const existingUnsignedPayloads = new Set(this.transactions.map(tx => tx.getUnsignedPayload()));\n            // Add transactions that are not already in the transactions array.\n            this.model.transactions.forEach(transaction => {\n                if (!existingUnsignedPayloads.has(transaction.unsigned_payload)) {\n                    this.transactions.push(new transaction_1.Transaction(transaction));\n                }\n            });\n        }\n    }\n}\nexports.StakingOperation = StakingOperation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfb3BlcmF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixjQUFjLG1CQUFPLENBQUMscUZBQWU7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSxjQUFjLFVBQVUsa0JBQWtCLGNBQWMscUJBQXFCLGNBQWMsc0JBQXNCO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQSxpQkFBaUIsOENBQThDLElBQUk7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfb3BlcmF0aW9uLmpzP2JhODAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YWtpbmdPcGVyYXRpb24gPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCIuLi9jbGllbnQvYXBpXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgc3Rha2luZyBvcGVyYXRpb24gKHN0YWtlLCB1bnN0YWtlLCBjbGFpbSBzdGFrZSwgZXRjLikuIEl0XG4gKiBtYXkgaGF2ZSBtdWx0aXBsZSBzdGVwcyB3aXRoIHNvbWUgYmVpbmcgdHJhbnNhY3Rpb25zIHRvIHNpZ24sIGFuZCBvdGhlcnMgdG8gd2FpdC5cbiAqL1xuY2xhc3MgU3Rha2luZ09wZXJhdGlvbiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHN0YWtpbmcgb3BlcmF0aW9uIHJlc3BvbnNlIGZyb20gdGhlIEFQSSBjYWxsLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMubG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWtpbmcgb3BlcmF0aW9uIGZvciB0aGUgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBhZGRyZXNzIElELlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBJRC5cbiAgICAgKiBAcGFyYW0gd2FsbGV0SWQgLSBUaGUgd2FsbGV0IElEIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIHdhbGxldCBpZCBpcyBkZWZpbmVkIGJ1dCBlbXB0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGZldGNoKG5ldHdvcmtJZCwgYWRkcmVzc0lkLCBpZCwgd2FsbGV0SWQpIHtcbiAgICAgICAgaWYgKHdhbGxldElkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24obmV0d29ya0lkLCBhZGRyZXNzSWQsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Rha2luZ09wZXJhdGlvbihyZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAod2FsbGV0SWQgIT0gdW5kZWZpbmVkICYmIHdhbGxldElkICE9IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXRTdGFrZS5nZXRTdGFraW5nT3BlcmF0aW9uKHdhbGxldElkLCBhZGRyZXNzSWQsIGlkKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3Rha2luZ09wZXJhdGlvbihyZXN1bHQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHdhbGxldCBJRFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTdGFraW5nIE9wZXJhdGlvbiBJRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGFraW5nIE9wZXJhdGlvbiBJRC5cbiAgICAgKi9cbiAgICBnZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhdHVzIG9mIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGF0dXMgb2YgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBZGRyZXNzIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFN0YWtpbmdPcGVyYXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3Rha2luZ09wZXJhdGlvbiB7IGlkOiAke3RoaXMuZ2V0SUQoKX0gc3RhdHVzOiAke3RoaXMuZ2V0U3RhdHVzKCl9IG5ldHdvcmtfaWQ6ICR7dGhpcy5nZXROZXR3b3JrSUQoKX0gYWRkcmVzc19pZDogJHt0aGlzLmdldEFkZHJlc3NJRCgpfSB9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgU3Rha2luZyBvcGVyYXRpb24gaXMgaW4gYSB0ZXJtaW5hbCBTdGF0ZVxuICAgICAqL1xuICAgIGlzVGVybWluYWxTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDb21wbGV0ZVN0YXRlKCkgfHwgdGhpcy5pc0ZhaWxlZFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgU3Rha2luZyBvcGVyYXRpb24gaXMgaW4gYSBmYWlsZWQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIGZhaWxlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBpc0ZhaWxlZFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGF0dXMoKSA9PT0gYXBpXzEuU3Rha2luZ09wZXJhdGlvblN0YXR1c0VudW0uRmFpbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFN0YWtpbmcgb3BlcmF0aW9uIGlzIGluIGEgY29tcGxldGUgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBTdGFraW5nIG9wZXJhdGlvbiBpcyBpbiBhIGNvbXBsZXRlIHN0YXRlLlxuICAgICAqL1xuICAgIGlzQ29tcGxldGVTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdHVzKCkgPT09IGFwaV8xLlN0YWtpbmdPcGVyYXRpb25TdGF0dXNFbnVtLkNvbXBsZXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5zYWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhpcyBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhcnJheSBvZiB0cmFuc2FjdGlvbnMuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaWduZWQgdm9sdW50YXJ5IGV4aXQgbWVzc2FnZXMgZm9yIG5hdGl2ZSBldGggdW5zdGFraW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc2lnbmVkIHZvbHVudGFyeSBleGl0IG1lc3NhZ2VzIGZvciBhIG5hdGl2ZSBldGggdW5zdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXRTaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5tZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5tZXRhZGF0YS5mb3JFYWNoKG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVkU2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2UgPSBhdG9iKG1ldGFkYXRhLnNpZ25lZF92b2x1bnRhcnlfZXhpdCk7XG4gICAgICAgICAgICAgICAgc2lnbmVkVm9sdW50YXJ5RXhpdE1lc3NhZ2VzLnB1c2goZGVjb2RlZFNpZ25lZFZvbHVudGFyeUV4aXRNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduZWRWb2x1bnRhcnlFeGl0TWVzc2FnZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbG9hZHMgdGhlIFN0YWtpbmdPcGVyYXRpb24gbW9kZWwgd2l0aCB0aGUgbGF0ZXN0IGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqIElmIHRoZSBTdGFraW5nT3BlcmF0aW9uIG9iamVjdCB3YXMgY3JlYXRlZCBieSBhbiBFeHRlcm5hbEFkZHJlc3MgdGhlbiBpdCB3aWxsXG4gICAgICogbm90IGhhdmUgYSB3YWxsZXQgSUQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCB0aGUgU3Rha2luZ09wZXJhdGlvbiBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gYSBTdGFraW5nT3BlcmF0aW9uIHdpdGhvdXQgYSB3YWxsZXQgSUQuXG4gICAgICovXG4gICAgYXN5bmMgcmVsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRXYWxsZXRJRCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5nZXRFeHRlcm5hbFN0YWtpbmdPcGVyYXRpb24odGhpcy5nZXROZXR3b3JrSUQoKSwgdGhpcy5nZXRBZGRyZXNzSUQoKSwgdGhpcy5nZXRJRCgpKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmdldFdhbGxldElEKCkgIT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0V2FsbGV0SUQoKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0U3Rha2UuZ2V0U3Rha2luZ09wZXJhdGlvbih0aGlzLmdldFdhbGxldElEKCksIHRoaXMuZ2V0QWRkcmVzc0lEKCksIHRoaXMuZ2V0SUQoKSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkVHJhbnNhY3Rpb25zRnJvbU1vZGVsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBTdGFraW5nIE9wZXJhdGlvbiBpcyBjb21wbGV0ZWQgb3IgZmFpbGVkIGJ5IHBvbGxpbmcgaXRzIHN0YXR1cyBhdCB0aGUgZ2l2ZW4gaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCwgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFN0YWtpbmdPcGVyYXRpb24gdG8gY29tcGxldGUsIGluIHNlY29uZHNcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIFN0YWtpbmdPcGVyYXRpb24gdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCBTdGFraW5nT3BlcmF0aW9uIG9iamVjdC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0KHsgaW50ZXJ2YWxTZWNvbmRzID0gNSwgdGltZW91dFNlY29uZHMgPSAzNjAwLCB9ID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2FsbGV0SUQoKSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCB3YWl0IG9uIHN0YWtpbmcgb3BlcmF0aW9uIGZvciB3YWxsZXQgYWRkcmVzcy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1Rlcm1pbmFsU3RhdGUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFraW5nIG9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdGFraW5nIG9wZXJhdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ24gdGhlIHRyYW5zYWN0aW9ucyBpbiB0aGUgU3Rha2luZ09wZXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB1c2VkIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBmb3IgKGNvbnN0IHR4IG9mIHRoaXMudHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoIXR4LmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0eC5zaWduKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogbG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCBsb2FkcyBuZXcgdW5zaWduZWQgdHJhbnNhY3Rpb25zIGZyb20gdGhlIG1vZGVsIGludG8gdGhlIHRyYW5zYWN0aW9ucyBhcnJheS5cbiAgICAgKiBOb3RlOiBGb3IgRXh0ZXJuYWwgQWRkcmVzcyBtb2RlbCBzaW5jZSB0eCBzaWduaW5nIGFuZCBicm9hZGNhc3Qgc3RhdHVzIGhhcHBlbnMgYnkgdGhlIGVuZCB1c2VyIGFuZCBub3Qgb3VyIGJhY2tlbmRcbiAgICAgKiB3ZSBuZWVkIHRvIGJlIGNhcmVmdWwgdG8gbm90IG92ZXJ3cml0ZSB0aGUgdHJhbnNhY3Rpb25zIGFycmF5IHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS4gRXg6IEVuZCB1c2VyIGNvdWxkIGhhdmUgdXNlZFxuICAgICAqIHN0YWtpbmdPcGVyYXRpb24uc2lnbigpIG1ldGhvZCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbnMsIGFuZCB3ZSBzaG91bGQgbm90IG92ZXJ3cml0ZSB0aGVtIHdpdGggdGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKiBUaGlzIGhvd2V2ZXIgaXMgb2sgdG8gZG8gc28gZm9yIHRoZSBXYWxsZXQgQWRkcmVzcyBtb2RlbCBzaW5jZSB0aGUgdHJhbnNhY3Rpb25zIHN0YXRlcyBhcmUgbWFpbnRhaW5lZCBieSBvdXIgYmFja2VuZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBhdHRlbXB0cyB0byBiZSBzYWZlIGZvciBib3RoIGFkZHJlc3MgbW9kZWxzLCBhbmQgb25seSBhZGRzIG5ld2x5IGNyZWF0ZWQgdW5zaWduZWQgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vdFxuICAgICAqICBhbHJlYWR5IGluIHRoZSB0cmFuc2FjdGlvbnMgYXJyYXkuXG4gICAgICovXG4gICAgbG9hZFRyYW5zYWN0aW9uc0Zyb21Nb2RlbCgpIHtcbiAgICAgICAgLy8gT25seSBvdmVyd3JpdGUgdGhlIHRyYW5zYWN0aW9ucyBpZiB0aGUgcmVzcG9uc2UgaXMgcG9wdWxhdGVkLlxuICAgICAgICBpZiAodGhpcy5tb2RlbC50cmFuc2FjdGlvbnMgJiYgdGhpcy5tb2RlbC50cmFuc2FjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGV4aXN0aW5nIHVuc2lnbmVkIHBheWxvYWRzIHRvIGF2b2lkIGR1cGxpY2F0ZXMuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ1Vuc2lnbmVkUGF5bG9hZHMgPSBuZXcgU2V0KHRoaXMudHJhbnNhY3Rpb25zLm1hcCh0eCA9PiB0eC5nZXRVbnNpZ25lZFBheWxvYWQoKSkpO1xuICAgICAgICAgICAgLy8gQWRkIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBub3QgYWxyZWFkeSBpbiB0aGUgdHJhbnNhY3Rpb25zIGFycmF5LlxuICAgICAgICAgICAgdGhpcy5tb2RlbC50cmFuc2FjdGlvbnMuZm9yRWFjaCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFleGlzdGluZ1Vuc2lnbmVkUGF5bG9hZHMuaGFzKHRyYW5zYWN0aW9uLnVuc2lnbmVkX3BheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLnB1c2gobmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3Rha2luZ09wZXJhdGlvbiA9IFN0YWtpbmdPcGVyYXRpb247XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StakingReward = void 0;\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a staking reward earned on a network for a given asset.\n */\nclass StakingReward {\n    /**\n     * Creates the StakingReward object.\n     *\n     * @param model - The underlying staking reward object.\n     * @param asset - The asset for the staking reward.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     */\n    constructor(model, asset, format) {\n        this.model = model;\n        this.asset = asset;\n        this.format = format;\n    }\n    /**\n     * Returns a list of StakingRewards for the provided network, asset, and addresses.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param addressIds - The address ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @returns The staking rewards.\n     */\n    static async list(networkId, assetId, addressIds, startTime, endTime, format = types_1.StakingRewardFormat.USD) {\n        const stakingRewards = [];\n        const queue = [\"\"];\n        while (queue.length > 0) {\n            const page = queue.shift();\n            const request = {\n                network_id: coinbase_1.Coinbase.normalizeNetwork(networkId),\n                asset_id: assetId,\n                address_ids: addressIds,\n                start_time: startTime,\n                end_time: endTime,\n                format: format,\n            };\n            const response = await coinbase_1.Coinbase.apiClients.stake.fetchStakingRewards(request, 100, page?.length ? page : undefined);\n            const asset = await asset_1.Asset.fetch(networkId, assetId);\n            response.data.data.forEach(stakingReward => {\n                stakingRewards.push(new StakingReward(stakingReward, asset, format));\n            });\n            if (response.data.has_more) {\n                if (response.data.next_page) {\n                    queue.push(response.data.next_page);\n                }\n            }\n        }\n        return stakingRewards;\n    }\n    /**\n     * Returns the amount of the StakingReward.\n     *\n     * @returns The amount.\n     */\n    amount() {\n        if (this.model.amount == \"\")\n            return 0;\n        if (this.format == types_1.StakingRewardFormat.USD) {\n            return new decimal_js_1.default(this.model.amount).div(new decimal_js_1.default(\"100\"));\n        }\n        return this.asset.fromAtomicAmount(new decimal_js_1.default(this.model.amount)).toNumber();\n    }\n    /**\n     * Returns the date of the StakingReward.\n     *\n     * @returns The date.\n     */\n    date() {\n        return new Date(this.model.date);\n    }\n    /**\n     * Returns the onchain address of the StakingReward.\n     *\n     * @returns The onchain address.\n     */\n    addressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the USD value of the StakingReward.\n     *\n     * @returns The USD value.\n     */\n    usdValue() {\n        return new decimal_js_1.default(this.model.usd_value.amount).div(new decimal_js_1.default(\"100\"));\n    }\n    /**\n     * Returns the conversion price of the StakingReward in USD.\n     *\n     * @returns The conversion price.\n     */\n    conversionPrice() {\n        return new decimal_js_1.default(this.model.usd_value.conversion_price);\n    }\n    /**\n     * Returns the time of calculating the conversion price.\n     *\n     * @returns The conversion time.\n     */\n    conversionTime() {\n        return new Date(this.model.usd_value.conversion_time);\n    }\n    /**\n     * Print the Staking Reward as a string.\n     *\n     * @returns The string representation of the Staking Reward.\n     */\n    toString() {\n        return `StakingReward { date: '${this.date().toISOString()}' address: '${this.addressId()}' amount: '${this.amount().toString()}' usd_value: '${this.usdValue().toString()}' conversion_price: '${this.conversionPrice().toString()}' conversion_time: '${this.conversionTime().toISOString()}' }`;\n    }\n}\nexports.StakingReward = StakingReward;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3N0YWtpbmdfcmV3YXJkLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFDQUFxQyxtQkFBTyxDQUFDLDhEQUFZO0FBQ3pELG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUywwQkFBMEIsY0FBYyxpQkFBaUIsYUFBYSx5QkFBeUIsZ0JBQWdCLDJCQUEyQix1QkFBdUIsa0NBQWtDLHNCQUFzQixvQ0FBb0MsR0FBRztBQUN6UztBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS9zdGFraW5nX3Jld2FyZC5qcz8yMDVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGFraW5nUmV3YXJkID0gdm9pZCAwO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi9hc3NldFwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHN0YWtpbmcgcmV3YXJkIGVhcm5lZCBvbiBhIG5ldHdvcmsgZm9yIGEgZ2l2ZW4gYXNzZXQuXG4gKi9cbmNsYXNzIFN0YWtpbmdSZXdhcmQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFN0YWtpbmdSZXdhcmQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgc3Rha2luZyByZXdhcmQgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBhc3NldCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgcmV3YXJkLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHJldHVybiB0aGUgcmV3YXJkcyBpbi4gKHVzZCwgbmF0aXZlKS4gRGVmYXVsdHMgdG8gdXNkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsLCBhc3NldCwgZm9ybWF0KSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICAgICAgdGhpcy5hc3NldCA9IGFzc2V0O1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgU3Rha2luZ1Jld2FyZHMgZm9yIHRoZSBwcm92aWRlZCBuZXR3b3JrLCBhc3NldCwgYW5kIGFkZHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc0lkcyAtIFRoZSBhZGRyZXNzIElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAcGFyYW0gZm9ybWF0IC0gVGhlIGZvcm1hdCB0byByZXR1cm4gdGhlIHJld2FyZHMgaW4uICh1c2QsIG5hdGl2ZSkuIERlZmF1bHRzIHRvIHVzZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyByZXdhcmRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBsaXN0KG5ldHdvcmtJZCwgYXNzZXRJZCwgYWRkcmVzc0lkcywgc3RhcnRUaW1lLCBlbmRUaW1lLCBmb3JtYXQgPSB0eXBlc18xLlN0YWtpbmdSZXdhcmRGb3JtYXQuVVNEKSB7XG4gICAgICAgIGNvbnN0IHN0YWtpbmdSZXdhcmRzID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW1wiXCJdO1xuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcGFnZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIG5ldHdvcmtfaWQ6IGNvaW5iYXNlXzEuQ29pbmJhc2Uubm9ybWFsaXplTmV0d29yayhuZXR3b3JrSWQpLFxuICAgICAgICAgICAgICAgIGFzc2V0X2lkOiBhc3NldElkLFxuICAgICAgICAgICAgICAgIGFkZHJlc3NfaWRzOiBhZGRyZXNzSWRzLFxuICAgICAgICAgICAgICAgIHN0YXJ0X3RpbWU6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgICAgICBlbmRfdGltZTogZW5kVGltZSxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy5zdGFrZS5mZXRjaFN0YWtpbmdSZXdhcmRzKHJlcXVlc3QsIDEwMCwgcGFnZT8ubGVuZ3RoID8gcGFnZSA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb25zdCBhc3NldCA9IGF3YWl0IGFzc2V0XzEuQXNzZXQuZmV0Y2gobmV0d29ya0lkLCBhc3NldElkKTtcbiAgICAgICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHN0YWtpbmdSZXdhcmQgPT4ge1xuICAgICAgICAgICAgICAgIHN0YWtpbmdSZXdhcmRzLnB1c2gobmV3IFN0YWtpbmdSZXdhcmQoc3Rha2luZ1Jld2FyZCwgYXNzZXQsIGZvcm1hdCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5oYXNfbW9yZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHRfcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWtpbmdSZXdhcmRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGhlIFN0YWtpbmdSZXdhcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYW1vdW50LlxuICAgICAqL1xuICAgIGFtb3VudCgpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuYW1vdW50ID09IFwiXCIpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0ID09IHR5cGVzXzEuU3Rha2luZ1Jld2FyZEZvcm1hdC5VU0QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQodGhpcy5tb2RlbC5hbW91bnQpLmRpdihuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoXCIxMDBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2V0LmZyb21BdG9taWNBbW91bnQobmV3IGRlY2ltYWxfanNfMS5kZWZhdWx0KHRoaXMubW9kZWwuYW1vdW50KSkudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0ZSBvZiB0aGUgU3Rha2luZ1Jld2FyZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkYXRlLlxuICAgICAqL1xuICAgIGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLm1vZGVsLmRhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvbmNoYWluIGFkZHJlc3Mgb2YgdGhlIFN0YWtpbmdSZXdhcmQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgb25jaGFpbiBhZGRyZXNzLlxuICAgICAqL1xuICAgIGFkZHJlc3NJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYWRkcmVzc19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVVNEIHZhbHVlIG9mIHRoZSBTdGFraW5nUmV3YXJkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFVTRCB2YWx1ZS5cbiAgICAgKi9cbiAgICB1c2RWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCh0aGlzLm1vZGVsLnVzZF92YWx1ZS5hbW91bnQpLmRpdihuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoXCIxMDBcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb252ZXJzaW9uIHByaWNlIG9mIHRoZSBTdGFraW5nUmV3YXJkIGluIFVTRC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJzaW9uIHByaWNlLlxuICAgICAqL1xuICAgIGNvbnZlcnNpb25QcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBkZWNpbWFsX2pzXzEuZGVmYXVsdCh0aGlzLm1vZGVsLnVzZF92YWx1ZS5jb252ZXJzaW9uX3ByaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGltZSBvZiBjYWxjdWxhdGluZyB0aGUgY29udmVyc2lvbiBwcmljZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjb252ZXJzaW9uIHRpbWUuXG4gICAgICovXG4gICAgY29udmVyc2lvblRpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLm1vZGVsLnVzZF92YWx1ZS5jb252ZXJzaW9uX3RpbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmludCB0aGUgU3Rha2luZyBSZXdhcmQgYXMgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBTdGFraW5nIFJld2FyZC5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBTdGFraW5nUmV3YXJkIHsgZGF0ZTogJyR7dGhpcy5kYXRlKCkudG9JU09TdHJpbmcoKX0nIGFkZHJlc3M6ICcke3RoaXMuYWRkcmVzc0lkKCl9JyBhbW91bnQ6ICcke3RoaXMuYW1vdW50KCkudG9TdHJpbmcoKX0nIHVzZF92YWx1ZTogJyR7dGhpcy51c2RWYWx1ZSgpLnRvU3RyaW5nKCl9JyBjb252ZXJzaW9uX3ByaWNlOiAnJHt0aGlzLmNvbnZlcnNpb25QcmljZSgpLnRvU3RyaW5nKCl9JyBjb252ZXJzaW9uX3RpbWU6ICcke3RoaXMuY29udmVyc2lvblRpbWUoKS50b0lTT1N0cmluZygpfScgfWA7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFraW5nUmV3YXJkID0gU3Rha2luZ1Jld2FyZDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Trade = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of a Trade, which trades an amount of an Asset to another Asset on a Network.\n * The fee is assumed to be paid in the native Asset of the Network.\n */\nclass Trade {\n    /**\n     * Trades should be created through Wallet.trade or Address.trade.\n     *\n     * @class\n     * @param model - The underlying Trade object.\n     * @throws {Error} - If the Trade model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Trade model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Trade ID.\n     *\n     * @returns The Trade ID.\n     */\n    getId() {\n        return this.model.trade_id;\n    }\n    /**\n     * Returns the Network ID of the Trade.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Trade.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the Address ID of the Trade.\n     *\n     * @returns The Address ID.\n     */\n    getAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the From Asset ID of the Trade.\n     *\n     * @returns The From Asset ID.\n     */\n    getFromAssetId() {\n        return this.model.from_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the from asset for the Trade.\n     *\n     * @returns The amount of the from asset.\n     */\n    getFromAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.from_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.from_asset.decimals));\n    }\n    /**\n     * Returns the To Asset ID of the Trade.\n     *\n     * @returns The To Asset ID.\n     */\n    getToAssetId() {\n        return this.model.to_asset.asset_id;\n    }\n    /**\n     * Returns the amount of the to asset for the Trade.\n     *\n     * @returns The amount of the to asset.\n     */\n    getToAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.to_amount);\n        return amount.div(decimal_js_1.Decimal.pow(10, this.model.to_asset.decimals));\n    }\n    /**\n     * Returns the Trade transaction.\n     *\n     * @returns The Trade transaction.\n     */\n    getTransaction() {\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        return this.transaction;\n    }\n    /**\n     * Returns the approve transaction if it exists.\n     *\n     * @returns The approve transaction.\n     */\n    getApproveTransaction() {\n        if (!this.approveTransaction && this.model.approve_transaction) {\n            this.approveTransaction = new transaction_1.Transaction(this.model.approve_transaction);\n        }\n        return this.approveTransaction;\n    }\n    /**\n     * Signs the Trade with the provided key.\n     * This signs the transfer transaction and will sign the approval transaction if present.\n     *\n     * @param key - The key to sign the Transfer with\n     */\n    async sign(key) {\n        if (this.getApproveTransaction()) {\n            await this.getApproveTransaction().sign(key);\n        }\n        await this.getTransaction().sign(key);\n    }\n    /**\n     * Broadcasts the Trade to the Network.\n     *\n     * @returns The Trade object\n     * @throws {APIError} if the API request to broadcast a Trade fails.\n     */\n    async broadcast() {\n        const tx = this.getTransaction();\n        const approveTx = this.getApproveTransaction();\n        if (!tx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned transaction\");\n        }\n        if (approveTx && !approveTx.isSigned()) {\n            throw new errors_1.NotSignedError(\"Cannot broadcast Trade with unsigned approve transaction\");\n        }\n        const response = await coinbase_1.Coinbase.apiClients.trade.broadcastTrade(this.getWalletId(), tx.fromAddressId(), this.getId(), {\n            signed_payload: tx.getSignature(),\n            approve_transaction_signed_payload: approveTx ? approveTx.getSignature() : undefined,\n        });\n        this.resetModel(response.data);\n        return this;\n    }\n    /**\n     * Returns the status of the Trade.\n     *\n     * @returns The status.\n     */\n    getStatus() {\n        return this.getTransaction()?.getStatus();\n    }\n    /**\n     * Waits until the Trade is completed or failed by polling the Network at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval at which to poll the Network, in seconds\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the Trade to complete, in seconds\n     * @throws {Error} If the Trade takes longer than the given timeout.\n     * @throws {APIError} If the request fails.\n     * @returns The completed Trade object.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            if (this.getTransaction().isTerminalState()) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Trade timed out\");\n    }\n    /**\n     * Reloads the Trade model with the latest version from the server side.\n     *\n     * @returns The most recent version of Trade from the server.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.trade.getTrade(this.getWalletId(), this.getAddressId(), this.getId());\n        return this.resetModel(result?.data);\n    }\n    /**\n     * Returns a String representation of the Trade.\n     *\n     * @returns A String representation of the Trade.\n     */\n    toString() {\n        return (`Trade { transfer_id: '${this.getId()}', network_id: '${this.getNetworkId()}', ` +\n            `address_id: '${this.getAddressId()}', from_asset_id: '${this.getFromAssetId()}', ` +\n            `to_asset_id: '${this.getToAssetId()}', from_amount: '${this.getFromAmount()}', ` +\n            `to_amount: '${this.getToAmount()}', status: '${this.getStatus()}' }`);\n    }\n    /**\n     * Resets the trade model with the specified data from the server.\n     *\n     * @param model - The Trade model\n     * @returns The updated Trade object\n     */\n    resetModel(model) {\n        this.model = model;\n        this.transaction = new transaction_1.Transaction(this.model.transaction);\n        this.approveTransaction = this.model.approve_transaction\n            ? new transaction_1.Transaction(this.model.approve_transaction)\n            : undefined;\n        return this;\n    }\n}\nexports.Trade = Trade;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYWRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx5RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBVTtBQUNuQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLGlCQUFpQiw2Q0FBNkMsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0IsYUFBYSxrQkFBa0Isb0JBQW9CO0FBQzVGLDRCQUE0QixvQkFBb0IscUJBQXFCLHNCQUFzQjtBQUMzRiw2QkFBNkIsb0JBQW9CLG1CQUFtQixxQkFBcUI7QUFDekYsMkJBQTJCLG1CQUFtQixjQUFjLGlCQUFpQixHQUFHO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdHJhZGUuanM/MTJjOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhZGUgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgVHJhZGUsIHdoaWNoIHRyYWRlcyBhbiBhbW91bnQgb2YgYW4gQXNzZXQgdG8gYW5vdGhlciBBc3NldCBvbiBhIE5ldHdvcmsuXG4gKiBUaGUgZmVlIGlzIGFzc3VtZWQgdG8gYmUgcGFpZCBpbiB0aGUgbmF0aXZlIEFzc2V0IG9mIHRoZSBOZXR3b3JrLlxuICovXG5jbGFzcyBUcmFkZSB7XG4gICAgLyoqXG4gICAgICogVHJhZGVzIHNob3VsZCBiZSBjcmVhdGVkIHRocm91Z2ggV2FsbGV0LnRyYWRlIG9yIEFkZHJlc3MudHJhZGUuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBUcmFkZSBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgdGhlIFRyYWRlIG1vZGVsIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYWRlIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYWRlIElELlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYWRlIElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFkZV9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgTmV0d29yayBJRC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLm5ldHdvcmtfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFdhbGxldCBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0IElELlxuICAgICAqL1xuICAgIGdldFdhbGxldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC53YWxsZXRfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEFkZHJlc3MgSUQgb2YgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFkZHJlc3MgSUQuXG4gICAgICovXG4gICAgZ2V0QWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFzc2V0IElEIG9mIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGcm9tIEFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEZyb21Bc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mcm9tX2Fzc2V0LmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhbW91bnQgb2YgdGhlIGZyb20gYXNzZXQgZm9yIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhbW91bnQgb2YgdGhlIGZyb20gYXNzZXQuXG4gICAgICovXG4gICAgZ2V0RnJvbUFtb3VudCgpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKHRoaXMubW9kZWwuZnJvbV9hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50LmRpdihkZWNpbWFsX2pzXzEuRGVjaW1hbC5wb3coMTAsIHRoaXMubW9kZWwuZnJvbV9hc3NldC5kZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUbyBBc3NldCBJRCBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVG8gQXNzZXQgSUQuXG4gICAgICovXG4gICAgZ2V0VG9Bc3NldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50b19hc3NldC5hc3NldF9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYW1vdW50IG9mIHRoZSB0byBhc3NldCBmb3IgdGhlIFRyYWRlLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFtb3VudCBvZiB0aGUgdG8gYXNzZXQuXG4gICAgICovXG4gICAgZ2V0VG9BbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh0aGlzLm1vZGVsLnRvX2Ftb3VudCk7XG4gICAgICAgIHJldHVybiBhbW91bnQuZGl2KGRlY2ltYWxfanNfMS5EZWNpbWFsLnBvdygxMCwgdGhpcy5tb2RlbC50b19hc3NldC5kZWNpbWFscykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBUcmFkZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFkZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwudHJhbnNhY3Rpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm92ZSB0cmFuc2FjdGlvbiBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92ZSB0cmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICBnZXRBcHByb3ZlVHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gJiYgdGhpcy5tb2RlbC5hcHByb3ZlX3RyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFwcHJvdmVUcmFuc2FjdGlvbiA9IG5ldyB0cmFuc2FjdGlvbl8xLlRyYW5zYWN0aW9uKHRoaXMubW9kZWwuYXBwcm92ZV90cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwcm92ZVRyYW5zYWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyB0aGUgVHJhZGUgd2l0aCB0aGUgcHJvdmlkZWQga2V5LlxuICAgICAqIFRoaXMgc2lnbnMgdGhlIHRyYW5zZmVyIHRyYW5zYWN0aW9uIGFuZCB3aWxsIHNpZ24gdGhlIGFwcHJvdmFsIHRyYW5zYWN0aW9uIGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSB0byBzaWduIHRoZSBUcmFuc2ZlciB3aXRoXG4gICAgICovXG4gICAgYXN5bmMgc2lnbihrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0QXBwcm92ZVRyYW5zYWN0aW9uKCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0QXBwcm92ZVRyYW5zYWN0aW9uKCkuc2lnbihrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKS5zaWduKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFRyYWRlIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYWRlIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhZGUgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0KCkge1xuICAgICAgICBjb25zdCB0eCA9IHRoaXMuZ2V0VHJhbnNhY3Rpb24oKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZVR4ID0gdGhpcy5nZXRBcHByb3ZlVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgaWYgKCF0eC5pc1NpZ25lZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuTm90U2lnbmVkRXJyb3IoXCJDYW5ub3QgYnJvYWRjYXN0IFRyYWRlIHdpdGggdW5zaWduZWQgdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFwcHJvdmVUeCAmJiAhYXBwcm92ZVR4LmlzU2lnbmVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob3RTaWduZWRFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgVHJhZGUgd2l0aCB1bnNpZ25lZCBhcHByb3ZlIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYWRlLmJyb2FkY2FzdFRyYWRlKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdHguZnJvbUFkZHJlc3NJZCgpLCB0aGlzLmdldElkKCksIHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0eC5nZXRTaWduYXR1cmUoKSxcbiAgICAgICAgICAgIGFwcHJvdmVfdHJhbnNhY3Rpb25fc2lnbmVkX3BheWxvYWQ6IGFwcHJvdmVUeCA/IGFwcHJvdmVUeC5nZXRTaWduYXR1cmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzZXRNb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdHVzLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNhY3Rpb24oKT8uZ2V0U3RhdHVzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhaXRzIHVudGlsIHRoZSBUcmFkZSBpcyBjb21wbGV0ZWQgb3IgZmFpbGVkIGJ5IHBvbGxpbmcgdGhlIE5ldHdvcmsgYXQgdGhlIGdpdmVuIGludGVydmFsLlxuICAgICAqIFJhaXNlcyBhbiBlcnJvciBpZiB0aGUgVHJhZGUgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbmZpZ3VyZSB0aGUgd2FpdCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbFNlY29uZHMgLSBUaGUgaW50ZXJ2YWwgYXQgd2hpY2ggdG8gcG9sbCB0aGUgTmV0d29yaywgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFRyYWRlIHRvIGNvbXBsZXRlLCBpbiBzZWNvbmRzXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBUcmFkZSB0YWtlcyBsb25nZXIgdGhhbiB0aGUgZ2l2ZW4gdGltZW91dC5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICogQHJldHVybnMgVGhlIGNvbXBsZXRlZCBUcmFkZSBvYmplY3QuXG4gICAgICovXG4gICAgYXN5bmMgd2FpdCh7IGludGVydmFsU2Vjb25kcyA9IDAuMiwgdGltZW91dFNlY29uZHMgPSAxMCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVsb2FkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRUcmFuc2FjdGlvbigpLmlzVGVybWluYWxTdGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiVHJhZGUgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBUcmFkZSBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgdmVyc2lvbiBmcm9tIHRoZSBzZXJ2ZXIgc2lkZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBtb3N0IHJlY2VudCB2ZXJzaW9uIG9mIFRyYWRlIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBhc3luYyByZWxvYWQoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy50cmFkZS5nZXRUcmFkZSh0aGlzLmdldFdhbGxldElkKCksIHRoaXMuZ2V0QWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2V0TW9kZWwocmVzdWx0Py5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhZGUuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFRyYWRlIHsgdHJhbnNmZXJfaWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrX2lkOiAnJHt0aGlzLmdldE5ldHdvcmtJZCgpfScsIGAgK1xuICAgICAgICAgICAgYGFkZHJlc3NfaWQ6ICcke3RoaXMuZ2V0QWRkcmVzc0lkKCl9JywgZnJvbV9hc3NldF9pZDogJyR7dGhpcy5nZXRGcm9tQXNzZXRJZCgpfScsIGAgK1xuICAgICAgICAgICAgYHRvX2Fzc2V0X2lkOiAnJHt0aGlzLmdldFRvQXNzZXRJZCgpfScsIGZyb21fYW1vdW50OiAnJHt0aGlzLmdldEZyb21BbW91bnQoKX0nLCBgICtcbiAgICAgICAgICAgIGB0b19hbW91bnQ6ICcke3RoaXMuZ2V0VG9BbW91bnQoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JyB9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgdHJhZGUgbW9kZWwgd2l0aCB0aGUgc3BlY2lmaWVkIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIFRyYWRlIG1vZGVsXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVHJhZGUgb2JqZWN0XG4gICAgICovXG4gICAgcmVzZXRNb2RlbChtb2RlbCkge1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMudHJhbnNhY3Rpb24gPSBuZXcgdHJhbnNhY3Rpb25fMS5UcmFuc2FjdGlvbih0aGlzLm1vZGVsLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5hcHByb3ZlVHJhbnNhY3Rpb24gPSB0aGlzLm1vZGVsLmFwcHJvdmVfdHJhbnNhY3Rpb25cbiAgICAgICAgICAgID8gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC5hcHByb3ZlX3RyYW5zYWN0aW9uKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhZGUgPSBUcmFkZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transaction = void 0;\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\n/**\n * A representation of an onchain Transaction.\n */\nclass Transaction {\n    /**\n     * Transactions should be constructed via higher level abstractions like Trade or Transfer.\n     *\n     * @class\n     * @param model - The underlying Transaction object.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the Unsigned Payload of the Transaction.\n     *\n     * @returns The Unsigned Payload\n     */\n    getUnsignedPayload() {\n        return this.model.unsigned_payload;\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignedPayload() {\n        return this.model.signed_payload;\n    }\n    /**\n     * Returns the Transaction Hash of the Transaction.\n     *\n     * @returns The Transaction Hash\n     */\n    getTransactionHash() {\n        return this.model.transaction_hash;\n    }\n    /**\n     * Returns the Status of the Transaction.\n     *\n     * @returns The Status\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransactionStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransactionStatus.BROADCAST;\n            case types_1.TransactionStatus.SIGNED:\n                return types_1.TransactionStatus.SIGNED;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransactionStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransactionStatus.FAILED;\n            default:\n                return types_1.TransactionStatus.UNSPECIFIED;\n        }\n    }\n    /**\n     * Returns whether the Transaction is in a terminal State.\n     *\n     * @returns Whether the Transaction is in a terminal State\n     */\n    isTerminalState() {\n        const status = this.getStatus();\n        return [types_1.TransactionStatus.COMPLETE, types_1.TransactionStatus.FAILED].includes(status);\n    }\n    /**\n     * Returns the From Address ID for the Transaction.\n     *\n     * @returns The From Address ID\n     */\n    fromAddressId() {\n        return this.model.from_address_id;\n    }\n    /**\n     * Returns the To Address ID for the Transaction if it's available.\n     *\n     * @returns The To Address ID\n     */\n    toAddressId() {\n        return this.model.to_address_id;\n    }\n    /**\n     * Returns the Block Height where the Transaction is recorded.\n     *\n     * @returns The Block Height\n     */\n    blockHeight() {\n        return this.model.block_height;\n    }\n    /**\n     * Returns the Block Hash where the Transaction is recorded.\n     *\n     * @returns The Block Hash\n     */\n    blockHash() {\n        return this.model.block_hash;\n    }\n    /**\n     * Returns the Content of the Transaction.\n     *\n     * @returns The transaction content\n     */\n    content() {\n        return this.model.content;\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer\n     */\n    getTransactionLink() {\n        return this.model.transaction_link;\n    }\n    /**\n     * Returns the Network ID of the Transaction.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the underlying raw transaction.\n     *\n     * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n     * @returns The ethers.js Transaction object\n     */\n    rawTransaction() {\n        if (this.raw) {\n            return this.raw;\n        }\n        const parsedPayload = (0, utils_1.parseUnsignedPayload)(this.getUnsignedPayload());\n        const transaction = new ethers_1.ethers.Transaction();\n        transaction.chainId = BigInt(parsedPayload.chainId);\n        transaction.nonce = BigInt(parsedPayload.nonce);\n        transaction.maxPriorityFeePerGas = BigInt(parsedPayload.maxPriorityFeePerGas);\n        transaction.maxFeePerGas = BigInt(parsedPayload.maxFeePerGas);\n        // TODO: Handle multiple currencies.\n        transaction.gasLimit = BigInt(parsedPayload.gas);\n        transaction.to = parsedPayload.to;\n        transaction.value = BigInt(parsedPayload.value);\n        transaction.data = parsedPayload.input;\n        this.raw = transaction;\n        return this.raw;\n    }\n    /**\n     * Signs the Transaction with the provided key and returns the hex signing payload.\n     *\n     * @param key - The key to sign the transaction with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        const signedPayload = await key.signTransaction(this.rawTransaction());\n        this.model.signed_payload = signedPayload;\n        // Removes the '0x' prefix as required by the API.\n        return signedPayload.slice(2);\n    }\n    /**\n     * Returns the Signed Payload of the Transaction.\n     *\n     * @returns The Signed Payload\n     */\n    getSignature() {\n        return this.getSignedPayload()?.slice(2);\n    }\n    /**\n     * Returns whether the transaction has been signed.\n     *\n     * @returns if the transaction has been signed.\n     */\n    isSigned() {\n        return !!this.getSignature();\n    }\n    /**\n     * Returns a string representation of the Transaction.\n     *\n     * @returns A string representation of the Transaction.\n     */\n    toString() {\n        return `Transaction { transactionHash: '${this.getTransactionHash()}', status: '${this.getStatus()}', unsignedPayload: '${this.getUnsignedPayload()}', signedPayload: ${this.getSignedPayload()}, transactionLink: ${this.getTransactionLink()} }`;\n    }\n}\nexports.Transaction = Transaction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zYWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQjtBQUNuQixpQkFBaUIsbUJBQU8sQ0FBQyxpRUFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsMEJBQTBCLGNBQWMsaUJBQWlCLHVCQUF1QiwwQkFBMEIsb0JBQW9CLHdCQUF3QixxQkFBcUIsNEJBQTRCO0FBQ3pQO0FBQ0E7QUFDQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zYWN0aW9uLmpzPzE4YzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uID0gdm9pZCAwO1xuY29uc3QgZXRoZXJzXzEgPSByZXF1aXJlKFwiZXRoZXJzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9uY2hhaW4gVHJhbnNhY3Rpb24uXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgICAvKipcbiAgICAgKiBUcmFuc2FjdGlvbnMgc2hvdWxkIGJlIGNvbnN0cnVjdGVkIHZpYSBoaWdoZXIgbGV2ZWwgYWJzdHJhY3Rpb25zIGxpa2UgVHJhZGUgb3IgVHJhbnNmZXIuXG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwpIHtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlbCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVW5zaWduZWQgUGF5bG9hZCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVW5zaWduZWQgUGF5bG9hZFxuICAgICAqL1xuICAgIGdldFVuc2lnbmVkUGF5bG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudW5zaWduZWRfcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU2lnbmVkIFBheWxvYWQgb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFNpZ25lZCBQYXlsb2FkXG4gICAgICovXG4gICAgZ2V0U2lnbmVkUGF5bG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuc2lnbmVkX3BheWxvYWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2hcbiAgICAgKi9cbiAgICBnZXRUcmFuc2FjdGlvbkhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRyYW5zYWN0aW9uX2hhc2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFN0YXR1cyBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgU3RhdHVzXG4gICAgICovXG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZWwuc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuUEVORElORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5QRU5ESU5HO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkJST0FEQ0FTVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5CUk9BRENBU1Q7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuU0lHTkVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLlNJR05FRDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5VTlNQRUNJRklFRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFRyYW5zYWN0aW9uIGlzIGluIGEgdGVybWluYWwgU3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBUcmFuc2FjdGlvbiBpcyBpbiBhIHRlcm1pbmFsIFN0YXRlXG4gICAgICovXG4gICAgaXNUZXJtaW5hbFN0YXRlKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICByZXR1cm4gW3R5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuQ09NUExFVEUsIHR5cGVzXzEuVHJhbnNhY3Rpb25TdGF0dXMuRkFJTEVEXS5pbmNsdWRlcyhzdGF0dXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFkZHJlc3MgSUQgZm9yIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBGcm9tIEFkZHJlc3MgSURcbiAgICAgKi9cbiAgICBmcm9tQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5mcm9tX2FkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRvIEFkZHJlc3MgSUQgZm9yIHRoZSBUcmFuc2FjdGlvbiBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUbyBBZGRyZXNzIElEXG4gICAgICovXG4gICAgdG9BZGRyZXNzSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnRvX2FkZHJlc3NfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIEJsb2NrIEhlaWdodCB3aGVyZSB0aGUgVHJhbnNhY3Rpb24gaXMgcmVjb3JkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmxvY2sgSGVpZ2h0XG4gICAgICovXG4gICAgYmxvY2tIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmJsb2NrX2hlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQmxvY2sgSGFzaCB3aGVyZSB0aGUgVHJhbnNhY3Rpb24gaXMgcmVjb3JkZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgQmxvY2sgSGFzaFxuICAgICAqL1xuICAgIGJsb2NrSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuYmxvY2tfaGFzaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQ29udGVudCBvZiB0aGUgVHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdHJhbnNhY3Rpb24gY29udGVudFxuICAgICAqL1xuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25MaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC50cmFuc2FjdGlvbl9saW5rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBOZXR3b3JrIElEIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBOZXR3b3JrIElELlxuICAgICAqL1xuICAgIGdldE5ldHdvcmtJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwubmV0d29ya19pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyByYXcgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkVW5zaWduZWRQYXlsb2FkfSBJZiB0aGUgVW5zaWduZWQgUGF5bG9hZCBpcyBpbnZhbGlkLlxuICAgICAqIEByZXR1cm5zIFRoZSBldGhlcnMuanMgVHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICovXG4gICAgcmF3VHJhbnNhY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJhdykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmF3O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFBheWxvYWQgPSAoMCwgdXRpbHNfMS5wYXJzZVVuc2lnbmVkUGF5bG9hZCkodGhpcy5nZXRVbnNpZ25lZFBheWxvYWQoKSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IGV0aGVyc18xLmV0aGVycy5UcmFuc2FjdGlvbigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gQmlnSW50KHBhcnNlZFBheWxvYWQuY2hhaW5JZCk7XG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KHBhcnNlZFBheWxvYWQubm9uY2UpO1xuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChwYXJzZWRQYXlsb2FkLm1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4RmVlUGVyR2FzID0gQmlnSW50KHBhcnNlZFBheWxvYWQubWF4RmVlUGVyR2FzKTtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIG11bHRpcGxlIGN1cnJlbmNpZXMuXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gQmlnSW50KHBhcnNlZFBheWxvYWQuZ2FzKTtcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSBwYXJzZWRQYXlsb2FkLnRvO1xuICAgICAgICB0cmFuc2FjdGlvbi52YWx1ZSA9IEJpZ0ludChwYXJzZWRQYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IHBhcnNlZFBheWxvYWQuaW5wdXQ7XG4gICAgICAgIHRoaXMucmF3ID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHJldHVybiB0aGlzLnJhdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdGhlIFRyYW5zYWN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGtleSBhbmQgcmV0dXJucyB0aGUgaGV4IHNpZ25pbmcgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICBjb25zdCBzaWduZWRQYXlsb2FkID0gYXdhaXQga2V5LnNpZ25UcmFuc2FjdGlvbih0aGlzLnJhd1RyYW5zYWN0aW9uKCkpO1xuICAgICAgICB0aGlzLm1vZGVsLnNpZ25lZF9wYXlsb2FkID0gc2lnbmVkUGF5bG9hZDtcbiAgICAgICAgLy8gUmVtb3ZlcyB0aGUgJzB4JyBwcmVmaXggYXMgcmVxdWlyZWQgYnkgdGhlIEFQSS5cbiAgICAgICAgcmV0dXJuIHNpZ25lZFBheWxvYWQuc2xpY2UoMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNpZ25lZCBQYXlsb2FkIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTaWduZWQgUGF5bG9hZFxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVkUGF5bG9hZCgpPy5zbGljZSgyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBzaWduZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBpZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkLlxuICAgICAqL1xuICAgIGlzU2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldFNpZ25hdHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBUcmFuc2FjdGlvbiB7IHRyYW5zYWN0aW9uSGFzaDogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkhhc2goKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9JywgdW5zaWduZWRQYXlsb2FkOiAnJHt0aGlzLmdldFVuc2lnbmVkUGF5bG9hZCgpfScsIHNpZ25lZFBheWxvYWQ6ICR7dGhpcy5nZXRTaWduZWRQYXlsb2FkKCl9LCB0cmFuc2FjdGlvbkxpbms6ICR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0gfWA7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc2FjdGlvbiA9IFRyYW5zYWN0aW9uO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transfer = void 0;\nconst decimal_js_1 = __webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\");\nconst sponsored_send_1 = __webpack_require__(/*! ./sponsored_send */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/sponsored_send.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * A representation of a Transfer, which moves an Amount of an Asset from\n * a user-controlled Wallet to another Address. The fee is assumed to be paid\n * in the native Asset of the Network.\n */\nclass Transfer {\n    /**\n     * Private constructor to prevent direct instantiation outside of the factory methods.\n     *\n     * @ignore\n     * @param transferModel - The Transfer model.\n     * @hideconstructor\n     */\n    constructor(transferModel) {\n        if (!transferModel) {\n            throw new Error(\"Transfer model cannot be empty\");\n        }\n        this.model = transferModel;\n    }\n    /**\n     * Converts a TransferModel into a Transfer object.\n     *\n     * @param transferModel - The Transfer model object.\n     * @returns The Transfer object.\n     */\n    static fromModel(transferModel) {\n        return new Transfer(transferModel);\n    }\n    /**\n     * Returns the ID of the Transfer.\n     *\n     * @returns The Transfer ID.\n     */\n    getId() {\n        return this.model.transfer_id;\n    }\n    /**\n     * Returns the Network ID of the Transfer.\n     *\n     * @returns The Network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the Wallet ID of the Transfer.\n     *\n     * @returns The Wallet ID.\n     */\n    getWalletId() {\n        return this.model.wallet_id;\n    }\n    /**\n     * Returns the From Address ID of the Transfer.\n     *\n     * @returns The From Address ID.\n     */\n    getFromAddressId() {\n        return this.model.address_id;\n    }\n    /**\n     * Returns the Destination Address ID of the Transfer.\n     *\n     * @returns The Destination Address ID.\n     */\n    getDestinationAddressId() {\n        return this.model.destination;\n    }\n    /**\n     * Returns the Asset ID of the Transfer.\n     *\n     * @returns The Asset ID.\n     */\n    getAssetId() {\n        return this.model.asset_id;\n    }\n    /**\n     * Returns the Amount of the Transfer.\n     *\n     * @returns The Amount of the Asset.\n     */\n    getAmount() {\n        const amount = new decimal_js_1.Decimal(this.model.amount);\n        return amount.dividedBy(new decimal_js_1.Decimal(10).pow(this.model.asset.decimals));\n    }\n    /**\n     * Returns the Transaction Hash of the Transfer.\n     *\n     * @returns The Transaction Hash as a Hex string, or undefined if not yet available.\n     */\n    getTransactionHash() {\n        return this.getSendTransactionDelegate()?.getTransactionHash();\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The ethers.js Transaction object.\n     * @throws (InvalidUnsignedPayload) If the Unsigned Payload is invalid.\n     */\n    getRawTransaction() {\n        if (!this.getTransaction())\n            return undefined;\n        return this.getTransaction().rawTransaction();\n    }\n    /**\n     * Signs the Transfer with the provided key and returns the hex signature\n     * required for broadcasting the Transfer.\n     *\n     * @param key - The key to sign the Transfer with\n     * @returns The hex-encoded signed payload\n     */\n    async sign(key) {\n        return this.getSendTransactionDelegate().sign(key);\n    }\n    /**\n     * Returns the Status of the Transfer.\n     *\n     * @returns The Status of the Transfer.\n     */\n    getStatus() {\n        switch (this.getSendTransactionDelegate().getStatus()) {\n            case types_1.TransactionStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.PENDING:\n                return types_1.TransferStatus.PENDING;\n            case types_1.SponsoredSendStatus.SIGNED:\n                return types_1.TransferStatus.PENDING;\n            case types_1.TransactionStatus.BROADCAST:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.SponsoredSendStatus.SUBMITTED:\n                return types_1.TransferStatus.BROADCAST;\n            case types_1.TransactionStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.SponsoredSendStatus.COMPLETE:\n                return types_1.TransferStatus.COMPLETE;\n            case types_1.TransactionStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            case types_1.SponsoredSendStatus.FAILED:\n                return types_1.TransferStatus.FAILED;\n            default:\n                return undefined;\n        }\n    }\n    /**\n     * Returns the Transaction of the Transfer.\n     *\n     * @returns The Transaction\n     */\n    getTransaction() {\n        if (!this.model.transaction)\n            return undefined;\n        return new transaction_1.Transaction(this.model.transaction);\n    }\n    /**\n     * Returns the Sponsored Send of the Transfer.\n     *\n     * @returns The Sponsored Send\n     */\n    getSponsoredSend() {\n        if (!this.model.sponsored_send)\n            return undefined;\n        return new sponsored_send_1.SponsoredSend(this.model.sponsored_send);\n    }\n    /**\n     * Returns the Send Transaction Delegate of the Transfer.\n     *\n     * @returns Either the Transaction or the Sponsored Send\n     */\n    getSendTransactionDelegate() {\n        return !this.getTransaction() ? this.getSponsoredSend() : this.getTransaction();\n    }\n    /**\n     * Returns the link to the Transaction on the blockchain explorer.\n     *\n     * @returns The link to the Transaction on the blockchain explorer.\n     */\n    getTransactionLink() {\n        return this.getSendTransactionDelegate()?.getTransactionLink();\n    }\n    /**\n     * Broadcasts the Transfer to the Network.\n     *\n     * @returns The Transfer object\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async broadcast() {\n        if (!this.getSendTransactionDelegate()?.isSigned())\n            throw new Error(\"Cannot broadcast unsigned Transfer\");\n        const broadcastTransferRequest = {\n            signed_payload: this.getSendTransactionDelegate().getSignature(),\n        };\n        const response = await coinbase_1.Coinbase.apiClients.transfer.broadcastTransfer(this.getWalletId(), this.getFromAddressId(), this.getId(), broadcastTransferRequest);\n        return Transfer.fromModel(response.data);\n    }\n    /**\n     * Waits for the Transfer to be confirmed on the Network or fail on chain.\n     * Waits until the Transfer is completed or failed on-chain by polling at the given interval.\n     * Raises an error if the Trade takes longer than the given timeout.\n     *\n     * @param options - The options to configure the wait function.\n     * @param options.intervalSeconds - The interval to check the status of the Transfer.\n     * @param options.timeoutSeconds - The maximum time to wait for the Transfer to be confirmed.\n     *\n     * @returns The Transfer object in a terminal state.\n     * @throws {Error} if the Transfer times out.\n     */\n    async wait({ intervalSeconds = 0.2, timeoutSeconds = 10 } = {}) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            await this.reload();\n            // If the Transfer is in a terminal state, return the Transfer.\n            const status = this.getStatus();\n            if (status === types_1.TransferStatus.COMPLETE || status === types_1.TransferStatus.FAILED) {\n                return this;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new errors_1.TimeoutError(\"Transfer timed out\");\n    }\n    /**\n     * Reloads the Transfer model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Transfer fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.transfer.getTransfer(this.getWalletId(), this.getFromAddressId(), this.getId());\n        this.model = result?.data;\n    }\n    /**\n     * Returns a string representation of the Transfer.\n     *\n     * @returns The string representation of the Transfer.\n     */\n    toString() {\n        return (`Transfer{transferId: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `fromAddressId: '${this.getFromAddressId()}', destinationAddressId: '${this.getDestinationAddressId()}', ` +\n            `assetId: '${this.getAssetId()}', amount: '${this.getAmount()}', transactionHash: '${this.getTransactionHash()}', ` +\n            `transactionLink: '${this.getTransactionLink()}', status: '${this.getStatus()}'}`);\n    }\n}\nexports.Transfer = Transfer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3RyYW5zZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixxQkFBcUIsbUJBQU8sQ0FBQyw4REFBWTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxtRkFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQywrRkFBZTtBQUM3Qyx5QkFBeUIsbUJBQU8sQ0FBQyxxR0FBa0I7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0EsaUJBQWlCLDZDQUE2QyxJQUFJO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxhQUFhLGlCQUFpQixvQkFBb0I7QUFDM0YsK0JBQStCLHdCQUF3Qiw0QkFBNEIsK0JBQStCO0FBQ2xILHlCQUF5QixrQkFBa0IsY0FBYyxpQkFBaUIsdUJBQXVCLDBCQUEwQjtBQUMzSCxpQ0FBaUMsMEJBQTBCLGNBQWMsaUJBQWlCLEVBQUU7QUFDNUY7QUFDQTtBQUNBLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2hlYWx0aGNoYWluLWFwcC8uL25vZGVfbW9kdWxlcy9AY29pbmJhc2UvY29pbmJhc2Utc2RrL2Rpc3QvY29pbmJhc2UvdHJhbnNmZXIuanM/ZjQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNmZXIgPSB2b2lkIDA7XG5jb25zdCBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHNwb25zb3JlZF9zZW5kXzEgPSByZXF1aXJlKFwiLi9zcG9uc29yZWRfc2VuZFwiKTtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuLyoqXG4gKiBBIHJlcHJlc2VudGF0aW9uIG9mIGEgVHJhbnNmZXIsIHdoaWNoIG1vdmVzIGFuIEFtb3VudCBvZiBhbiBBc3NldCBmcm9tXG4gKiBhIHVzZXItY29udHJvbGxlZCBXYWxsZXQgdG8gYW5vdGhlciBBZGRyZXNzLiBUaGUgZmVlIGlzIGFzc3VtZWQgdG8gYmUgcGFpZFxuICogaW4gdGhlIG5hdGl2ZSBBc3NldCBvZiB0aGUgTmV0d29yay5cbiAqL1xuY2xhc3MgVHJhbnNmZXIge1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgY29uc3RydWN0b3IgdG8gcHJldmVudCBkaXJlY3QgaW5zdGFudGlhdGlvbiBvdXRzaWRlIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHRyYW5zZmVyTW9kZWwgLSBUaGUgVHJhbnNmZXIgbW9kZWwuXG4gICAgICogQGhpZGVjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRyYW5zZmVyTW9kZWwpIHtcbiAgICAgICAgaWYgKCF0cmFuc2Zlck1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2ZlciBtb2RlbCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IHRyYW5zZmVyTW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgVHJhbnNmZXJNb2RlbCBpbnRvIGEgVHJhbnNmZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zZmVyTW9kZWwgLSBUaGUgVHJhbnNmZXIgbW9kZWwgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2ZlciBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Nb2RlbCh0cmFuc2Zlck1vZGVsKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmZXIodHJhbnNmZXJNb2RlbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIElEIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2ZlciBJRC5cbiAgICAgKi9cbiAgICBnZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwudHJhbnNmZXJfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE5ldHdvcmsgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIE5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXQgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFdhbGxldCBJRC5cbiAgICAgKi9cbiAgICBnZXRXYWxsZXRJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwud2FsbGV0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBGcm9tIEFkZHJlc3MgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEZyb20gQWRkcmVzcyBJRC5cbiAgICAgKi9cbiAgICBnZXRGcm9tQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5hZGRyZXNzX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElEIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBEZXN0aW5hdGlvbiBBZGRyZXNzIElELlxuICAgICAqL1xuICAgIGdldERlc3RpbmF0aW9uQWRkcmVzc0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5kZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQXNzZXQgSUQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFzc2V0IElELlxuICAgICAqL1xuICAgIGdldEFzc2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLmFzc2V0X2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBbW91bnQgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIEFtb3VudCBvZiB0aGUgQXNzZXQuXG4gICAgICovXG4gICAgZ2V0QW1vdW50KCkge1xuICAgICAgICBjb25zdCBhbW91bnQgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwodGhpcy5tb2RlbC5hbW91bnQpO1xuICAgICAgICByZXR1cm4gYW1vdW50LmRpdmlkZWRCeShuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoMTApLnBvdyh0aGlzLm1vZGVsLmFzc2V0LmRlY2ltYWxzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIEhhc2ggb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zYWN0aW9uIEhhc2ggYXMgYSBIZXggc3RyaW5nLCBvciB1bmRlZmluZWQgaWYgbm90IHlldCBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0VHJhbnNhY3Rpb25IYXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpPy5nZXRUcmFuc2FjdGlvbkhhc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVHJhbnNhY3Rpb24gb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGV0aGVycy5qcyBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAgICogQHRocm93cyAoSW52YWxpZFVuc2lnbmVkUGF5bG9hZCkgSWYgdGhlIFVuc2lnbmVkIFBheWxvYWQgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBnZXRSYXdUcmFuc2FjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldFRyYW5zYWN0aW9uKCkpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUcmFuc2FjdGlvbigpLnJhd1RyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHRoZSBUcmFuc2ZlciB3aXRoIHRoZSBwcm92aWRlZCBrZXkgYW5kIHJldHVybnMgdGhlIGhleCBzaWduYXR1cmVcbiAgICAgKiByZXF1aXJlZCBmb3IgYnJvYWRjYXN0aW5nIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIHNpZ24gdGhlIFRyYW5zZmVyIHdpdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgaGV4LWVuY29kZWQgc2lnbmVkIHBheWxvYWRcbiAgICAgKi9cbiAgICBhc3luYyBzaWduKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZW5kVHJhbnNhY3Rpb25EZWxlZ2F0ZSgpLnNpZ24oa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgU3RhdHVzIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqL1xuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCkuZ2V0U3RhdHVzKCkpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5QRU5ESU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLlBFTkRJTkc7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5TSUdORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuUEVORElORztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5CUk9BRENBU1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuQlJPQURDQVNUO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlNwb25zb3JlZFNlbmRTdGF0dXMuU1VCTUlUVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkJST0FEQ0FTVDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5UcmFuc2FjdGlvblN0YXR1cy5DT01QTEVURTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5DT01QTEVURTtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5TcG9uc29yZWRTZW5kU3RhdHVzLkNPTVBMRVRFOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlRyYW5zZmVyU3RhdHVzLkNPTVBMRVRFO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlRyYW5zYWN0aW9uU3RhdHVzLkZBSUxFRDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5GQUlMRUQ7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuU3BvbnNvcmVkU2VuZFN0YXR1cy5GQUlMRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFRyYW5zYWN0aW9uIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBUcmFuc2FjdGlvblxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMubW9kZWwudHJhbnNhY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zYWN0aW9uXzEuVHJhbnNhY3Rpb24odGhpcy5tb2RlbC50cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFNwb25zb3JlZCBTZW5kIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBTcG9uc29yZWQgU2VuZFxuICAgICAqL1xuICAgIGdldFNwb25zb3JlZFNlbmQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5zcG9uc29yZWRfc2VuZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBuZXcgc3BvbnNvcmVkX3NlbmRfMS5TcG9uc29yZWRTZW5kKHRoaXMubW9kZWwuc3BvbnNvcmVkX3NlbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTZW5kIFRyYW5zYWN0aW9uIERlbGVnYXRlIG9mIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEVpdGhlciB0aGUgVHJhbnNhY3Rpb24gb3IgdGhlIFNwb25zb3JlZCBTZW5kXG4gICAgICovXG4gICAgZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5nZXRUcmFuc2FjdGlvbigpID8gdGhpcy5nZXRTcG9uc29yZWRTZW5kKCkgOiB0aGlzLmdldFRyYW5zYWN0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGxpbmsgdG8gdGhlIFRyYW5zYWN0aW9uIG9uIHRoZSBibG9ja2NoYWluIGV4cGxvcmVyLlxuICAgICAqL1xuICAgIGdldFRyYW5zYWN0aW9uTGluaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKT8uZ2V0VHJhbnNhY3Rpb25MaW5rKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgdGhlIFRyYW5zZmVyIHRvIHRoZSBOZXR3b3JrLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIG9iamVjdFxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gYnJvYWRjYXN0IGEgVHJhbnNmZXIgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgYnJvYWRjYXN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2V0U2VuZFRyYW5zYWN0aW9uRGVsZWdhdGUoKT8uaXNTaWduZWQoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBicm9hZGNhc3QgdW5zaWduZWQgVHJhbnNmZXJcIik7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdFRyYW5zZmVyUmVxdWVzdCA9IHtcbiAgICAgICAgICAgIHNpZ25lZF9wYXlsb2FkOiB0aGlzLmdldFNlbmRUcmFuc2FjdGlvbkRlbGVnYXRlKCkuZ2V0U2lnbmF0dXJlKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmJyb2FkY2FzdFRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSwgYnJvYWRjYXN0VHJhbnNmZXJSZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIFRyYW5zZmVyLmZyb21Nb2RlbChyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdHMgZm9yIHRoZSBUcmFuc2ZlciB0byBiZSBjb25maXJtZWQgb24gdGhlIE5ldHdvcmsgb3IgZmFpbCBvbiBjaGFpbi5cbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgVHJhbnNmZXIgaXMgY29tcGxldGVkIG9yIGZhaWxlZCBvbi1jaGFpbiBieSBwb2xsaW5nIGF0IHRoZSBnaXZlbiBpbnRlcnZhbC5cbiAgICAgKiBSYWlzZXMgYW4gZXJyb3IgaWYgdGhlIFRyYWRlIHRha2VzIGxvbmdlciB0aGFuIHRoZSBnaXZlbiB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb25maWd1cmUgdGhlIHdhaXQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIHRvIGNoZWNrIHRoZSBzdGF0dXMgb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gdGltZSB0byB3YWl0IGZvciB0aGUgVHJhbnNmZXIgdG8gYmUgY29uZmlybWVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFRyYW5zZmVyIG9iamVjdCBpbiBhIHRlcm1pbmFsIHN0YXRlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgVHJhbnNmZXIgdGltZXMgb3V0LlxuICAgICAqL1xuICAgIGFzeW5jIHdhaXQoeyBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMTAgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dFNlY29uZHMgKiAxMDAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIFRyYW5zZmVyIGlzIGluIGEgdGVybWluYWwgc3RhdGUsIHJldHVybiB0aGUgVHJhbnNmZXIuXG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLmdldFN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHlwZXNfMS5UcmFuc2ZlclN0YXR1cy5DT01QTEVURSB8fCBzdGF0dXMgPT09IHR5cGVzXzEuVHJhbnNmZXJTdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVGltZW91dEVycm9yKFwiVHJhbnNmZXIgdGltZWQgb3V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxvYWRzIHRoZSBUcmFuc2ZlciBtb2RlbCB3aXRoIHRoZSBsYXRlc3QgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGdldCBhIFRyYW5zZmVyIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnRyYW5zZmVyLmdldFRyYW5zZmVyKHRoaXMuZ2V0V2FsbGV0SWQoKSwgdGhpcy5nZXRGcm9tQWRkcmVzc0lkKCksIHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNmZXIuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFRyYW5zZmVye3RyYW5zZmVySWQ6ICcke3RoaXMuZ2V0SWQoKX0nLCBuZXR3b3JrSWQ6ICcke3RoaXMuZ2V0TmV0d29ya0lkKCl9JywgYCArXG4gICAgICAgICAgICBgZnJvbUFkZHJlc3NJZDogJyR7dGhpcy5nZXRGcm9tQWRkcmVzc0lkKCl9JywgZGVzdGluYXRpb25BZGRyZXNzSWQ6ICcke3RoaXMuZ2V0RGVzdGluYXRpb25BZGRyZXNzSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBhc3NldElkOiAnJHt0aGlzLmdldEFzc2V0SWQoKX0nLCBhbW91bnQ6ICcke3RoaXMuZ2V0QW1vdW50KCl9JywgdHJhbnNhY3Rpb25IYXNoOiAnJHt0aGlzLmdldFRyYW5zYWN0aW9uSGFzaCgpfScsIGAgK1xuICAgICAgICAgICAgYHRyYW5zYWN0aW9uTGluazogJyR7dGhpcy5nZXRUcmFuc2FjdGlvbkxpbmsoKX0nLCBzdGF0dXM6ICcke3RoaXMuZ2V0U3RhdHVzKCl9J31gKTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zZmVyID0gVHJhbnNmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SmartContractType = exports.StakeOptionsMode = exports.ServerSignerStatus = exports.PayloadSignatureStatus = exports.StakingRewardFormat = exports.ValidatorStatus = exports.SponsoredSendStatus = exports.TransactionStatus = exports.TransferStatus = void 0;\n/**\n * Transfer status type definition.\n */\nvar TransferStatus;\n(function (TransferStatus) {\n    TransferStatus[\"PENDING\"] = \"pending\";\n    TransferStatus[\"BROADCAST\"] = \"broadcast\";\n    TransferStatus[\"COMPLETE\"] = \"complete\";\n    TransferStatus[\"FAILED\"] = \"failed\";\n})(TransferStatus || (exports.TransferStatus = TransferStatus = {}));\n/**\n * Transaction status type definition.\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n    TransactionStatus[\"PENDING\"] = \"pending\";\n    TransactionStatus[\"SIGNED\"] = \"signed\";\n    TransactionStatus[\"BROADCAST\"] = \"broadcast\";\n    TransactionStatus[\"COMPLETE\"] = \"complete\";\n    TransactionStatus[\"FAILED\"] = \"failed\";\n    TransactionStatus[\"UNSPECIFIED\"] = \"unspecified\";\n})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));\n/**\n * Sponsored Send status type definition.\n */\nvar SponsoredSendStatus;\n(function (SponsoredSendStatus) {\n    SponsoredSendStatus[\"PENDING\"] = \"pending\";\n    SponsoredSendStatus[\"SIGNED\"] = \"signed\";\n    SponsoredSendStatus[\"SUBMITTED\"] = \"submitted\";\n    SponsoredSendStatus[\"COMPLETE\"] = \"complete\";\n    SponsoredSendStatus[\"FAILED\"] = \"failed\";\n})(SponsoredSendStatus || (exports.SponsoredSendStatus = SponsoredSendStatus = {}));\n/**\n * Validator status type definition.\n * Represents the various states a validator can be in.\n */\nvar ValidatorStatus;\n(function (ValidatorStatus) {\n    ValidatorStatus[\"UNKNOWN\"] = \"unknown\";\n    ValidatorStatus[\"PROVISIONING\"] = \"provisioning\";\n    ValidatorStatus[\"PROVISIONED\"] = \"provisioned\";\n    ValidatorStatus[\"DEPOSITED\"] = \"deposited\";\n    ValidatorStatus[\"PENDING_ACTIVATION\"] = \"pending_activation\";\n    ValidatorStatus[\"ACTIVE\"] = \"active\";\n    ValidatorStatus[\"EXITING\"] = \"exiting\";\n    ValidatorStatus[\"EXITED\"] = \"exited\";\n    ValidatorStatus[\"WITHDRAWAL_AVAILABLE\"] = \"withdrawal_available\";\n    ValidatorStatus[\"WITHDRAWAL_COMPLETE\"] = \"withdrawal_complete\";\n    ValidatorStatus[\"ACTIVE_SLASHED\"] = \"active_slashed\";\n    ValidatorStatus[\"EXITED_SLASHED\"] = \"exited_slashed\";\n    ValidatorStatus[\"REAPED\"] = \"reaped\";\n})(ValidatorStatus || (exports.ValidatorStatus = ValidatorStatus = {}));\n/**\n * Staking reward format type definition.\n * Represents the format in which staking rewards can be queried.\n */\nvar StakingRewardFormat;\n(function (StakingRewardFormat) {\n    StakingRewardFormat[\"USD\"] = \"usd\";\n    StakingRewardFormat[\"NATIVE\"] = \"native\";\n})(StakingRewardFormat || (exports.StakingRewardFormat = StakingRewardFormat = {}));\n/**\n * Payload Signature status type definition.\n */\nvar PayloadSignatureStatus;\n(function (PayloadSignatureStatus) {\n    PayloadSignatureStatus[\"PENDING\"] = \"pending\";\n    PayloadSignatureStatus[\"SIGNED\"] = \"signed\";\n    PayloadSignatureStatus[\"FAILED\"] = \"failed\";\n})(PayloadSignatureStatus || (exports.PayloadSignatureStatus = PayloadSignatureStatus = {}));\n/**\n * ServerSigner status type definition.\n */\nvar ServerSignerStatus;\n(function (ServerSignerStatus) {\n    ServerSignerStatus[\"PENDING\"] = \"pending_seed_creation\";\n    ServerSignerStatus[\"ACTIVE\"] = \"active_seed\";\n})(ServerSignerStatus || (exports.ServerSignerStatus = ServerSignerStatus = {}));\n/**\n * StakeOptionsMode type definition.\n */\nvar StakeOptionsMode;\n(function (StakeOptionsMode) {\n    /**\n     * Defaults to the mode specific to the asset.\n     */\n    StakeOptionsMode[\"DEFAULT\"] = \"default\";\n    /**\n     * Partial represents Partial Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"PARTIAL\"] = \"partial\";\n    /**\n     * Native represents Native Ethereum Staking mode.\n     */\n    StakeOptionsMode[\"NATIVE\"] = \"native\";\n})(StakeOptionsMode || (exports.StakeOptionsMode = StakeOptionsMode = {}));\n/**\n * Smart Contract Type\n */\nvar SmartContractType;\n(function (SmartContractType) {\n    SmartContractType[\"ERC20\"] = \"erc20\";\n    SmartContractType[\"ERC721\"] = \"erc721\";\n    SmartContractType[\"ERC1155\"] = \"erc1155\";\n})(SmartContractType || (exports.SmartContractType = SmartContractType = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLDhCQUE4QixHQUFHLDJCQUEyQixHQUFHLHVCQUF1QixHQUFHLDJCQUEyQixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQjtBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQixzQkFBc0Isc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsMkJBQTJCLDJCQUEyQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCLDhCQUE4Qiw4QkFBOEI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHlCQUF5QiwwQkFBMEIsMEJBQTBCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1Qix3QkFBd0Isd0JBQXdCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS90eXBlcy5qcz83ZDU4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TbWFydENvbnRyYWN0VHlwZSA9IGV4cG9ydHMuU3Rha2VPcHRpb25zTW9kZSA9IGV4cG9ydHMuU2VydmVyU2lnbmVyU3RhdHVzID0gZXhwb3J0cy5QYXlsb2FkU2lnbmF0dXJlU3RhdHVzID0gZXhwb3J0cy5TdGFraW5nUmV3YXJkRm9ybWF0ID0gZXhwb3J0cy5WYWxpZGF0b3JTdGF0dXMgPSBleHBvcnRzLlNwb25zb3JlZFNlbmRTdGF0dXMgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0gZXhwb3J0cy5UcmFuc2ZlclN0YXR1cyA9IHZvaWQgMDtcbi8qKlxuICogVHJhbnNmZXIgc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFRyYW5zZmVyU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2ZlclN0YXR1cykge1xuICAgIFRyYW5zZmVyU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFRyYW5zZmVyU3RhdHVzW1wiQlJPQURDQVNUXCJdID0gXCJicm9hZGNhc3RcIjtcbiAgICBUcmFuc2ZlclN0YXR1c1tcIkNPTVBMRVRFXCJdID0gXCJjb21wbGV0ZVwiO1xuICAgIFRyYW5zZmVyU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbn0pKFRyYW5zZmVyU3RhdHVzIHx8IChleHBvcnRzLlRyYW5zZmVyU3RhdHVzID0gVHJhbnNmZXJTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBUcmFuc2FjdGlvbiBzdGF0dXMgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgVHJhbnNhY3Rpb25TdGF0dXM7XG4oZnVuY3Rpb24gKFRyYW5zYWN0aW9uU3RhdHVzKSB7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJQRU5ESU5HXCJdID0gXCJwZW5kaW5nXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJTSUdORURcIl0gPSBcInNpZ25lZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiQlJPQURDQVNUXCJdID0gXCJicm9hZGNhc3RcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIkNPTVBMRVRFXCJdID0gXCJjb21wbGV0ZVwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcIlVOU1BFQ0lGSUVEXCJdID0gXCJ1bnNwZWNpZmllZFwiO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgfHwgKGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFNwb25zb3JlZCBTZW5kIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBTcG9uc29yZWRTZW5kU3RhdHVzO1xuKGZ1bmN0aW9uIChTcG9uc29yZWRTZW5kU3RhdHVzKSB7XG4gICAgU3BvbnNvcmVkU2VuZFN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBTcG9uc29yZWRTZW5kU3RhdHVzW1wiU0lHTkVEXCJdID0gXCJzaWduZWRcIjtcbiAgICBTcG9uc29yZWRTZW5kU3RhdHVzW1wiU1VCTUlUVEVEXCJdID0gXCJzdWJtaXR0ZWRcIjtcbiAgICBTcG9uc29yZWRTZW5kU3RhdHVzW1wiQ09NUExFVEVcIl0gPSBcImNvbXBsZXRlXCI7XG4gICAgU3BvbnNvcmVkU2VuZFN0YXR1c1tcIkZBSUxFRFwiXSA9IFwiZmFpbGVkXCI7XG59KShTcG9uc29yZWRTZW5kU3RhdHVzIHx8IChleHBvcnRzLlNwb25zb3JlZFNlbmRTdGF0dXMgPSBTcG9uc29yZWRTZW5kU3RhdHVzID0ge30pKTtcbi8qKlxuICogVmFsaWRhdG9yIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKiBSZXByZXNlbnRzIHRoZSB2YXJpb3VzIHN0YXRlcyBhIHZhbGlkYXRvciBjYW4gYmUgaW4uXG4gKi9cbnZhciBWYWxpZGF0b3JTdGF0dXM7XG4oZnVuY3Rpb24gKFZhbGlkYXRvclN0YXR1cykge1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJQUk9WSVNJT05JTkdcIl0gPSBcInByb3Zpc2lvbmluZ1wiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIlBST1ZJU0lPTkVEXCJdID0gXCJwcm92aXNpb25lZFwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkRFUE9TSVRFRFwiXSA9IFwiZGVwb3NpdGVkXCI7XG4gICAgVmFsaWRhdG9yU3RhdHVzW1wiUEVORElOR19BQ1RJVkFUSU9OXCJdID0gXCJwZW5kaW5nX2FjdGl2YXRpb25cIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJBQ1RJVkVcIl0gPSBcImFjdGl2ZVwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIkVYSVRJTkdcIl0gPSBcImV4aXRpbmdcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJFWElURURcIl0gPSBcImV4aXRlZFwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIldJVEhEUkFXQUxfQVZBSUxBQkxFXCJdID0gXCJ3aXRoZHJhd2FsX2F2YWlsYWJsZVwiO1xuICAgIFZhbGlkYXRvclN0YXR1c1tcIldJVEhEUkFXQUxfQ09NUExFVEVcIl0gPSBcIndpdGhkcmF3YWxfY29tcGxldGVcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJBQ1RJVkVfU0xBU0hFRFwiXSA9IFwiYWN0aXZlX3NsYXNoZWRcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJFWElURURfU0xBU0hFRFwiXSA9IFwiZXhpdGVkX3NsYXNoZWRcIjtcbiAgICBWYWxpZGF0b3JTdGF0dXNbXCJSRUFQRURcIl0gPSBcInJlYXBlZFwiO1xufSkoVmFsaWRhdG9yU3RhdHVzIHx8IChleHBvcnRzLlZhbGlkYXRvclN0YXR1cyA9IFZhbGlkYXRvclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFN0YWtpbmcgcmV3YXJkIGZvcm1hdCB0eXBlIGRlZmluaXRpb24uXG4gKiBSZXByZXNlbnRzIHRoZSBmb3JtYXQgaW4gd2hpY2ggc3Rha2luZyByZXdhcmRzIGNhbiBiZSBxdWVyaWVkLlxuICovXG52YXIgU3Rha2luZ1Jld2FyZEZvcm1hdDtcbihmdW5jdGlvbiAoU3Rha2luZ1Jld2FyZEZvcm1hdCkge1xuICAgIFN0YWtpbmdSZXdhcmRGb3JtYXRbXCJVU0RcIl0gPSBcInVzZFwiO1xuICAgIFN0YWtpbmdSZXdhcmRGb3JtYXRbXCJOQVRJVkVcIl0gPSBcIm5hdGl2ZVwiO1xufSkoU3Rha2luZ1Jld2FyZEZvcm1hdCB8fCAoZXhwb3J0cy5TdGFraW5nUmV3YXJkRm9ybWF0ID0gU3Rha2luZ1Jld2FyZEZvcm1hdCA9IHt9KSk7XG4vKipcbiAqIFBheWxvYWQgU2lnbmF0dXJlIHN0YXR1cyB0eXBlIGRlZmluaXRpb24uXG4gKi9cbnZhciBQYXlsb2FkU2lnbmF0dXJlU3RhdHVzO1xuKGZ1bmN0aW9uIChQYXlsb2FkU2lnbmF0dXJlU3RhdHVzKSB7XG4gICAgUGF5bG9hZFNpZ25hdHVyZVN0YXR1c1tcIlBFTkRJTkdcIl0gPSBcInBlbmRpbmdcIjtcbiAgICBQYXlsb2FkU2lnbmF0dXJlU3RhdHVzW1wiU0lHTkVEXCJdID0gXCJzaWduZWRcIjtcbiAgICBQYXlsb2FkU2lnbmF0dXJlU3RhdHVzW1wiRkFJTEVEXCJdID0gXCJmYWlsZWRcIjtcbn0pKFBheWxvYWRTaWduYXR1cmVTdGF0dXMgfHwgKGV4cG9ydHMuUGF5bG9hZFNpZ25hdHVyZVN0YXR1cyA9IFBheWxvYWRTaWduYXR1cmVTdGF0dXMgPSB7fSkpO1xuLyoqXG4gKiBTZXJ2ZXJTaWduZXIgc3RhdHVzIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xudmFyIFNlcnZlclNpZ25lclN0YXR1cztcbihmdW5jdGlvbiAoU2VydmVyU2lnbmVyU3RhdHVzKSB7XG4gICAgU2VydmVyU2lnbmVyU3RhdHVzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ19zZWVkX2NyZWF0aW9uXCI7XG4gICAgU2VydmVyU2lnbmVyU3RhdHVzW1wiQUNUSVZFXCJdID0gXCJhY3RpdmVfc2VlZFwiO1xufSkoU2VydmVyU2lnbmVyU3RhdHVzIHx8IChleHBvcnRzLlNlcnZlclNpZ25lclN0YXR1cyA9IFNlcnZlclNpZ25lclN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIFN0YWtlT3B0aW9uc01vZGUgdHlwZSBkZWZpbml0aW9uLlxuICovXG52YXIgU3Rha2VPcHRpb25zTW9kZTtcbihmdW5jdGlvbiAoU3Rha2VPcHRpb25zTW9kZSkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHRzIHRvIHRoZSBtb2RlIHNwZWNpZmljIHRvIHRoZSBhc3NldC5cbiAgICAgKi9cbiAgICBTdGFrZU9wdGlvbnNNb2RlW1wiREVGQVVMVFwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIC8qKlxuICAgICAqIFBhcnRpYWwgcmVwcmVzZW50cyBQYXJ0aWFsIEV0aGVyZXVtIFN0YWtpbmcgbW9kZS5cbiAgICAgKi9cbiAgICBTdGFrZU9wdGlvbnNNb2RlW1wiUEFSVElBTFwiXSA9IFwicGFydGlhbFwiO1xuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByZXByZXNlbnRzIE5hdGl2ZSBFdGhlcmV1bSBTdGFraW5nIG1vZGUuXG4gICAgICovXG4gICAgU3Rha2VPcHRpb25zTW9kZVtcIk5BVElWRVwiXSA9IFwibmF0aXZlXCI7XG59KShTdGFrZU9wdGlvbnNNb2RlIHx8IChleHBvcnRzLlN0YWtlT3B0aW9uc01vZGUgPSBTdGFrZU9wdGlvbnNNb2RlID0ge30pKTtcbi8qKlxuICogU21hcnQgQ29udHJhY3QgVHlwZVxuICovXG52YXIgU21hcnRDb250cmFjdFR5cGU7XG4oZnVuY3Rpb24gKFNtYXJ0Q29udHJhY3RUeXBlKSB7XG4gICAgU21hcnRDb250cmFjdFR5cGVbXCJFUkMyMFwiXSA9IFwiZXJjMjBcIjtcbiAgICBTbWFydENvbnRyYWN0VHlwZVtcIkVSQzcyMVwiXSA9IFwiZXJjNzIxXCI7XG4gICAgU21hcnRDb250cmFjdFR5cGVbXCJFUkMxMTU1XCJdID0gXCJlcmMxMTU1XCI7XG59KShTbWFydENvbnRyYWN0VHlwZSB8fCAoZXhwb3J0cy5TbWFydENvbnRyYWN0VHlwZSA9IFNtYXJ0Q29udHJhY3RUeXBlID0ge30pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getWeekBackDate = exports.formatDate = exports.parseUnsignedPayload = exports.delay = exports.convertStringToHex = exports.registerAxiosInterceptors = exports.logApiResponse = void 0;\nconst api_error_1 = __webpack_require__(/*! ./api_error */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\n/**\n * Prints Axios response to the console for debugging purposes.\n *\n * @param response - The Axios response object.\n * @param debugging - Flag to enable or disable logging.\n * @returns The Axios response object.\n */\nconst logApiResponse = (response, debugging = false) => {\n    if (debugging) {\n        let output = typeof response.data === \"string\" ? response.data : \"\";\n        if (typeof response.data === \"object\") {\n            output = JSON.stringify(response.data, null, 4);\n        }\n        console.log(`API RESPONSE: \n      Status: ${response.status} \n      URL: ${response.config.url} \n      Data: ${output}`);\n    }\n    return response;\n};\nexports.logApiResponse = logApiResponse;\n/**\n * Registers request and response interceptors to an Axios instance.\n *\n * @param axiosInstance - The Axios instance to register the interceptors.\n * @param requestFn - The request interceptor function.\n * @param responseFn - The response interceptor function.\n */\nconst registerAxiosInterceptors = (axiosInstance, requestFn, responseFn) => {\n    axiosInstance.interceptors.request.use(requestFn);\n    axiosInstance.interceptors.response.use(responseFn, error => {\n        return Promise.reject(api_error_1.APIError.fromError(error));\n    });\n};\nexports.registerAxiosInterceptors = registerAxiosInterceptors;\n/**\n * Converts a Uint8Array to a hex string.\n *\n * @param key - The key to convert.\n * @returns The converted hex string.\n */\nconst convertStringToHex = (key) => {\n    return Buffer.from(key).toString(\"hex\");\n};\nexports.convertStringToHex = convertStringToHex;\n/**\n * Delays the execution of the function by the specified number of seconds.\n *\n * @param seconds - The number of seconds to delay the execution.\n * @returns A promise that resolves after the specified number of seconds.\n */\nasync function delay(seconds) {\n    return new Promise(resolve => setTimeout(resolve, seconds * 1000));\n}\nexports.delay = delay;\n/**\n * Parses an Unsigned Payload and returns the JSON object.\n *\n * @throws {InvalidUnsignedPayload} If the Unsigned Payload is invalid.\n * @param payload - The Unsigned Payload.\n * @returns The parsed JSON object.\n */\nfunction parseUnsignedPayload(payload) {\n    const rawPayload = payload.match(/../g)?.map(byte => parseInt(byte, 16));\n    if (!rawPayload) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to parse unsigned payload\");\n    }\n    let parsedPayload;\n    try {\n        const rawPayloadBytes = new Uint8Array(rawPayload);\n        const decoder = new TextDecoder();\n        parsedPayload = JSON.parse(decoder.decode(rawPayloadBytes));\n    }\n    catch (error) {\n        throw new errors_1.InvalidUnsignedPayloadError(\"Unable to decode unsigned payload JSON\");\n    }\n    return parsedPayload;\n}\nexports.parseUnsignedPayload = parseUnsignedPayload;\n/**\n * Formats the input date to 'YYYY-MM-DD'\n *\n * @param date - The date to format.\n *\n * @returns a formated date of 'YYYY-MM-DD'\n */\nfunction formatDate(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, \"0\"); // Months are zero-based, so add 1\n    const day = String(date.getDate()).padStart(2, \"0\");\n    return `${year}-${month}-${day}T00:00:00Z`;\n}\nexports.formatDate = formatDate;\n/**\n *\n * Takes a date and subtracts a week from it. (7 days)\n *\n * @param date - The date to be formatted.\n *\n * @returns a formatted date that is one week ago.\n */\nfunction getWeekBackDate(date) {\n    date.setDate(date.getDate() - 7);\n    return formatDate(date);\n}\nexports.getWeekBackDate = getWeekBackDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGtCQUFrQixHQUFHLDRCQUE0QixHQUFHLGFBQWEsR0FBRywwQkFBMEIsR0FBRyxpQ0FBaUMsR0FBRyxzQkFBc0I7QUFDckwsb0JBQW9CLG1CQUFPLENBQUMsMkZBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsY0FBYyxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUk7QUFDbkM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS91dGlscy5qcz83ZGI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRXZWVrQmFja0RhdGUgPSBleHBvcnRzLmZvcm1hdERhdGUgPSBleHBvcnRzLnBhcnNlVW5zaWduZWRQYXlsb2FkID0gZXhwb3J0cy5kZWxheSA9IGV4cG9ydHMuY29udmVydFN0cmluZ1RvSGV4ID0gZXhwb3J0cy5yZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzID0gZXhwb3J0cy5sb2dBcGlSZXNwb25zZSA9IHZvaWQgMDtcbmNvbnN0IGFwaV9lcnJvcl8xID0gcmVxdWlyZShcIi4vYXBpX2Vycm9yXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG4vKipcbiAqIFByaW50cyBBeGlvcyByZXNwb25zZSB0byB0aGUgY29uc29sZSBmb3IgZGVidWdnaW5nIHB1cnBvc2VzLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZSAtIFRoZSBBeGlvcyByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0gZGVidWdnaW5nIC0gRmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSBsb2dnaW5nLlxuICogQHJldHVybnMgVGhlIEF4aW9zIHJlc3BvbnNlIG9iamVjdC5cbiAqL1xuY29uc3QgbG9nQXBpUmVzcG9uc2UgPSAocmVzcG9uc2UsIGRlYnVnZ2luZyA9IGZhbHNlKSA9PiB7XG4gICAgaWYgKGRlYnVnZ2luZykge1xuICAgICAgICBsZXQgb3V0cHV0ID0gdHlwZW9mIHJlc3BvbnNlLmRhdGEgPT09IFwic3RyaW5nXCIgPyByZXNwb25zZS5kYXRhIDogXCJcIjtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZS5kYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBKU09OLnN0cmluZ2lmeShyZXNwb25zZS5kYXRhLCBudWxsLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgQVBJIFJFU1BPTlNFOiBcbiAgICAgIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9IFxuICAgICAgVVJMOiAke3Jlc3BvbnNlLmNvbmZpZy51cmx9IFxuICAgICAgRGF0YTogJHtvdXRwdXR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn07XG5leHBvcnRzLmxvZ0FwaVJlc3BvbnNlID0gbG9nQXBpUmVzcG9uc2U7XG4vKipcbiAqIFJlZ2lzdGVycyByZXF1ZXN0IGFuZCByZXNwb25zZSBpbnRlcmNlcHRvcnMgdG8gYW4gQXhpb3MgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGF4aW9zSW5zdGFuY2UgLSBUaGUgQXhpb3MgaW5zdGFuY2UgdG8gcmVnaXN0ZXIgdGhlIGludGVyY2VwdG9ycy5cbiAqIEBwYXJhbSByZXF1ZXN0Rm4gLSBUaGUgcmVxdWVzdCBpbnRlcmNlcHRvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSByZXNwb25zZUZuIC0gVGhlIHJlc3BvbnNlIGludGVyY2VwdG9yIGZ1bmN0aW9uLlxuICovXG5jb25zdCByZWdpc3RlckF4aW9zSW50ZXJjZXB0b3JzID0gKGF4aW9zSW5zdGFuY2UsIHJlcXVlc3RGbiwgcmVzcG9uc2VGbikgPT4ge1xuICAgIGF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKHJlcXVlc3RGbik7XG4gICAgYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKHJlc3BvbnNlRm4sIGVycm9yID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFwaV9lcnJvcl8xLkFQSUVycm9yLmZyb21FcnJvcihlcnJvcikpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJBeGlvc0ludGVyY2VwdG9ycyA9IHJlZ2lzdGVyQXhpb3NJbnRlcmNlcHRvcnM7XG4vKipcbiAqIENvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgaGV4IHN0cmluZy5cbiAqL1xuY29uc3QgY29udmVydFN0cmluZ1RvSGV4ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShrZXkpLnRvU3RyaW5nKFwiaGV4XCIpO1xufTtcbmV4cG9ydHMuY29udmVydFN0cmluZ1RvSGV4ID0gY29udmVydFN0cmluZ1RvSGV4O1xuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgZnVuY3Rpb24gYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB0byBkZWxheSB0aGUgZXhlY3V0aW9uLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlIHNwZWNpZmllZCBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoc2Vjb25kcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2Vjb25kcyAqIDEwMDApKTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbi8qKlxuICogUGFyc2VzIGFuIFVuc2lnbmVkIFBheWxvYWQgYW5kIHJldHVybnMgdGhlIEpTT04gb2JqZWN0LlxuICpcbiAqIEB0aHJvd3Mge0ludmFsaWRVbnNpZ25lZFBheWxvYWR9IElmIHRoZSBVbnNpZ25lZCBQYXlsb2FkIGlzIGludmFsaWQuXG4gKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBVbnNpZ25lZCBQYXlsb2FkLlxuICogQHJldHVybnMgVGhlIHBhcnNlZCBKU09OIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VVbnNpZ25lZFBheWxvYWQocGF5bG9hZCkge1xuICAgIGNvbnN0IHJhd1BheWxvYWQgPSBwYXlsb2FkLm1hdGNoKC8uLi9nKT8ubWFwKGJ5dGUgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKTtcbiAgICBpZiAoIXJhd1BheWxvYWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRVbnNpZ25lZFBheWxvYWRFcnJvcihcIlVuYWJsZSB0byBwYXJzZSB1bnNpZ25lZCBwYXlsb2FkXCIpO1xuICAgIH1cbiAgICBsZXQgcGFyc2VkUGF5bG9hZDtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByYXdQYXlsb2FkQnl0ZXMgPSBuZXcgVWludDhBcnJheShyYXdQYXlsb2FkKTtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICBwYXJzZWRQYXlsb2FkID0gSlNPTi5wYXJzZShkZWNvZGVyLmRlY29kZShyYXdQYXlsb2FkQnl0ZXMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkVW5zaWduZWRQYXlsb2FkRXJyb3IoXCJVbmFibGUgdG8gZGVjb2RlIHVuc2lnbmVkIHBheWxvYWQgSlNPTlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZFBheWxvYWQ7XG59XG5leHBvcnRzLnBhcnNlVW5zaWduZWRQYXlsb2FkID0gcGFyc2VVbnNpZ25lZFBheWxvYWQ7XG4vKipcbiAqIEZvcm1hdHMgdGhlIGlucHV0IGRhdGUgdG8gJ1lZWVktTU0tREQnXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gKlxuICogQHJldHVybnMgYSBmb3JtYXRlZCBkYXRlIG9mICdZWVlZLU1NLUREJ1xuICovXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUpIHtcbiAgICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRoID0gU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpLnBhZFN0YXJ0KDIsIFwiMFwiKTsgLy8gTW9udGhzIGFyZSB6ZXJvLWJhc2VkLCBzbyBhZGQgMVxuICAgIGNvbnN0IGRheSA9IFN0cmluZyhkYXRlLmdldERhdGUoKSkucGFkU3RhcnQoMiwgXCIwXCIpO1xuICAgIHJldHVybiBgJHt5ZWFyfS0ke21vbnRofS0ke2RheX1UMDA6MDA6MDBaYDtcbn1cbmV4cG9ydHMuZm9ybWF0RGF0ZSA9IGZvcm1hdERhdGU7XG4vKipcbiAqXG4gKiBUYWtlcyBhIGRhdGUgYW5kIHN1YnRyYWN0cyBhIHdlZWsgZnJvbSBpdC4gKDcgZGF5cylcbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGJlIGZvcm1hdHRlZC5cbiAqXG4gKiBAcmV0dXJucyBhIGZvcm1hdHRlZCBkYXRlIHRoYXQgaXMgb25lIHdlZWsgYWdvLlxuICovXG5mdW5jdGlvbiBnZXRXZWVrQmFja0RhdGUoZGF0ZSkge1xuICAgIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSAtIDcpO1xuICAgIHJldHVybiBmb3JtYXREYXRlKGRhdGUpO1xufVxuZXhwb3J0cy5nZXRXZWVrQmFja0RhdGUgPSBnZXRXZWVrQmFja0RhdGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js":
/*!************************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Validator = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst api_1 = __webpack_require__(/*! ../client/api */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/client/api.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\n/**\n * A representation of a validator onchain.\n */\nclass Validator {\n    /**\n     * Creates a Validator object.\n     *\n     * @class\n     * @param model - The underlying Validator object.\n     * @throws {Error} - If the Validator model is empty.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Invalid model type\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns the list of Validators.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param status - The status to filter by.\n     * @returns The list of Validators.\n     */\n    static async list(networkId, assetId, status) {\n        const validators = [];\n        const response = await coinbase_1.Coinbase.apiClients.validator.listValidators(networkId, assetId, Validator.getAPIValidatorStatus(status));\n        response.data.data.forEach(validator => {\n            validators.push(new Validator(validator));\n        });\n        return validators;\n    }\n    /**\n     *\n     * Returns the details of a specific validator.\n     *\n     * @param networkId - The network ID.\n     * @param assetId - The asset ID.\n     * @param id - The unique publicly identifiable id of the validator for which to fetch the data.\n     * @returns The requested validator details.\n     */\n    static async fetch(networkId, assetId, id) {\n        const response = await coinbase_1.Coinbase.apiClients.validator.getValidator(networkId, assetId, id);\n        return new Validator(response.data);\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @param status - The API Validator status.\n     * @returns The Validator status.\n     */\n    static getAPIValidatorStatus(status) {\n        /* istanbul ignore next */\n        switch (status) {\n            case types_1.ValidatorStatus.UNKNOWN:\n                return api_1.ValidatorStatus.Unknown;\n            case types_1.ValidatorStatus.PROVISIONING:\n                return api_1.ValidatorStatus.Provisioning;\n            case types_1.ValidatorStatus.PROVISIONED:\n                return api_1.ValidatorStatus.Provisioned;\n            case types_1.ValidatorStatus.DEPOSITED:\n                return api_1.ValidatorStatus.Deposited;\n            case types_1.ValidatorStatus.PENDING_ACTIVATION:\n                return api_1.ValidatorStatus.PendingActivation;\n            case types_1.ValidatorStatus.ACTIVE:\n                return api_1.ValidatorStatus.Active;\n            case types_1.ValidatorStatus.EXITING:\n                return api_1.ValidatorStatus.Exiting;\n            case types_1.ValidatorStatus.EXITED:\n                return api_1.ValidatorStatus.Exited;\n            case types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE:\n                return api_1.ValidatorStatus.WithdrawalAvailable;\n            case types_1.ValidatorStatus.WITHDRAWAL_COMPLETE:\n                return api_1.ValidatorStatus.WithdrawalComplete;\n            case types_1.ValidatorStatus.ACTIVE_SLASHED:\n                return api_1.ValidatorStatus.ActiveSlashed;\n            case types_1.ValidatorStatus.EXITED_SLASHED:\n                return api_1.ValidatorStatus.ExitedSlashed;\n            case types_1.ValidatorStatus.REAPED:\n                return api_1.ValidatorStatus.Reaped;\n            default:\n                return api_1.ValidatorStatus.Unknown;\n        }\n    }\n    /**\n     * Returns the Validator ID.\n     *\n     * @returns The Validator ID.\n     */\n    getValidatorId() {\n        return this.model.validator_id;\n    }\n    /**\n     * Returns the Validator status.\n     *\n     * @returns The Validator status.\n     */\n    getStatus() {\n        switch (this.model.status) {\n            case api_1.ValidatorStatus.Unknown:\n                return types_1.ValidatorStatus.UNKNOWN;\n            case api_1.ValidatorStatus.Provisioning:\n                return types_1.ValidatorStatus.PROVISIONING;\n            case api_1.ValidatorStatus.Provisioned:\n                return types_1.ValidatorStatus.PROVISIONED;\n            case api_1.ValidatorStatus.Deposited:\n                return types_1.ValidatorStatus.DEPOSITED;\n            case api_1.ValidatorStatus.PendingActivation:\n                return types_1.ValidatorStatus.PENDING_ACTIVATION;\n            case api_1.ValidatorStatus.Active:\n                return types_1.ValidatorStatus.ACTIVE;\n            case api_1.ValidatorStatus.Exiting:\n                return types_1.ValidatorStatus.EXITING;\n            case api_1.ValidatorStatus.Exited:\n                return types_1.ValidatorStatus.EXITED;\n            case api_1.ValidatorStatus.WithdrawalAvailable:\n                return types_1.ValidatorStatus.WITHDRAWAL_AVAILABLE;\n            case api_1.ValidatorStatus.WithdrawalComplete:\n                return types_1.ValidatorStatus.WITHDRAWAL_COMPLETE;\n            case api_1.ValidatorStatus.ActiveSlashed:\n                return types_1.ValidatorStatus.ACTIVE_SLASHED;\n            case api_1.ValidatorStatus.ExitedSlashed:\n                return types_1.ValidatorStatus.EXITED_SLASHED;\n            case api_1.ValidatorStatus.Reaped:\n                return types_1.ValidatorStatus.REAPED;\n            default:\n                return types_1.ValidatorStatus.UNKNOWN;\n        }\n    }\n    /**\n     * Returns the string representation of the Validator.\n     *\n     * @returns The string representation of the Validator.\n     */\n    toString() {\n        return `Id: ${this.getValidatorId()} Status: ${this.getStatus()}`;\n    }\n}\nexports.Validator = Validator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3ZhbGlkYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsY0FBYyxtQkFBTyxDQUFDLHFGQUFlO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLG1GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QixVQUFVLGlCQUFpQjtBQUN4RTtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9jb2luYmFzZS92YWxpZGF0b3IuanM/ZDM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVmFsaWRhdG9yID0gdm9pZCAwO1xuY29uc3QgY29pbmJhc2VfMSA9IHJlcXVpcmUoXCIuL2NvaW5iYXNlXCIpO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiLi4vY2xpZW50L2FwaVwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIHZhbGlkYXRvciBvbmNoYWluLlxuICovXG5jbGFzcyBWYWxpZGF0b3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBWYWxpZGF0b3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNsYXNzXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHVuZGVybHlpbmcgVmFsaWRhdG9yIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUgVmFsaWRhdG9yIG1vZGVsIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsKSB7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgVmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRC5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBJRC5cbiAgICAgKiBAcGFyYW0gc3RhdHVzIC0gVGhlIHN0YXR1cyB0byBmaWx0ZXIgYnkuXG4gICAgICogQHJldHVybnMgVGhlIGxpc3Qgb2YgVmFsaWRhdG9ycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbGlzdChuZXR3b3JrSWQsIGFzc2V0SWQsIHN0YXR1cykge1xuICAgICAgICBjb25zdCB2YWxpZGF0b3JzID0gW107XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLnZhbGlkYXRvci5saXN0VmFsaWRhdG9ycyhuZXR3b3JrSWQsIGFzc2V0SWQsIFZhbGlkYXRvci5nZXRBUElWYWxpZGF0b3JTdGF0dXMoc3RhdHVzKSk7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEuZGF0YS5mb3JFYWNoKHZhbGlkYXRvciA9PiB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2gobmV3IFZhbGlkYXRvcih2YWxpZGF0b3IpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0b3JzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgdGhlIGRldGFpbHMgb2YgYSBzcGVjaWZpYyB2YWxpZGF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya0lkIC0gVGhlIG5ldHdvcmsgSUQuXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBwdWJsaWNseSBpZGVudGlmaWFibGUgaWQgb2YgdGhlIHZhbGlkYXRvciBmb3Igd2hpY2ggdG8gZmV0Y2ggdGhlIGRhdGEuXG4gICAgICogQHJldHVybnMgVGhlIHJlcXVlc3RlZCB2YWxpZGF0b3IgZGV0YWlscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZmV0Y2gobmV0d29ya0lkLCBhc3NldElkLCBpZCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy52YWxpZGF0b3IuZ2V0VmFsaWRhdG9yKG5ldHdvcmtJZCwgYXNzZXRJZCwgaWQpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvcihyZXNwb25zZS5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgQVBJIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICogQHJldHVybnMgVGhlIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICovXG4gICAgc3RhdGljIGdldEFQSVZhbGlkYXRvclN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuVU5LTk9XTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlVua25vd247XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBST1ZJU0lPTklORzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmluZztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuUFJPVklTSU9ORUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5Qcm92aXNpb25lZDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuREVQT1NJVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRGVwb3NpdGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5QRU5ESU5HX0FDVElWQVRJT046XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5QZW5kaW5nQWN0aXZhdGlvbjtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuQUNUSVZFOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuQWN0aXZlO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5FWElUSU5HOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGluZztcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5XSVRIRFJBV0FMX0FWQUlMQUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBpXzEuVmFsaWRhdG9yU3RhdHVzLldpdGhkcmF3YWxBdmFpbGFibGU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLldJVEhEUkFXQUxfQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5XaXRoZHJhd2FsQ29tcGxldGU7XG4gICAgICAgICAgICBjYXNlIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkFDVElWRV9TTEFTSEVEOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuQWN0aXZlU2xhc2hlZDtcbiAgICAgICAgICAgIGNhc2UgdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEX1NMQVNIRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5FeGl0ZWRTbGFzaGVkO1xuICAgICAgICAgICAgY2FzZSB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5SRUFQRUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5SZWFwZWQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuVW5rbm93bjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBWYWxpZGF0b3IgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVmFsaWRhdG9yIElELlxuICAgICAqL1xuICAgIGdldFZhbGlkYXRvcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC52YWxpZGF0b3JfaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFZhbGlkYXRvciBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgVmFsaWRhdG9yIHN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlbC5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlVua25vd246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlVOS05PV047XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5Qcm92aXNpb25pbmc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBST1ZJU0lPTklORztcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLlByb3Zpc2lvbmVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5QUk9WSVNJT05FRDtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkRlcG9zaXRlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuREVQT1NJVEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUGVuZGluZ0FjdGl2YXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLlBFTkRJTkdfQUNUSVZBVElPTjtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkFjdGl2ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuQUNUSVZFO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuRXhpdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVElORztcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkV4aXRlZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuRVhJVEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuV2l0aGRyYXdhbEF2YWlsYWJsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5WYWxpZGF0b3JTdGF0dXMuV0lUSERSQVdBTF9BVkFJTEFCTEU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5XaXRoZHJhd2FsQ29tcGxldGU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLldJVEhEUkFXQUxfQ09NUExFVEU7XG4gICAgICAgICAgICBjYXNlIGFwaV8xLlZhbGlkYXRvclN0YXR1cy5BY3RpdmVTbGFzaGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5BQ1RJVkVfU0xBU0hFRDtcbiAgICAgICAgICAgIGNhc2UgYXBpXzEuVmFsaWRhdG9yU3RhdHVzLkV4aXRlZFNsYXNoZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuVmFsaWRhdG9yU3RhdHVzLkVYSVRFRF9TTEFTSEVEO1xuICAgICAgICAgICAgY2FzZSBhcGlfMS5WYWxpZGF0b3JTdGF0dXMuUmVhcGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5SRUFQRUQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlZhbGlkYXRvclN0YXR1cy5VTktOT1dOO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsaWRhdG9yLlxuICAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYElkOiAke3RoaXMuZ2V0VmFsaWRhdG9ySWQoKX0gU3RhdHVzOiAke3RoaXMuZ2V0U3RhdHVzKCl9YDtcbiAgICB9XG59XG5leHBvcnRzLlZhbGlkYXRvciA9IFZhbGlkYXRvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = void 0;\nconst bip32_1 = __webpack_require__(/*! @scure/bip32 */ \"(ssr)/./node_modules/@scure/bip32/lib/index.js\");\nconst crypto = __importStar(__webpack_require__(/*! crypto */ \"crypto\"));\nconst decimal_js_1 = __importDefault(__webpack_require__(/*! decimal.js */ \"(ssr)/./node_modules/decimal.js/decimal.js\"));\nconst ethers_1 = __webpack_require__(/*! ethers */ \"(ssr)/./node_modules/ethers/lib.commonjs/index.js\");\nconst fs = __importStar(__webpack_require__(/*! fs */ \"fs\"));\nconst secp256k1 = __importStar(__webpack_require__(/*! secp256k1 */ \"(ssr)/./node_modules/secp256k1/index.js\"));\nconst wallet_address_1 = __webpack_require__(/*! ./address/wallet_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\");\nconst asset_1 = __webpack_require__(/*! ./asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\");\nconst balance_1 = __webpack_require__(/*! ./balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\");\nconst balance_map_1 = __webpack_require__(/*! ./balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\");\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\nconst errors_1 = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/utils.js\");\nconst webhook_1 = __webpack_require__(/*! ./webhook */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\");\n/**\n * A representation of a Wallet. Wallets come with a single default Address, but can expand to have a set of Addresses,\n * each of which can hold a balance of one or more Assets. Wallets can create new Addresses, list their addresses,\n * list their balances, and transfer Assets to other Addresses. Wallets should be created through User.createWallet or User.importWallet.\n * Wallets should be created using `Wallet.create`, imported using `Wallet.import`, or fetched using `Wallet.fetch`.\n * Existing wallets can be imported with a seed using `Wallet.import`.\n * Wallets backed by a Server Signer can be fetched with `Wallet.fetch` and used for signing operations immediately.\n */\nclass Wallet {\n    /**\n     * Private constructor to prevent direct instantiation outside of factory method. Use Wallet.init instead.\n     *\n     * @ignore\n     * @param model - The wallet model object.\n     * @param master - The HD master key.\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @hideconstructor\n     */\n    constructor(model, master, seed) {\n        this.addresses = [];\n        this.addressPathPrefix = \"m/44'/60'/0'/0\";\n        this.model = model;\n        this.master = master;\n        this.seed = seed;\n    }\n    /**\n     * Lists the Wallets belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Wallets to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Wallets. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Wallets.\n     */\n    static async listWallets({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWallets(limit, page);\n        const wallets = response.data.data;\n        for (const wallet of wallets) {\n            data.push(Wallet.init(wallet, \"\"));\n        }\n        const hasMore = response.data.has_more;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Fetches a Wallet by its ID. The returned wallet can be immediately used for signing operations if backed by a server signer.\n     * If the wallet is not backed by a server signer, the wallet's seed will need to be set before it can be used for signing operations.\n     *\n     * @param wallet_id - The ID of the Wallet to fetch\n     * @returns The fetched Wallet\n     */\n    static async fetch(wallet_id) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(wallet_id);\n        return Wallet.init(response.data, \"\");\n    }\n    /**\n     * Imports a Wallet for the given Wallet data.\n     *\n     * @param data - The Wallet data to import.\n     * @param data.walletId - The ID of the Wallet to import.\n     * @param data.seed - The seed to use for the Wallet.\n     * @returns The imported Wallet.\n     * @throws {ArgumentError} If the Wallet ID is not provided.\n     * @throws {ArgumentError} If the seed is not provided.\n     * @throws {APIError} If the request fails.\n     */\n    static async import(data) {\n        if (!data.walletId) {\n            throw new errors_1.ArgumentError(\"Wallet ID must be provided\");\n        }\n        if (!data.seed) {\n            throw new errors_1.ArgumentError(\"Seed must be provided\");\n        }\n        const walletModel = await coinbase_1.Coinbase.apiClients.wallet.getWallet(data.walletId);\n        const wallet = Wallet.init(walletModel.data, data.seed);\n        await wallet.listAddresses();\n        return wallet;\n    }\n    /**\n     * Returns a newly created Wallet object.\n     *\n     * @constructs Wallet\n     * @param options - The options to create the Wallet.\n     * @param options.networkId - the ID of the blockchain network. Defaults to 'base-sepolia'.\n     * @param options.intervalSeconds - The interval at which to poll the backend, in seconds.\n     * @param options.timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static async create({ networkId = coinbase_1.Coinbase.networks.BaseSepolia, timeoutSeconds = 20, intervalSeconds = 0.2, } = {}) {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.createWallet({\n            wallet: {\n                network_id: networkId,\n                use_server_signer: coinbase_1.Coinbase.useServerSigner,\n            },\n        });\n        const wallet = Wallet.init(result.data, undefined);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            await wallet.waitForSigner(wallet.getId(), intervalSeconds, timeoutSeconds);\n        }\n        await wallet.createAddress();\n        return wallet;\n    }\n    /**\n     * Returns a new Wallet object. Do not use this method directly. Instead, use one of:\n     * - Wallet.create (Create a new Wallet),\n     * - Wallet.import (Import a Wallet with seed),\n     * - Wallet.fetch (fetch a Wallet by ID w/o seed, useful for server signer wallets).\n     *\n     * @constructs Wallet\n     * @param model - The underlying Wallet model object\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix. If null or undefined, a new seed will be generated.\n     * If the empty string, no seed is generated, and the Wallet will be instantiated without a seed and its corresponding private keys.\n     * @throws {ArgumentError} If the model or client is not provided.\n     * @throws {Error} - If address derivation or caching fails.\n     * @throws {APIError} - If the request fails.\n     * @returns A promise that resolves with the new Wallet object.\n     */\n    static init(model, seed) {\n        const wallet = new Wallet(model, undefined, seed);\n        if (coinbase_1.Coinbase.useServerSigner) {\n            return wallet;\n        }\n        wallet.setMasterNode(seed);\n        return wallet;\n    }\n    /**\n     * Exports the Wallet's data to a WalletData object.\n     *\n     * @returns The Wallet's data.\n     * @throws {APIError} - If the request fails.\n     */\n    export() {\n        if (!this.seed) {\n            throw new Error(\"Cannot export Wallet without loaded seed\");\n        }\n        return { walletId: this.getId(), seed: this.seed };\n    }\n    /**\n     * Creates a new Address in the Wallet.\n     *\n     * @returns The new Address.\n     * @throws {APIError} - If the address creation fails.\n     */\n    async createAddress() {\n        let payload, key;\n        if (!coinbase_1.Coinbase.useServerSigner) {\n            // TODO: Coordinate this value with concurrent calls to createAddress.\n            const addressIndex = this.addresses.length;\n            const hdKey = this.deriveKey(addressIndex);\n            const attestation = this.createAttestation(hdKey);\n            const publicKey = (0, utils_1.convertStringToHex)(hdKey.publicKey);\n            key = new ethers_1.ethers.Wallet((0, utils_1.convertStringToHex)(hdKey.privateKey));\n            payload = {\n                public_key: publicKey,\n                attestation: attestation,\n                address_index: addressIndex,\n            };\n        }\n        const response = await coinbase_1.Coinbase.apiClients.address.createAddress(this.model.id, payload);\n        if (!this.addresses.length || !coinbase_1.Coinbase.useServerSigner) {\n            await this.reload();\n        }\n        const address = new wallet_address_1.WalletAddress(response.data, key);\n        this.addresses.push(address);\n        return address;\n    }\n    /**\n     * Set the seed for the Wallet.\n     *\n     * @param seed - The seed to use for the Wallet. Expects a 32-byte hexadecimal with no 0x prefix.\n     * @throws {ArgumentError} If the seed is empty.\n     * @throws {Error} If the seed is already set.\n     */\n    setSeed(seed) {\n        if (seed === undefined || seed === \"\") {\n            throw new errors_1.ArgumentError(\"Seed must not be empty\");\n        }\n        if (this.master) {\n            throw new Error(\"Seed is already set\");\n        }\n        this.setMasterNode(seed);\n        if (this.addresses.length < 1) {\n            return;\n        }\n        this.addresses.forEach((address, index) => {\n            const derivedKey = this.deriveKey(index);\n            const etherWallet = new ethers_1.ethers.Wallet((0, utils_1.convertStringToHex)(derivedKey.privateKey));\n            if (etherWallet.address != address.getId()) {\n                throw new Error(`Seed does not match wallet; cannot find address ${etherWallet.address}`);\n            }\n            address.setKey(etherWallet);\n        });\n    }\n    /**\n     * Returns the WalletAddress with the given ID.\n     *\n     * @param addressId - The ID of the WalletAddress to retrieve.\n     * @returns The WalletAddress.\n     */\n    async getAddress(addressId) {\n        if (this.addresses.length < 1) {\n            this.addresses = await this.listAddresses();\n        }\n        return this.addresses.find(address => {\n            return address.getId() === addressId;\n        });\n    }\n    /**\n     * Returns the list of Addresses in the Wallet.\n     *\n     * @returns The list of Addresses.\n     */\n    async listAddresses() {\n        const response = await coinbase_1.Coinbase.apiClients.address.listAddresses(this.getId(), Wallet.MAX_ADDRESSES);\n        const addresses = response.data.data.map((address, index) => {\n            return this.buildWalletAddress(address, index);\n        });\n        this.addresses = addresses;\n        return addresses;\n    }\n    /**\n     *  Trades the given amount of the given Asset for another Asset.\n     *  Currently only the default address is used to source the Trade.\n     *\n     * @param options - The options to create the Trade.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.fromAssetId - The ID of the Asset to trade from.\n     * @param options.toAssetId - The ID of the Asset to trade to.\n     * @throws {Error} If the default address is not found.\n     * @throws {Error} If the private key is not loaded, or if the asset IDs are unsupported, or if there are insufficient funds.\n     * @returns The created Trade object.\n     */\n    async createTrade(options) {\n        return (await this.getDefaultAddress()).createTrade(options);\n    }\n    /**\n     * Get the stakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the stakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the stakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The stakeable balance.\n     */\n    async stakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).stakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the unstakeable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check the unstakeable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the unstakeable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The unstakeable balance.\n     */\n    async unstakeableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).unstakeableBalance(asset_id, mode, options);\n    }\n    /**\n     * Get the claimable balance for the supplied asset.\n     *\n     * @param asset_id - The asset to check claimable balance for.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options for getting the claimable balance.\n     * @throws {Error} if the default address is not found.\n     * @returns The claimable balance.\n     */\n    async claimableBalance(asset_id, mode = types_1.StakeOptionsMode.DEFAULT, options = {}) {\n        return (await this.getDefaultAddress()).claimableBalance(asset_id, mode, options);\n    }\n    /**\n     * Lists the staking rewards for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @param format - The format to return the rewards in. (usd, native). Defaults to usd.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking rewards.\n     */\n    async stakingRewards(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date()), format = types_1.StakingRewardFormat.USD) {\n        return (await this.getDefaultAddress()).stakingRewards(assetId, startTime, endTime, format);\n    }\n    /**\n     * Lists the historical staking balances for the address.\n     *\n     * @param assetId - The asset ID.\n     * @param startTime - The start time.\n     * @param endTime - The end time.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking balances.\n     */\n    async historicalStakingBalances(assetId, startTime = (0, utils_1.getWeekBackDate)(new Date()), endTime = (0, utils_1.formatDate)(new Date())) {\n        return (await this.getDefaultAddress()).historicalStakingBalances(assetId, startTime, endTime);\n    }\n    /**\n     * Lists the historical balances for a given asset belonging to the default address of the wallet.\n     *\n     * @param assetId - The asset ID.\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Historical Balances to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Historical Balances. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Historical Balances for the given Asset ID.\n     */\n    async listHistoricalBalances(assetId, { limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined } = {}) {\n        return (await this.getDefaultAddress()).listHistoricalBalances(assetId, { limit, page });\n    }\n    /**\n     * Creates a staking operation to stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to unstake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed successfully.\n     */\n    async createUnstake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createUnstake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Creates a staking operation to claim stake, signs it, and broadcasts it on the blockchain.\n     *\n     * @param amount - The amount for the staking operation.\n     * @param assetId - The asset for the staking operation.\n     * @param mode - The staking mode. Defaults to DEFAULT.\n     * @param options - Additional options such as setting the mode for the staking action.\n     * @param timeoutSeconds - The amount to wait for the transaction to complete when broadcasted.\n     * @param intervalSeconds - The amount to check each time for a successful broadcast.\n     * @throws {Error} if the default address is not found.\n     * @returns The staking operation after it's completed fully.\n     */\n    async createClaimStake(amount, assetId, mode = types_1.StakeOptionsMode.DEFAULT, options = {}, timeoutSeconds = 60, intervalSeconds = 0.2) {\n        return (await this.getDefaultAddress()).createClaimStake(amount, assetId, mode, options, timeoutSeconds, intervalSeconds);\n    }\n    /**\n     * Returns the list of balances of this Wallet. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @returns The list of balances. The key is the Asset ID, and the value is the balance.\n     */\n    async listBalances() {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.listWalletBalances(this.model.id);\n        return balance_map_1.BalanceMap.fromBalances(response.data.data);\n    }\n    /**\n     * Returns the balance of the provided Asset. Balances are aggregated across all Addresses in the Wallet.\n     *\n     * @param assetId - The ID of the Asset to retrieve the balance for.\n     * @returns The balance of the Asset.\n     */\n    async getBalance(assetId) {\n        const response = await coinbase_1.Coinbase.apiClients.wallet.getWalletBalance(this.model.id, asset_1.Asset.primaryDenomination(assetId));\n        if (!response.data.amount) {\n            return new decimal_js_1.default(0);\n        }\n        const balance = balance_1.Balance.fromModelAndAssetId(response.data, assetId);\n        return balance.amount;\n    }\n    /**\n     * Returns the Network ID of the Wallet.\n     *\n     * @returns The network ID.\n     */\n    getNetworkId() {\n        return this.model.network_id;\n    }\n    /**\n     * Returns the ServerSigner Status of the Wallet.\n     *\n     * @returns the ServerSigner Status.\n     */\n    getServerSignerStatus() {\n        const status = {\n            pending_seed_creation: types_1.ServerSignerStatus.PENDING,\n            active_seed: types_1.ServerSignerStatus.ACTIVE,\n        };\n        return this.model.server_signer_status ? status[this.model.server_signer_status] : undefined;\n    }\n    /**\n     * Returns the wallet ID.\n     *\n     * @returns The wallet ID.\n     */\n    getId() {\n        return this.model.id;\n    }\n    /**\n     * Saves the seed of the Wallet to the given file. Wallets whose seeds are saved this way can be\n     * rehydrated using load_seed. A single file can be used for multiple Wallet seeds.\n     * This is an insecure method of storing Wallet seeds and should only be used for development purposes.\n     *\n     * @param filePath - The path of the file to save the seed to\n     * @param encrypt - Whether the seed information persisted to the local file system should be\n     * encrypted or not. Data is unencrypted by default.\n     * @returns A string indicating the success of the operation\n     * @throws {Error} If the Wallet does not have a seed\n     */\n    saveSeed(filePath, encrypt = false) {\n        if (!this.master) {\n            throw new Error(\"Cannot save Wallet without loaded seed\");\n        }\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        const data = this.export();\n        let seedToStore = data.seed;\n        let authTag = \"\";\n        let iv = \"\";\n        if (encrypt) {\n            const ivBytes = crypto.randomBytes(12);\n            const sharedSecret = this.getEncryptionKey();\n            const cipher = crypto.createCipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), ivBytes);\n            const encryptedData = Buffer.concat([cipher.update(data.seed, \"utf8\"), cipher.final()]);\n            authTag = cipher.getAuthTag().toString(\"hex\");\n            seedToStore = encryptedData.toString(\"hex\");\n            iv = ivBytes.toString(\"hex\");\n        }\n        existingSeedsInStore[data.walletId] = {\n            seed: seedToStore,\n            encrypted: encrypt,\n            authTag: authTag,\n            iv: iv,\n        };\n        fs.writeFileSync(filePath, JSON.stringify(existingSeedsInStore, null, 2), \"utf8\");\n        return `Successfully saved seed for ${data.walletId} to ${filePath}.`;\n    }\n    /**\n     * Loads the seed of the Wallet from the given file.\n     *\n     * @param filePath - The path of the file to load the seed from\n     * @returns A string indicating the success of the operation\n     */\n    async loadSeed(filePath) {\n        const existingSeedsInStore = this.getExistingSeeds(filePath);\n        if (Object.keys(existingSeedsInStore).length === 0) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain any seed data`);\n        }\n        if (existingSeedsInStore[this.getId()] === undefined) {\n            throw new errors_1.ArgumentError(`File ${filePath} does not contain seed data for wallet ${this.getId()}`);\n        }\n        const seedData = existingSeedsInStore[this.getId()];\n        let seed = seedData.seed;\n        if (!seed) {\n            /* istanbul ignore next */\n            throw new errors_1.ArgumentError(\"Seed data is malformed\");\n        }\n        if (seedData.encrypted) {\n            const sharedSecret = this.getEncryptionKey();\n            if (!seedData.iv || !seedData.authTag) {\n                /* istanbul ignore next */\n                throw new errors_1.ArgumentError(\"Encrypted seed data is malformed\");\n            }\n            const decipher = crypto.createDecipheriv(\"aes-256-gcm\", crypto.createHash(\"sha256\").update(sharedSecret).digest(), Buffer.from(seedData.iv, \"hex\"));\n            decipher.setAuthTag(Buffer.from(seedData.authTag, \"hex\"));\n            const decryptedData = Buffer.concat([\n                decipher.update(Buffer.from(seed, \"hex\")),\n                decipher.final(),\n            ]);\n            seed = decryptedData.toString(\"utf8\");\n        }\n        this.setSeed(seed);\n        await this.listAddresses();\n        return `Successfully loaded seed for wallet ${this.getId()} from ${filePath}.`;\n    }\n    /**\n     * Returns the default address of the Wallet.\n     *\n     * @returns The default address\n     */\n    async getDefaultAddress() {\n        if (this.model.default_address === undefined) {\n            throw new Error(\"WalletModel default address not set\");\n        }\n        const defaultAddress = await this.getAddress(this.model.default_address.address_id);\n        if (!defaultAddress) {\n            throw new Error(\"Default address not found\");\n        }\n        return defaultAddress;\n    }\n    /**\n     * Returns whether the Wallet has a seed with which to derive keys and sign transactions.\n     *\n     * @returns Whether the Wallet has a seed with which to derive keys and sign transactions.\n     */\n    canSign() {\n        return this.master?.publicKey !== undefined;\n    }\n    /**\n     * Requests funds from the faucet for the Wallet's default address and returns the faucet transaction.\n     * This is only supported on testnet networks.\n     *\n     * @param assetId - The ID of the Asset to request from the faucet.\n     * @throws {Error} If the default address is not found.\n     * @throws {APIError} If the request fails.\n     * @returns The successful faucet transaction\n     */\n    async faucet(assetId) {\n        if (!this.model.default_address) {\n            throw new Error(\"Default address not found\");\n        }\n        const transaction = (await this.getDefaultAddress()).faucet(assetId);\n        return transaction;\n    }\n    /**\n     * Transfers the given amount of the given Asset to the given address. Only same-Network Transfers are supported.\n     * Currently only the default_address is used to source the Transfer.\n     *\n     * @param options - The options to create the Transfer.\n     * @param options.amount - The amount of the Asset to send.\n     * @param options.assetId - The ID of the Asset to send.\n     * @param options.destination - The destination of the transfer. If a Wallet, sends to the Wallet's default address. If a String, interprets it as the address ID.\n     * @param options.gasless - Whether the Transfer should be gasless. Defaults to false.\n     * @returns The created Transfer object.\n     * @throws {APIError} if the API request to create a Transfer fails.\n     * @throws {APIError} if the API request to broadcast a Transfer fails.\n     */\n    async createTransfer(options) {\n        return (await this.getDefaultAddress()).createTransfer(options);\n    }\n    /**\n     * Creates a Payload Signature.\n     *\n     * @param unsignedPayload - The Unsigned Payload to sign.\n     * @returns A promise that resolves to the Payload Signature object.\n     * @throws {APIError} if the API request to create a Payload Signature fails.\n     * @throws {Error} if the default address is not found.\n     */\n    async createPayloadSignature(unsignedPayload) {\n        return (await this.getDefaultAddress()).createPayloadSignature(unsignedPayload);\n    }\n    /**\n     * Creates a Webhook for a wallet, monitors all wallet addresses for onchain events.\n     *\n     * @param notificationUri - The URI to which the webhook notifications will be sent.\n     *\n     * @returns The newly created webhook instance.\n     */\n    async createWebhook(notificationUri) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWalletWebhook(this.getId(), {\n            notification_uri: notificationUri,\n        });\n        return webhook_1.Webhook.init(result.data);\n    }\n    /**\n     * Invokes a contract with the given data.\n     *\n     * @param options - The options to invoke the contract\n     * @param options.contractAddress - The address of the contract the method will be invoked on.\n     * @param options.method - The method to invoke on the contract.\n     * @param options.abi - The ABI of the contract.\n     * @param options.args - The arguments to pass to the contract method invocation.\n     *   The keys should be the argument names and the values should be the argument values.\n     * @param options.amount - The amount of the asset to send to a payable contract method.\n     * @param options.assetId - The ID of the asset to send to a payable contract method.\n     *   The asset must be a denomination of the native asset. (Ex. \"wei\", \"gwei\", or \"eth\").\n     * @returns The ContractInvocation object.\n     * @throws {APIError} if the API request to create a contract invocation fails.\n     */\n    async invokeContract(options) {\n        return (await this.getDefaultAddress()).invokeContract(options);\n    }\n    /**\n     * Deploys an ERC20 token contract.\n     *\n     * @param options - The options for creating the ERC20 token.\n     * @param options.name - The name of the ERC20 token.\n     * @param options.symbol - The symbol of the ERC20 token.\n     * @param options.totalSupply - The total supply of the ERC20 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployToken(options) {\n        return (await this.getDefaultAddress()).deployToken(options);\n    }\n    /**\n     * Deploys an ERC721 token contract.\n     *\n     * @param options - The options for creating the ERC721 token.\n     * @param options.name - The name of the ERC721 token.\n     * @param options.symbol - The symbol of the ERC721 token.\n     * @param options.baseURI - The base URI of the ERC721 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployNFT(options) {\n        return (await this.getDefaultAddress()).deployNFT(options);\n    }\n    /**\n     * Deploys an ERC1155 token contract.\n     *\n     * @param options - The options for creating the ERC1155 token.\n     * @param options.name - The name of the ERC1155 token.\n     * @param options.symbol - The symbol of the ERC1155 token.\n     * @param options.baseURI - The base URI of the ERC1155 token.\n     * @returns A Promise that resolves to the deployed SmartContract object.\n     * @throws {Error} If the private key is not loaded when not using server signer.\n     */\n    async deployMultiToken(options) {\n        return (await this.getDefaultAddress()).deployMultiToken(options);\n    }\n    /**\n     * Returns a String representation of the Wallet.\n     *\n     * @returns a String representation of the Wallet\n     */\n    toString() {\n        return `Wallet{id: '${this.model.id}', networkId: '${this.model.network_id}'}`;\n    }\n    /**\n     * Validates the seed and address models passed to the constructor.\n     *\n     * @param seed - The seed to use for the Wallet\n     */\n    validateSeed(seed) {\n        if (seed && seed.length !== 64) {\n            throw new errors_1.ArgumentError(\"Seed must be 32 bytes\");\n        }\n    }\n    /**\n     * Loads the seed data from the given file.\n     *\n     * @param filePath - The path of the file to load the seed data from\n     * @returns The seed data\n     */\n    getExistingSeeds(filePath) {\n        try {\n            const data = fs.readFileSync(filePath, \"utf8\");\n            if (!data) {\n                return {};\n            }\n            const seedData = JSON.parse(data);\n            if (!Object.entries(seedData).every(([key, value]) => typeof key === \"string\" &&\n                /* eslint-disable @typescript-eslint/no-explicit-any */\n                typeof value.authTag === \"string\" &&\n                typeof value.encrypted === \"boolean\" &&\n                typeof value.iv === \"string\" &&\n                typeof value.seed === \"string\")) {\n                throw new errors_1.ArgumentError(\"Malformed backup data\");\n            }\n            return seedData;\n        }\n        catch (error) {\n            /* eslint-enable @typescript-eslint/no-explicit-any */\n            if (error.code === \"ENOENT\") {\n                return {};\n            }\n            throw new errors_1.ArgumentError(\"Malformed backup data\");\n        }\n    }\n    /**\n     * Gets the key for encrypting seed data.\n     *\n     * @returns The encryption key.\n     */\n    getEncryptionKey() {\n        const privateKey = crypto.createPrivateKey(coinbase_1.Coinbase.apiKeyPrivateKey);\n        const publicKey = crypto.createPublicKey(coinbase_1.Coinbase.apiKeyPrivateKey);\n        const encryptionKey = crypto.diffieHellman({\n            privateKey,\n            publicKey,\n        });\n        return encryptionKey;\n    }\n    /**\n     * Returns a WalletAddress object for the given AddressModel.\n     *\n     * @param addressModel - The AddressModel to build the WalletAddress from.\n     * @param index - The index of the AddressModel.\n     * @returns The WalletAddress object.\n     */\n    buildWalletAddress(addressModel, index) {\n        if (!this.master) {\n            return new wallet_address_1.WalletAddress(addressModel);\n        }\n        const key = this.deriveKey(index);\n        const ethWallet = new ethers_1.ethers.Wallet((0, utils_1.convertStringToHex)(key.privateKey));\n        if (ethWallet.address != addressModel.address_id) {\n            throw new Error(`Seed does not match wallet`);\n        }\n        return new wallet_address_1.WalletAddress(addressModel, ethWallet);\n    }\n    /**\n     * Waits until the ServerSigner has created a seed for the Wallet.\n     *\n     * @param walletId - The ID of the Wallet that is awaiting seed creation.\n     * @param intervalSeconds - The interval at which to poll the CDPService, in seconds.\n     * @param timeoutSeconds - The maximum amount of time to wait for the ServerSigner to create a seed, in seconds.\n     * @throws {APIError} if the API request to get a Wallet fails.\n     * @throws {Error} if the ServerSigner times out.\n     */\n    async waitForSigner(walletId, intervalSeconds = 0.2, timeoutSeconds = 20) {\n        const startTime = Date.now();\n        while (Date.now() - startTime < timeoutSeconds * 1000) {\n            const response = await coinbase_1.Coinbase.apiClients.wallet.getWallet(walletId);\n            if (response?.data.server_signer_status === types_1.ServerSignerStatus.ACTIVE) {\n                return;\n            }\n            await (0, utils_1.delay)(intervalSeconds);\n        }\n        throw new Error(\"Wallet creation timed out. Check status of your Server-Signer\");\n    }\n    /**\n     * Sets the master node for the given seed, if valid. If the seed is undefined it will set the master node using a random seed.\n     *\n     * @param seed - The seed to use for the Wallet.\n     * @returns The master node for the given seed.\n     */\n    setMasterNode(seed) {\n        if (seed === \"\") {\n            return undefined;\n        }\n        if (seed === undefined) {\n            seed = ethers_1.ethers.Wallet.createRandom().privateKey.slice(2);\n        }\n        this.validateSeed(seed);\n        this.seed = seed;\n        this.master = bip32_1.HDKey.fromMasterSeed(Buffer.from(seed, \"hex\"));\n    }\n    /**\n     * Derives a key for an already registered Address in the Wallet.\n     *\n     * @param index - The index of the Address to derive.\n     * @throws {Error} - If the key derivation fails.\n     * @returns The derived key.\n     */\n    deriveKey(index) {\n        if (!this.master) {\n            throw new Error(\"Cannot derive key for Wallet without seed loaded\");\n        }\n        const derivedKey = this.master?.derive(this.addressPathPrefix + `/${index}`);\n        if (!derivedKey?.privateKey) {\n            throw new Error(\"Failed to derive key\");\n        }\n        return derivedKey;\n    }\n    /**\n     * Creates an attestation for the Address currently being created.\n     *\n     * @param key - The key of the Wallet.\n     * @returns The attestation.\n     */\n    createAttestation(key) {\n        if (!key.publicKey || !key.privateKey) {\n            /* istanbul ignore next */\n            throw Error;\n        }\n        const publicKey = (0, utils_1.convertStringToHex)(key.publicKey);\n        const payload = JSON.stringify({\n            wallet_id: this.model.id,\n            public_key: publicKey,\n        });\n        const hashedPayload = crypto.createHash(\"sha256\").update(payload).digest();\n        const signature = secp256k1.ecdsaSign(hashedPayload, key.privateKey);\n        const r = signature.signature.slice(0, 32);\n        const s = signature.signature.slice(32, 64);\n        const v = signature.recid + 27 + 4;\n        const newSignatureBuffer = Buffer.concat([Buffer.from([v]), r, s]);\n        const newSignatureHex = newSignatureBuffer.toString(\"hex\");\n        return newSignatureHex;\n    }\n    /**\n     * Reloads the Wallet model with the latest data from the server.\n     *\n     * @throws {APIError} if the API request to get a Wallet fails.\n     */\n    async reload() {\n        const result = await coinbase_1.Coinbase.apiClients.wallet.getWallet(this.model.id);\n        this.model = result?.data;\n    }\n}\nexports.Wallet = Wallet;\nWallet.MAX_ADDRESSES = 20;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZ0JBQWdCLG1CQUFPLENBQUMsb0VBQWM7QUFDdEMsNEJBQTRCLG1CQUFPLENBQUMsc0JBQVE7QUFDNUMscUNBQXFDLG1CQUFPLENBQUMsOERBQVk7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsaUVBQVE7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsY0FBSTtBQUNwQywrQkFBK0IsbUJBQU8sQ0FBQywwREFBVztBQUNsRCx5QkFBeUIsbUJBQU8sQ0FBQyxxSEFBMEI7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckMsc0JBQXNCLG1CQUFPLENBQUMsK0ZBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMseUZBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMscUZBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMsdUZBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE9BQU8sY0FBYyxpQkFBaUIsc0JBQXNCLEVBQUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLE1BQU07QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dhbGxldC5qcz84NjJkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldhbGxldCA9IHZvaWQgMDtcbmNvbnN0IGJpcDMyXzEgPSByZXF1aXJlKFwiQHNjdXJlL2JpcDMyXCIpO1xuY29uc3QgY3J5cHRvID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJjcnlwdG9cIikpO1xuY29uc3QgZGVjaW1hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IGZzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJmc1wiKSk7XG5jb25zdCBzZWNwMjU2azEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNlY3AyNTZrMVwiKSk7XG5jb25zdCB3YWxsZXRfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vYWRkcmVzcy93YWxsZXRfYWRkcmVzc1wiKTtcbmNvbnN0IGFzc2V0XzEgPSByZXF1aXJlKFwiLi9hc3NldFwiKTtcbmNvbnN0IGJhbGFuY2VfMSA9IHJlcXVpcmUoXCIuL2JhbGFuY2VcIik7XG5jb25zdCBiYWxhbmNlX21hcF8xID0gcmVxdWlyZShcIi4vYmFsYW5jZV9tYXBcIik7XG5jb25zdCBjb2luYmFzZV8xID0gcmVxdWlyZShcIi4vY29pbmJhc2VcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHdlYmhvb2tfMSA9IHJlcXVpcmUoXCIuL3dlYmhvb2tcIik7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYSBXYWxsZXQuIFdhbGxldHMgY29tZSB3aXRoIGEgc2luZ2xlIGRlZmF1bHQgQWRkcmVzcywgYnV0IGNhbiBleHBhbmQgdG8gaGF2ZSBhIHNldCBvZiBBZGRyZXNzZXMsXG4gKiBlYWNoIG9mIHdoaWNoIGNhbiBob2xkIGEgYmFsYW5jZSBvZiBvbmUgb3IgbW9yZSBBc3NldHMuIFdhbGxldHMgY2FuIGNyZWF0ZSBuZXcgQWRkcmVzc2VzLCBsaXN0IHRoZWlyIGFkZHJlc3NlcyxcbiAqIGxpc3QgdGhlaXIgYmFsYW5jZXMsIGFuZCB0cmFuc2ZlciBBc3NldHMgdG8gb3RoZXIgQWRkcmVzc2VzLiBXYWxsZXRzIHNob3VsZCBiZSBjcmVhdGVkIHRocm91Z2ggVXNlci5jcmVhdGVXYWxsZXQgb3IgVXNlci5pbXBvcnRXYWxsZXQuXG4gKiBXYWxsZXRzIHNob3VsZCBiZSBjcmVhdGVkIHVzaW5nIGBXYWxsZXQuY3JlYXRlYCwgaW1wb3J0ZWQgdXNpbmcgYFdhbGxldC5pbXBvcnRgLCBvciBmZXRjaGVkIHVzaW5nIGBXYWxsZXQuZmV0Y2hgLlxuICogRXhpc3Rpbmcgd2FsbGV0cyBjYW4gYmUgaW1wb3J0ZWQgd2l0aCBhIHNlZWQgdXNpbmcgYFdhbGxldC5pbXBvcnRgLlxuICogV2FsbGV0cyBiYWNrZWQgYnkgYSBTZXJ2ZXIgU2lnbmVyIGNhbiBiZSBmZXRjaGVkIHdpdGggYFdhbGxldC5mZXRjaGAgYW5kIHVzZWQgZm9yIHNpZ25pbmcgb3BlcmF0aW9ucyBpbW1lZGlhdGVseS5cbiAqL1xuY2xhc3MgV2FsbGV0IHtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yIHRvIHByZXZlbnQgZGlyZWN0IGluc3RhbnRpYXRpb24gb3V0c2lkZSBvZiBmYWN0b3J5IG1ldGhvZC4gVXNlIFdhbGxldC5pbml0IGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIG1vZGVsIC0gVGhlIHdhbGxldCBtb2RlbCBvYmplY3QuXG4gICAgICogQHBhcmFtIG1hc3RlciAtIFRoZSBIRCBtYXN0ZXIga2V5LlxuICAgICAqIEBwYXJhbSBzZWVkIC0gVGhlIHNlZWQgdG8gdXNlIGZvciB0aGUgV2FsbGV0LiBFeHBlY3RzIGEgMzItYnl0ZSBoZXhhZGVjaW1hbCB3aXRoIG5vIDB4IHByZWZpeC5cbiAgICAgKiBAaGlkZWNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobW9kZWwsIG1hc3Rlciwgc2VlZCkge1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZHJlc3NQYXRoUHJlZml4ID0gXCJtLzQ0Jy82MCcvMCcvMFwiO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMubWFzdGVyID0gbWFzdGVyO1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgV2FsbGV0cyBiZWxvbmdpbmcgdG8gdGhlIENEUCBQcm9qZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcGFnaW5hdGlvbiBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIFdhbGxldHMgdG8gcmV0dXJuLiBMaW1pdCBjYW4gcmFuZ2UgYmV0d2VlbiAxIGFuZCAxMDAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFnZSAtIFRoZSBjdXJzb3IgZm9yIHBhZ2luYXRpb24gYWNyb3NzIG11bHRpcGxlIHBhZ2VzIG9mIFdhbGxldHMuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgV2FsbGV0cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgbGlzdFdhbGxldHMoeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQYWdlO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQubGlzdFdhbGxldHMobGltaXQsIHBhZ2UpO1xuICAgICAgICBjb25zdCB3YWxsZXRzID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xuICAgICAgICBmb3IgKGNvbnN0IHdhbGxldCBvZiB3YWxsZXRzKSB7XG4gICAgICAgICAgICBkYXRhLnB1c2goV2FsbGV0LmluaXQod2FsbGV0LCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmU7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgV2FsbGV0IGJ5IGl0cyBJRC4gVGhlIHJldHVybmVkIHdhbGxldCBjYW4gYmUgaW1tZWRpYXRlbHkgdXNlZCBmb3Igc2lnbmluZyBvcGVyYXRpb25zIGlmIGJhY2tlZCBieSBhIHNlcnZlciBzaWduZXIuXG4gICAgICogSWYgdGhlIHdhbGxldCBpcyBub3QgYmFja2VkIGJ5IGEgc2VydmVyIHNpZ25lciwgdGhlIHdhbGxldCdzIHNlZWQgd2lsbCBuZWVkIHRvIGJlIHNldCBiZWZvcmUgaXQgY2FuIGJlIHVzZWQgZm9yIHNpZ25pbmcgb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRfaWQgLSBUaGUgSUQgb2YgdGhlIFdhbGxldCB0byBmZXRjaFxuICAgICAqIEByZXR1cm5zIFRoZSBmZXRjaGVkIFdhbGxldFxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmZXRjaCh3YWxsZXRfaWQpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2FsbGV0LmdldFdhbGxldCh3YWxsZXRfaWQpO1xuICAgICAgICByZXR1cm4gV2FsbGV0LmluaXQocmVzcG9uc2UuZGF0YSwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYSBXYWxsZXQgZm9yIHRoZSBnaXZlbiBXYWxsZXQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIFdhbGxldCBkYXRhIHRvIGltcG9ydC5cbiAgICAgKiBAcGFyYW0gZGF0YS53YWxsZXRJZCAtIFRoZSBJRCBvZiB0aGUgV2FsbGV0IHRvIGltcG9ydC5cbiAgICAgKiBAcGFyYW0gZGF0YS5zZWVkIC0gVGhlIHNlZWQgdG8gdXNlIGZvciB0aGUgV2FsbGV0LlxuICAgICAqIEByZXR1cm5zIFRoZSBpbXBvcnRlZCBXYWxsZXQuXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIFdhbGxldCBJRCBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIHNlZWQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgaW1wb3J0KGRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXRhLndhbGxldElkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIldhbGxldCBJRCBtdXN0IGJlIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YS5zZWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIlNlZWQgbXVzdCBiZSBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXRNb2RlbCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQuZ2V0V2FsbGV0KGRhdGEud2FsbGV0SWQpO1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBXYWxsZXQuaW5pdCh3YWxsZXRNb2RlbC5kYXRhLCBkYXRhLnNlZWQpO1xuICAgICAgICBhd2FpdCB3YWxsZXQubGlzdEFkZHJlc3NlcygpO1xuICAgICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3bHkgY3JlYXRlZCBXYWxsZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdHMgV2FsbGV0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgdGhlIFdhbGxldC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXR3b3JrSWQgLSB0aGUgSUQgb2YgdGhlIGJsb2NrY2hhaW4gbmV0d29yay4gRGVmYXVsdHMgdG8gJ2Jhc2Utc2Vwb2xpYScuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHBvbGwgdGhlIGJhY2tlbmQsIGluIHNlY29uZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudGltZW91dFNlY29uZHMgLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciB0aGUgU2VydmVyU2lnbmVyIHRvIGNyZWF0ZSBhIHNlZWQsIGluIHNlY29uZHMuXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIG1vZGVsIG9yIGNsaWVudCBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gSWYgYWRkcmVzcyBkZXJpdmF0aW9uIG9yIGNhY2hpbmcgZmFpbHMuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IC0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgbmV3IFdhbGxldCBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZSh7IG5ldHdvcmtJZCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UubmV0d29ya3MuQmFzZVNlcG9saWEsIHRpbWVvdXRTZWNvbmRzID0gMjAsIGludGVydmFsU2Vjb25kcyA9IDAuMiwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53YWxsZXQuY3JlYXRlV2FsbGV0KHtcbiAgICAgICAgICAgIHdhbGxldDoge1xuICAgICAgICAgICAgICAgIG5ldHdvcmtfaWQ6IG5ldHdvcmtJZCxcbiAgICAgICAgICAgICAgICB1c2Vfc2VydmVyX3NpZ25lcjogY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gV2FsbGV0LmluaXQocmVzdWx0LmRhdGEsIHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChjb2luYmFzZV8xLkNvaW5iYXNlLnVzZVNlcnZlclNpZ25lcikge1xuICAgICAgICAgICAgYXdhaXQgd2FsbGV0LndhaXRGb3JTaWduZXIod2FsbGV0LmdldElkKCksIGludGVydmFsU2Vjb25kcywgdGltZW91dFNlY29uZHMpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHdhbGxldC5jcmVhdGVBZGRyZXNzKCk7XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgV2FsbGV0IG9iamVjdC4gRG8gbm90IHVzZSB0aGlzIG1ldGhvZCBkaXJlY3RseS4gSW5zdGVhZCwgdXNlIG9uZSBvZjpcbiAgICAgKiAtIFdhbGxldC5jcmVhdGUgKENyZWF0ZSBhIG5ldyBXYWxsZXQpLFxuICAgICAqIC0gV2FsbGV0LmltcG9ydCAoSW1wb3J0IGEgV2FsbGV0IHdpdGggc2VlZCksXG4gICAgICogLSBXYWxsZXQuZmV0Y2ggKGZldGNoIGEgV2FsbGV0IGJ5IElEIHcvbyBzZWVkLCB1c2VmdWwgZm9yIHNlcnZlciBzaWduZXIgd2FsbGV0cykuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0cyBXYWxsZXRcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBXYWxsZXQgbW9kZWwgb2JqZWN0XG4gICAgICogQHBhcmFtIHNlZWQgLSBUaGUgc2VlZCB0byB1c2UgZm9yIHRoZSBXYWxsZXQuIEV4cGVjdHMgYSAzMi1ieXRlIGhleGFkZWNpbWFsIHdpdGggbm8gMHggcHJlZml4LiBJZiBudWxsIG9yIHVuZGVmaW5lZCwgYSBuZXcgc2VlZCB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICAgKiBJZiB0aGUgZW1wdHkgc3RyaW5nLCBubyBzZWVkIGlzIGdlbmVyYXRlZCwgYW5kIHRoZSBXYWxsZXQgd2lsbCBiZSBpbnN0YW50aWF0ZWQgd2l0aG91dCBhIHNlZWQgYW5kIGl0cyBjb3JyZXNwb25kaW5nIHByaXZhdGUga2V5cy5cbiAgICAgKiBAdGhyb3dzIHtBcmd1bWVudEVycm9yfSBJZiB0aGUgbW9kZWwgb3IgY2xpZW50IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiBhZGRyZXNzIGRlcml2YXRpb24gb3IgY2FjaGluZyBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gLSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXcgV2FsbGV0IG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdChtb2RlbCwgc2VlZCkge1xuICAgICAgICBjb25zdCB3YWxsZXQgPSBuZXcgV2FsbGV0KG1vZGVsLCB1bmRlZmluZWQsIHNlZWQpO1xuICAgICAgICBpZiAoY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgICAgIH1cbiAgICAgICAgd2FsbGV0LnNldE1hc3Rlck5vZGUoc2VlZCk7XG4gICAgICAgIHJldHVybiB3YWxsZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIFdhbGxldCdzIGRhdGEgdG8gYSBXYWxsZXREYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBXYWxsZXQncyBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGV4cG9ydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBleHBvcnQgV2FsbGV0IHdpdGhvdXQgbG9hZGVkIHNlZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgd2FsbGV0SWQ6IHRoaXMuZ2V0SWQoKSwgc2VlZDogdGhpcy5zZWVkIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQWRkcmVzcyBpbiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBBZGRyZXNzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSAtIElmIHRoZSBhZGRyZXNzIGNyZWF0aW9uIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZUFkZHJlc3MoKSB7XG4gICAgICAgIGxldCBwYXlsb2FkLCBrZXk7XG4gICAgICAgIGlmICghY29pbmJhc2VfMS5Db2luYmFzZS51c2VTZXJ2ZXJTaWduZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IENvb3JkaW5hdGUgdGhpcyB2YWx1ZSB3aXRoIGNvbmN1cnJlbnQgY2FsbHMgdG8gY3JlYXRlQWRkcmVzcy5cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NJbmRleCA9IHRoaXMuYWRkcmVzc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhkS2V5ID0gdGhpcy5kZXJpdmVLZXkoYWRkcmVzc0luZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVzdGF0aW9uID0gdGhpcy5jcmVhdGVBdHRlc3RhdGlvbihoZEtleSk7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMS5jb252ZXJ0U3RyaW5nVG9IZXgpKGhkS2V5LnB1YmxpY0tleSk7XG4gICAgICAgICAgICBrZXkgPSBuZXcgZXRoZXJzXzEuZXRoZXJzLldhbGxldCgoMCwgdXRpbHNfMS5jb252ZXJ0U3RyaW5nVG9IZXgpKGhkS2V5LnByaXZhdGVLZXkpKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgcHVibGljX2tleTogcHVibGljS2V5LFxuICAgICAgICAgICAgICAgIGF0dGVzdGF0aW9uOiBhdHRlc3RhdGlvbixcbiAgICAgICAgICAgICAgICBhZGRyZXNzX2luZGV4OiBhZGRyZXNzSW5kZXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLmFkZHJlc3MuY3JlYXRlQWRkcmVzcyh0aGlzLm1vZGVsLmlkLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3Nlcy5sZW5ndGggfHwgIWNvaW5iYXNlXzEuQ29pbmJhc2UudXNlU2VydmVyU2lnbmVyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBuZXcgd2FsbGV0X2FkZHJlc3NfMS5XYWxsZXRBZGRyZXNzKHJlc3BvbnNlLmRhdGEsIGtleSk7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzLnB1c2goYWRkcmVzcyk7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNlZWQgZm9yIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC4gRXhwZWN0cyBhIDMyLWJ5dGUgaGV4YWRlY2ltYWwgd2l0aCBubyAweCBwcmVmaXguXG4gICAgICogQHRocm93cyB7QXJndW1lbnRFcnJvcn0gSWYgdGhlIHNlZWQgaXMgZW1wdHkuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBzZWVkIGlzIGFscmVhZHkgc2V0LlxuICAgICAqL1xuICAgIHNldFNlZWQoc2VlZCkge1xuICAgICAgICBpZiAoc2VlZCA9PT0gdW5kZWZpbmVkIHx8IHNlZWQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiU2VlZCBtdXN0IG5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXN0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlZWQgaXMgYWxyZWFkeSBzZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRNYXN0ZXJOb2RlKHNlZWQpO1xuICAgICAgICBpZiAodGhpcy5hZGRyZXNzZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gdGhpcy5kZXJpdmVLZXkoaW5kZXgpO1xuICAgICAgICAgICAgY29uc3QgZXRoZXJXYWxsZXQgPSBuZXcgZXRoZXJzXzEuZXRoZXJzLldhbGxldCgoMCwgdXRpbHNfMS5jb252ZXJ0U3RyaW5nVG9IZXgpKGRlcml2ZWRLZXkucHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgaWYgKGV0aGVyV2FsbGV0LmFkZHJlc3MgIT0gYWRkcmVzcy5nZXRJZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWVkIGRvZXMgbm90IG1hdGNoIHdhbGxldDsgY2Fubm90IGZpbmQgYWRkcmVzcyAke2V0aGVyV2FsbGV0LmFkZHJlc3N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzLnNldEtleShldGhlcldhbGxldCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBXYWxsZXRBZGRyZXNzIHdpdGggdGhlIGdpdmVuIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NJZCAtIFRoZSBJRCBvZiB0aGUgV2FsbGV0QWRkcmVzcyB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0QWRkcmVzcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBZGRyZXNzKGFkZHJlc3NJZCkge1xuICAgICAgICBpZiAodGhpcy5hZGRyZXNzZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBhd2FpdCB0aGlzLmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGRyZXNzZXMuZmluZChhZGRyZXNzID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhZGRyZXNzLmdldElkKCkgPT09IGFkZHJlc3NJZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgQWRkcmVzc2VzIGluIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBBZGRyZXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdEFkZHJlc3NlcygpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMuYWRkcmVzcy5saXN0QWRkcmVzc2VzKHRoaXMuZ2V0SWQoKSwgV2FsbGV0Lk1BWF9BRERSRVNTRVMpO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSByZXNwb25zZS5kYXRhLmRhdGEubWFwKChhZGRyZXNzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRXYWxsZXRBZGRyZXNzKGFkZHJlc3MsIGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gYWRkcmVzc2VzO1xuICAgICAgICByZXR1cm4gYWRkcmVzc2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgVHJhZGVzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IGZvciBhbm90aGVyIEFzc2V0LlxuICAgICAqICBDdXJyZW50bHkgb25seSB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIHVzZWQgdG8gc291cmNlIHRoZSBUcmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFkZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZyb21Bc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byB0cmFkZSBmcm9tLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRvQXNzZXRJZCAtIFRoZSBJRCBvZiB0aGUgQXNzZXQgdG8gdHJhZGUgdG8uXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCwgb3IgaWYgdGhlIGFzc2V0IElEcyBhcmUgdW5zdXBwb3J0ZWQsIG9yIGlmIHRoZXJlIGFyZSBpbnN1ZmZpY2llbnQgZnVuZHMuXG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgVHJhZGUgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYWRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZVRyYWRlKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0YWtlYWJsZSBiYWxhbmNlIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRfaWQgLSBUaGUgYXNzZXQgdG8gY2hlY2sgdGhlIHN0YWtlYWJsZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGdldHRpbmcgdGhlIHN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2VhYmxlIGJhbGFuY2UuXG4gICAgICovXG4gICAgYXN5bmMgc3Rha2VhYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuc3Rha2VhYmxlIGJhbGFuY2UgZm9yIHRoZSBzdXBwbGllZCBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldF9pZCAtIFRoZSBhc3NldCB0byBjaGVjayB0aGUgdW5zdGFrZWFibGUgYmFsYW5jZSBmb3IuXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBnZXR0aW5nIHRoZSB1bnN0YWtlYWJsZSBiYWxhbmNlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdW5zdGFrZWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyB1bnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS51bnN0YWtlYWJsZUJhbGFuY2UoYXNzZXRfaWQsIG1vZGUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNsYWltYWJsZSBiYWxhbmNlIGZvciB0aGUgc3VwcGxpZWQgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXRfaWQgLSBUaGUgYXNzZXQgdG8gY2hlY2sgY2xhaW1hYmxlIGJhbGFuY2UgZm9yLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgZ2V0dGluZyB0aGUgY2xhaW1hYmxlIGJhbGFuY2UuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBjbGFpbWFibGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBjbGFpbWFibGVCYWxhbmNlKGFzc2V0X2lkLCBtb2RlID0gdHlwZXNfMS5TdGFrZU9wdGlvbnNNb2RlLkRFRkFVTFQsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY2xhaW1hYmxlQmFsYW5jZShhc3NldF9pZCwgbW9kZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHRoZSBzdGFraW5nIHJld2FyZHMgZm9yIHRoZSBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgSUQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSAtIFRoZSBzdGFydCB0aW1lLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIC0gVGhlIGVuZCB0aW1lLlxuICAgICAqIEBwYXJhbSBmb3JtYXQgLSBUaGUgZm9ybWF0IHRvIHJldHVybiB0aGUgcmV3YXJkcyBpbi4gKHVzZCwgbmF0aXZlKS4gRGVmYXVsdHMgdG8gdXNkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyByZXdhcmRzLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YWtpbmdSZXdhcmRzKGFzc2V0SWQsIHN0YXJ0VGltZSA9ICgwLCB1dGlsc18xLmdldFdlZWtCYWNrRGF0ZSkobmV3IERhdGUoKSksIGVuZFRpbWUgPSAoMCwgdXRpbHNfMS5mb3JtYXREYXRlKShuZXcgRGF0ZSgpKSwgZm9ybWF0ID0gdHlwZXNfMS5TdGFraW5nUmV3YXJkRm9ybWF0LlVTRCkge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuc3Rha2luZ1Jld2FyZHMoYXNzZXRJZCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBmb3JtYXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgaGlzdG9yaWNhbCBzdGFraW5nIGJhbGFuY2VzIGZvciB0aGUgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBzdGFydFRpbWUgLSBUaGUgc3RhcnQgdGltZS5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSAtIFRoZSBlbmQgdGltZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgYmFsYW5jZXMuXG4gICAgICovXG4gICAgYXN5bmMgaGlzdG9yaWNhbFN0YWtpbmdCYWxhbmNlcyhhc3NldElkLCBzdGFydFRpbWUgPSAoMCwgdXRpbHNfMS5nZXRXZWVrQmFja0RhdGUpKG5ldyBEYXRlKCkpLCBlbmRUaW1lID0gKDAsIHV0aWxzXzEuZm9ybWF0RGF0ZSkobmV3IERhdGUoKSkpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmhpc3RvcmljYWxTdGFraW5nQmFsYW5jZXMoYXNzZXRJZCwgc3RhcnRUaW1lLCBlbmRUaW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGhpc3RvcmljYWwgYmFsYW5jZXMgZm9yIGEgZ2l2ZW4gYXNzZXQgYmVsb25naW5nIHRvIHRoZSBkZWZhdWx0IGFkZHJlc3Mgb2YgdGhlIHdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IElELlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBIaXN0b3JpY2FsIEJhbGFuY2VzIHRvIHJldHVybi4gTGltaXQgY2FuIHJhbmdlIGJldHdlZW4gMSBhbmQgMTAwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhZ2UgLSBUaGUgY3Vyc29yIGZvciBwYWdpbmF0aW9uIGFjcm9zcyBtdWx0aXBsZSBwYWdlcyBvZiBIaXN0b3JpY2FsIEJhbGFuY2VzLiBEb25cXCYjMzk7dCBpbmNsdWRlIHRoaXMgcGFyYW1ldGVyIG9uIHRoZSBmaXJzdCBjYWxsLiBVc2UgdGhlIG5leHQgcGFnZSB2YWx1ZSByZXR1cm5lZCBpbiBhIHByZXZpb3VzIHJlc3BvbnNlIHRvIHJlcXVlc3Qgc3Vic2VxdWVudCByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHBhZ2luYXRlZCBsaXN0IHJlc3BvbnNlIG9mIEhpc3RvcmljYWwgQmFsYW5jZXMgZm9yIHRoZSBnaXZlbiBBc3NldCBJRC5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0SGlzdG9yaWNhbEJhbGFuY2VzKGFzc2V0SWQsIHsgbGltaXQgPSBjb2luYmFzZV8xLkNvaW5iYXNlLmRlZmF1bHRQYWdlTGltaXQsIHBhZ2UgPSB1bmRlZmluZWQgfSA9IHt9KSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5saXN0SGlzdG9yaWNhbEJhbGFuY2VzKGFzc2V0SWQsIHsgbGltaXQsIHBhZ2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFraW5nIG9wZXJhdGlvbiB0byBzdGFrZSwgc2lnbnMgaXQsIGFuZCBicm9hZGNhc3RzIGl0IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFtb3VudCAtIFRoZSBhbW91bnQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gYXNzZXRJZCAtIFRoZSBhc3NldCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBtb2RlIC0gVGhlIHN0YWtpbmcgbW9kZS4gRGVmYXVsdHMgdG8gREVGQVVMVC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBzdWNoIGFzIHNldHRpbmcgdGhlIG1vZGUgZm9yIHRoZSBzdGFraW5nIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gdGltZW91dFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIHdhaXQgZm9yIHRoZSB0cmFuc2FjdGlvbiB0byBjb21wbGV0ZSB3aGVuIGJyb2FkY2FzdGVkLlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbFNlY29uZHMgLSBUaGUgYW1vdW50IHRvIGNoZWNrIGVhY2ggdGltZSBmb3IgYSBzdWNjZXNzZnVsIGJyb2FkY2FzdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHJldHVybnMgVGhlIHN0YWtpbmcgb3BlcmF0aW9uIGFmdGVyIGl0J3MgY29tcGxldGVkIGZ1bGx5LlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVN0YWtlKGFtb3VudCwgYXNzZXRJZCwgbW9kZSA9IHR5cGVzXzEuU3Rha2VPcHRpb25zTW9kZS5ERUZBVUxULCBvcHRpb25zID0ge30sIHRpbWVvdXRTZWNvbmRzID0gNjAsIGludGVydmFsU2Vjb25kcyA9IDAuMikge1xuICAgICAgICByZXR1cm4gKGF3YWl0IHRoaXMuZ2V0RGVmYXVsdEFkZHJlc3MoKSkuY3JlYXRlU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zLCB0aW1lb3V0U2Vjb25kcywgaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWtpbmcgb3BlcmF0aW9uIHRvIHVuc3Rha2UsIHNpZ25zIGl0LCBhbmQgYnJvYWRjYXN0cyBpdCBvbiB0aGUgYmxvY2tjaGFpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbW91bnQgLSBUaGUgYW1vdW50IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgYXNzZXQgZm9yIHRoZSBzdGFraW5nIG9wZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0gbW9kZSAtIFRoZSBzdGFraW5nIG1vZGUuIERlZmF1bHRzIHRvIERFRkFVTFQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgc3VjaCBhcyBzZXR0aW5nIHRoZSBtb2RlIGZvciB0aGUgc3Rha2luZyBhY3Rpb24uXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIGFtb3VudCB0byB3YWl0IGZvciB0aGUgdHJhbnNhY3Rpb24gdG8gY29tcGxldGUgd2hlbiBicm9hZGNhc3RlZC5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGFtb3VudCB0byBjaGVjayBlYWNoIHRpbWUgZm9yIGEgc3VjY2Vzc2Z1bCBicm9hZGNhc3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdGFraW5nIG9wZXJhdGlvbiBhZnRlciBpdCdzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlVW5zdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9LCB0aW1lb3V0U2Vjb25kcyA9IDYwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZVVuc3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zLCB0aW1lb3V0U2Vjb25kcywgaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0YWtpbmcgb3BlcmF0aW9uIHRvIGNsYWltIHN0YWtlLCBzaWducyBpdCwgYW5kIGJyb2FkY2FzdHMgaXQgb24gdGhlIGJsb2NrY2hhaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IC0gVGhlIGFtb3VudCBmb3IgdGhlIHN0YWtpbmcgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIGFzc2V0IGZvciB0aGUgc3Rha2luZyBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIG1vZGUgLSBUaGUgc3Rha2luZyBtb2RlLiBEZWZhdWx0cyB0byBERUZBVUxULlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIHN1Y2ggYXMgc2V0dGluZyB0aGUgbW9kZSBmb3IgdGhlIHN0YWtpbmcgYWN0aW9uLlxuICAgICAqIEBwYXJhbSB0aW1lb3V0U2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gd2FpdCBmb3IgdGhlIHRyYW5zYWN0aW9uIHRvIGNvbXBsZXRlIHdoZW4gYnJvYWRjYXN0ZWQuXG4gICAgICogQHBhcmFtIGludGVydmFsU2Vjb25kcyAtIFRoZSBhbW91bnQgdG8gY2hlY2sgZWFjaCB0aW1lIGZvciBhIHN1Y2Nlc3NmdWwgYnJvYWRjYXN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgZGVmYXVsdCBhZGRyZXNzIGlzIG5vdCBmb3VuZC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc3Rha2luZyBvcGVyYXRpb24gYWZ0ZXIgaXQncyBjb21wbGV0ZWQgZnVsbHkuXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlQ2xhaW1TdGFrZShhbW91bnQsIGFzc2V0SWQsIG1vZGUgPSB0eXBlc18xLlN0YWtlT3B0aW9uc01vZGUuREVGQVVMVCwgb3B0aW9ucyA9IHt9LCB0aW1lb3V0U2Vjb25kcyA9IDYwLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZUNsYWltU3Rha2UoYW1vdW50LCBhc3NldElkLCBtb2RlLCBvcHRpb25zLCB0aW1lb3V0U2Vjb25kcywgaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBiYWxhbmNlcyBvZiB0aGlzIFdhbGxldC4gQmFsYW5jZXMgYXJlIGFnZ3JlZ2F0ZWQgYWNyb3NzIGFsbCBBZGRyZXNzZXMgaW4gdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJhbGFuY2VzLiBUaGUga2V5IGlzIHRoZSBBc3NldCBJRCwgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgYmFsYW5jZS5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0QmFsYW5jZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5saXN0V2FsbGV0QmFsYW5jZXModGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlX21hcF8xLkJhbGFuY2VNYXAuZnJvbUJhbGFuY2VzKHJlc3BvbnNlLmRhdGEuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJhbGFuY2Ugb2YgdGhlIHByb3ZpZGVkIEFzc2V0LiBCYWxhbmNlcyBhcmUgYWdncmVnYXRlZCBhY3Jvc3MgYWxsIEFkZHJlc3NlcyBpbiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHJldHJpZXZlIHRoZSBiYWxhbmNlIGZvci5cbiAgICAgKiBAcmV0dXJucyBUaGUgYmFsYW5jZSBvZiB0aGUgQXNzZXQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0QmFsYW5jZShhc3NldElkKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXRCYWxhbmNlKHRoaXMubW9kZWwuaWQsIGFzc2V0XzEuQXNzZXQucHJpbWFyeURlbm9taW5hdGlvbihhc3NldElkKSk7XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YS5hbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgZGVjaW1hbF9qc18xLmRlZmF1bHQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IGJhbGFuY2VfMS5CYWxhbmNlLmZyb21Nb2RlbEFuZEFzc2V0SWQocmVzcG9uc2UuZGF0YSwgYXNzZXRJZCk7XG4gICAgICAgIHJldHVybiBiYWxhbmNlLmFtb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgTmV0d29yayBJRCBvZiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldHdvcmsgSUQuXG4gICAgICovXG4gICAgZ2V0TmV0d29ya0lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBTZXJ2ZXJTaWduZXIgU3RhdHVzIG9mIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgU2VydmVyU2lnbmVyIFN0YXR1cy5cbiAgICAgKi9cbiAgICBnZXRTZXJ2ZXJTaWduZXJTdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIHBlbmRpbmdfc2VlZF9jcmVhdGlvbjogdHlwZXNfMS5TZXJ2ZXJTaWduZXJTdGF0dXMuUEVORElORyxcbiAgICAgICAgICAgIGFjdGl2ZV9zZWVkOiB0eXBlc18xLlNlcnZlclNpZ25lclN0YXR1cy5BQ1RJVkUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsLnNlcnZlcl9zaWduZXJfc3RhdHVzID8gc3RhdHVzW3RoaXMubW9kZWwuc2VydmVyX3NpZ25lcl9zdGF0dXNdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3YWxsZXQgSUQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgd2FsbGV0IElELlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2F2ZXMgdGhlIHNlZWQgb2YgdGhlIFdhbGxldCB0byB0aGUgZ2l2ZW4gZmlsZS4gV2FsbGV0cyB3aG9zZSBzZWVkcyBhcmUgc2F2ZWQgdGhpcyB3YXkgY2FuIGJlXG4gICAgICogcmVoeWRyYXRlZCB1c2luZyBsb2FkX3NlZWQuIEEgc2luZ2xlIGZpbGUgY2FuIGJlIHVzZWQgZm9yIG11bHRpcGxlIFdhbGxldCBzZWVkcy5cbiAgICAgKiBUaGlzIGlzIGFuIGluc2VjdXJlIG1ldGhvZCBvZiBzdG9yaW5nIFdhbGxldCBzZWVkcyBhbmQgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBzYXZlIHRoZSBzZWVkIHRvXG4gICAgICogQHBhcmFtIGVuY3J5cHQgLSBXaGV0aGVyIHRoZSBzZWVkIGluZm9ybWF0aW9uIHBlcnNpc3RlZCB0byB0aGUgbG9jYWwgZmlsZSBzeXN0ZW0gc2hvdWxkIGJlXG4gICAgICogZW5jcnlwdGVkIG9yIG5vdC4gRGF0YSBpcyB1bmVuY3J5cHRlZCBieSBkZWZhdWx0LlxuICAgICAqIEByZXR1cm5zIEEgc3RyaW5nIGluZGljYXRpbmcgdGhlIHN1Y2Nlc3Mgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgV2FsbGV0IGRvZXMgbm90IGhhdmUgYSBzZWVkXG4gICAgICovXG4gICAgc2F2ZVNlZWQoZmlsZVBhdGgsIGVuY3J5cHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2F2ZSBXYWxsZXQgd2l0aG91dCBsb2FkZWQgc2VlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGlzdGluZ1NlZWRzSW5TdG9yZSA9IHRoaXMuZ2V0RXhpc3RpbmdTZWVkcyhmaWxlUGF0aCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmV4cG9ydCgpO1xuICAgICAgICBsZXQgc2VlZFRvU3RvcmUgPSBkYXRhLnNlZWQ7XG4gICAgICAgIGxldCBhdXRoVGFnID0gXCJcIjtcbiAgICAgICAgbGV0IGl2ID0gXCJcIjtcbiAgICAgICAgaWYgKGVuY3J5cHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGl2Qnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTIpO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoXCJhZXMtMjU2LWdjbVwiLCBjcnlwdG8uY3JlYXRlSGFzaChcInNoYTI1NlwiKS51cGRhdGUoc2hhcmVkU2VjcmV0KS5kaWdlc3QoKSwgaXZCeXRlcyk7XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWREYXRhID0gQnVmZmVyLmNvbmNhdChbY2lwaGVyLnVwZGF0ZShkYXRhLnNlZWQsIFwidXRmOFwiKSwgY2lwaGVyLmZpbmFsKCldKTtcbiAgICAgICAgICAgIGF1dGhUYWcgPSBjaXBoZXIuZ2V0QXV0aFRhZygpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgc2VlZFRvU3RvcmUgPSBlbmNyeXB0ZWREYXRhLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICAgICAgaXYgPSBpdkJ5dGVzLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4aXN0aW5nU2VlZHNJblN0b3JlW2RhdGEud2FsbGV0SWRdID0ge1xuICAgICAgICAgICAgc2VlZDogc2VlZFRvU3RvcmUsXG4gICAgICAgICAgICBlbmNyeXB0ZWQ6IGVuY3J5cHQsXG4gICAgICAgICAgICBhdXRoVGFnOiBhdXRoVGFnLFxuICAgICAgICAgICAgaXY6IGl2LFxuICAgICAgICB9O1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBKU09OLnN0cmluZ2lmeShleGlzdGluZ1NlZWRzSW5TdG9yZSwgbnVsbCwgMiksIFwidXRmOFwiKTtcbiAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgc2F2ZWQgc2VlZCBmb3IgJHtkYXRhLndhbGxldElkfSB0byAke2ZpbGVQYXRofS5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgc2VlZCBvZiB0aGUgV2FsbGV0IGZyb20gdGhlIGdpdmVuIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsZVBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZSB0byBsb2FkIHRoZSBzZWVkIGZyb21cbiAgICAgKiBAcmV0dXJucyBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBzdWNjZXNzIG9mIHRoZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBsb2FkU2VlZChmaWxlUGF0aCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ1NlZWRzSW5TdG9yZSA9IHRoaXMuZ2V0RXhpc3RpbmdTZWVkcyhmaWxlUGF0aCk7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhleGlzdGluZ1NlZWRzSW5TdG9yZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgRmlsZSAke2ZpbGVQYXRofSBkb2VzIG5vdCBjb250YWluIGFueSBzZWVkIGRhdGFgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhpc3RpbmdTZWVkc0luU3RvcmVbdGhpcy5nZXRJZCgpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihgRmlsZSAke2ZpbGVQYXRofSBkb2VzIG5vdCBjb250YWluIHNlZWQgZGF0YSBmb3Igd2FsbGV0ICR7dGhpcy5nZXRJZCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWREYXRhID0gZXhpc3RpbmdTZWVkc0luU3RvcmVbdGhpcy5nZXRJZCgpXTtcbiAgICAgICAgbGV0IHNlZWQgPSBzZWVkRGF0YS5zZWVkO1xuICAgICAgICBpZiAoIXNlZWQpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIlNlZWQgZGF0YSBpcyBtYWxmb3JtZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlZWREYXRhLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0gdGhpcy5nZXRFbmNyeXB0aW9uS2V5KCk7XG4gICAgICAgICAgICBpZiAoIXNlZWREYXRhLml2IHx8ICFzZWVkRGF0YS5hdXRoVGFnKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXJndW1lbnRFcnJvcihcIkVuY3J5cHRlZCBzZWVkIGRhdGEgaXMgbWFsZm9ybWVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdihcImFlcy0yNTYtZ2NtXCIsIGNyeXB0by5jcmVhdGVIYXNoKFwic2hhMjU2XCIpLnVwZGF0ZShzaGFyZWRTZWNyZXQpLmRpZ2VzdCgpLCBCdWZmZXIuZnJvbShzZWVkRGF0YS5pdiwgXCJoZXhcIikpO1xuICAgICAgICAgICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhCdWZmZXIuZnJvbShzZWVkRGF0YS5hdXRoVGFnLCBcImhleFwiKSk7XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgZGVjaXBoZXIudXBkYXRlKEJ1ZmZlci5mcm9tKHNlZWQsIFwiaGV4XCIpKSxcbiAgICAgICAgICAgICAgICBkZWNpcGhlci5maW5hbCgpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBzZWVkID0gZGVjcnlwdGVkRGF0YS50b1N0cmluZyhcInV0ZjhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTZWVkKHNlZWQpO1xuICAgICAgICBhd2FpdCB0aGlzLmxpc3RBZGRyZXNzZXMoKTtcbiAgICAgICAgcmV0dXJuIGBTdWNjZXNzZnVsbHkgbG9hZGVkIHNlZWQgZm9yIHdhbGxldCAke3RoaXMuZ2V0SWQoKX0gZnJvbSAke2ZpbGVQYXRofS5gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGFkZHJlc3Mgb2YgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBkZWZhdWx0IGFkZHJlc3NcbiAgICAgKi9cbiAgICBhc3luYyBnZXREZWZhdWx0QWRkcmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuZGVmYXVsdF9hZGRyZXNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIldhbGxldE1vZGVsIGRlZmF1bHQgYWRkcmVzcyBub3Qgc2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBZGRyZXNzID0gYXdhaXQgdGhpcy5nZXRBZGRyZXNzKHRoaXMubW9kZWwuZGVmYXVsdF9hZGRyZXNzLmFkZHJlc3NfaWQpO1xuICAgICAgICBpZiAoIWRlZmF1bHRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZhdWx0IGFkZHJlc3Mgbm90IGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWRkcmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBXYWxsZXQgaGFzIGEgc2VlZCB3aXRoIHdoaWNoIHRvIGRlcml2ZSBrZXlzIGFuZCBzaWduIHRyYW5zYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFdhbGxldCBoYXMgYSBzZWVkIHdpdGggd2hpY2ggdG8gZGVyaXZlIGtleXMgYW5kIHNpZ24gdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGNhblNpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hc3Rlcj8ucHVibGljS2V5ICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGZ1bmRzIGZyb20gdGhlIGZhdWNldCBmb3IgdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcyBhbmQgcmV0dXJucyB0aGUgZmF1Y2V0IHRyYW5zYWN0aW9uLlxuICAgICAqIFRoaXMgaXMgb25seSBzdXBwb3J0ZWQgb24gdGVzdG5ldCBuZXR3b3Jrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3NldElkIC0gVGhlIElEIG9mIHRoZSBBc3NldCB0byByZXF1ZXN0IGZyb20gdGhlIGZhdWNldC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGRlZmF1bHQgYWRkcmVzcyBpcyBub3QgZm91bmQuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqIEByZXR1cm5zIFRoZSBzdWNjZXNzZnVsIGZhdWNldCB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGFzeW5jIGZhdWNldChhc3NldElkKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RlbC5kZWZhdWx0X2FkZHJlc3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlZmF1bHQgYWRkcmVzcyBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5mYXVjZXQoYXNzZXRJZCk7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmZXJzIHRoZSBnaXZlbiBhbW91bnQgb2YgdGhlIGdpdmVuIEFzc2V0IHRvIHRoZSBnaXZlbiBhZGRyZXNzLiBPbmx5IHNhbWUtTmV0d29yayBUcmFuc2ZlcnMgYXJlIHN1cHBvcnRlZC5cbiAgICAgKiBDdXJyZW50bHkgb25seSB0aGUgZGVmYXVsdF9hZGRyZXNzIGlzIHVzZWQgdG8gc291cmNlIHRoZSBUcmFuc2Zlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gY3JlYXRlIHRoZSBUcmFuc2Zlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbW91bnQgLSBUaGUgYW1vdW50IG9mIHRoZSBBc3NldCB0byBzZW5kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIEFzc2V0IHRvIHNlbmQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVzdGluYXRpb24gLSBUaGUgZGVzdGluYXRpb24gb2YgdGhlIHRyYW5zZmVyLiBJZiBhIFdhbGxldCwgc2VuZHMgdG8gdGhlIFdhbGxldCdzIGRlZmF1bHQgYWRkcmVzcy4gSWYgYSBTdHJpbmcsIGludGVycHJldHMgaXQgYXMgdGhlIGFkZHJlc3MgSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2FzbGVzcyAtIFdoZXRoZXIgdGhlIFRyYW5zZmVyIHNob3VsZCBiZSBnYXNsZXNzLiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBUcmFuc2ZlciBvYmplY3QuXG4gICAgICogQHRocm93cyB7QVBJRXJyb3J9IGlmIHRoZSBBUEkgcmVxdWVzdCB0byBjcmVhdGUgYSBUcmFuc2ZlciBmYWlscy5cbiAgICAgKiBAdGhyb3dzIHtBUElFcnJvcn0gaWYgdGhlIEFQSSByZXF1ZXN0IHRvIGJyb2FkY2FzdCBhIFRyYW5zZmVyIGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVRyYW5zZmVyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmNyZWF0ZVRyYW5zZmVyKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUGF5bG9hZCBTaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdW5zaWduZWRQYXlsb2FkIC0gVGhlIFVuc2lnbmVkIFBheWxvYWQgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgUGF5bG9hZCBTaWduYXR1cmUgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgUGF5bG9hZCBTaWduYXR1cmUgZmFpbHMuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBkZWZhdWx0IGFkZHJlc3MgaXMgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVBheWxvYWRTaWduYXR1cmUodW5zaWduZWRQYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5jcmVhdGVQYXlsb2FkU2lnbmF0dXJlKHVuc2lnbmVkUGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJob29rIGZvciBhIHdhbGxldCwgbW9uaXRvcnMgYWxsIHdhbGxldCBhZGRyZXNzZXMgZm9yIG9uY2hhaW4gZXZlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5vdGlmaWNhdGlvblVyaSAtIFRoZSBVUkkgdG8gd2hpY2ggdGhlIHdlYmhvb2sgbm90aWZpY2F0aW9ucyB3aWxsIGJlIHNlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3bHkgY3JlYXRlZCB3ZWJob29rIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVdlYmhvb2sobm90aWZpY2F0aW9uVXJpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLmNyZWF0ZVdhbGxldFdlYmhvb2sodGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25fdXJpOiBub3RpZmljYXRpb25VcmksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd2ViaG9va18xLldlYmhvb2suaW5pdChyZXN1bHQuZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZXMgYSBjb250cmFjdCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBpbnZva2UgdGhlIGNvbnRyYWN0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuY29udHJhY3RBZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHRoZSBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIG9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGhvZCAtIFRoZSBtZXRob2QgdG8gaW52b2tlIG9uIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hYmkgLSBUaGUgQUJJIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjb250cmFjdCBtZXRob2QgaW52b2NhdGlvbi5cbiAgICAgKiAgIFRoZSBrZXlzIHNob3VsZCBiZSB0aGUgYXJndW1lbnQgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgc2hvdWxkIGJlIHRoZSBhcmd1bWVudCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYW1vdW50IC0gVGhlIGFtb3VudCBvZiB0aGUgYXNzZXQgdG8gc2VuZCB0byBhIHBheWFibGUgY29udHJhY3QgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFzc2V0SWQgLSBUaGUgSUQgb2YgdGhlIGFzc2V0IHRvIHNlbmQgdG8gYSBwYXlhYmxlIGNvbnRyYWN0IG1ldGhvZC5cbiAgICAgKiAgIFRoZSBhc3NldCBtdXN0IGJlIGEgZGVub21pbmF0aW9uIG9mIHRoZSBuYXRpdmUgYXNzZXQuIChFeC4gXCJ3ZWlcIiwgXCJnd2VpXCIsIG9yIFwiZXRoXCIpLlxuICAgICAqIEByZXR1cm5zIFRoZSBDb250cmFjdEludm9jYXRpb24gb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gY3JlYXRlIGEgY29udHJhY3QgaW52b2NhdGlvbiBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBpbnZva2VDb250cmFjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5pbnZva2VDb250cmFjdChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkMyMCB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkMyMCB0b2tlbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzIwIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRvdGFsU3VwcGx5IC0gVGhlIHRvdGFsIHN1cHBseSBvZiB0aGUgRVJDMjAgdG9rZW4uXG4gICAgICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRlcGxveWVkIFNtYXJ0Q29udHJhY3Qgb2JqZWN0LlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGUgcHJpdmF0ZSBrZXkgaXMgbm90IGxvYWRlZCB3aGVuIG5vdCB1c2luZyBzZXJ2ZXIgc2lnbmVyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlcGxveVRva2VuKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmRlcGxveVRva2VuKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXBsb3lzIGFuIEVSQzcyMSB0b2tlbiBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkM3MjEgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3ltYm9sIC0gVGhlIHN5bWJvbCBvZiB0aGUgRVJDNzIxIHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmJhc2VVUkkgLSBUaGUgYmFzZSBVUkkgb2YgdGhlIEVSQzcyMSB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95TkZUKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChhd2FpdCB0aGlzLmdldERlZmF1bHRBZGRyZXNzKCkpLmRlcGxveU5GVChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVwbG95cyBhbiBFUkMxMTU1IHRva2VuIGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIEVSQzExNTUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBFUkMxMTU1IHRva2VuLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bWJvbCAtIFRoZSBzeW1ib2wgb2YgdGhlIEVSQzExNTUgdG9rZW4uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYmFzZVVSSSAtIFRoZSBiYXNlIFVSSSBvZiB0aGUgRVJDMTE1NSB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGVwbG95ZWQgU21hcnRDb250cmFjdCBvYmplY3QuXG4gICAgICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwcml2YXRlIGtleSBpcyBub3QgbG9hZGVkIHdoZW4gbm90IHVzaW5nIHNlcnZlciBzaWduZXIuXG4gICAgICovXG4gICAgYXN5bmMgZGVwbG95TXVsdGlUb2tlbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXREZWZhdWx0QWRkcmVzcygpKS5kZXBsb3lNdWx0aVRva2VuKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXYWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgV2FsbGV0XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgV2FsbGV0e2lkOiAnJHt0aGlzLm1vZGVsLmlkfScsIG5ldHdvcmtJZDogJyR7dGhpcy5tb2RlbC5uZXR3b3JrX2lkfSd9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBzZWVkIGFuZCBhZGRyZXNzIG1vZGVscyBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlZWQgLSBUaGUgc2VlZCB0byB1c2UgZm9yIHRoZSBXYWxsZXRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZVNlZWQoc2VlZCkge1xuICAgICAgICBpZiAoc2VlZCAmJiBzZWVkLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiU2VlZCBtdXN0IGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWRzIHRoZSBzZWVkIGRhdGEgZnJvbSB0aGUgZ2l2ZW4gZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlUGF0aCAtIFRoZSBwYXRoIG9mIHRoZSBmaWxlIHRvIGxvYWQgdGhlIHNlZWQgZGF0YSBmcm9tXG4gICAgICogQHJldHVybnMgVGhlIHNlZWQgZGF0YVxuICAgICAqL1xuICAgIGdldEV4aXN0aW5nU2VlZHMoZmlsZVBhdGgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmMoZmlsZVBhdGgsIFwidXRmOFwiKTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZWREYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LmVudHJpZXMoc2VlZERhdGEpLmV2ZXJ5KChba2V5LCB2YWx1ZV0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLmF1dGhUYWcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUuZW5jcnlwdGVkID09PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5pdiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5zZWVkID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiTWFsZm9ybWVkIGJhY2t1cCBkYXRhXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlZWREYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Bcmd1bWVudEVycm9yKFwiTWFsZm9ybWVkIGJhY2t1cCBkYXRhXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGtleSBmb3IgZW5jcnlwdGluZyBzZWVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZW5jcnlwdGlvbiBrZXkuXG4gICAgICovXG4gICAgZ2V0RW5jcnlwdGlvbktleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IGNyeXB0by5jcmVhdGVQcml2YXRlS2V5KGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpS2V5UHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGNyeXB0by5jcmVhdGVQdWJsaWNLZXkoY29pbmJhc2VfMS5Db2luYmFzZS5hcGlLZXlQcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgZW5jcnlwdGlvbktleSA9IGNyeXB0by5kaWZmaWVIZWxsbWFuKHtcbiAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW5jcnlwdGlvbktleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIFdhbGxldEFkZHJlc3Mgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gQWRkcmVzc01vZGVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NNb2RlbCAtIFRoZSBBZGRyZXNzTW9kZWwgdG8gYnVpbGQgdGhlIFdhbGxldEFkZHJlc3MgZnJvbS5cbiAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIEFkZHJlc3NNb2RlbC5cbiAgICAgKiBAcmV0dXJucyBUaGUgV2FsbGV0QWRkcmVzcyBvYmplY3QuXG4gICAgICovXG4gICAgYnVpbGRXYWxsZXRBZGRyZXNzKGFkZHJlc3NNb2RlbCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hc3Rlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MoYWRkcmVzc01vZGVsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlcml2ZUtleShpbmRleCk7XG4gICAgICAgIGNvbnN0IGV0aFdhbGxldCA9IG5ldyBldGhlcnNfMS5ldGhlcnMuV2FsbGV0KCgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoa2V5LnByaXZhdGVLZXkpKTtcbiAgICAgICAgaWYgKGV0aFdhbGxldC5hZGRyZXNzICE9IGFkZHJlc3NNb2RlbC5hZGRyZXNzX2lkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlZWQgZG9lcyBub3QgbWF0Y2ggd2FsbGV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB3YWxsZXRfYWRkcmVzc18xLldhbGxldEFkZHJlc3MoYWRkcmVzc01vZGVsLCBldGhXYWxsZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0cyB1bnRpbCB0aGUgU2VydmVyU2lnbmVyIGhhcyBjcmVhdGVkIGEgc2VlZCBmb3IgdGhlIFdhbGxldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB3YWxsZXRJZCAtIFRoZSBJRCBvZiB0aGUgV2FsbGV0IHRoYXQgaXMgYXdhaXRpbmcgc2VlZCBjcmVhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxTZWNvbmRzIC0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHBvbGwgdGhlIENEUFNlcnZpY2UsIGluIHNlY29uZHMuXG4gICAgICogQHBhcmFtIHRpbWVvdXRTZWNvbmRzIC0gVGhlIG1heGltdW0gYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgdGhlIFNlcnZlclNpZ25lciB0byBjcmVhdGUgYSBzZWVkLCBpbiBzZWNvbmRzLlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgV2FsbGV0IGZhaWxzLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiB0aGUgU2VydmVyU2lnbmVyIHRpbWVzIG91dC5cbiAgICAgKi9cbiAgICBhc3luYyB3YWl0Rm9yU2lnbmVyKHdhbGxldElkLCBpbnRlcnZhbFNlY29uZHMgPSAwLjIsIHRpbWVvdXRTZWNvbmRzID0gMjApIHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPCB0aW1lb3V0U2Vjb25kcyAqIDEwMDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQod2FsbGV0SWQpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlPy5kYXRhLnNlcnZlcl9zaWduZXJfc3RhdHVzID09PSB0eXBlc18xLlNlcnZlclNpZ25lclN0YXR1cy5BQ1RJVkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhd2FpdCAoMCwgdXRpbHNfMS5kZWxheSkoaW50ZXJ2YWxTZWNvbmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgY3JlYXRpb24gdGltZWQgb3V0LiBDaGVjayBzdGF0dXMgb2YgeW91ciBTZXJ2ZXItU2lnbmVyXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXN0ZXIgbm9kZSBmb3IgdGhlIGdpdmVuIHNlZWQsIGlmIHZhbGlkLiBJZiB0aGUgc2VlZCBpcyB1bmRlZmluZWQgaXQgd2lsbCBzZXQgdGhlIG1hc3RlciBub2RlIHVzaW5nIGEgcmFuZG9tIHNlZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VlZCAtIFRoZSBzZWVkIHRvIHVzZSBmb3IgdGhlIFdhbGxldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWFzdGVyIG5vZGUgZm9yIHRoZSBnaXZlbiBzZWVkLlxuICAgICAqL1xuICAgIHNldE1hc3Rlck5vZGUoc2VlZCkge1xuICAgICAgICBpZiAoc2VlZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWVkID0gZXRoZXJzXzEuZXRoZXJzLldhbGxldC5jcmVhdGVSYW5kb20oKS5wcml2YXRlS2V5LnNsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVTZWVkKHNlZWQpO1xuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xuICAgICAgICB0aGlzLm1hc3RlciA9IGJpcDMyXzEuSERLZXkuZnJvbU1hc3RlclNlZWQoQnVmZmVyLmZyb20oc2VlZCwgXCJoZXhcIikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmVzIGEga2V5IGZvciBhbiBhbHJlYWR5IHJlZ2lzdGVyZWQgQWRkcmVzcyBpbiB0aGUgV2FsbGV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBBZGRyZXNzIHRvIGRlcml2ZS5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBJZiB0aGUga2V5IGRlcml2YXRpb24gZmFpbHMuXG4gICAgICogQHJldHVybnMgVGhlIGRlcml2ZWQga2V5LlxuICAgICAqL1xuICAgIGRlcml2ZUtleShpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMubWFzdGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZGVyaXZlIGtleSBmb3IgV2FsbGV0IHdpdGhvdXQgc2VlZCBsb2FkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHRoaXMubWFzdGVyPy5kZXJpdmUodGhpcy5hZGRyZXNzUGF0aFByZWZpeCArIGAvJHtpbmRleH1gKTtcbiAgICAgICAgaWYgKCFkZXJpdmVkS2V5Py5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZGVyaXZlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhdHRlc3RhdGlvbiBmb3IgdGhlIEFkZHJlc3MgY3VycmVudGx5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBvZiB0aGUgV2FsbGV0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhdHRlc3RhdGlvbi5cbiAgICAgKi9cbiAgICBjcmVhdGVBdHRlc3RhdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCFrZXkucHVibGljS2V5IHx8ICFrZXkucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRocm93IEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLmNvbnZlcnRTdHJpbmdUb0hleCkoa2V5LnB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB3YWxsZXRfaWQ6IHRoaXMubW9kZWwuaWQsXG4gICAgICAgICAgICBwdWJsaWNfa2V5OiBwdWJsaWNLZXksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYXNoZWRQYXlsb2FkID0gY3J5cHRvLmNyZWF0ZUhhc2goXCJzaGEyNTZcIikudXBkYXRlKHBheWxvYWQpLmRpZ2VzdCgpO1xuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSBzZWNwMjU2azEuZWNkc2FTaWduKGhhc2hlZFBheWxvYWQsIGtleS5wcml2YXRlS2V5KTtcbiAgICAgICAgY29uc3QgciA9IHNpZ25hdHVyZS5zaWduYXR1cmUuc2xpY2UoMCwgMzIpO1xuICAgICAgICBjb25zdCBzID0gc2lnbmF0dXJlLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICAgICAgICBjb25zdCB2ID0gc2lnbmF0dXJlLnJlY2lkICsgMjcgKyA0O1xuICAgICAgICBjb25zdCBuZXdTaWduYXR1cmVCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbdl0pLCByLCBzXSk7XG4gICAgICAgIGNvbnN0IG5ld1NpZ25hdHVyZUhleCA9IG5ld1NpZ25hdHVyZUJ1ZmZlci50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgcmV0dXJuIG5ld1NpZ25hdHVyZUhleDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgV2FsbGV0IG1vZGVsIHdpdGggdGhlIGxhdGVzdCBkYXRhIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FQSUVycm9yfSBpZiB0aGUgQVBJIHJlcXVlc3QgdG8gZ2V0IGEgV2FsbGV0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHJlbG9hZCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29pbmJhc2VfMS5Db2luYmFzZS5hcGlDbGllbnRzLndhbGxldC5nZXRXYWxsZXQodGhpcy5tb2RlbC5pZCk7XG4gICAgICAgIHRoaXMubW9kZWwgPSByZXN1bHQ/LmRhdGE7XG4gICAgfVxufVxuZXhwb3J0cy5XYWxsZXQgPSBXYWxsZXQ7XG5XYWxsZXQuTUFYX0FERFJFU1NFUyA9IDIwO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Webhook = void 0;\nconst coinbase_1 = __webpack_require__(/*! ./coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\");\n/**\n * A representation of a Webhook,\n * which provides methods to create, list, update, and delete webhooks that are used to receive notifications of specific events.\n */\nclass Webhook {\n    /**\n     * Initializes a new Webhook object.\n     *\n     * @param model - The underlying Webhook object.\n     * @throws {Error} If the model is not provided.\n     */\n    constructor(model) {\n        if (!model) {\n            throw new Error(\"Webhook model cannot be empty\");\n        }\n        this.model = model;\n    }\n    /**\n     * Returns a new Webhook object. Do not use this method directly. Instead, Webhook.create(...)\n     *\n     * @constructs Webhook\n     * @param model - The underlying Webhook model object\n     * @returns A Webhook object.\n     */\n    static init(model) {\n        return new Webhook(model);\n    }\n    /**\n     * Creates a new webhook for a specified network.\n     *\n     * @param options - The options to create webhook.\n     * @param options.networkId - The network ID for which the webhook is created.\n     * @param options.notificationUri - The URI where notifications should be sent.\n     * @param options.eventType - The type of event for the webhook.\n     * @param options.eventTypeFilter - Filter for wallet activity event type.\n     * @param options.eventFilters - Filters applied to the events that determine which specific events trigger the webhook.\n     * @returns A promise that resolves to a new instance of Webhook.\n     */\n    static async create({ networkId, notificationUri, eventType, eventTypeFilter, eventFilters = [], }) {\n        const result = await coinbase_1.Coinbase.apiClients.webhook.createWebhook({\n            network_id: networkId,\n            notification_uri: notificationUri,\n            event_type: eventType,\n            event_type_filter: eventTypeFilter,\n            event_filters: eventFilters,\n        });\n        return new Webhook(result.data);\n    }\n    /**\n     * Lists the Webhooks belonging to the CDP Project.\n     *\n     * @param options - The pagination options.\n     * @param options.limit - The maximum number of Webhooks to return. Limit can range between 1 and 100.\n     * @param options.page - The cursor for pagination across multiple pages of Webhooks. Don\\&#39;t include this parameter on the first call. Use the next page value returned in a previous response to request subsequent results.\n     *\n     * @returns The paginated list response of Webhooks.\n     */\n    static async list({ limit = coinbase_1.Coinbase.defaultPageLimit, page = undefined, } = {}) {\n        const data = [];\n        let nextPage;\n        const response = await coinbase_1.Coinbase.apiClients.webhook.listWebhooks(limit, page);\n        const webhooks = response.data.data;\n        for (const w of webhooks) {\n            data.push(new Webhook(w));\n        }\n        const hasMore = response.data.has_more ? response.data.has_more : false;\n        if (hasMore) {\n            if (response.data.next_page) {\n                nextPage = response.data.next_page;\n            }\n        }\n        return {\n            data,\n            hasMore,\n            nextPage,\n        };\n    }\n    /**\n     * Returns the ID of the webhook.\n     *\n     * @returns The ID of the webhook, or undefined if the model is null.\n     */\n    getId() {\n        return this.model?.id;\n    }\n    /**\n     * Returns the network ID associated with the webhook.\n     *\n     * @returns The network ID of the webhook, or undefined if the model is null.\n     */\n    getNetworkId() {\n        return this.model?.network_id;\n    }\n    /**\n     * Returns the notification URI of the webhook.\n     *\n     * @returns The URI where notifications are sent, or undefined if the model is null.\n     */\n    getNotificationURI() {\n        return this.model?.notification_uri;\n    }\n    /**\n     * Returns the event type of the webhook.\n     *\n     * @returns The type of event the webhook listens for, or undefined if the model is null.\n     */\n    getEventType() {\n        return this.model?.event_type;\n    }\n    /**\n     * Returns the event type filter of the webhook.\n     *\n     * @returns The filter which will be used to filter for events of a certain event type\n     */\n    getEventTypeFilter() {\n        return this.model?.event_type_filter;\n    }\n    /**\n     * Returns the event filters applied to the webhook.\n     *\n     * @returns An array of event filters used by the webhook, or undefined if the model is null.\n     */\n    getEventFilters() {\n        return this.model?.event_filters;\n    }\n    /**\n     * Returns the signature header of the webhook.\n     *\n     * @returns The signature header which will be set on the callback requests, or undefined if the model is null.\n     */\n    getSignatureHeader() {\n        return this.model?.signature_header;\n    }\n    /**\n     * Updates the webhook with a new notification URI, and optionally a new list of addresses to monitor.\n     *\n     * @param options - The options to update webhook.\n     * @param options.notificationUri - The new URI for webhook notifications.\n     * @param options.eventTypeFilter - The new eventTypeFilter that contains a new list (replacement) of addresses to monitor for the webhook.\n     * @returns A promise that resolves to the updated Webhook object.\n     */\n    async update({ notificationUri, eventTypeFilter, }) {\n        const finalNotificationUri = notificationUri ?? this.getNotificationURI();\n        const finalEventTypeFilter = eventTypeFilter ?? this.getEventTypeFilter();\n        const result = await coinbase_1.Coinbase.apiClients.webhook.updateWebhook(this.getId(), {\n            notification_uri: finalNotificationUri,\n            event_filters: this.getEventFilters(),\n            event_type_filter: finalEventTypeFilter,\n        });\n        this.model = result.data;\n        return this;\n    }\n    /**\n     * Deletes the webhook.\n     *\n     * @returns A promise that resolves when the webhook is deleted and its attributes are set to null.\n     */\n    async delete() {\n        await coinbase_1.Coinbase.apiClients.webhook.deleteWebhook(this.getId());\n        this.model = null;\n    }\n    /**\n     * Returns a String representation of the Webhook.\n     *\n     * @returns A String representation of the Webhook.\n     */\n    toString() {\n        return (`Webhook { id: '${this.getId()}', networkId: '${this.getNetworkId()}', ` +\n            `eventType: '${this.getEventType()}', eventFilter: ${JSON.stringify(this.getEventFilters())}, ` +\n            `eventTypeFilter: ${JSON.stringify(this.getEventTypeFilter())}, ` +\n            `notificationUri: '${this.getNotificationURI()}', signatureHeader: '${this.getSignatureHeader()}' }`);\n    }\n}\nexports.Webhook = Webhook;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dlYmhvb2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmLG1CQUFtQixtQkFBTyxDQUFDLHlGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDRFQUE0RTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtFQUFrRSxJQUFJO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxhQUFhLGlCQUFpQixvQkFBb0I7QUFDcEYsMkJBQTJCLG9CQUFvQixrQkFBa0IsdUNBQXVDO0FBQ3hHLGdDQUFnQywwQ0FBMEM7QUFDMUUsaUNBQWlDLDBCQUEwQix1QkFBdUIsMEJBQTBCLEdBQUc7QUFDL0c7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9oZWFsdGhjaGFpbi1hcHAvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2NvaW5iYXNlL3dlYmhvb2suanM/N2ZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViaG9vayA9IHZvaWQgMDtcbmNvbnN0IGNvaW5iYXNlXzEgPSByZXF1aXJlKFwiLi9jb2luYmFzZVwiKTtcbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhIFdlYmhvb2ssXG4gKiB3aGljaCBwcm92aWRlcyBtZXRob2RzIHRvIGNyZWF0ZSwgbGlzdCwgdXBkYXRlLCBhbmQgZGVsZXRlIHdlYmhvb2tzIHRoYXQgYXJlIHVzZWQgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHNwZWNpZmljIGV2ZW50cy5cbiAqL1xuY2xhc3MgV2ViaG9vayB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgV2ViaG9vayBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBXZWJob29rIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG1vZGVsIGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihtb2RlbCkge1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJob29rIG1vZGVsIGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgV2ViaG9vayBvYmplY3QuIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkuIEluc3RlYWQsIFdlYmhvb2suY3JlYXRlKC4uLilcbiAgICAgKlxuICAgICAqIEBjb25zdHJ1Y3RzIFdlYmhvb2tcbiAgICAgKiBAcGFyYW0gbW9kZWwgLSBUaGUgdW5kZXJseWluZyBXZWJob29rIG1vZGVsIG9iamVjdFxuICAgICAqIEByZXR1cm5zIEEgV2ViaG9vayBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGluaXQobW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJob29rKG1vZGVsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3ZWJob29rIGZvciBhIHNwZWNpZmllZCBuZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjcmVhdGUgd2ViaG9vay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXR3b3JrSWQgLSBUaGUgbmV0d29yayBJRCBmb3Igd2hpY2ggdGhlIHdlYmhvb2sgaXMgY3JlYXRlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5ub3RpZmljYXRpb25VcmkgLSBUaGUgVVJJIHdoZXJlIG5vdGlmaWNhdGlvbnMgc2hvdWxkIGJlIHNlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRUeXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgZm9yIHRoZSB3ZWJob29rLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmV2ZW50VHlwZUZpbHRlciAtIEZpbHRlciBmb3Igd2FsbGV0IGFjdGl2aXR5IGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRGaWx0ZXJzIC0gRmlsdGVycyBhcHBsaWVkIHRvIHRoZSBldmVudHMgdGhhdCBkZXRlcm1pbmUgd2hpY2ggc3BlY2lmaWMgZXZlbnRzIHRyaWdnZXIgdGhlIHdlYmhvb2suXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBuZXcgaW5zdGFuY2Ugb2YgV2ViaG9vay5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKHsgbmV0d29ya0lkLCBub3RpZmljYXRpb25VcmksIGV2ZW50VHlwZSwgZXZlbnRUeXBlRmlsdGVyLCBldmVudEZpbHRlcnMgPSBbXSwgfSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vay5jcmVhdGVXZWJob29rKHtcbiAgICAgICAgICAgIG5ldHdvcmtfaWQ6IG5ldHdvcmtJZCxcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbl91cmk6IG5vdGlmaWNhdGlvblVyaSxcbiAgICAgICAgICAgIGV2ZW50X3R5cGU6IGV2ZW50VHlwZSxcbiAgICAgICAgICAgIGV2ZW50X3R5cGVfZmlsdGVyOiBldmVudFR5cGVGaWx0ZXIsXG4gICAgICAgICAgICBldmVudF9maWx0ZXJzOiBldmVudEZpbHRlcnMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFdlYmhvb2socmVzdWx0LmRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgV2ViaG9va3MgYmVsb25naW5nIHRvIHRoZSBDRFAgUHJvamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBhZ2luYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5saW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBXZWJob29rcyB0byByZXR1cm4uIExpbWl0IGNhbiByYW5nZSBiZXR3ZWVuIDEgYW5kIDEwMC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wYWdlIC0gVGhlIGN1cnNvciBmb3IgcGFnaW5hdGlvbiBhY3Jvc3MgbXVsdGlwbGUgcGFnZXMgb2YgV2ViaG9va3MuIERvblxcJiMzOTt0IGluY2x1ZGUgdGhpcyBwYXJhbWV0ZXIgb24gdGhlIGZpcnN0IGNhbGwuIFVzZSB0aGUgbmV4dCBwYWdlIHZhbHVlIHJldHVybmVkIGluIGEgcHJldmlvdXMgcmVzcG9uc2UgdG8gcmVxdWVzdCBzdWJzZXF1ZW50IHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgcGFnaW5hdGVkIGxpc3QgcmVzcG9uc2Ugb2YgV2ViaG9va3MuXG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIGxpc3QoeyBsaW1pdCA9IGNvaW5iYXNlXzEuQ29pbmJhc2UuZGVmYXVsdFBhZ2VMaW1pdCwgcGFnZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgbGV0IG5leHRQYWdlO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLmxpc3RXZWJob29rcyhsaW1pdCwgcGFnZSk7XG4gICAgICAgIGNvbnN0IHdlYmhvb2tzID0gcmVzcG9uc2UuZGF0YS5kYXRhO1xuICAgICAgICBmb3IgKGNvbnN0IHcgb2Ygd2ViaG9va3MpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChuZXcgV2ViaG9vayh3KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTW9yZSA9IHJlc3BvbnNlLmRhdGEuaGFzX21vcmUgPyByZXNwb25zZS5kYXRhLmhhc19tb3JlIDogZmFsc2U7XG4gICAgICAgIGlmIChoYXNNb3JlKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5uZXh0X3BhZ2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0UGFnZSA9IHJlc3BvbnNlLmRhdGEubmV4dF9wYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgaGFzTW9yZSxcbiAgICAgICAgICAgIG5leHRQYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBJRCBvZiB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgd2ViaG9vaywgb3IgdW5kZWZpbmVkIGlmIHRoZSBtb2RlbCBpcyBudWxsLlxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8uaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG5ldHdvcmsgSUQgYXNzb2NpYXRlZCB3aXRoIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIG5ldHdvcmsgSUQgb2YgdGhlIHdlYmhvb2ssIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXROZXR3b3JrSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5uZXR3b3JrX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBub3RpZmljYXRpb24gVVJJIG9mIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIFVSSSB3aGVyZSBub3RpZmljYXRpb25zIGFyZSBzZW50LCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0Tm90aWZpY2F0aW9uVVJJKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8ubm90aWZpY2F0aW9uX3VyaTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgdHlwZSBvZiB0aGUgd2ViaG9vay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIGV2ZW50IHRoZSB3ZWJob29rIGxpc3RlbnMgZm9yLCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0RXZlbnRUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8uZXZlbnRfdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZXZlbnQgdHlwZSBmaWx0ZXIgb2YgdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlsdGVyIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBmaWx0ZXIgZm9yIGV2ZW50cyBvZiBhIGNlcnRhaW4gZXZlbnQgdHlwZVxuICAgICAqL1xuICAgIGdldEV2ZW50VHlwZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kZWw/LmV2ZW50X3R5cGVfZmlsdGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBldmVudCBmaWx0ZXJzIGFwcGxpZWQgdG8gdGhlIHdlYmhvb2suXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBldmVudCBmaWx0ZXJzIHVzZWQgYnkgdGhlIHdlYmhvb2ssIG9yIHVuZGVmaW5lZCBpZiB0aGUgbW9kZWwgaXMgbnVsbC5cbiAgICAgKi9cbiAgICBnZXRFdmVudEZpbHRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVsPy5ldmVudF9maWx0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaWduYXR1cmUgaGVhZGVyIG9mIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBoZWFkZXIgd2hpY2ggd2lsbCBiZSBzZXQgb24gdGhlIGNhbGxiYWNrIHJlcXVlc3RzLCBvciB1bmRlZmluZWQgaWYgdGhlIG1vZGVsIGlzIG51bGwuXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlSGVhZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbD8uc2lnbmF0dXJlX2hlYWRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgd2ViaG9vayB3aXRoIGEgbmV3IG5vdGlmaWNhdGlvbiBVUkksIGFuZCBvcHRpb25hbGx5IGEgbmV3IGxpc3Qgb2YgYWRkcmVzc2VzIHRvIG1vbml0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIHVwZGF0ZSB3ZWJob29rLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm5vdGlmaWNhdGlvblVyaSAtIFRoZSBuZXcgVVJJIGZvciB3ZWJob29rIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZXZlbnRUeXBlRmlsdGVyIC0gVGhlIG5ldyBldmVudFR5cGVGaWx0ZXIgdGhhdCBjb250YWlucyBhIG5ldyBsaXN0IChyZXBsYWNlbWVudCkgb2YgYWRkcmVzc2VzIHRvIG1vbml0b3IgZm9yIHRoZSB3ZWJob29rLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1cGRhdGVkIFdlYmhvb2sgb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZSh7IG5vdGlmaWNhdGlvblVyaSwgZXZlbnRUeXBlRmlsdGVyLCB9KSB7XG4gICAgICAgIGNvbnN0IGZpbmFsTm90aWZpY2F0aW9uVXJpID0gbm90aWZpY2F0aW9uVXJpID8/IHRoaXMuZ2V0Tm90aWZpY2F0aW9uVVJJKCk7XG4gICAgICAgIGNvbnN0IGZpbmFsRXZlbnRUeXBlRmlsdGVyID0gZXZlbnRUeXBlRmlsdGVyID8/IHRoaXMuZ2V0RXZlbnRUeXBlRmlsdGVyKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvaW5iYXNlXzEuQ29pbmJhc2UuYXBpQ2xpZW50cy53ZWJob29rLnVwZGF0ZVdlYmhvb2sodGhpcy5nZXRJZCgpLCB7XG4gICAgICAgICAgICBub3RpZmljYXRpb25fdXJpOiBmaW5hbE5vdGlmaWNhdGlvblVyaSxcbiAgICAgICAgICAgIGV2ZW50X2ZpbHRlcnM6IHRoaXMuZ2V0RXZlbnRGaWx0ZXJzKCksXG4gICAgICAgICAgICBldmVudF90eXBlX2ZpbHRlcjogZmluYWxFdmVudFR5cGVGaWx0ZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSB3ZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgd2ViaG9vayBpcyBkZWxldGVkIGFuZCBpdHMgYXR0cmlidXRlcyBhcmUgc2V0IHRvIG51bGwuXG4gICAgICovXG4gICAgYXN5bmMgZGVsZXRlKCkge1xuICAgICAgICBhd2FpdCBjb2luYmFzZV8xLkNvaW5iYXNlLmFwaUNsaWVudHMud2ViaG9vay5kZWxldGVXZWJob29rKHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBXZWJob29rLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFdlYmhvb2suXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoYFdlYmhvb2sgeyBpZDogJyR7dGhpcy5nZXRJZCgpfScsIG5ldHdvcmtJZDogJyR7dGhpcy5nZXROZXR3b3JrSWQoKX0nLCBgICtcbiAgICAgICAgICAgIGBldmVudFR5cGU6ICcke3RoaXMuZ2V0RXZlbnRUeXBlKCl9JywgZXZlbnRGaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5nZXRFdmVudEZpbHRlcnMoKSl9LCBgICtcbiAgICAgICAgICAgIGBldmVudFR5cGVGaWx0ZXI6ICR7SlNPTi5zdHJpbmdpZnkodGhpcy5nZXRFdmVudFR5cGVGaWx0ZXIoKSl9LCBgICtcbiAgICAgICAgICAgIGBub3RpZmljYXRpb25Vcmk6ICcke3RoaXMuZ2V0Tm90aWZpY2F0aW9uVVJJKCl9Jywgc2lnbmF0dXJlSGVhZGVyOiAnJHt0aGlzLmdldFNpZ25hdHVyZUhlYWRlcigpfScgfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViaG9vayA9IFdlYmhvb2s7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./coinbase/address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/external_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/external_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/address/wallet_address */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/address/wallet_address.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/api_error */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/api_error.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/asset */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/asset.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/authenticator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/authenticator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/balance_map */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/balance_map.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/coinbase */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/coinbase.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/constants */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/constants.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_event */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_event.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/contract_invocation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/contract_invocation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/errors */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/faucet_transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/faucet_transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/hash */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/hash.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/historical_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/historical_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/payload_signature */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/payload_signature.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/server_signer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/server_signer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/smart_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/smart_contract.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_balance */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_balance.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_operation */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_operation.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/staking_reward */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/staking_reward.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/trade */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/trade.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transaction */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/transfer */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/transfer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/types */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/validator */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/validator.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/wallet */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/wallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/webhook */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/webhook.js\"), exports);\n__exportStar(__webpack_require__(/*! ./coinbase/read_contract */ \"(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/coinbase/read_contract.js\"), exports);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGNvaW5iYXNlL2NvaW5iYXNlLXNkay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLGtJQUFxQztBQUMxRCxhQUFhLG1CQUFPLENBQUMsOEhBQW1DO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyxnR0FBb0I7QUFDekMsYUFBYSxtQkFBTyxDQUFDLHdHQUF3QjtBQUM3QyxhQUFhLG1CQUFPLENBQUMsa0dBQXFCO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxvR0FBc0I7QUFDM0MsYUFBYSxtQkFBTyxDQUFDLDhHQUEyQjtBQUNoRCxhQUFhLG1CQUFPLENBQUMsd0hBQWdDO0FBQ3JELGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLHNIQUErQjtBQUNwRCxhQUFhLG1CQUFPLENBQUMsMEZBQWlCO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxzSEFBK0I7QUFDcEQsYUFBYSxtQkFBTyxDQUFDLG9IQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsNEdBQTBCO0FBQy9DLGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGdIQUE0QjtBQUNqRCxhQUFhLG1CQUFPLENBQUMsb0hBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyw4R0FBMkI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsd0dBQXdCO0FBQzdDLGFBQWEsbUJBQU8sQ0FBQyxrR0FBcUI7QUFDMUMsYUFBYSxtQkFBTyxDQUFDLDRGQUFrQjtBQUN2QyxhQUFhLG1CQUFPLENBQUMsb0dBQXNCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw4RkFBbUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGdHQUFvQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsNEdBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaGVhbHRoY2hhaW4tYXBwLy4vbm9kZV9tb2R1bGVzL0Bjb2luYmFzZS9jb2luYmFzZS1zZGsvZGlzdC9pbmRleC5qcz9iMjA1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYWRkcmVzc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvYWRkcmVzcy9leHRlcm5hbF9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9hZGRyZXNzL3dhbGxldF9hZGRyZXNzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9hcGlfZXJyb3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2Fzc2V0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9hdXRoZW50aWNhdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9iYWxhbmNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9iYWxhbmNlX21hcFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvY29pbmJhc2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvY29udHJhY3RfZXZlbnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2NvbnRyYWN0X2ludm9jYXRpb25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL2Vycm9yc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvZmF1Y2V0X3RyYW5zYWN0aW9uXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9oYXNoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9oaXN0b3JpY2FsX2JhbGFuY2VcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3BheWxvYWRfc2lnbmF0dXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9zZXJ2ZXJfc2lnbmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9zbWFydF9jb250cmFjdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc3Rha2luZ19iYWxhbmNlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS9zdGFraW5nX29wZXJhdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvc3Rha2luZ19yZXdhcmRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3RyYWRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS90cmFuc2FjdGlvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvdHJhbnNmZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3R5cGVzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2luYmFzZS92YWxpZGF0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvaW5iYXNlL3dhbGxldFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2Uvd2ViaG9va1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29pbmJhc2UvcmVhZF9jb250cmFjdFwiKSwgZXhwb3J0cyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@coinbase/coinbase-sdk/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@coinbase/coinbase-sdk/package.json":
/*!**********************************************************!*\
  !*** ./node_modules/@coinbase/coinbase-sdk/package.json ***!
  \**********************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@coinbase/coinbase-sdk","author":"Coinbase Inc.","license":"ISC","description":"Coinbase Platform SDK","repository":"https://github.com/coinbase/coinbase-sdk-nodejs","version":"0.10.0","main":"dist/index.js","types":"dist/index.d.ts","scripts":{"lint":"eslint -c .eslintrc.json src/coinbase/**.ts","lint-fix":"eslint -c .eslintrc.json src/coinbase/*.ts --fix","format":"prettier -c .prettierrc --write \\"**/*.{ts,js,cjs,json,md}\\"","format-check":"prettier -c .prettierrc --check \\"**/*.{ts,js,cjs,json,md}\\"","check":"tsc --noEmit","test":"npx jest --no-cache  --testMatch=**/*_test.ts","test:dry-run":"npm install && npm ci && npm publish --dry-run","test:e2e":"npx jest --no-cache --testMatch=**/e2e.ts --coverageThreshold \'{}\'","test:types":"tsd --files src/tests/types.test-d.ts","clean":"rm -rf dist/*","build":"tsc","prepack":"tsc","docs":"typedoc --entryPoints ./src --entryPointStrategy expand --exclude ./src/tests/**/*.ts"},"files":["dist"],"dependencies":{"@scure/bip32":"^1.4.0","abitype":"^1.0.6","axios":"^1.6.8","axios-mock-adapter":"^1.22.0","axios-retry":"^4.4.1","bip32":"^4.0.0","bip39":"^3.1.0","decimal.js":"^10.4.3","dotenv":"^16.4.5","ethers":"^6.12.1","node-jose":"^2.2.0","secp256k1":"^5.0.0","viem":"^2.21.26"},"devDependencies":{"@types/jest":"^29.5.12","@types/node":"^20.12.11","@types/node-jose":"^1.1.13","@types/secp256k1":"^4.0.6","@typescript-eslint/eslint-plugin":"^7.8.0","@typescript-eslint/parser":"^7.8.0","eslint":"^8.57.0","eslint-config-prettier":"^9.1.0","eslint-plugin-jsdoc":"^48.2.5","eslint-plugin-prettier":"^5.1.3","jest":"^29.7.0","mock-fs":"^5.2.0","prettier":"^3.2.5","ts-jest":"^29.1.2","ts-node":"^10.9.2","tsd":"^0.31.2","typedoc":"^0.25.13","typescript":"^5.4.5"}}');

/***/ })

};
;